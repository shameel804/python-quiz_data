[
  {
    "q": "What is the basic data structure in pandas used to represent one-dimensional labeled data?",
    "c": null,
    "o": [
      "Series",
      "DataFrame",
      "Array",
      "Dictionary"
    ]
  },
  {
    "q": "Which pandas structure is used for two-dimensional labeled data?",
    "c": null,
    "o": [
      "DataFrame",
      "Series",
      "Tuple",
      "List"
    ]
  },
  {
    "q": "How do you read a CSV file into a pandas DataFrame?",
    "c": null,
    "o": [
      "pd.read_csv('file.csv')",
      "pd.load_csv('file.csv')",
      "pd.readFile('file.csv')",
      "pd.open_csv('file.csv')"
    ]
  },
  {
    "q": "Which method is used to write a DataFrame to an Excel file?",
    "c": null,
    "o": [
      "to_excel",
      "write_excel",
      "save_excel",
      "export_excel"
    ]
  },
  {
    "q": "Which of the following pandas functions is used to remove missing values from a DataFrame?",
    "c": null,
    "o": [
      "dropna()",
      "fillna()",
      "remove_nulls()",
      "delete_na()"
    ]
  },
  {
    "q": "How can you change the data type of a pandas column?",
    "c": null,
    "o": [
      "astype()",
      "convert()",
      "change_type()",
      "set_dtype()"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "import pandas as pd\ns = pd.Series([1, 2, 3])\nprint(s[1])",
    "o": [
      "2",
      "1",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which pandas method is used to group rows by column values?",
    "c": null,
    "o": [
      "groupby()",
      "filter()",
      "aggregate()",
      "sort()"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "import pandas as pd\ns = pd.Series([1, None, 3])\nprint(s.isnull().sum())",
    "o": [
      "1",
      "0",
      "2",
      "None"
    ]
  },
  {
    "q": "Which method is used to merge two DataFrames by a common column?",
    "c": null,
    "o": [
      "merge()",
      "concat()",
      "join()",
      "append()"
    ]
  },
  {
    "q": "Which function is used to convert a column to datetime format in pandas?",
    "c": null,
    "o": [
      "pd.to_datetime()",
      "pd.convert_date()",
      "pd.date_format()",
      "pd.change_date()"
    ]
  },
  {
    "q": "How do you resample time series data to monthly frequency?",
    "c": "df.resample('M').mean()",
    "o": [
      "Resamples to monthly and calculates the mean",
      "Groups data by month",
      "Filters data by month",
      "Sorts data by month"
    ]
  },
  {
    "q": "Which pandas function helps identify memory usage of a DataFrame?",
    "c": null,
    "o": [
      "memory_usage()",
      "size()",
      "info_usage()",
      "mem_info()"
    ]
  },
  {
    "q": "Which of the following is faster and more efficient in pandas?",
    "c": null,
    "o": [
      "Vectorized operations",
      "Using apply with lambda",
      "For loops",
      "Recursion"
    ]
  },
  {
    "q": "Which of the following methods adds a new row to a DataFrame?",
    "c": null,
    "o": [
      "append()",
      "add_row()",
      "insert_row()",
      "concat_row()"
    ]
  },
  {
    "q": "Which argument is used in read_csv() to specify the column used as the index?",
    "c": null,
    "o": [
      "index_col",
      "set_index",
      "index",
      "use_index"
    ]
  },
  {
    "q": "Which method is used to rename columns in a DataFrame?",
    "c": null,
    "o": [
      "rename()",
      "change_columns()",
      "set_columns()",
      "columns_rename()"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "import pandas as pd\ndf = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\nprint(df.shape)",
    "o": [
      "(2, 2)",
      "(1, 4)",
      "(4, 1)",
      "(2,)"
    ]
  },
  {
    "q": "What is the default axis for dropna() in a DataFrame?",
    "c": null,
    "o": [
      "0 (rows)",
      "1 (columns)",
      "None",
      "Both"
    ]
  },
  {
    "q": "Which method returns the first 5 rows of a DataFrame?",
    "c": null,
    "o": [
      "head()",
      "top()",
      "first()",
      "start()"
    ]
  },
  {
    "q": "Which method returns summary statistics of numeric columns?",
    "c": null,
    "o": [
      "describe()",
      "summary()",
      "info()",
      "details()"
    ]
  },
  {
    "q": "Which method checks for duplicate rows in a DataFrame?",
    "c": null,
    "o": [
      "duplicated()",
      "check_duplicates()",
      "find_duplicates()",
      "is_duplicated()"
    ]
  },
  {
    "q": "What does the 'inplace=True' argument do in pandas methods?",
    "c": null,
    "o": [
      "Modifies the original object directly",
      "Creates a new object",
      "Returns nothing",
      "Deletes the object"
    ]
  },
  {
    "q": "Which method is used to reset the index of a DataFrame?",
    "c": null,
    "o": [
      "reset_index()",
      "drop_index()",
      "clear_index()",
      "remove_index()"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "import pandas as pd\ndf = pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]})\nprint(df['col1'].mean())",
    "o": [
      "1.5",
      "2.0",
      "3.0",
      "5.0"
    ]
  },
  {
    "q": "Which method is used to combine DataFrames along rows?",
    "c": null,
    "o": [
      "concat()",
      "merge()",
      "join()",
      "groupby()"
    ]
  },
  {
    "q": "What does df['A'].apply(len) do?",
    "c": null,
    "o": [
      "Applies the len function to each element in column A",
      "Applies len to the entire column A",
      "Returns the number of columns in df",
      "Throws an error"
    ]
  },
  {
    "q": "How do you convert a DataFrame to JSON format?",
    "c": null,
    "o": [
      "to_json()",
      "export_json()",
      "write_json()",
      "save_json()"
    ]
  },
  {
    "q": "How can you check the data types of columns in a DataFrame?",
    "c": null,
    "o": [
      "dtypes",
      "types()",
      "column_types()",
      "get_dtypes()"
    ]
  },
  {
    "q": "Which method is used to round all float values in a DataFrame?",
    "c": null,
    "o": [
      "round()",
      "fix()",
      "floor()",
      "intify()"
    ]
  },
  {
    "q": "What is the default delimiter used by `read_csv()` in pandas?",
    "c": null,
    "o": [
      "Comma",
      "Tab",
      "Semicolon",
      "Pipe"
    ]
  },
  {
    "q": "Which of the following is NOT a valid method for combining DataFrames?",
    "c": null,
    "o": [
      "stack()",
      "concat()",
      "merge()",
      "join()"
    ]
  },
  {
    "q": "Which method provides the number of non-null entries per column?",
    "c": null,
    "o": [
      "count()",
      "sum()",
      "info()",
      "len()"
    ]
  },
  {
    "q": "Which function is used to create a Series in pandas?",
    "c": null,
    "o": [
      "pd.Series()",
      "pd.CreateSeries()",
      "pd.NewSeries()",
      "pd.MakeSeries()"
    ]
  },
  {
    "q": "Which of the following code snippets creates a DataFrame?",
    "c": "import pandas as pd\ndata = {'A': [1, 2], 'B': [3, 4]}\ndf = pd.DataFrame(data)\nprint(type(df))",
    "o": [
      "<class 'pandas.core.frame.DataFrame'>",
      "<class 'pandas.core.series.Series'>",
      "<class 'dict'>",
      "<class 'list'>"
    ]
  },
  {
    "q": "How do you select multiple columns from a DataFrame?",
    "c": null,
    "o": [
      "df[['col1', 'col2']]",
      "df['col1', 'col2']",
      "df.select('col1', 'col2')",
      "df.get(['col1', 'col2'])"
    ]
  },
  {
    "q": "What does `df.columns` return?",
    "c": null,
    "o": [
      "A list-like object of column names",
      "Only the first column",
      "The number of columns",
      "A dictionary of column data"
    ]
  },
  {
    "q": "What happens if you use `df.drop('A', axis=1)`?",
    "c": null,
    "o": [
      "Drops column 'A'",
      "Drops row with index 'A'",
      "Renames column 'A'",
      "Does nothing"
    ]
  },
  {
    "q": "Which function is used to fill missing values in a DataFrame?",
    "c": null,
    "o": [
      "fillna()",
      "replace_na()",
      "insert_null()",
      "fill_missing()"
    ]
  },
  {
    "q": "Which parameter of `read_csv()` is used to parse date columns?",
    "c": null,
    "o": [
      "parse_dates",
      "convert_dates",
      "date_columns",
      "to_datetime"
    ]
  },
  {
    "q": "Which method returns a DataFrame with rows sorted by column values?",
    "c": null,
    "o": [
      "sort_values()",
      "order_by()",
      "arrange()",
      "sort_index()"
    ]
  },
  {
    "q": "What is the purpose of `df.iloc[0]`?",
    "c": null,
    "o": [
      "Returns the first row",
      "Returns the first column",
      "Returns the index label 0",
      "Raises an error"
    ]
  },
  {
    "q": "What does `df.index` return?",
    "c": null,
    "o": [
      "The index labels of the DataFrame",
      "Column names",
      "Row values",
      "Cell values"
    ]
  },
  {
    "q": "What does the method `isna()` do?",
    "c": null,
    "o": [
      "Detects missing values",
      "Fills missing values",
      "Removes missing values",
      "Creates missing values"
    ]
  },
  {
    "q": "Which of the following can be used to join two DataFrames by index?",
    "c": null,
    "o": [
      "join()",
      "merge()",
      "groupby()",
      "pivot()"
    ]
  },
  {
    "q": "Which pandas function creates a range of dates?",
    "c": null,
    "o": [
      "pd.date_range()",
      "pd.create_dates()",
      "pd.make_dates()",
      "pd.daterange()"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "import pandas as pd\ns = pd.Series([10, 20, 30])\nprint(s.index)",
    "o": [
      "RangeIndex(start=0, stop=3, step=1)",
      "[0, 1, 2]",
      "Int64Index([10, 20, 30], dtype='int64')",
      "Index of values"
    ]
  },
  {
    "q": "What does `df.T` do in pandas?",
    "c": null,
    "o": [
      "Transposes the DataFrame",
      "Returns top rows",
      "Deletes top rows",
      "Sorts the DataFrame"
    ]
  },
  {
    "q": "Which method returns the last n rows of a DataFrame?",
    "c": null,
    "o": [
      "tail()",
      "bottom()",
      "last()",
      "end()"
    ]
  },
  {
    "q": "Which of the following is used to check if a column exists in a DataFrame?",
    "c": "import pandas as pd\ndf = pd.DataFrame({'A': [1, 2]})\nprint('A' in df)",
    "o": [
      "True",
      "False",
      "Error",
      "None"
    ]
  },
  {
    "q": "What will `df.isnull().any()` return?",
    "c": null,
    "o": [
      "True for columns with at least one null value",
      "Counts of null values",
      "Indexes of null rows",
      "Boolean for entire DataFrame"
    ]
  },
  {
    "q": "Which method is used to set a column as the index of a DataFrame?",
    "c": null,
    "o": [
      "set_index()",
      "make_index()",
      "assign_index()",
      "create_index()"
    ]
  },
  {
    "q": "Which method is used to convert a DataFrame to a dictionary?",
    "c": null,
    "o": [
      "to_dict()",
      "to_dictionary()",
      "as_dict()",
      "df.dict()"
    ]
  },
  {
    "q": "What does `df.mean()` do by default?",
    "c": null,
    "o": [
      "Calculates mean of numeric columns",
      "Calculates mean of all rows and columns",
      "Raises an error",
      "Calculates row-wise mean only"
    ]
  },
  {
    "q": "Which method can be used to replace values in a DataFrame?",
    "c": null,
    "o": [
      "replace()",
      "update()",
      "switch()",
      "map()"
    ]
  },
  {
    "q": "Which of the following will combine DataFrames column-wise (horizontally)?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], axis=1)",
      "pd.concat([df1, df2], axis=0)",
      "df1 + df2",
      "pd.append(df1, df2)"
    ]
  },
  {
    "q": "What is the default axis for aggregation methods like `mean()` or `sum()`?",
    "c": null,
    "o": [
      "axis=0 (columns)",
      "axis=1 (rows)",
      "axis=None",
      "Both rows and columns"
    ]
  },
  {
    "q": "What is the output type of `df['column']`?",
    "c": null,
    "o": [
      "Series",
      "DataFrame",
      "List",
      "Array"
    ]
  },
  {
    "q": "What does `df[df['A'] > 10]` return?",
    "c": null,
    "o": [
      "Filtered rows where A > 10",
      "Filtered columns with A > 10",
      "A single value",
      "Nothing"
    ]
  },
  {
    "q": "Which method is used to convert a string column to datetime?",
    "c": null,
    "o": [
      "pd.to_datetime()",
      "convert_to_date()",
      "datetime.convert()",
      "pd.date_format()"
    ]
  },
  {
    "q": "Which method is used to sort a DataFrame by its index?",
    "c": null,
    "o": [
      "sort_index()",
      "sort_values()",
      "order_by()",
      "index_sort()"
    ]
  },
  {
    "q": "What does `df.empty` return?",
    "c": null,
    "o": [
      "True if DataFrame is empty",
      "Number of empty rows",
      "Number of NaN values",
      "False if all values are non-null"
    ]
  },
  {
    "q": "Which method can be used to get unique values from a Series?",
    "c": null,
    "o": [
      "unique()",
      "distinct()",
      "get_unique()",
      "set_unique()"
    ]
  },
  {
    "q": "How can you drop duplicate rows from a DataFrame?",
    "c": null,
    "o": [
      "drop_duplicates()",
      "remove_duplicates()",
      "clear_duplicates()",
      "unique_rows()"
    ]
  },
  {
    "q": "Which pandas method is used to create a pivot table?",
    "c": null,
    "o": [
      "pivot_table()",
      "pivot()",
      "create_pivot()",
      "make_table()"
    ]
  },
  {
    "q": "Which method is used to append one DataFrame to another?",
    "c": null,
    "o": [
      "append()",
      "extend()",
      "merge()",
      "add()"
    ]
  },
  {
    "q": "How do you calculate the median of values in a Series?",
    "c": null,
    "o": [
      "median()",
      "mean()",
      "mode()",
      "average()"
    ]
  },
  {
    "q": "What is the type of index returned by default in a new DataFrame?",
    "c": null,
    "o": [
      "RangeIndex",
      "Int64Index",
      "LabelIndex",
      "FloatIndex"
    ]
  },
  {
    "q": "Which method is used to convert a DataFrame to a NumPy array?",
    "c": null,
    "o": [
      "to_numpy()",
      "to_array()",
      "as_matrix()",
      "df.array()"
    ]
  },
  {
    "q": "How can you rename both rows and columns in a DataFrame?",
    "c": null,
    "o": [
      "rename(index=..., columns=...)",
      "rename_all()",
      "set_axis()",
      "update_names()"
    ]
  },
  {
    "q": "What does `df.info()` provide?",
    "c": null,
    "o": [
      "Summary of DataFrame structure",
      "Basic statistics",
      "Data types only",
      "Memory size only"
    ]
  },
  {
    "q": "Which of the following is used to iterate row-wise through a DataFrame?",
    "c": null,
    "o": [
      "iterrows()",
      "itertuples()",
      "enumerate()",
      "looprows()"
    ]
  },
  {
    "q": "Which method is used to remove specific columns from a DataFrame?",
    "c": null,
    "o": [
      "drop(columns=[...])",
      "remove(columns=[...])",
      "delete(columns=[...])",
      "exclude(columns=[...])"
    ]
  },
  {
    "q": "Which method in pandas is used to export data to a SQL database?",
    "c": null,
    "o": [
      "to_sql()",
      "write_sql()",
      "export_sql()",
      "save_sql()"
    ]
  },
  {
    "q": "What will the following code return?",
    "c": "import pandas as pd\ns = pd.Series([1, 2, 2, 3, 3, 3])\nprint(s.value_counts())",
    "o": [
      "Counts of unique values",
      "Sum of values",
      "Mean of values",
      "List of unique values"
    ]
  },
  {
    "q": "Which method would you use to get column-wise standard deviation in a DataFrame?",
    "c": null,
    "o": [
      "std()",
      "mean()",
      "describe()",
      "variance()"
    ]
  },
  {
    "q": "Which function is used to read Excel files in pandas?",
    "c": null,
    "o": [
      "read_excel()",
      "open_excel()",
      "import_excel()",
      "load_excel()"
    ]
  },
  {
    "q": "How do you retrieve the first column of a DataFrame `df`?",
    "c": null,
    "o": [
      "df[df.columns[0]]",
      "df.iloc[0]",
      "df.head(1)",
      "df.index[0]"
    ]
  },
  {
    "q": "Which method combines DataFrames vertically by default?",
    "c": null,
    "o": [
      "pd.concat([df1, df2])",
      "pd.merge(df1, df2)",
      "df1.join(df2)",
      "df1.append_columns(df2)"
    ]
  },
  {
    "q": "What does the `value_counts()` method return?",
    "c": null,
    "o": [
      "Frequency of unique values",
      "Unique values only",
      "Sum of all values",
      "List of duplicates"
    ]
  },
  {
    "q": "What is the output type of `df[['A']]`?",
    "c": null,
    "o": [
      "DataFrame",
      "Series",
      "List",
      "String"
    ]
  },
  {
    "q": "Which method changes all column names to lowercase?",
    "c": "df.columns = df.columns.str.lower()",
    "o": [
      "Renames all columns to lowercase",
      "Drops all columns",
      "Changes column data to lowercase",
      "Resets column values"
    ]
  },
  {
    "q": "Which method shows the memory usage of a DataFrame?",
    "c": null,
    "o": [
      "info()",
      "memory()",
      "usage()",
      "describe()"
    ]
  },
  {
    "q": "Which parameter in `read_csv()` is used to specify column names manually?",
    "c": null,
    "o": [
      "names",
      "columns",
      "set_columns",
      "rename"
    ]
  },
  {
    "q": "What does `axis=1` mean in pandas?",
    "c": null,
    "o": [
      "Operation is applied on columns",
      "Operation is applied on rows",
      "Nothing",
      "Operates on both rows and columns"
    ]
  },
  {
    "q": "What is the use of `df.describe()`?",
    "c": null,
    "o": [
      "Summary statistics for numeric columns",
      "DataFrame structure",
      "Column names",
      "Row count only"
    ]
  },
  {
    "q": "Which of the following methods will fill all NaN values with 0?",
    "c": null,
    "o": [
      "fillna(0)",
      "replace(0)",
      "dropna()",
      "zero_fill()"
    ]
  },
  {
    "q": "What will `df.nunique()` return?",
    "c": null,
    "o": [
      "Number of unique values in each column",
      "All unique values",
      "Number of NaN values",
      "Total row count"
    ]
  },
  {
    "q": "How can you reset a DataFrame index back to default integers?",
    "c": null,
    "o": [
      "reset_index()",
      "drop_index()",
      "reindex()",
      "clear_index()"
    ]
  },
  {
    "q": "Which method is used to apply a function to each element in a Series?",
    "c": null,
    "o": [
      "apply()",
      "map()",
      "filter()",
      "transform()"
    ]
  },
  {
    "q": "Which parameter of `read_csv()` allows you to skip a number of initial rows?",
    "c": null,
    "o": [
      "skiprows",
      "droprows",
      "ignore_rows",
      "remove_rows"
    ]
  },
  {
    "q": "Which of the following returns a copy of the DataFrame with all missing values dropped?",
    "c": null,
    "o": [
      "dropna()",
      "fillna()",
      "remove_na()",
      "clear_nulls()"
    ]
  },
  {
    "q": "How do you filter rows where column 'A' is equal to 5?",
    "c": null,
    "o": [
      "df[df['A'] == 5]",
      "df.where('A' = 5)",
      "df.select('A' == 5)",
      "df.filter('A' == 5)"
    ]
  },
  {
    "q": "Which of the following code will convert a DataFrame to a list of dictionaries?",
    "c": null,
    "o": [
      "df.to_dict(orient='records')",
      "df.to_list()",
      "dict(df)",
      "df.tolist()"
    ]
  },
  {
    "q": "What will `df.duplicated().sum()` return?",
    "c": null,
    "o": [
      "Number of duplicate rows",
      "Boolean values of duplicates",
      "Number of NaNs",
      "Count of unique rows"
    ]
  },
  {
    "q": "Which method is used to rename the index in a DataFrame?",
    "c": null,
    "o": [
      "rename(index={...})",
      "change_index()",
      "set_index_name()",
      "replace_index()"
    ]
  },
  {
    "q": "What does `df['A'].notnull()` return?",
    "c": null,
    "o": [
      "Boolean Series where values are not NaN",
      "Only non-null values",
      "Null values in column A",
      "Removes NaN values"
    ]
  },
  {
    "q": "Which of the following is used to create a copy of a DataFrame?",
    "c": null,
    "o": [
      "df.copy()",
      "df.clone()",
      "df.duplicate()",
      "df.replicate()"
    ]
  },
  {
    "q": "What is the result of `df['A'].sum()`?",
    "c": null,
    "o": [
      "Sum of all values in column A",
      "Average of column A",
      "Count of values in A",
      "Cumulative sum of A"
    ]
  },
  {
    "q": "Which pandas object is returned by `groupby()`?",
    "c": null,
    "o": [
      "DataFrameGroupBy",
      "GroupedDataFrame",
      "GroupedObject",
      "GroupData"
    ]
  },
  {
    "q": "How can you get column data types in a DataFrame?",
    "c": null,
    "o": [
      "df.dtypes",
      "df.types",
      "df.get_types()",
      "df.schema()"
    ]
  },
  {
    "q": "What does `df.loc[0]` return?",
    "c": null,
    "o": [
      "Row with index label 0",
      "Row at position 0",
      "First column",
      "All rows except index 0"
    ]
  },
  {
    "q": "How do you remove columns with all NaN values?",
    "c": null,
    "o": [
      "df.dropna(axis=1, how='all')",
      "df.remove_nan(axis=1)",
      "df.fillna(0)",
      "df.clear(columns='all')"
    ]
  },
  {
    "q": "What is the default behavior of `pd.concat()` when `axis` is not specified?",
    "c": null,
    "o": [
      "Stacks along rows (axis=0)",
      "Stacks along columns (axis=1)",
      "Merges on index",
      "Raises an error"
    ]
  },
  {
    "q": "What does the `axis=0` represent in a DataFrame operation?",
    "c": null,
    "o": [
      "Rows",
      "Columns",
      "Cells",
      "All elements"
    ]
  },
  {
    "q": "What is the correct method to check if any value is NaN in a DataFrame?",
    "c": null,
    "o": [
      "df.isnull().any().any()",
      "df.isnull() == True",
      "df.hasna()",
      "df.check_nan()"
    ]
  },
  {
    "q": "Which argument is used in `to_csv()` to prevent the index from being written?",
    "c": null,
    "o": [
      "index=False",
      "skip_index=True",
      "drop_index=True",
      "write_index=False"
    ]
  },
  {
    "q": "Which method can be used to assign new column values using logic or conditions?",
    "c": null,
    "o": [
      "assign()",
      "set_column()",
      "insert_column()",
      "update_column()"
    ]
  },
  {
    "q": "What will `df['A'].cumsum()` compute?",
    "c": null,
    "o": [
      "Cumulative sum of values in column A",
      "Total sum of values in A",
      "Count of values in A",
      "Mean of A"
    ]
  },
  {
    "q": "How do you convert a DataFrame to a string format for printing?",
    "c": null,
    "o": [
      "to_string()",
      "as_text()",
      "stringify()",
      "print_table()"
    ]
  },
  {
    "q": "Which method would you use to generate dummy/indicator variables?",
    "c": null,
    "o": [
      "get_dummies()",
      "to_one_hot()",
      "make_indicators()",
      "generate_dummy()"
    ]
  },
  {
    "q": "What is the purpose of `df.sample()`?",
    "c": null,
    "o": [
      "Returns a random sample of rows",
      "Sorts the DataFrame",
      "Filters missing rows",
      "Applies sampling rate"
    ]
  },
  {
    "q": "Which of the following methods returns the index labels?",
    "c": null,
    "o": [
      "df.index",
      "df.labels",
      "df.rows",
      "df.indices"
    ]
  },
  {
    "q": "How do you combine two DataFrames by matching values in a specific column?",
    "c": null,
    "o": [
      "merge()",
      "concat()",
      "append()",
      "groupby()"
    ]
  },
  {
    "q": "Which of the following will export a DataFrame to a JSON file?",
    "c": null,
    "o": [
      "to_json()",
      "save_json()",
      "write_json()",
      "export_to_json()"
    ]
  },
  {
    "q": "Which method shows the number of rows and columns of a DataFrame?",
    "c": null,
    "o": [
      "shape",
      "size",
      "length",
      "dim()"
    ]
  },
  {
    "q": "How can you drop multiple columns at once?",
    "c": null,
    "o": [
      "df.drop(['A', 'B'], axis=1)",
      "df.remove(['A', 'B'])",
      "df.delete(columns=['A','B'])",
      "df.exclude('A', 'B')"
    ]
  },
  {
    "q": "Which method is used to rename column labels in pandas?",
    "c": null,
    "o": [
      "rename(columns={...})",
      "set_columns({...})",
      "change_labels({...})",
      "alter_columns({...})"
    ]
  },
  {
    "q": "How do you select rows by index position in pandas?",
    "c": null,
    "o": [
      "iloc",
      "loc",
      "ix",
      "id"
    ]
  },
  {
    "q": "What does `df.values` return?",
    "c": null,
    "o": [
      "Underlying numpy array of the DataFrame",
      "Column headers",
      "DataFrame as dictionary",
      "Only non-null values"
    ]
  },
  {
    "q": "What does the `df.columns.tolist()` return?",
    "c": null,
    "o": [
      "A list of column names",
      "A list of row values",
      "A dictionary of column data",
      "A string of column headers"
    ]
  },
  {
    "q": "Which method returns the number of elements in a DataFrame?",
    "c": null,
    "o": [
      "size",
      "shape",
      "len()",
      "count()"
    ]
  },
  {
    "q": "What does the `df['A'].max()` return?",
    "c": null,
    "o": [
      "Maximum value in column A",
      "Index of the max value",
      "Row with max value",
      "Minimum value in column A"
    ]
  },
  {
    "q": "How can you count the number of unique values in a Series?",
    "c": null,
    "o": [
      "nunique()",
      "count_unique()",
      "unique().count()",
      "value_counts()"
    ]
  },
  {
    "q": "Which of the following will convert a column to string type?",
    "c": null,
    "o": [
      "astype(str)",
      "convert(str)",
      "to_string()",
      "stringify()"
    ]
  },
  {
    "q": "What does `df.iloc[0, 0]` return?",
    "c": null,
    "o": [
      "Value at first row and first column",
      "First row only",
      "First column only",
      "Index label of first row"
    ]
  },
  {
    "q": "Which of the following will return the data type of each Series in a DataFrame?",
    "c": null,
    "o": [
      "df.dtypes",
      "df.datatypes",
      "df.schema",
      "df.columns.types"
    ]
  },
  {
    "q": "How do you select all rows where column 'A' is not null?",
    "c": null,
    "o": [
      "df[df['A'].notnull()]",
      "df.notna('A')",
      "df.dropna('A')",
      "df[df['A'] != NaN]"
    ]
  },
  {
    "q": "What does the `axis` parameter control in many pandas methods?",
    "c": null,
    "o": [
      "Whether to apply operation across rows or columns",
      "Whether to return a DataFrame or Series",
      "Whether to skip null values",
      "Whether to apply inplace or not"
    ]
  },
  {
    "q": "Which of the following will select the last 10 rows of a DataFrame?",
    "c": null,
    "o": [
      "df.tail(10)",
      "df.bottom(10)",
      "df[-10:]",
      "df.last(10)"
    ]
  },
  {
    "q": "How can you concatenate two Series vertically?",
    "c": null,
    "o": [
      "pd.concat([s1, s2])",
      "s1.append(s2, axis=1)",
      "s1 + s2",
      "pd.merge(s1, s2)"
    ]
  },
  {
    "q": "Which parameter of `read_csv()` is used to limit the number of rows read?",
    "c": null,
    "o": [
      "nrows",
      "max_rows",
      "row_limit",
      "read_limit"
    ]
  },
  {
    "q": "What does the `inplace=True` argument do in DataFrame methods?",
    "c": null,
    "o": [
      "Modifies the DataFrame directly",
      "Returns a new DataFrame",
      "Creates a deep copy",
      "Asks for user input"
    ]
  },
  {
    "q": "Which of the following correctly sets 'col1' as the index of a DataFrame?",
    "c": null,
    "o": [
      "df.set_index('col1')",
      "df.index = 'col1'",
      "df.set_index = 'col1'",
      "df.index_by('col1')"
    ]
  },
  {
    "q": "Which argument in `read_csv()` specifies the delimiter if not a comma?",
    "c": null,
    "o": [
      "sep",
      "delimiter",
      "split_by",
      "delim"
    ]
  },
  {
    "q": "Which method is used to sort a DataFrame by its index?",
    "c": null,
    "o": [
      "sort_index()",
      "sort_by_index()",
      "index_sort()",
      "sort(axis='index')"
    ]
  },
  {
    "q": "How do you round all numerical values in a DataFrame to 2 decimal places?",
    "c": null,
    "o": [
      "df.round(2)",
      "df.precision(2)",
      "df.set_decimal(2)",
      "df.fix(2)"
    ]
  },
  {
    "q": "What does `df.describe()` return?",
    "c": null,
    "o": [
      "Summary statistics of numeric columns",
      "Data types of each column",
      "All column names",
      "Null value count"
    ]
  },
  {
    "q": "How do you create a date range with 10 daily periods starting from 2022-01-01?",
    "c": null,
    "o": [
      "pd.date_range('2022-01-01', periods=10)",
      "pd.date_series('2022-01-01', 10)",
      "pd.range_date('2022-01-01', 10)",
      "pd.date_index('2022-01-01', 10)"
    ]
  },
  {
    "q": "Which method resets the index of a DataFrame?",
    "c": null,
    "o": [
      "reset_index()",
      "drop_index()",
      "index_reset()",
      "clear_index()"
    ]
  },
  {
    "q": "What is the default axis in `df.dropna()`?",
    "c": null,
    "o": [
      "axis=0 (rows)",
      "axis=1 (columns)",
      "axis='both'",
      "axis=None"
    ]
  },
  {
    "q": "Which method shows the number of non-null entries per column?",
    "c": null,
    "o": [
      "df.count()",
      "df.length()",
      "df.describe(count=True)",
      "df.notnull()"
    ]
  },
  {
    "q": "How do you rename a single column 'old' to 'new'?",
    "c": null,
    "o": [
      "df.rename(columns={'old': 'new'})",
      "df.columns['old'] = 'new'",
      "df.rename_column('old', 'new')",
      "df.change_column('old', 'new')"
    ]
  },
  {
    "q": "Which method would you use to convert string dates to datetime objects?",
    "c": null,
    "o": [
      "pd.to_datetime()",
      "pd.convert_to_date()",
      "pd.date_object()",
      "pd.as_datetime()"
    ]
  },
  {
    "q": "What does `df.T` return?",
    "c": null,
    "o": [
      "The transpose of the DataFrame",
      "The top 5 rows",
      "The type of DataFrame",
      "A Series of column names"
    ]
  },
  {
    "q": "Which method returns unique values in a Series?",
    "c": null,
    "o": [
      "unique()",
      "distinct()",
      "get_uniques()",
      "singles()"
    ]
  },
  {
    "q": "How do you merge two DataFrames using a common column?",
    "c": null,
    "o": [
      "merge()",
      "concat()",
      "stack()",
      "groupby()"
    ]
  },
  {
    "q": "What does `df.memory_usage()` show?",
    "c": null,
    "o": [
      "Memory used by each column",
      "Total memory on system",
      "Memory leaks",
      "CPU time for each operation"
    ]
  },
  {
    "q": "Which method fills missing values with a specified value?",
    "c": null,
    "o": [
      "fillna()",
      "replace_nulls()",
      "fill_missing()",
      "patchna()"
    ]
  },
  {
    "q": "Which method can you use to convert column names to lowercase?",
    "c": null,
    "o": [
      "df.columns = df.columns.str.lower()",
      "df.columns.lower()",
      "df.rename_lower()",
      "df.set_lowercase_columns()"
    ]
  },
  {
    "q": "Which method gives the first few rows of a DataFrame?",
    "c": null,
    "o": [
      "head()",
      "top()",
      "start()",
      "first()"
    ]
  },
  {
    "q": "What does `df.info()` provide?",
    "c": null,
    "o": [
      "Summary including index dtype, column dtypes, and non-null values",
      "Basic statistics like mean and std",
      "Value counts of categorical columns",
      "List of missing values only"
    ]
  },
  {
    "q": "How can you check if any column has missing values?",
    "c": null,
    "o": [
      "df.isnull().any()",
      "df.null().exists()",
      "df.has_null()",
      "df.check_na()"
    ]
  },
  {
    "q": "What does `df.mean()` do?",
    "c": null,
    "o": [
      "Returns mean of each numerical column",
      "Returns overall mean of entire DataFrame",
      "Returns mean of index values",
      "Returns only the column with highest mean"
    ]
  },
  {
    "q": "Which function is used to combine DataFrames along columns?",
    "c": null,
    "o": [
      "pd.concat([...], axis=1)",
      "pd.merge([...], axis=1)",
      "pd.append([...], axis=1)",
      "pd.join([...], axis=1)"
    ]
  },
  {
    "q": "Which of the following will drop duplicate rows in a DataFrame?",
    "c": null,
    "o": [
      "drop_duplicates()",
      "remove_duplicates()",
      "drop_duplicated()",
      "unique_rows()"
    ]
  },
  {
    "q": "How do you convert a DataFrame column to datetime?",
    "c": null,
    "o": [
      "pd.to_datetime(df['col'])",
      "df.to_date('col')",
      "convert(df['col']).to_date()",
      "df.datetime('col')"
    ]
  },
  {
    "q": "Which attribute gives the number of rows and columns of a DataFrame?",
    "c": null,
    "o": [
      "shape",
      "size",
      "count",
      "length"
    ]
  },
  {
    "q": "What is the purpose of `dropna(how='all')`?",
    "c": null,
    "o": [
      "Drop rows where all values are missing",
      "Drop columns with any missing values",
      "Drop non-null rows",
      "Drop only duplicated rows"
    ]
  },
  {
    "q": "Which method replaces missing values using forward fill?",
    "c": null,
    "o": [
      "fillna(method='ffill')",
      "fill_forward()",
      "fillna(direction='forward')",
      "fillna(ff=True)"
    ]
  },
  {
    "q": "How do you get the index of a DataFrame?",
    "c": null,
    "o": [
      "df.index",
      "df.get_index()",
      "df.row_index",
      "df.idx"
    ]
  },
  {
    "q": "What is the default behavior of `groupby()`?",
    "c": null,
    "o": [
      "Groups by unique values in the given column",
      "Sorts data by group",
      "Aggregates using sum",
      "Filters only duplicated values"
    ]
  },
  {
    "q": "How can you check for duplicated rows?",
    "c": null,
    "o": [
      "df.duplicated()",
      "df.is_duplicated()",
      "df.check_duplicates()",
      "df.duplicates()"
    ]
  },
  {
    "q": "What will `df['A'].astype(float)` do?",
    "c": null,
    "o": [
      "Convert column 'A' to float",
      "Remove decimals from 'A'",
      "Cast entire DataFrame to float",
      "Round column 'A' values"
    ]
  },
  {
    "q": "Which of the following selects multiple specific columns from a DataFrame?",
    "c": null,
    "o": [
      "df[['A', 'B']]",
      "df['A', 'B']",
      "df.select(['A', 'B'])",
      "df.get('A', 'B')"
    ]
  },
  {
    "q": "Which method would you use to change the column order of a DataFrame?",
    "c": null,
    "o": [
      "df = df[['col3', 'col1', 'col2']]",
      "df.change_order(['col3', 'col1', 'col2'])",
      "df.reorder_columns(['col3', 'col1', 'col2'])",
      "df.set_column_order(['col3', 'col1', 'col2'])"
    ]
  },
  {
    "q": "How do you get summary statistics for only object (string) columns?",
    "c": null,
    "o": [
      "df.describe(include=['object'])",
      "df.describe_objects()",
      "df.summary(object=True)",
      "df.describe().only_object()"
    ]
  },
  {
    "q": "Which method can count how many times each unique value occurs in a Series?",
    "c": null,
    "o": [
      "value_counts()",
      "unique()",
      "count_unique()",
      "mode()"
    ]
  },
  {
    "q": "What does `inplace=True` do in pandas methods?",
    "c": null,
    "o": [
      "Modifies the original object without returning a new one",
      "Creates a temporary DataFrame",
      "Forces garbage collection",
      "Returns a backup copy of the data"
    ]
  },
  {
    "q": "Which of the following is a correct way to read a CSV file into a DataFrame?",
    "c": null,
    "o": [
      "pd.read_csv('file.csv')",
      "pd.import_csv('file.csv')",
      "pd.read.file('file.csv')",
      "pd.load_csv('file.csv')"
    ]
  },
  {
    "q": "Which attribute returns the number of elements in a DataFrame?",
    "c": null,
    "o": [
      "df.size",
      "df.shape",
      "df.count",
      "df.length"
    ]
  },
  {
    "q": "Which pandas function helps to check for missing values?",
    "c": null,
    "o": [
      "isnull()",
      "missing()",
      "checkna()",
      "nullvalues()"
    ]
  },
  {
    "q": "Which method returns a cross-tabulation of two columns?",
    "c": null,
    "o": [
      "pd.crosstab()",
      "pd.pivot_table()",
      "df.groupby()",
      "df.pivot()"
    ]
  },
  {
    "q": "What is the purpose of `pd.options.display.max_rows`?",
    "c": null,
    "o": [
      "Control how many rows are printed when displaying a DataFrame",
      "Limit the number of rows that can be in a DataFrame",
      "Remove extra rows from the end",
      "Hide all rows with null values"
    ]
  },
  {
    "q": "What does `df.dtypes` return?",
    "c": null,
    "o": [
      "Data types of each column",
      "Null status of each column",
      "Unique values in each column",
      "Description of column labels"
    ]
  },
  {
    "q": "Which pandas method is best for converting categorical columns into dummy/indicator variables?",
    "c": null,
    "o": [
      "get_dummies()",
      "one_hot()",
      "make_dummies()",
      "dummy_vars()"
    ]
  },
  {
    "q": "Which method removes all rows with missing values?",
    "c": null,
    "o": [
      "dropna()",
      "fillna(drop=True)",
      "remove_null()",
      "clear_missing()"
    ]
  },
  {
    "q": "Which of the following gives column names of a DataFrame?",
    "c": null,
    "o": [
      "df.columns",
      "df.colnames()",
      "df.col",
      "df.header"
    ]
  },
  {
    "q": "What is the default delimiter for `pd.read_csv()`?",
    "c": null,
    "o": [
      "Comma",
      "Semicolon",
      "Tab",
      "Whitespace"
    ]
  },
  {
    "q": "How do you access the values in a DataFrame as a NumPy array?",
    "c": null,
    "o": [
      "df.values",
      "df.array()",
      "df.to_numpy_array()",
      "df.get_array()"
    ]
  },
  {
    "q": "Which of the following selects rows by label in a DataFrame?",
    "c": null,
    "o": [
      "df.loc[]",
      "df.iloc[]",
      "df.select[]",
      "df.label[]"
    ]
  },
  {
    "q": "Which of the following selects rows by integer location?",
    "c": null,
    "o": [
      "df.iloc[]",
      "df.loc[]",
      "df.index[]",
      "df.row[]"
    ]
  },
  {
    "q": "Which method provides basic statistical summary of DataFrame?",
    "c": null,
    "o": [
      "df.describe()",
      "df.summary()",
      "df.stats()",
      "df.explain()"
    ]
  },
  {
    "q": "Which parameter of `read_csv()` specifies the column to use as index?",
    "c": null,
    "o": [
      "index_col",
      "set_index",
      "use_index",
      "key_col"
    ]
  },
  {
    "q": "Which method removes a column from a DataFrame?",
    "c": null,
    "o": [
      "df.drop('col', axis=1)",
      "df.remove_column('col')",
      "df.delete('col')",
      "df.drop_column('col')"
    ]
  },
  {
    "q": "What does `df['A'].unique()` return?",
    "c": null,
    "o": [
      "Array of unique values in column A",
      "Number of unique values",
      "Duplicates in column A",
      "Rows with missing values"
    ]
  },
  {
    "q": "Which method resets the index of a DataFrame?",
    "c": null,
    "o": [
      "reset_index()",
      "index_reset()",
      "reindex()",
      "drop_index()"
    ]
  },
  {
    "q": "Which pandas object is a 1-dimensional labeled array?",
    "c": null,
    "o": [
      "Series",
      "DataFrame",
      "Array",
      "Matrix"
    ]
  },
  {
    "q": "How do you get the number of non-null entries per column?",
    "c": null,
    "o": [
      "df.count()",
      "df.length()",
      "df.total()",
      "df.size()"
    ]
  },
  {
    "q": "Which is used to combine DataFrames based on a common key?",
    "c": null,
    "o": [
      "merge()",
      "join()",
      "append()",
      "concat()"
    ]
  },
  {
    "q": "Which method checks if all values in a Series are True?",
    "c": null,
    "o": [
      "all()",
      "is_all()",
      "every()",
      "check_all()"
    ]
  },
  {
    "q": "How can you round the values of a DataFrame to 2 decimals?",
    "c": null,
    "o": [
      "df.round(2)",
      "df.precision(2)",
      "df.decimal(2)",
      "df.set_precision(2)"
    ]
  },
  {
    "q": "How do you select rows where column 'A' is greater than 5?",
    "c": "\ndf[df['A'] > 5]",
    "o": [
      "df[df['A'] > 5]",
      "df('A' > 5)",
      "df.select('A' > 5)",
      "df.where('A' > 5)"
    ]
  },
  {
    "q": "What does `df.T` represent in pandas?",
    "c": null,
    "o": [
      "Transpose of the DataFrame",
      "Type of DataFrame",
      "Top rows of DataFrame",
      "Total rows in DataFrame"
    ]
  },
  {
    "q": "Which method is used to get the data types of each column?",
    "c": null,
    "o": [
      "df.dtypes",
      "df.types()",
      "df.column_types",
      "df.get_types()"
    ]
  },
  {
    "q": "Which of the following is faster and more efficient in pandas?",
    "c": null,
    "o": [
      "Vectorized operations",
      "Using apply with lambda",
      "Using for loops",
      "Using map with custom function"
    ]
  },
  {
    "q": "What does `vectorized` mean in the context of pandas?",
    "c": null,
    "o": [
      "Operations are applied to whole arrays at once",
      "Each element is processed in a separate thread",
      "Operations require GPU acceleration",
      "Each row is iterated using a for loop"
    ]
  },
  {
    "q": "Which is usually faster for numeric transformations?",
    "c": null,
    "o": [
      "Using built-in vectorized functions",
      "Using `apply()` with lambda",
      "Using `map()` with lambda",
      "Using nested for loops"
    ]
  },
  {
    "q": "When should you avoid using `.apply()` in pandas?",
    "c": null,
    "o": [
      "When a vectorized alternative is available",
      "When working with strings",
      "When applying to a Series",
      "When using custom functions"
    ]
  },
  {
    "q": "What is the use of `df.memory_usage()` in pandas?",
    "c": null,
    "o": [
      "To check the memory used by each column",
      "To estimate the time taken for computation",
      "To count the number of missing values",
      "To measure CPU usage"
    ]
  },
  {
    "q": "What does `df.astype()` do in terms of performance?",
    "c": null,
    "o": [
      "Changes data type which can reduce memory usage",
      "Creates a backup of the DataFrame",
      "Applies functions row by row",
      "Removes unnecessary columns"
    ]
  },
  {
    "q": "Which data type uses less memory in pandas?",
    "c": null,
    "o": [
      "category",
      "object",
      "float64",
      "int64"
    ]
  },
  {
    "q": "What is a benefit of converting object columns to category?",
    "c": null,
    "o": [
      "Saves memory and speeds up operations",
      "Increases file size",
      "Makes data immutable",
      "Automatically sorts the values"
    ]
  },
  {
    "q": "What is a disadvantage of using `apply()` with a custom Python function?",
    "c": null,
    "o": [
      "Slower than built-in vectorized operations",
      "Returns incorrect results",
      "Changes the original DataFrame",
      "Only works with numeric data"
    ]
  },
  {
    "q": "Which is more memory-efficient for storing yes/no or gender-like data?",
    "c": null,
    "o": [
      "Using pandas 'category' dtype",
      "Using string values",
      "Using integer codes",
      "Using float64 values"
    ]
  },
  {
    "q": "Which of the following will combine DataFrames `df1` and `df2` by their indexes?",
    "c": "\npd.concat([df1, df2], axis=1)",
    "o": [
      "pd.concat([df1, df2], axis=1)",
      "df1.append(df2)",
      "pd.merge(df1, df2)",
      "pd.concat([df1, df2])"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "\ndf.groupby('Category')['Sales'].agg(['sum', 'mean'])",
    "o": [
      "It shows total and average sales per category",
      "It throws an error",
      "It creates a pivot table",
      "It merges 'Sales' with 'Category'"
    ]
  },
  {
    "q": "Which of the following methods is **NOT** used for handling missing values?",
    "c": null,
    "o": [
      "fill_range()",
      "fillna()",
      "dropna()",
      "interpolate()"
    ]
  },
  {
    "q": "What does `df['col'].apply(len)` do when `col` contains string values?",
    "c": null,
    "o": [
      "Returns length of each string in the column",
      "Applies len() to entire column at once",
      "Converts strings to numbers",
      "Drops null values"
    ]
  },
  {
    "q": "Which method is used to write a DataFrame to a SQL table?",
    "c": null,
    "o": [
      "to_sql()",
      "write_sql()",
      "export_sql()",
      "save_to_db()"
    ]
  },
  {
    "q": "Which of the following is best to reduce memory usage of a float64 column with only small values?",
    "c": null,
    "o": [
      "Convert to float32 using astype('float32')",
      "Convert to int",
      "Convert to object",
      "Use category dtype"
    ]
  },
  {
    "q": "How can you group by two columns in pandas?",
    "c": "\ndf.groupby(['col1', 'col2']).sum()",
    "o": [
      "df.groupby(['col1', 'col2']).sum()",
      "df.group(['col1', 'col2'])",
      "df.groupby('col1', 'col2')",
      "groupby(df, ['col1', 'col2'])"
    ]
  },
  {
    "q": "Which of the following methods pivots data by converting rows to columns?",
    "c": null,
    "o": [
      "pivot()",
      "melt()",
      "stack()",
      "groupby()"
    ]
  },
  {
    "q": "What does `df['date'] = pd.to_datetime(df['date'])` achieve?",
    "c": null,
    "o": [
      "Converts string or object to datetime dtype",
      "Removes time zone information",
      "Converts datetime to string",
      "Creates a new column"
    ]
  },
  {
    "q": "What is the difference between `merge()` and `join()` in pandas?",
    "c": null,
    "o": [
      "`merge()` is more flexible and used for combining on columns, `join()` is index-based",
      "Both are identical in all use cases",
      "`join()` is for SQL databases only",
      "`merge()` only works on Series"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "df.resample('M').sum()",
    "o": [
      "Monthly sum of rows based on datetime index",
      "Adds a new month column",
      "Removes rows without date values",
      "Returns rows where column 'M' is summed"
    ]
  },
  {
    "q": "Which of the following reshapes a DataFrame from wide to long format?",
    "c": null,
    "o": [
      "melt()",
      "pivot()",
      "stack()",
      "explode()"
    ]
  },
  {
    "q": "When merging DataFrames, which parameter defines the type of join (e.g., 'inner', 'left')?",
    "c": null,
    "o": [
      "how",
      "on",
      "type",
      "join_type"
    ]
  },
  {
    "q": "Which method is used to evaluate row-wise conditions more efficiently than using `apply()`?",
    "c": null,
    "o": [
      "np.where()",
      "df.apply()",
      "df.eval()",
      "df.query()"
    ]
  },
  {
    "q": "Which function is best suited for chaining multiple condition filters using strings?",
    "c": null,
    "o": [
      "query()",
      "apply()",
      "select()",
      "loc[]"
    ]
  },
  {
    "q": "Which of the following best describes the `.transform()` method in a groupby operation?",
    "c": null,
    "o": [
      "Returns same shape as original, applying function group-wise",
      "Returns aggregated result per group",
      "Filters groups based on condition",
      "Combines two groupby objects"
    ]
  },
  {
    "q": "What does `drop_duplicates(subset=['A'], keep='last')` do?",
    "c": null,
    "o": [
      "Keeps the last occurrence of each duplicate in column A",
      "Drops all rows with any duplicates",
      "Keeps all rows except the first duplicate",
      "Drops column A"
    ]
  },
  {
    "q": "What is the result of using `dt.tz_convert('US/Eastern')` on a datetime-aware column?",
    "c": null,
    "o": [
      "Converts timezone to US/Eastern",
      "Changes data type to string",
      "Removes timezone",
      "Converts to UTC"
    ]
  },
  {
    "q": "Which of the following allows chained method calls on DataFrames safely?",
    "c": null,
    "o": [
      "df.pipe()",
      "df.eval()",
      "df.applymap()",
      "df.transform()"
    ]
  },
  {
    "q": "If you want to apply a function to every element of a DataFrame, what should you use?",
    "c": null,
    "o": [
      "applymap()",
      "apply()",
      "map()",
      "eval()"
    ]
  },
  {
    "q": "What is the output shape of this operation?\n`df.groupby('Category').transform('sum')`",
    "c": null,
    "o": [
      "Same shape as original DataFrame",
      "Smaller shape due to grouping",
      "Single scalar value",
      "Only the group keys"
    ]
  },
  {
    "q": "Which of the following is true about `pivot_table()` compared to `pivot()`?",
    "c": null,
    "o": [
      "`pivot_table()` allows aggregation functions",
      "`pivot()` handles missing data better",
      "`pivot()` is faster for large datasets",
      "`pivot_table()` only works on numeric data"
    ]
  },
  {
    "q": "What does `df.loc[:, 'B':'D']` return?",
    "c": null,
    "o": [
      "All rows and columns B through D (inclusive)",
      "Only columns B and D",
      "Only rows where B equals D",
      "First 3 rows of the DataFrame"
    ]
  },
  {
    "q": "Which code converts column 'A' from object to category and sorts by its order?",
    "c": null,
    "o": [
      "df['A'] = df['A'].astype('category'); df.sort_values('A')",
      "df['A'].to_category(); df.sort('A')",
      "df.sort_values('A').astype('category')",
      "df['A'].convert('category')"
    ]
  },
  {
    "q": "How can you check which columns in a DataFrame are taking the most memory?",
    "c": null,
    "o": [
      "df.memory_usage().sort_values(ascending=False)",
      "df.describe()",
      "df.dtypes.sort()",
      "df.columns.memory()"
    ]
  },
  {
    "q": "What does `df.index.is_monotonic_increasing` check?",
    "c": null,
    "o": [
      "Whether index values are sorted in increasing order",
      "Whether index values are unique",
      "Whether DataFrame is sorted by columns",
      "Whether rows are increasing in size"
    ]
  },
  {
    "q": "Which function is used to create lag features in time series data?",
    "c": null,
    "o": [
      "df.shift()",
      "df.diff()",
      "df.rolling()",
      "df.resample()"
    ]
  },
  {
    "q": "Which of the following is **not true** about `apply()`?",
    "c": null,
    "o": [
      "It always returns a DataFrame",
      "It can be applied on rows or columns",
      "It is slower than vectorized operations",
      "It accepts user-defined functions"
    ]
  },
  {
    "q": "What is the purpose of `errors='coerce'` in `pd.to_numeric()`?",
    "c": null,
    "o": [
      "Converts invalid values to NaN",
      "Raises error on invalid values",
      "Drops invalid rows",
      "Replaces invalid values with 0"
    ]
  },
  {
    "q": "What is the result of `df.corr()` on a DataFrame with numerical columns?",
    "c": null,
    "o": [
      "A matrix of pairwise correlation coefficients",
      "A matrix of differences between columns",
      "A grouped summary by column type",
      "A one-hot encoded version of the DataFrame"
    ]
  },
  {
    "q": "What will the following code output?\n`df['col'].map({'A': 1, 'B': 2})`",
    "c": null,
    "o": [
      "Replaces 'A' with 1, 'B' with 2 in 'col', leaves others as NaN",
      "Replaces all values in 'col' with 1 or 2",
      "Throws an error if other values exist",
      "Removes rows with values not in the dictionary"
    ]
  },
  {
    "q": "Which operation is more memory efficient when replacing many repeating strings in a column?",
    "c": null,
    "o": [
      "Convert to category dtype",
      "Use map() with a lambda",
      "Convert to string",
      "Apply a for loop"
    ]
  },
  {
    "q": "What is the difference between `df['A'].fillna(method='bfill')` and `df['A'].bfill()`?",
    "c": null,
    "o": [
      "Both are equivalent and fill missing values using next valid value",
      "Only bfill() can be chained",
      "fillna() cant fill strings",
      "bfill() fills with zero"
    ]
  },
  {
    "q": "How can you calculate a rolling average of 3 periods on a time series?",
    "c": null,
    "o": [
      "df.rolling(window=3).mean()",
      "df.shift(3).mean()",
      "df.resample('3D').mean()",
      "df.expanding(3).mean()"
    ]
  },
  {
    "q": "What is the purpose of `dropna(subset=['A'])`?",
    "c": null,
    "o": [
      "Drops rows where column A has NaN",
      "Drops column A if it has any NaNs",
      "Drops NaNs across all columns",
      "Drops duplicates in column A"
    ]
  },
  {
    "q": "Which join type returns all rows from both DataFrames, filling with NaNs where no match is found?",
    "c": null,
    "o": [
      "outer",
      "inner",
      "left",
      "right"
    ]
  },
  {
    "q": "What does `df[df['A'].notnull() & df['B'] > 10]` do?",
    "c": null,
    "o": [
      "Filters rows where A is not null and B is greater than 10",
      "Fills null values in A with 10",
      "Drops rows where A or B are null",
      "Returns summary stats for columns A and B"
    ]
  },
  {
    "q": "Which method allows safe filtering using a string expression like `'A > 10 and B < 20'`?",
    "c": null,
    "o": [
      "df.query()",
      "df.loc[]",
      "df.eval()",
      "df.filter()"
    ]
  },
  {
    "q": "What is the output of `df.T`?",
    "c": null,
    "o": [
      "Transposes the DataFrame (swaps rows and columns)",
      "Removes text columns",
      "Returns only top rows",
      "Times each element by 10"
    ]
  },
  {
    "q": "Which method is useful for checking correlation between columns in a DataFrame?",
    "c": null,
    "o": [
      "df.corr()",
      "df.describe()",
      "df.agg()",
      "df.hist()"
    ]
  },
  {
    "q": "What does `df.groupby('key').agg({'A': 'sum', 'B': 'mean'})` return?",
    "c": null,
    "o": [
      "A DataFrame with 'A' summed and 'B' averaged for each group in 'key'",
      "Only the sum of column A",
      "The same shape as the original DataFrame",
      "Only averages of column B"
    ]
  },
  {
    "q": "How would you get a list of columns that contain any missing values?",
    "c": null,
    "o": [
      "df.columns[df.isnull().any()].tolist()",
      "df.columns[df.isnull().all()]",
      "df.columns[df.notnull().any()]",
      "df.columns[df.dtypes == 'NaN']"
    ]
  },
  {
    "q": "Which method allows you to apply a different function to each column type?",
    "c": null,
    "o": [
      "df.aggregate({'col1': np.sum, 'col2': np.mean})",
      "df.applymap()",
      "df.transform()",
      "df.map()"
    ]
  },
  {
    "q": "What will `df['date'].dt.year` return?",
    "c": null,
    "o": [
      "Extracts year from datetime column",
      "Converts entire date to year type",
      "Removes time component",
      "Adds year as new index"
    ]
  },
  {
    "q": "Which method is used to optimize memory for large string columns?",
    "c": null,
    "o": [
      "astype('category')",
      "astype('object')",
      "to_string()",
      "df.memory_usage(deep=False)"
    ]
  },
  {
    "q": "What does `df.reindex(range(10))` do?",
    "c": null,
    "o": [
      "Changes the index to range(10), inserting NaNs if index missing",
      "Shuffles the DataFrame",
      "Deletes existing index permanently",
      "Returns the first 10 rows"
    ]
  },
  {
    "q": "When would `explode()` be used in Pandas?",
    "c": null,
    "o": [
      "To transform list-like entries in a column into multiple rows",
      "To delete duplicate entries",
      "To split a string into characters",
      "To flatten a DataFrame"
    ]
  },
  {
    "q": "What is the key difference between `apply()` and `transform()` in a groupby context?",
    "c": null,
    "o": [
      "`transform()` returns same shape as original; `apply()` may not",
      "`apply()` is faster than `transform()`",
      "`transform()` only works on numerical data",
      "`apply()` cannot use custom functions"
    ]
  },
  {
    "q": "What is the use of `np.select()` in Pandas workflows?",
    "c": null,
    "o": [
      "To apply multiple conditional logic branches vectorized",
      "To randomly select a row from a DataFrame",
      "To sample rows based on probability",
      "To select columns by name"
    ]
  },
  {
    "q": "How can you chain multiple operations without intermediate variables in Pandas?",
    "c": null,
    "o": [
      "Using `pipe()`",
      "Using `applymap()`",
      "Using `groupby()`",
      "Using backslashes"
    ]
  },
  {
    "q": "Which function reads a SQL table directly into a DataFrame?",
    "c": null,
    "o": [
      "pd.read_sql_table()",
      "pd.read_sql_query()",
      "pd.read_sql_db()",
      "pd.import_sql_table()"
    ]
  },
  {
    "q": "How would you export a DataFrame to an Excel file with multiple sheets?",
    "c": null,
    "o": [
      "Using `pd.ExcelWriter()` context manager",
      "Using `df.to_csv()` with sheet_name parameter",
      "Using `df.save()` with Excel format",
      "Using `df.to_excel('file.xlsx', sheet=True)`"
    ]
  },
  {
    "q": "Which method shows memory usage of each column including object dtype?",
    "c": null,
    "o": [
      "df.memory_usage(deep=True)",
      "df.info(memory=True)",
      "df.describe(include='object')",
      "df.size(deep=True)"
    ]
  },
  {
    "q": "What happens when reading a large CSV file with `low_memory=False`?",
    "c": null,
    "o": [
      "Pandas reads entire file into memory to infer data types accurately",
      "File loads faster by skipping type inference",
      "Pandas chunks the file into batches",
      "It disables column type detection"
    ]
  },
  {
    "q": "Which method allows combining DataFrames with overlapping columns using a specific key?",
    "c": null,
    "o": [
      "pd.merge()",
      "df.concat()",
      "df.combine()",
      "df.append()"
    ]
  },
  {
    "q": "What does `df.resample('H').ffill()` do?",
    "c": null,
    "o": [
      "Resamples data to hourly frequency and forward-fills missing values",
      "Fills NaNs with 0 after hourly grouping",
      "Backfills missing values before resampling",
      "Interpolates values over hours"
    ]
  },
  {
    "q": "How can you improve performance when working with large string columns?",
    "c": null,
    "o": [
      "Convert them to 'category' dtype",
      "Convert to 'object' dtype",
      "Use `.apply(str)`",
      "Replace all missing strings with ''"
    ]
  },
  {
    "q": "What is the output of `df.iloc[:, [1, 3]]`?",
    "c": null,
    "o": [
      "All rows, only columns at index 1 and 3",
      "Rows 1 through 3, all columns",
      "First 3 columns, 2nd and 4th rows only",
      "Only rows where column 1 > 3"
    ]
  },
  {
    "q": "What does `df.drop(columns=['A', 'B'], inplace=True)` do?",
    "c": null,
    "o": [
      "Removes columns A and B from the DataFrame permanently",
      "Temporarily hides columns A and B",
      "Deletes rows that contain A or B values",
      "Renames columns A and B to null"
    ]
  },
  {
    "q": "Whats the benefit of using `query()` over standard Boolean indexing?",
    "c": null,
    "o": [
      "More readable and potentially faster for large DataFrames",
      "Does not require column names",
      "Supports regular expressions natively",
      "Avoids any type conversion"
    ]
  },
  {
    "q": "What does `df.astype({'A': 'float32'})` do?",
    "c": null,
    "o": [
      "Converts column A to 32-bit float",
      "Casts the entire DataFrame to float32",
      "Normalizes column A",
      "Rounding values in column A"
    ]
  },
  {
    "q": "Which parameter in `read_csv()` helps to load only a portion of a large file?",
    "c": null,
    "o": [
      "nrows",
      "skiprows",
      "chunksize",
      "partial"
    ]
  },
  {
    "q": "How can you write a DataFrame to a SQLite database?",
    "c": null,
    "o": [
      "df.to_sql('table_name', connection)",
      "df.to_sqlite('file.db')",
      "df.save_sql('table_name')",
      "pd.write_sql(df, connection)"
    ]
  },
  {
    "q": "Which method is best to fill missing values using the median of a column?",
    "c": null,
    "o": [
      "df['col'].fillna(df['col'].median())",
      "df['col'].replace(np.nan, df.mean())",
      "df.fillna('median')",
      "df['col'].fill(df.median())"
    ]
  },
  {
    "q": "What will `df['timestamp'].dt.tz_localize('UTC')` do?",
    "c": null,
    "o": [
      "Assigns UTC timezone to a naive datetime column",
      "Converts UTC datetime to local time",
      "Changes timezone from one to another",
      "Removes time part from datetime"
    ]
  },
  {
    "q": "How would you extract rows where column B is duplicated but keep only the first occurrence?",
    "c": null,
    "o": [
      "df[~df.duplicated('B')]",
      "df[df.duplicated('B')]",
      "df.drop_duplicates('B', keep='last')",
      "df[df.B.duplicated(keep='first')]"
    ]
  },
  {
    "q": "Whats the main benefit of using `df.eval('A + B')` over `df['A'] + df['B']`?",
    "c": null,
    "o": [
      "More efficient for large DataFrames due to expression evaluation engine",
      "It avoids memory allocation",
      "It works on non-numeric data",
      "It supports list operations"
    ]
  },
  {
    "q": "Which of the following is NOT a valid merge type in `pd.merge()`?",
    "c": null,
    "o": [
      "top",
      "left",
      "right",
      "outer"
    ]
  },
  {
    "q": "Which method can reshape long-format data to wide-format using a key and values?",
    "c": null,
    "o": [
      "pivot()",
      "melt()",
      "stack()",
      "unstack()"
    ]
  },
  {
    "q": "What does `df.isin(['X', 'Y'])` return?",
    "c": null,
    "o": [
      "Boolean DataFrame showing if each element is 'X' or 'Y'",
      "Selects rows containing 'X' or 'Y'",
      "Filters only 'X' and 'Y' columns",
      "Replaces other values with NaN"
    ]
  },
  {
    "q": "How can you write only specific columns of a DataFrame to a CSV file?",
    "c": null,
    "o": [
      "df.to_csv('file.csv', columns=['A', 'B'])",
      "df.write_csv(['A', 'B'], 'file.csv')",
      "df.save_csv('file.csv', include=['A', 'B'])",
      "df.to_csv(['A', 'B'], filename='file.csv')"
    ]
  },
  {
    "q": "Which method efficiently checks if any missing value exists in the DataFrame?",
    "c": null,
    "o": [
      "df.isnull().values.any()",
      "df.any(isna=True)",
      "df.hasna()",
      "pd.has_missing(df)"
    ]
  },
  {
    "q": "What is the purpose of using `parse_dates=['col']` in `read_csv()`?",
    "c": null,
    "o": [
      "Automatically convert column 'col' to datetime",
      "Sort by datetime values after reading",
      "Drop rows with invalid datetime",
      "Ensure no duplicates in datetime"
    ]
  },
  {
    "q": "Which parameter in `to_sql()` avoids inserting the index as a column?",
    "c": null,
    "o": [
      "index=False",
      "no_index=True",
      "ignore_index=True",
      "drop_index=True"
    ]
  },
  {
    "q": "Which Pandas method is best suited for converting object dtype with repeating values into an efficient format?",
    "c": null,
    "o": [
      "astype('category')",
      "astype('str')",
      "convert_objects()",
      "apply(str)"
    ]
  },
  {
    "q": "What does the `normalize=True` parameter in `value_counts()` do?",
    "c": null,
    "o": [
      "Returns relative frequencies instead of raw counts",
      "Sorts values before counting",
      "Removes NaN before counting",
      "Counts only non-numeric values"
    ]
  },
  {
    "q": "Which method is used to resample time series data backward with padding?",
    "c": null,
    "o": [
      "bfill()",
      "ffill()",
      "pad()",
      "interpolate()"
    ]
  },
  {
    "q": "What does `df.groupby('key', sort=False)` do?",
    "c": null,
    "o": [
      "Keeps the original order of keys instead of sorting them",
      "Ignores the group keys",
      "Sorts rows before grouping",
      "Groups only numeric keys"
    ]
  },
  {
    "q": "Which of the following ensures column names are preserved when saving to JSON?",
    "c": null,
    "o": [
      "df.to_json(orient='columns')",
      "df.to_json(orient='records')",
      "df.to_json(orient='values')",
      "df.to_json(header=True)"
    ]
  },
  {
    "q": "What is the effect of using `inplace=True` in a Pandas method?",
    "c": null,
    "o": [
      "Modifies the original object directly without returning a new one",
      "Creates a copy and modifies it",
      "Returns a new object with changes but keeps original unchanged",
      "Applies function to each element in a copy"
    ]
  },
  {
    "q": "What does `df.to_json(orient='records', lines=True)` do?",
    "c": null,
    "o": [
      "Exports the DataFrame as newline-delimited JSON records",
      "Exports only record-indexed rows to JSON",
      "Saves the DataFrame as a CSV and then converts to JSON",
      "Combines all columns into a single JSON line"
    ]
  },
  {
    "q": "Which method would you use to apply a custom function to each column of a DataFrame?",
    "c": null,
    "o": [
      "df.apply(func, axis=0)",
      "df.map(func)",
      "df.applymap(func, axis=0)",
      "df.transform(func, axis=1)"
    ]
  },
  {
    "q": "What is the result of using `df.groupby('col').size()`?",
    "c": null,
    "o": [
      "Returns the number of rows in each group",
      "Returns the sum of each group",
      "Returns only non-null values in groups",
      "Returns the length of the entire DataFrame"
    ]
  },
  {
    "q": "How can you convert a timezone-aware datetime to another timezone?",
    "c": null,
    "o": [
      "df['ts'].dt.tz_convert('US/Pacific')",
      "df['ts'].tz('US/Pacific')",
      "df['ts'].astype('US/Pacific')",
      "df['ts'].tz_localize('US/Pacific')"
    ]
  },
  {
    "q": "What does `df.memory_usage(index=True, deep=True)` return?",
    "c": null,
    "o": [
      "Memory usage of each column and the index, including deep objects",
      "Only the memory usage of the index",
      "Shallow memory of all columns",
      "Total memory in megabytes"
    ]
  },
  {
    "q": "How to count unique values in each column of a DataFrame?",
    "c": null,
    "o": [
      "df.nunique()",
      "df.unique()",
      "df.value_counts()",
      "df.count_unique()"
    ]
  },
  {
    "q": "Which method is best suited for converting long-format data into a format suitable for heatmaps?",
    "c": null,
    "o": [
      "pivot_table()",
      "melt()",
      "explode()",
      "stack()"
    ]
  },
  {
    "q": "Which method is used to iterate row-wise with better performance than `iterrows()`?",
    "c": null,
    "o": [
      "itertuples()",
      "items()",
      "iteritems()",
      "apply(lambda x: x)"
    ]
  },
  {
    "q": "When using `df.resample('M').mean()`, what is the default label of the output?",
    "c": null,
    "o": [
      "End of the month",
      "Start of the month",
      "Middle of the month",
      "Week start"
    ]
  },
  {
    "q": "How would you filter a DataFrame to show only rows where a column has numeric type?",
    "c": null,
    "o": [
      "df[df['col'].apply(pd.api.types.is_numeric_dtype)]",
      "df[df['col'].dtype == 'number']",
      "df.select_dtypes(include='object')",
      "df[df['col'] % 1 == 0]"
    ]
  },
  {
    "q": "Which of the following ensures that a categorical column consumes the least memory?",
    "c": null,
    "o": [
      "df['col'] = df['col'].astype('category')",
      "df['col'] = df['col'].astype('object')",
      "df['col'] = pd.CategoricalIndex(df['col'])",
      "df['col'] = df['col'].convert('lowmem')"
    ]
  },
  {
    "q": "How can you remove duplicate rows based on multiple columns in a DataFrame?",
    "c": null,
    "o": [
      "df.drop_duplicates(subset=['col1', 'col2'])",
      "df.drop_duplicates(columns=['col1', 'col2'])",
      "df.remove_duplicates(on=['col1', 'col2'])",
      "df.drop_duplicated(['col1', 'col2'])"
    ]
  },
  {
    "q": "Which method is used to concatenate DataFrames along rows?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], axis=0)",
      "pd.merge(df1, df2)",
      "df1.append(df2, axis=1)",
      "pd.join([df1, df2], how='outer')"
    ]
  },
  {
    "q": "What does the `dropna(subset=['col'])` method do?",
    "c": null,
    "o": [
      "Drops rows where 'col' has NaN values",
      "Drops columns that contain 'col'",
      "Fills NaN in 'col' with 0",
      "Drops all NaN values in the DataFrame"
    ]
  },
  {
    "q": "What is the result of `df[df['score'].between(50, 70)]`?",
    "c": null,
    "o": [
      "Filters rows where score is between 50 and 70",
      "Selects the score column only",
      "Replaces out-of-range values",
      "Normalizes scores between 50 and 70"
    ]
  },
  {
    "q": "In SQL-style joins using Pandas, which keyword joins only matching keys in both DataFrames?",
    "c": null,
    "o": [
      "inner",
      "outer",
      "left",
      "right"
    ]
  },
  {
    "q": "What does `df.reindex(columns=['B', 'A', 'C'])` do?",
    "c": null,
    "o": [
      "Reorders the columns to B, A, C",
      "Deletes all columns except B, A, C",
      "Sorts columns alphabetically",
      "Reverses the order of index"
    ]
  },
  {
    "q": "Which resampling method would you use to count number of entries per day in a time series?",
    "c": null,
    "o": [
      "df.resample('D').count()",
      "df.groupby('D').size()",
      "df.set_freq('D').count()",
      "df.resample('D').nunique()"
    ]
  },
  {
    "q": "Whats the purpose of using `df.select_dtypes(include='number')`?",
    "c": null,
    "o": [
      "Selects all numeric columns from the DataFrame",
      "Selects only integer columns",
      "Selects float columns and drops NaNs",
      "Converts strings to numbers"
    ]
  },
  {
    "q": "Which argument in `read_sql()` allows parameter substitution to prevent SQL injection?",
    "c": null,
    "o": [
      "params",
      "query",
      "substitute",
      "injection_safe"
    ]
  },
  {
    "q": "What does `pd.merge(df1, df2, on='id', how='outer')` do?",
    "c": null,
    "o": [
      "Returns all rows from both DataFrames with NaNs where no match is found",
      "Only matches rows from both DataFrames where 'id' is present",
      "Updates df1 with values from df2",
      "Returns only rows where df1 has 'id'"
    ]
  },
  {
    "q": "Which method is preferred for reshaping data when you want to aggregate values by two dimensions?",
    "c": null,
    "o": [
      "pivot_table()",
      "melt()",
      "stack()",
      "pivot()"
    ]
  },
  {
    "q": "What is the purpose of setting `observed=True` in a `groupby()` operation involving categorical columns?",
    "c": null,
    "o": [
      "To only group by categories that actually appear in the data",
      "To observe the memory usage of grouping",
      "To count null values in group",
      "To force Pandas to retain all unused categories"
    ]
  },
  {
    "q": "What does the following line do: `df.astype({'col1': 'int32', 'col2': 'category'})`?",
    "c": null,
    "o": [
      "Converts data types of specified columns",
      "Drops all non-integer and non-categorical columns",
      "Removes NaNs in col1 and col2",
      "Renames the columns to int32 and category"
    ]
  },
  {
    "q": "Which of the following will resample time series data to weekly frequency and take max value?",
    "c": null,
    "o": [
      "df.resample('W').max()",
      "df.group_by('W').max()",
      "df.set_freq('W').max()",
      "df.resample('7D').sum()"
    ]
  },
  {
    "q": "What is the default behavior of `pivot_table()` when duplicate entries exist for the index/columns?",
    "c": null,
    "o": [
      "It performs an aggregation like mean",
      "It raises an error",
      "It deletes duplicates silently",
      "It keeps only the first entry"
    ]
  },
  {
    "q": "Which of the following best describes `df[df['score'] > df['score'].mean()]`?",
    "c": null,
    "o": [
      "Filters rows where score is greater than average",
      "Normalizes the score column",
      "Creates a new column of average scores",
      "Assigns 1 to above average scores"
    ]
  },
  {
    "q": "What does `df['new'] = df['col'].rank(method='dense')` do?",
    "c": null,
    "o": [
      "Ranks values in col without gaps in ranking numbers",
      "Creates percentile ranking",
      "Assigns ranks but skips equal values",
      "Sorts values and returns index"
    ]
  },
  {
    "q": "Which method provides the best performance for checking multiple column conditions?",
    "c": null,
    "o": [
      "np.where()",
      "df.apply(lambda row: ... , axis=1)",
      "df.map()",
      "df.pipe()"
    ]
  },
  {
    "q": "Which of the following functions is used to see whether all values across rows are True?",
    "c": null,
    "o": [
      "df.all(axis=1)",
      "df.any(axis=0)",
      "df.eval('all')",
      "df.groupby().all()"
    ]
  },
  {
    "q": "What is the difference between `pivot()` and `pivot_table()` in pandas?",
    "c": null,
    "o": [
      "`pivot_table()` can handle duplicate entries with aggregation; `pivot()` cannot",
      "`pivot()` is faster than `pivot_table()` in all cases",
      "`pivot()` works only with numeric data",
      "`pivot_table()` can only be used with multi-indexed DataFrames"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "df = pd.DataFrame({'val': [1, 2, 3, 4]})\nprint(df.query('val % 2 == 0').shape[0])",
    "o": [
      "2",
      "1",
      "4",
      "0"
    ]
  },
  {
    "q": "You want to reduce memory usage in a large DataFrame. Which of the following is the most effective first step?",
    "c": null,
    "o": [
      "Convert numeric columns to smaller subtypes (e.g., float32)",
      "Drop columns with nulls",
      "Change column names to shorter strings",
      "Split the DataFrame into multiple parts"
    ]
  },
  {
    "q": "Which of the following statements will correctly create a datetime index from a column?",
    "c": null,
    "o": [
      "df.index = pd.to_datetime(df['date'])",
      "df = df.to_datetime('date')",
      "df['date'] = df['date'].astype('datetime64')\ndf.set_index('date', inplace=False)",
      "df = df.set_index(datetime='date')"
    ]
  },
  {
    "q": "What does `df.groupby('dept')['salary'].transform('mean')` return?",
    "c": null,
    "o": [
      "A Series with mean salary per group, aligned with original index",
      "A single value that is the global mean of salary",
      "A Series of median salary per department",
      "A grouped object awaiting further transformation"
    ]
  },
  {
    "q": "Which Pandas method lets you reshape data from wide to long format?",
    "c": null,
    "o": [
      "melt()",
      "pivot()",
      "explode()",
      "stack()"
    ]
  },
  {
    "q": "What is the result of `df[df['A'].str.contains('abc')]`?",
    "c": null,
    "o": [
      "Filters rows where column A contains the substring 'abc'",
      "Filters rows where column A equals 'abc'",
      "Replaces 'abc' with NaN in column A",
      "Creates a new column with 'abc' values"
    ]
  },
  {
    "q": "In a time series, what does `df.shift(1)` do?",
    "c": null,
    "o": [
      "Shifts all rows down by 1 (forward in time)",
      "Shifts all rows up by 1 (backward in time)",
      "Sorts the data by index",
      "Drops the first row of the DataFrame"
    ]
  },
  {
    "q": "Which function can be used to profile and understand memory usage of a DataFrame?",
    "c": null,
    "o": [
      "df.info(memory_usage='deep')",
      "df.memory_summary()",
      "df.describe('memory')",
      "pd.profile(df)"
    ]
  },
  {
    "q": "What does `df.resample('Q').sum()` do in a time-indexed DataFrame?",
    "c": null,
    "o": [
      "Aggregates data quarterly by summing values",
      "Splits data into four equal parts",
      "Sorts data every 4 months",
      "Sums values for each calendar year"
    ]
  },
  {
    "q": "What will be the result of using `df.loc[5:10]` in a DataFrame?",
    "c": null,
    "o": [
      "Includes both index labels 5 and 10",
      "Includes index 5 but excludes 10",
      "Raises a ValueError if 10 is not present",
      "Selects only the columns from 5 to 10"
    ]
  },
  {
    "q": "How does `df.between_time('09:00', '17:00')` work on a time-indexed DataFrame?",
    "c": null,
    "o": [
      "Returns rows between 9AM and 5PM based on index",
      "Filters rows with values in column named 'time'",
      "Returns rows where time column is not null",
      "Truncates the DataFrame to business days"
    ]
  },
  {
    "q": "Which of the following is true about `.isin()` method in pandas?",
    "c": null,
    "o": [
      "It checks whether each element is contained in a list-like object",
      "It filters columns based on data type",
      "It matches regex values in a string column",
      "It converts boolean values to integers"
    ]
  },
  {
    "q": "When using `df.groupby(['A', 'B']).size().unstack()`, what is the likely goal?",
    "c": null,
    "o": [
      "To create a pivot-like count table",
      "To get average of values in A and B",
      "To reshape DataFrame from long to wide format using sum",
      "To drop NA values in A and B"
    ]
  },
  {
    "q": "Which of the following will set multiple columns as index in a DataFrame?",
    "c": null,
    "o": [
      "df.set_index(['col1', 'col2'])",
      "df.index = df[['col1', 'col2']]",
      "df.set_index('col1', 'col2')",
      "df.columns.set_index(['col1', 'col2'])"
    ]
  },
  {
    "q": "You want to apply a custom function to every column of a DataFrame. Which method do you use?",
    "c": null,
    "o": [
      "df.apply(func)",
      "df.map(func)",
      "df.transform(func)",
      "df.aggregate(axis=1)"
    ]
  },
  {
    "q": "Which of the following returns all rows with NaN in any column?",
    "c": null,
    "o": [
      "df[df.isnull().any(axis=1)]",
      "df[df.isnull()]",
      "df.isnull().sum()",
      "df[df == NaN]"
    ]
  },
  {
    "q": "Why might one convert a column to `category` type in pandas?",
    "c": null,
    "o": [
      "To reduce memory usage and improve performance on repeated values",
      "To preserve null values for sorting",
      "To convert numerical values to string",
      "To merge with other categorical columns"
    ]
  },
  {
    "q": "What happens if two DataFrames have the same column name during a merge?",
    "c": null,
    "o": [
      "The columns are suffixed with _x and _y",
      "An error is raised",
      "Only the left DataFrames column is kept",
      "The second column overwrites the first"
    ]
  },
  {
    "q": "What does `df.interpolate(method='linear')` do?",
    "c": null,
    "o": [
      "Fills NaNs by interpolating linearly between known values",
      "Drops all null values in DataFrame",
      "Creates new rows based on linear trend",
      "Averages rows with missing values"
    ]
  },
  {
    "q": "What will `df.resample('M').mean()` return if `df` has a datetime index?",
    "c": null,
    "o": [
      "Monthly average values for each column",
      "Mean of values grouped by day",
      "Rolling average over a month",
      "The sum of values over each calendar month"
    ]
  },
  {
    "q": "Which method can be used to detect duplicate rows in a DataFrame?",
    "c": null,
    "o": [
      "df.duplicated()",
      "df.is_duplicate()",
      "df.find_duplicates()",
      "df.detect_duplicates()"
    ]
  },
  {
    "q": "What does the following code return?\n`df.groupby('A').filter(lambda x: len(x) > 2)`",
    "c": null,
    "o": [
      "All groups from column A having more than 2 rows",
      "All rows where column A > 2",
      "Filters values in column A greater than length of A",
      "Nothing, it raises an error"
    ]
  },
  {
    "q": "How can you convert a timezone-naive datetime column to timezone-aware (UTC)?",
    "c": null,
    "o": [
      "df['time'] = pd.to_datetime(df['time']).dt.tz_localize('UTC')",
      "df['time'] = df['time'].astype('datetime64[utc]')",
      "df['time'] = df['time'].tzinfo('UTC')",
      "df['time'] = df['time'].localize('UTC')"
    ]
  },
  {
    "q": "Which of the following pandas methods is NOT vectorized and is typically slower?",
    "c": null,
    "o": [
      "apply()",
      "sum()",
      "mean()",
      "clip()"
    ]
  },
  {
    "q": "You want to remove rows where any value is duplicated across all columns. Which code works?",
    "c": null,
    "o": [
      "df.drop_duplicates()",
      "df.remove_duplicated()",
      "df = df.drop_rows('duplicates')",
      "df.unique_rows(drop=True)"
    ]
  },
  {
    "q": "What will `df.groupby('dept', group_keys=False).apply(some_func)` do?",
    "c": null,
    "o": [
      "Apply the function without adding the group label back in the result index",
      "Add group key as new column",
      "Raise a TypeError unless 'dept' is a numeric column",
      "Sort the results by group label"
    ]
  },
  {
    "q": "Which method can convert an entire DataFrame to a specific type with coercion for invalid parsing?",
    "c": null,
    "o": [
      "df.astype(dtype, errors='coerce')",
      "df.convert_type(dtype='auto')",
      "df.apply_type(dtype, force=True)",
      "df.cast_all('coerce')"
    ]
  },
  {
    "q": "How does `df.fillna(method='ffill')` behave?",
    "c": null,
    "o": [
      "Fills NaNs using the last valid observation (forward fill)",
      "Fills NaNs with zeros",
      "Fills NaNs by averaging column values",
      "Drops rows with NaNs"
    ]
  },
  {
    "q": "Which of the following helps monitor large DataFrame memory consumption?",
    "c": null,
    "o": [
      "df.memory_usage(deep=True)",
      "df.describe(memory=True)",
      "pd.check_memory(df)",
      "df.info(verbose=False)"
    ]
  },
  {
    "q": "What is the difference between `df.copy(deep=True)` and `df.copy(deep=False)`?",
    "c": null,
    "o": [
      "deep=False creates a new DataFrame with shared data (not fully independent)",
      "deep=True creates a shallow copy",
      "deep=False also resets the index",
      "There is no difference, both create full copies"
    ]
  },
  {
    "q": "Which method will convert a DataFrame to a JSON string?",
    "c": null,
    "o": [
      "df.to_json()",
      "df.write_json()",
      "df.to_string(format='json')",
      "df.export_json()"
    ]
  },
  {
    "q": "Given a Series `s`, what does `s.index.name = 'Date'` do?",
    "c": null,
    "o": [
      "Sets the name of the index to 'Date'",
      "Renames the Series to 'Date'",
      "Changes all index values to 'Date'",
      "Creates a new column called 'Date'"
    ]
  },
  {
    "q": "Which method should you use to replace all 0s in a DataFrame with NaN?",
    "c": null,
    "o": [
      "df.replace(0, np.nan)",
      "df.fillna(0)",
      "df.mask(df == 0)",
      "df.convert(0, to=np.nan)"
    ]
  },
  {
    "q": "Which of the following combinations is best for merging two DataFrames based on common keys?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, on='id')",
      "df1.concat(df2, on='id')",
      "df1.append(df2, match='id')",
      "df1.join(df2, how='merge')"
    ]
  },
  {
    "q": "You need to read only the first 1000 rows of a large CSV file. Which argument is used?",
    "c": null,
    "o": [
      "nrows=1000",
      "chunksize=1000",
      "maxrows=1000",
      "start_row=0, stop_row=1000"
    ]
  },
  {
    "q": "What does `df.index.is_monotonic` return?",
    "c": null,
    "o": [
      "True if the index is sorted in increasing order",
      "True if the index has unique values",
      "True if the index is a range index",
      "True if index is categorical"
    ]
  },
  {
    "q": "In which case would you prefer using `.values` over `.to_numpy()`?",
    "c": null,
    "o": [
      "When performance is critical and internal layout does not matter",
      "To maintain dtype casting options",
      "When working with mixed dtypes safely",
      "Never, `.values` is deprecated"
    ]
  },
  {
    "q": "Which pandas method is best suited to remove columns with more than 50% missing values?",
    "c": null,
    "o": [
      "df.dropna(thresh=int(df.shape[0] * 0.5), axis=1)",
      "df.drop(columns='missing')",
      "df.remove_na(axis=1, ratio=0.5)",
      "df.cleanna(percent=50)"
    ]
  },
  {
    "q": "What will `df.iloc[::-1]` return?",
    "c": null,
    "o": [
      "Reverses the rows of the DataFrame",
      "Reverses the columns of the DataFrame",
      "Sorts the DataFrame by index",
      "Returns the first row only"
    ]
  },
  {
    "q": "What does the `dropna(how='all')` method do in pandas?",
    "c": null,
    "o": [
      "Drops rows where all elements are missing",
      "Drops columns that have any NaN values",
      "Drops rows where any element is NaN",
      "Drops all NaN values from the DataFrame"
    ]
  },
  {
    "q": "How can you improve performance when applying a function row-wise in pandas?",
    "c": null,
    "o": [
      "Use vectorized operations instead of `apply(axis=1)`",
      "Always use `applymap` instead of `apply`",
      "Use `map` with axis=1",
      "Convert DataFrame to list and loop"
    ]
  },
  {
    "q": "Which of the following correctly combines two DataFrames with same columns vertically?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], axis=0)",
      "df1.append(df2, axis=1)",
      "df1.merge(df2)",
      "df1.join(df2)"
    ]
  },
  {
    "q": "What does `df.pivot(index='A', columns='B', values='C')` do?",
    "c": null,
    "o": [
      "Reshapes the DataFrame turning unique values of B into columns",
      "Pivots rows into columns based on index",
      "Changes the DataFrames index to column A",
      "Melts the DataFrame into long format"
    ]
  },
  {
    "q": "What does `df.loc[:, 'col1':'col3']` select?",
    "c": null,
    "o": [
      "All rows and columns from 'col1' to 'col3' inclusive",
      "Only the 'col1' and 'col3' columns",
      "All rows and only 'col3' column",
      "First three columns of the DataFrame"
    ]
  },
  {
    "q": "Which parameter allows efficient reading of large CSVs in chunks?",
    "c": null,
    "o": [
      "chunksize",
      "batchsize",
      "lines_per_read",
      "iterator"
    ]
  },
  {
    "q": "How do you convert a column with date strings into pandas datetime objects?",
    "c": null,
    "o": [
      "pd.to_datetime(df['col'])",
      "df['col'].astype('datetime64')",
      "df['col'].to_date()",
      "df.convert_to_datetime('col')"
    ]
  },
  {
    "q": "How would you filter rows in a DataFrame where column 'score' is between 50 and 70 (inclusive)?",
    "c": null,
    "o": [
      "df[df['score'].between(50, 70)]",
      "df['score'] >= 50 and df['score'] <= 70",
      "df['score'].range(50, 70)",
      "df[50 <= 'score' <= 70]"
    ]
  },
  {
    "q": "How does `df.sort_values(['A', 'B'], ascending=[True, False])` behave?",
    "c": null,
    "o": [
      "Sorts DataFrame by A ascending and B descending",
      "Sorts both columns A and B in descending order",
      "Sorts column A in-place but column B alphabetically",
      "Sorts only column B descending"
    ]
  },
  {
    "q": "Which pandas method can be used to remove an index and return a flat DataFrame?",
    "c": null,
    "o": [
      "df.reset_index()",
      "df.drop_index()",
      "df.flatten()",
      "df.unstack_index()"
    ]
  },
  {
    "q": "Which method efficiently converts multiple columns of a DataFrame from object to numeric, ignoring errors?",
    "c": null,
    "o": [
      "df.apply(pd.to_numeric, errors='coerce')",
      "df.astype('int')",
      "df.convert_dtypes(safe=True)",
      "pd.to_int(df)"
    ]
  },
  {
    "q": "What is the purpose of `df['col'].map({'A': 1, 'B': 2})`?",
    "c": null,
    "o": [
      "Maps values in 'col' based on a dictionary",
      "Converts column 'col' to a numeric dtype",
      "Applies a function to each row in 'col'",
      "Sorts column 'col'"
    ]
  },
  {
    "q": "Which is true about `pd.read_csv('file.csv', index_col=0)`?",
    "c": null,
    "o": [
      "Uses the first column as the DataFrame index",
      "Skips the first row of data",
      "Treats the first row as column headers",
      "Assigns a default RangeIndex"
    ]
  },
  {
    "q": "You want to aggregate multiple functions per group using `groupby`. Which method allows this?",
    "c": null,
    "o": [
      "agg()",
      "sum()",
      "transform()",
      "filter()"
    ]
  },
  {
    "q": "How would you align two DataFrames with different shapes on their indices?",
    "c": null,
    "o": [
      "df1.align(df2)",
      "df1.join(df2, on='index')",
      "df1 + df2",
      "pd.merge(df1, df2, how='outer')"
    ]
  },
  {
    "q": "How do you find all duplicate rows in a DataFrame?",
    "c": null,
    "o": [
      "df[df.duplicated()]",
      "df.drop_duplicates()",
      "df.is_duplicated()",
      "df.check_duplicates()"
    ]
  },
  {
    "q": "Which method will summarize memory usage of a DataFrame including deep introspection of object dtype?",
    "c": null,
    "o": [
      "df.info(memory_usage='deep')",
      "df.memory()",
      "df.describe(memory=True)",
      "df.usage(deep=True)"
    ]
  },
  {
    "q": "What does `df['col'].shift(1)` do?",
    "c": null,
    "o": [
      "Shifts values in 'col' down by 1 row",
      "Shifts column 'col' to the right",
      "Sorts 'col' in ascending order",
      "Removes first row of 'col'"
    ]
  },
  {
    "q": "Which resampling rule aggregates data to monthly frequency?",
    "c": null,
    "o": [
      "'M'",
      "'D'",
      "'W-MON'",
      "'YQ'"
    ]
  },
  {
    "q": "Which of the following creates a time zone-aware timestamp?",
    "c": null,
    "o": [
      "pd.Timestamp('2023-01-01', tz='UTC')",
      "datetime.datetime('2023-01-01', tz='UTC')",
      "pd.to_datetime('2023-01-01').localize('UTC')",
      "pd.Timestamp('2023-01-01').tz='UTC'"
    ]
  },
  {
    "q": "What does `df.query('age > 30 and income < 50000')` do?",
    "c": null,
    "o": [
      "Filters rows where age > 30 and income < 50000",
      "Creates a new DataFrame with those column values",
      "Updates values of age and income",
      "Filters columns age and income only"
    ]
  },
  {
    "q": "Which method converts a DataFrame to a JSON-formatted string?",
    "c": null,
    "o": [
      "df.to_json()",
      "json.dumps(df)",
      "df.to_dict(json=True)",
      "df.to_string('json')"
    ]
  },
  {
    "q": "What is the result of `df.groupby('dept')['salary'].transform('mean')`?",
    "c": null,
    "o": [
      "A Series with the mean salary per group repeated for each row",
      "The overall mean salary for the DataFrame",
      "A DataFrame grouped by dept and aggregated by mean",
      "A new column with cumulative means"
    ]
  },
  {
    "q": "Which pandas function can export data to a SQL table?",
    "c": null,
    "o": [
      "df.to_sql('table_name', conn)",
      "df.write_sql('table_name', conn)",
      "pd.write_sql_table(df, conn)",
      "df.save_sql('table_name')"
    ]
  },
  {
    "q": "What does `df.resample('W').sum()` do when used on a DateTime-indexed DataFrame?",
    "c": null,
    "o": [
      "Aggregates values weekly using sum",
      "Returns a rolling weekly average",
      "Resets time index to weeks",
      "Groups by weeks and returns counts"
    ]
  },
  {
    "q": "How would you change a column's dtype to category for better memory performance?",
    "c": null,
    "o": [
      "df['col'] = df['col'].astype('category')",
      "df['col'].to_categorical()",
      "df['col'].category()",
      "df['col'] = category(df['col'])"
    ]
  },
  {
    "q": "Which operation is more performant for filtering: vectorized comparison or `apply()`?",
    "c": null,
    "o": [
      "Vectorized comparison",
      "apply() with lambda",
      "map() on rows",
      "Using `for` loop with condition"
    ]
  },
  {
    "q": "How can you join two DataFrames on different column names?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, left_on='a', right_on='b')",
      "df1.join(df2, on='a=b')",
      "df1.merge(df2, how='on:a=b')",
      "df1.concat(df2, key='a=b')"
    ]
  },
  {
    "q": "What will `df.loc[df['A'].isnull(), 'A'] = 0` do?",
    "c": null,
    "o": [
      "Replace all NaN in column 'A' with 0",
      "Drop NaN values in 'A'",
      "Set the entire column 'A' to 0",
      "Replace NaN values in all columns with 0"
    ]
  },
  {
    "q": "What does `df['A'].cumsum()` return?",
    "c": null,
    "o": [
      "Cumulative sum of values in column A",
      "Sum of A grouped by index",
      "Column A with missing values dropped",
      "Sorted values of column A"
    ]
  },
  {
    "q": "How can you efficiently find rows where two DataFrame columns are equal?",
    "c": null,
    "o": [
      "df[df['col1'] == df['col2']]",
      "df.query('col1 = col2')",
      "df.loc['col1' == 'col2']",
      "df.where('col1' == 'col2')"
    ]
  },
  {
    "q": "What does `df['ts'].dt.tz_localize('UTC')` do?",
    "c": null,
    "o": [
      "Assigns a UTC timezone to a naive datetime column",
      "Converts a timezone-aware column to UTC",
      "Drops time zone from the datetime column",
      "Adds a timestamp column called 'UTC'"
    ]
  },
  {
    "q": "Which is faster for row-wise operations when the logic can be vectorized?",
    "c": null,
    "o": [
      "Vectorized operations",
      "df.apply(axis=1)",
      "Using `for` loop",
      "map()"
    ]
  },
  {
    "q": "What does the parameter `chunksize` in `pd.read_csv()` enable?",
    "c": null,
    "o": [
      "Reads file in smaller chunks to save memory",
      "Splits the file into multiple smaller CSVs",
      "Loads CSV without headers",
      "Compresses the file while reading"
    ]
  },
  {
    "q": "What will `df.pivot(index='date', columns='category', values='sales')` do?",
    "c": null,
    "o": [
      "Rearranges the DataFrame to wide format by category",
      "Reshapes the DataFrame to long format",
      "Sorts by date and category",
      "Groups sales data by date and category"
    ]
  },
  {
    "q": "How to get the number of unique rows in a DataFrame?",
    "c": null,
    "o": [
      "df.drop_duplicates().shape[0]",
      "df.count_unique()",
      "df.value_counts().nunique()",
      "len(set(df))"
    ]
  },
  {
    "q": "What does `df.iloc[1:4, 2:5]` select?",
    "c": null,
    "o": [
      "Rows 1 to 3 and columns 2 to 4 by position",
      "Rows 1 to 4 and columns 2 to 5 by labels",
      "First 4 rows and first 5 columns",
      "Every 2nd row and every 4th column"
    ]
  },
  {
    "q": "Which argument ensures that `to_csv()` writes UTF-8 with BOM encoding?",
    "c": null,
    "o": [
      "encoding='utf-8-sig'",
      "utf=True",
      "format='BOM'",
      "encoding='utf-8-bom'"
    ]
  },
  {
    "q": "What does `df.memory_usage(deep=True)` return?",
    "c": null,
    "o": [
      "Memory usage of all columns, including object types deeply",
      "The percentage of memory used by each column",
      "A list of data types and memory sizes",
      "Compressed memory view of numeric columns"
    ]
  },
  {
    "q": "What does `pd.merge(df1, df2, on='key', how='outer')` perform?",
    "c": null,
    "o": [
      "Combines both DataFrames on 'key' with all rows from both sides",
      "Joins only common rows from both DataFrames",
      "Merges DataFrames without duplication",
      "Adds df2 as new rows to df1"
    ]
  },
  {
    "q": "Which of the following operations is best for replacing multiple values efficiently in a column?",
    "c": null,
    "o": [
      "df['col'].replace({'old1': 'new1', 'old2': 'new2'})",
      "df['col'].map({'old1': 'new1', 'old2': 'new2'})",
      "df['col'].apply(lambda x: x if x != 'old1' else 'new1')",
      "df['col'].fillna({'old1': 'new1', 'old2': 'new2'})"
    ]
  },
  {
    "q": "What does the `parse_dates` parameter do in `pd.read_csv()`?",
    "c": null,
    "o": [
      "Automatically converts date columns to datetime dtype",
      "Skips parsing datetime columns",
      "Parses only rows with date values",
      "Sets index column to current timestamp"
    ]
  },
  {
    "q": "What is a key benefit of using `category` dtype in Pandas?",
    "c": null,
    "o": [
      "Reduces memory usage for columns with repeated string values",
      "Allows columns to store multiple datatypes",
      "Supports mixed data types in one column",
      "Improves floating-point precision"
    ]
  },
  {
    "q": "Which operation is used to reshape a DataFrame from long to wide format?",
    "c": null,
    "o": [
      "pivot()",
      "melt()",
      "stack()",
      "explode()"
    ]
  },
  {
    "q": "What will `df.index = pd.to_datetime(df['date_column'])` do?",
    "c": null,
    "o": [
      "Set the DataFrame index to datetime values from the column",
      "Sort the DataFrame by date_column",
      "Convert the entire DataFrame to a datetime object",
      "Add a new column with index timestamps"
    ]
  },
  {
    "q": "What is the role of `dropna(subset=['col'])`?",
    "c": null,
    "o": [
      "Drops rows with NaN in the specified column only",
      "Drops all columns with any NaN values",
      "Drops rows where all columns are NaN",
      "Fills NaN with default value"
    ]
  },
  {
    "q": "How do you select the last 5 rows of a DataFrame?",
    "c": null,
    "o": [
      "df.tail()",
      "df[-5:]",
      "df.head(-5)",
      "df.iloc[-5]"
    ]
  },
  {
    "q": "Which method is preferred for joining DataFrames with different indexes?",
    "c": null,
    "o": [
      "merge() with left_on and right_on",
      "join()",
      "concat()",
      "append()"
    ]
  },
  {
    "q": "What is the output of `df[df.duplicated()]`?",
    "c": null,
    "o": [
      "All duplicate rows except their first occurrence",
      "Only unique rows",
      "All rows without duplicates",
      "All first occurrences of duplicates"
    ]
  },
  {
    "q": "Which of the following best describes `df.eval('col1 + col2')`?",
    "c": null,
    "o": [
      "Performs fast arithmetic operations using pandas expression evaluator",
      "Evaluates only numeric columns in a DataFrame",
      "Converts string columns to numeric types",
      "Performs logical operations only"
    ]
  },
  {
    "q": "Which of the following resampling methods would you use to get the sum of values every month?",
    "c": "df.resample('M').____",
    "o": [
      "sum()",
      "mean()",
      "groupby()",
      "pivot()"
    ]
  },
  {
    "q": "What is the purpose of the `left_on` and `right_on` parameters in `pd.merge()`?",
    "c": null,
    "o": [
      "To merge on different columns from left and right DataFrames",
      "To sort both DataFrames before merging",
      "To enforce merge on index only",
      "To drop duplicates from both DataFrames"
    ]
  },
  {
    "q": "Which of the following helps identify columns with the highest memory usage?",
    "c": null,
    "o": [
      "df.memory_usage(deep=True).sort_values(ascending=False)",
      "df.info(memory=True)",
      "df.describe().max()",
      "df.nbytes().top()"
    ]
  },
  {
    "q": "What does `pd.read_json('file.json', orient='records')` assume?",
    "c": null,
    "o": [
      "Each JSON object is a row",
      "Each JSON key is a column name",
      "All rows are stored as lists of lists",
      "The file contains a single JSON object"
    ]
  },
  {
    "q": "What will be the result of the following code snippet?",
    "c": "df.groupby('category')['value'].transform('sum')",
    "o": [
      "A Series with summed values broadcasted back to original index",
      "A DataFrame grouped and summed by category",
      "A Series with only the total sum",
      "A column dropped from the DataFrame"
    ]
  },
  {
    "q": "Which method is **not** recommended inside method chaining for performance-sensitive code?",
    "c": null,
    "o": [
      "apply(lambda x: ...)",
      "dropna()",
      "sort_values()",
      "astype()"
    ]
  },
  {
    "q": "How would you best reduce memory usage for a large `int64` column with small values?",
    "c": null,
    "o": [
      "Convert it to 'int8' using astype",
      "Apply `np.float32`",
      "Convert to 'object'",
      "Use `memory_usage='low'`"
    ]
  },
  {
    "q": "What will `df['col'].value_counts(normalize=True)` return?",
    "c": null,
    "o": [
      "Relative frequencies (as fractions) of unique values",
      "Raw count of unique values",
      "List of unique column names",
      "Sorted values of the column"
    ]
  },
  {
    "q": "What is a correct use of `explode()`?",
    "c": "df = pd.DataFrame({'A': [[1,2], [3], []]})\ndf.explode('A')",
    "o": [
      "Converts each list in column 'A' to multiple rows",
      "Combines nested lists into one row",
      "Removes all list columns",
      "Flattens the entire DataFrame to a NumPy array"
    ]
  },
  {
    "q": "Which Pandas function is best suited to combine DataFrames with unequal column sets?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], sort=False)",
      "pd.merge(df1, df2, on='key')",
      "df1.join(df2)",
      "df1.append(df2, match_columns=True)"
    ]
  },
  {
    "q": "Which of the following expressions performs a left join on two DataFrames with different key names?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, how='left', left_on='id1', right_on='id2')",
      "df1.join(df2, how='left')",
      "pd.concat([df1, df2], axis=1, join='left')",
      "pd.merge(df1, df2, on='id1', how='left')"
    ]
  },
  {
    "q": "How can you convert a string column 'dob' to datetime objects?",
    "c": null,
    "o": [
      "pd.to_datetime(df['dob'])",
      "df['dob'].astype('datetime')",
      "df['dob'].convert('date')",
      "datetime.strptime(df['dob'])"
    ]
  },
  {
    "q": "Which method returns the number of distinct values in a Series?",
    "c": null,
    "o": [
      "series.nunique()",
      "series.unique().count()",
      "series.value_counts()",
      "series.count(unique=True)"
    ]
  },
  {
    "q": "Which of the following operations will filter rows where 'score' is between 50 and 90 (inclusive)?",
    "c": null,
    "o": [
      "df[df['score'].between(50, 90)]",
      "df[(df['score'] >= 50) & (df['score'] < 90)]",
      "df[df['score'].isin(range(50, 90))]",
      "df[df['score'] in range(50, 91)]"
    ]
  },
  {
    "q": "Which code correctly pivots a DataFrame to have 'month' as columns and 'sales' as values?",
    "c": null,
    "o": [
      "df.pivot(index='region', columns='month', values='sales')",
      "df.pivot_table(index='month', values='sales')",
      "df.unstack('month')['sales']",
      "df.groupby('month')['sales'].pivot()"
    ]
  },
  {
    "q": "What will the following return?",
    "c": "df[df['value'].isnull()]",
    "o": [
      "All rows where the 'value' column is NaN",
      "Rows where all columns are NaN",
      "Only rows where 'value' is not NaN",
      "A boolean Series"
    ]
  },
  {
    "q": "What is the purpose of `inplace=True` in many Pandas methods?",
    "c": null,
    "o": [
      "Modifies the object directly without creating a copy",
      "Prevents the operation from being executed",
      "Creates a backup before performing the operation",
      "Improves performance by avoiding garbage collection"
    ]
  },
  {
    "q": "Which of the following retrieves rows with the highest values in 'sales' column?",
    "c": null,
    "o": [
      "df.nlargest(5, 'sales')",
      "df.sort_values('sales').tail(5)",
      "df.groupby('sales').max().head(5)",
      "df['sales'].value_counts().head(5)"
    ]
  },
  {
    "q": "What does the following do?",
    "c": "df.set_index('id', inplace=True)",
    "o": [
      "Sets 'id' as the index of df and modifies df directly",
      "Creates a new DataFrame with 'id' as index",
      "Adds 'id' as a new column to the index",
      "Deletes the 'id' column"
    ]
  },
  {
    "q": "Which method allows resampling to a weekly frequency using mean?",
    "c": null,
    "o": [
      "df.resample('W').mean()",
      "df.groupby('W').mean()",
      "df.rolling('7D').mean()",
      "df.resample('7D').agg('mean')"
    ]
  },
  {
    "q": "Which method reads a nested JSON file and flattens it into columns?",
    "c": null,
    "o": [
      "pd.json_normalize(data)",
      "pd.read_json('file.json')",
      "pd.DataFrame.from_json('file.json')",
      "pd.read_nested_json('file.json')"
    ]
  },
  {
    "q": "Which of the following merges `df1` and `df2` on a common index?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, left_index=True, right_index=True)",
      "df1.merge(df2, on='index')",
      "df1.join(df2, on='index')",
      "pd.concat(df1, df2, on='index')"
    ]
  },
  {
    "q": "Which method fills missing values using the previous non-null value?",
    "c": null,
    "o": [
      "df.fillna(method='ffill')",
      "df.fillna(method='bfill')",
      "df.replace(np.nan, 'previous')",
      "df.interpolate(method='linear')"
    ]
  },
  {
    "q": "How do you convert a UTC datetime column to Asia/Kolkata time?",
    "c": null,
    "o": [
      "df['col'].dt.tz_convert('Asia/Kolkata')",
      "df['col'].tz_localize('Asia/Kolkata')",
      "pd.to_datetime(df['col'], tz='Asia/Kolkata')",
      "df['col'].convert_timezone('Asia/Kolkata')"
    ]
  },
  {
    "q": "Which option shows the memory usage of each column including object types?",
    "c": null,
    "o": [
      "df.memory_usage(deep=True)",
      "df.info(deep=False)",
      "df.describe(memory=True)",
      "df.profile_memory()"
    ]
  },
  {
    "q": "Which of the following will broadcast the max value in each group back to original DataFrame?",
    "c": "df.groupby('group')['score'].____",
    "o": [
      "transform('max')",
      "agg('max')",
      "apply(max)",
      "map(max)"
    ]
  },
  {
    "q": "How can you remove all duplicate rows based on only 'name' and 'age' columns?",
    "c": null,
    "o": [
      "df.drop_duplicates(subset=['name', 'age'])",
      "df.duplicated(['name', 'age'])",
      "df.remove_duplicates('name', 'age')",
      "df.drop_duplicates(columns=['name', 'age'])"
    ]
  },
  {
    "q": "Which function finds all columns with numeric datatypes?",
    "c": null,
    "o": [
      "df.select_dtypes(include='number')",
      "df.filter(dtype='int|float')",
      "df.columns[df.dtypes in ['int', 'float']]",
      "df.describe(numeric=True)"
    ]
  },
  {
    "q": "What does `df['amount'].cumsum()` compute?",
    "c": null,
    "o": [
      "Cumulative sum of the 'amount' column",
      "Total of all columns row-wise",
      "Moving average of 'amount'",
      "Sum of squares in 'amount'"
    ]
  },
  {
    "q": "Which of the following expressions gets the last 3 rows of the DataFrame?",
    "c": null,
    "o": [
      "df.tail(3)",
      "df[-3:]",
      "df.iloc[-4:]",
      "df.last(3)"
    ]
  },
  {
    "q": "Which function allows you to apply a custom function to each column of a DataFrame?",
    "c": null,
    "o": [
      "df.apply(func, axis=0)",
      "df.map(func)",
      "df.transform(func)",
      "df.aggregate(func)"
    ]
  },
  {
    "q": "How would you group by 'department' and then calculate the average salary?",
    "c": null,
    "o": [
      "df.groupby('department')['salary'].mean()",
      "df.groupby('salary')['department'].mean()",
      "df.group('department').agg('mean')",
      "df['salary'].groupby('department').agg('avg')"
    ]
  },
  {
    "q": "Which Pandas method creates a contingency table or cross-tabulation?",
    "c": null,
    "o": [
      "pd.crosstab(df['A'], df['B'])",
      "df.pivot_table('A', 'B')",
      "pd.contingency(df['A'], df['B'])",
      "df.group_by('A').pivot('B')"
    ]
  },
  {
    "q": "What does `df.iloc[:, [0, 2]]` return?",
    "c": null,
    "o": [
      "All rows with only columns 0 and 2",
      "Rows 0 and 2 of all columns",
      "Rows where column 0 or 2 is not null",
      "First and last column"
    ]
  },
  {
    "q": "Which function resamples time-series data to quarterly frequency with sum aggregation?",
    "c": null,
    "o": [
      "df.resample('Q').sum()",
      "df.groupby('Q').sum()",
      "df.asfreq('Q', method='sum')",
      "df.rolling('Q').sum()"
    ]
  },
  {
    "q": "How would you identify which columns contain missing values?",
    "c": null,
    "o": [
      "df.isnull().any()",
      "df.isna().sum() == 0",
      "df.has_missing()",
      "df.filterna()"
    ]
  },
  {
    "q": "What is the purpose of `df.astype({'col': 'category'})`?",
    "c": null,
    "o": [
      "Converts column 'col' to categorical type for efficiency",
      "Deletes unused categories in 'col'",
      "Encodes 'col' as a numeric label",
      "Creates a dummy variable from 'col'"
    ]
  },
  {
    "q": "Which operation calculates cumulative maximum over a Series?",
    "c": null,
    "o": [
      "series.cummax()",
      "series.rolling().max()",
      "series.expanding().max()",
      "series.cumsum().max()"
    ]
  },
  {
    "q": "What is the output of the following?",
    "c": "pd.Series(['a', 'b', 'a', 'c']).value_counts()",
    "o": [
      "Counts of each unique value",
      "Index of the maximum value",
      "Sorted list of unique values",
      "Cumulative frequency"
    ]
  },
  {
    "q": "Which of the following is used to combine rows from two DataFrames while keeping all rows from both?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, how='outer')",
      "df1.append(df2, how='outer')",
      "pd.concat([df1, df2], join='inner')",
      "pd.concat(df1, df2, on='outer')"
    ]
  },
  {
    "q": "Which of the following operations changes the column order in a DataFrame?",
    "c": null,
    "o": [
      "df = df[['B', 'A', 'C']]",
      "df.reorder(columns=['B', 'A', 'C'])",
      "df.columns = ['B', 'A', 'C']",
      "df = df.set_columns(['B', 'A', 'C'])"
    ]
  },
  {
    "q": "How would you apply a lambda function to double values in column 'sales'?",
    "c": null,
    "o": [
      "df['sales'].apply(lambda x: x * 2)",
      "df.apply(lambda x: x['sales'] * 2)",
      "df['sales'].map(x * 2)",
      "df['sales'].agg(x => x * 2)"
    ]
  },
  {
    "q": "What is the benefit of converting a text column with repeated values into a 'category' dtype?",
    "c": null,
    "o": [
      "Reduced memory usage and faster operations",
      "Improved string formatting",
      "Increased precision for floating point values",
      "Allows text column to be used in numeric operations"
    ]
  },
  {
    "q": "Which method changes the index to a datetime column and sorts it?",
    "c": null,
    "o": [
      "df.set_index('date').sort_index()",
      "df.index = df['date']",
      "df.sort_values('date').reset_index()",
      "df.date_as_index().sort()"
    ]
  },
  {
    "q": "How can you combine multiple filters using `&` on a DataFrame?",
    "c": null,
    "o": [
      "(df['age'] > 20) & (df['income'] < 50000)",
      "df['age'] > 20 & df['income'] < 50000",
      "df.where(df['age'] > 20 and df['income'] < 50000)",
      "df['age'] > 20, df['income'] < 50000"
    ]
  },
  {
    "q": "How do you localize a naive datetime column to UTC?",
    "c": null,
    "o": [
      "df['date'].dt.tz_localize('UTC')",
      "df['date'].tz_convert('UTC')",
      "pd.to_datetime(df['date'], tz='UTC')",
      "df['date'].convert_tz('UTC')"
    ]
  },
  {
    "q": "Which of the following returns the unique counts per column?",
    "c": null,
    "o": [
      "df.nunique()",
      "df.count(unique=True)",
      "df.unique().count()",
      "df.value_counts()"
    ]
  },
  {
    "q": "How would you reduce memory usage when loading a large CSV with known dtypes?",
    "c": null,
    "o": [
      "Use `dtype` argument in `pd.read_csv()`",
      "Use `low_memory=False` only",
      "Load all columns as strings first",
      "Read file line by line using `open()`"
    ]
  },
  {
    "q": "Which operation pivots data using multiple columns as index?",
    "c": null,
    "o": [
      "df.pivot_table(index=['region', 'year'], values='sales', aggfunc='sum')",
      "df.pivot(index='region', values='year')",
      "df.set_index(['region', 'year']).sum()",
      "df.groupby(['region', 'year'])['sales'].pivot()"
    ]
  },
  {
    "q": "What will `df.iloc[2:5]` return?",
    "c": null,
    "o": [
      "Rows at index positions 2, 3, and 4",
      "Rows 2 through 5 inclusive",
      "First 5 rows of the DataFrame",
      "Only the 5th row"
    ]
  },
  {
    "q": "Which function is used to reshape a DataFrame by column values, with support for aggregation?",
    "c": null,
    "o": [
      "df.pivot_table()",
      "df.pivot()",
      "df.reshape()",
      "df.stack()"
    ]
  },
  {
    "q": "What does `df.sort_values(['col1', 'col2'], ascending=[True, False])` do?",
    "c": null,
    "o": [
      "Sorts DataFrame by 'col1' ascending and 'col2' descending",
      "Sorts all columns in descending order",
      "Sorts only 'col2' in descending order",
      "Raises a ValueError due to mixed ascending list"
    ]
  },
  {
    "q": "Which method is used to convert a column of lists into multiple rows?",
    "c": null,
    "o": [
      "df.explode('col')",
      "df.flatten('col')",
      "df.unstack('col')",
      "df.spread('col')"
    ]
  },
  {
    "q": "What is a potential benefit of converting an object column to 'category' dtype?",
    "c": null,
    "o": [
      "Reduced memory usage and faster groupby operations",
      "It can now be plotted with matplotlib",
      "It becomes a numeric column",
      "It removes duplicate values automatically"
    ]
  },
  {
    "q": "What does the `on` parameter specify in a merge operation?",
    "c": null,
    "o": [
      "The key(s) to join on in both DataFrames",
      "The order of merge result",
      "Whether to sort after merge",
      "How duplicates are handled after merge"
    ]
  },
  {
    "q": "Which operation removes all rows with any missing value?",
    "c": null,
    "o": [
      "df.dropna()",
      "df.remove_nulls()",
      "df.clean()",
      "df.isnull(drop=True)"
    ]
  },
  {
    "q": "You have a DataFrame with 1 million rows. Which is the most efficient way to filter rows where 'col' > 50?",
    "c": null,
    "o": [
      "df[df['col'] > 50]",
      "df.query('col > 50', engine='python')",
      "df.filter('col > 50')",
      "df.loc['col' > 50]"
    ]
  },
  {
    "q": "What will `df.duplicated(keep=False)` return?",
    "c": null,
    "o": [
      "All duplicate rows including the first occurrence",
      "Only the first duplicate of each duplicated row",
      "Only the last duplicate of each duplicated row",
      "True for unique rows, False for duplicates"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "df = pd.DataFrame({\n    'A': ['foo', 'foo', 'bar'],\n    'B': [1, 2, 3]\n})\ndf.groupby('A').sum()",
    "o": [
      "Groups rows by 'A' and sums values in 'B'",
      "Counts the number of entries per group",
      "Creates a pivot table with index 'B'",
      "Raises a TypeError due to string values in 'A'"
    ]
  },
  {
    "q": "Which is the best way to get memory usage details for each column?",
    "c": null,
    "o": [
      "df.info(memory_usage='deep')",
      "df.memory_info()",
      "df.describe(deep=True)",
      "df.columns.memory_usage()"
    ]
  },
  {
    "q": "What is the difference between `pd.merge()` and `pd.concat()`?",
    "c": null,
    "o": [
      "`merge()` combines based on keys, `concat()` combines along an axis without key matching",
      "`merge()` only works on Series, `concat()` works on DataFrames",
      "`concat()` can join on index, `merge()` cannot",
      "`merge()` is for vertical stacking, `concat()` for horizontal"
    ]
  },
  {
    "q": "Which method converts wide-format data to long-format?",
    "c": null,
    "o": [
      "pd.melt()",
      "pd.pivot_table()",
      "pd.wide_to_long()",
      "pd.stack_table()"
    ]
  },
  {
    "q": "What does `df['col'].astype('float32')` do?",
    "c": null,
    "o": [
      "Converts the data type of column 'col' to 32-bit float",
      "Normalizes the values in the column",
      "Converts float to integers",
      "Removes missing values from the column"
    ]
  },
  {
    "q": "Which of the following creates a DateTime index and sets it as index?",
    "c": "df['date'] = pd.to_datetime(df['date'])\ndf = df.set_index('date')",
    "o": [
      "Converts 'date' column to datetime and sets it as index",
      "Parses date column as string and resets index",
      "Creates a new DataFrame with daily index",
      "Creates a date range from 'date' column"
    ]
  },
  {
    "q": "Which argument of `pd.read_csv()` is used to parse date columns?",
    "c": null,
    "o": [
      "parse_dates",
      "convert_dates",
      "date_parser",
      "use_dates"
    ]
  },
  {
    "q": "What is a potential issue when joining on columns with missing values?",
    "c": null,
    "o": [
      "Missing values are treated as non-matching keys and excluded from join",
      "They raise a KeyError",
      "They are automatically filled with zeros",
      "Pandas will duplicate the rows with NaN keys"
    ]
  },
  {
    "q": "How can you inspect the first 10 rows and check memory usage at once?",
    "c": null,
    "o": [
      "df.info(verbose=True, memory_usage='deep'); df.head(10)",
      "df.describe(); df.info()",
      "df.head(10).memory_usage()",
      "df.memory_usage(); df.tail(10)"
    ]
  },
  {
    "q": "You want to find rows where column A is 'yes' and B > 100. What is the correct syntax?",
    "c": null,
    "o": [
      "df[(df['A'] == 'yes') & (df['B'] > 100)]",
      "df[df['A'] == 'yes' & df['B'] > 100]",
      "df['A'] == 'yes' and df['B'] > 100",
      "df.where('A' == 'yes' and 'B' > 100)"
    ]
  },
  {
    "q": "What will `df.resample('W').mean()` do if 'df' has a DateTime index?",
    "c": null,
    "o": [
      "Computes weekly mean for all numeric columns",
      "Resamples to weekdays only",
      "Converts DataFrame into 7 columns (1 per weekday)",
      "Sorts the index weekly"
    ]
  },
  {
    "q": "Which option best describes the difference between `.loc[]` and `.iloc[]`?",
    "c": null,
    "o": [
      "`.loc[]` uses labels, `.iloc[]` uses integer positions",
      "`.loc[]` is faster than `.iloc[]`",
      "`.iloc[]` only works for columns, `.loc[]` only for rows",
      "`.loc[]` allows slicing, `.iloc[]` does not"
    ]
  },
  {
    "q": "What is the purpose of using `df['A'].str.contains('foo')`?",
    "c": null,
    "o": [
      "Filters rows where column 'A' contains substring 'foo'",
      "Checks if 'foo' is in any column",
      "Replaces 'foo' with NaN in column 'A'",
      "Removes rows with 'foo' in column 'A'"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "df = pd.DataFrame({\n  'key': ['a', 'b', 'c'],\n  'val': [1, 2, 3]\n})\ndf.set_index('key', inplace=True)\ndf.loc['b']",
    "o": [
      "Returns the row with index 'b'",
      "Raises KeyError since 'key' was removed",
      "Returns only the column 'val'",
      "Returns None"
    ]
  },
  {
    "q": "How does `df.tz_localize('UTC').tz_convert('Asia/Kolkata')` affect a datetime column?",
    "c": null,
    "o": [
      "First sets timezone to UTC, then converts it to Asia/Kolkata time",
      "Only converts the column to Asia/Kolkata time without setting tz",
      "Removes timezone information",
      "Adds 5 hours and 30 minutes statically"
    ]
  },
  {
    "q": "Which function is preferred to apply row-wise custom logic efficiently?",
    "c": null,
    "o": [
      "df.apply(func, axis=1)",
      "df.transform(func)",
      "df.map(func)",
      "df.eval(func)"
    ]
  },
  {
    "q": "What is the role of `drop=True` in `df.reset_index(drop=True)`?",
    "c": null,
    "o": [
      "Removes the old index and does not add it as a column",
      "Deletes duplicate rows before reset",
      "Drops NaN rows only from the index",
      "Keeps the old index as a column"
    ]
  },
  {
    "q": "When performing a `left` join using `pd.merge()`, what happens to unmatched rows from the right DataFrame?",
    "c": null,
    "o": [
      "They are discarded from the result",
      "They are included with NaN values",
      "They replace existing rows",
      "An error is raised"
    ]
  },
  {
    "q": "Which of the following methods is used to create a sliding window over time-based data?",
    "c": null,
    "o": [
      "df.rolling(window=3)",
      "df.shift(periods=3)",
      "df.cumsum()",
      "df.sample(3)"
    ]
  },
  {
    "q": "What is the output type of `df[['A', 'B']].sum(axis=1)`?",
    "c": null,
    "o": [
      "A Series with row-wise sums",
      "A DataFrame with column-wise sums",
      "A scalar value",
      "A NumPy array"
    ]
  },
  {
    "q": "What does `df.query('score > 70 and subject == \"math\"')` return?",
    "c": null,
    "o": [
      "Rows where score > 70 and subject is math",
      "All rows with subject = math regardless of score",
      "A syntax error due to nested quotes",
      "Rows where subject is not math"
    ]
  },
  {
    "q": "Which operation below will reduce DataFrame size by converting string columns to category?",
    "c": null,
    "o": [
      "df['col'] = df['col'].astype('category')",
      "df['col'].dropna(inplace=True)",
      "df['col'].fillna('unknown')",
      "df['col'] = df['col'].astype(str)"
    ]
  },
  {
    "q": "Which method allows applying multiple aggregation functions to multiple columns after a groupby?",
    "c": null,
    "o": [
      "grouped.agg({'col1': ['mean', 'sum'], 'col2': 'max'})",
      "grouped.apply(['mean', 'sum'])",
      "grouped.transform(['mean', 'sum'])",
      "grouped.aggregate('col1', ['mean', 'sum'])"
    ]
  },
  {
    "q": "What is the use of the `on` parameter in `pd.merge()`?",
    "c": null,
    "o": [
      "It specifies the common column(s) used for joining",
      "It sets a condition for filtering after the join",
      "It renames columns after merging",
      "It defines the axis to merge along"
    ]
  },
  {
    "q": "What will `df.iloc[::2]` return?",
    "c": null,
    "o": [
      "Every second row (i.e., rows with even index positions)",
      "Every second column",
      "Only the last two rows",
      "A random 50% sample of the DataFrame"
    ]
  },
  {
    "q": "Which method can reduce memory usage by optimizing numeric types?",
    "c": null,
    "o": [
      "pd.to_numeric(df['col'], downcast='integer')",
      "df['col'].astype('float64')",
      "df['col'].convert_dtypes()",
      "df.astype('object')"
    ]
  },
  {
    "q": "How do you get the number of unique values in each column of a DataFrame?",
    "c": null,
    "o": [
      "df.nunique()",
      "df.value_counts()",
      "df.unique()",
      "df.columns.nunique()"
    ]
  },
  {
    "q": "Which function would you use to combine rows with the same key and apply a custom aggregation?",
    "c": null,
    "o": [
      "groupby()",
      "pivot()",
      "join()",
      "combine_first()"
    ]
  },
  {
    "q": "Which operation reshapes the DataFrame by rotating the row index to columns?",
    "c": null,
    "o": [
      "unstack()",
      "melt()",
      "stack()",
      "pivot_table()"
    ]
  },
  {
    "q": "What does `df['price'].pct_change()` compute?",
    "c": null,
    "o": [
      "Percentage change between current and prior element",
      "Percentile rank of prices",
      "Cumulative product of price column",
      "Rolling mean of price"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "df.index = pd.to_datetime(df.index)\ndf = df.resample('M').sum()",
    "o": [
      "Resamples the DataFrame monthly and computes sum for each month",
      "Filters only monthly data rows",
      "Adds new month column",
      "Changes index to numerical"
    ]
  },
  {
    "q": "Which is **not** a valid method of reading data into a pandas DataFrame?",
    "c": null,
    "o": [
      "pd.read_table_sql()",
      "pd.read_csv()",
      "pd.read_json()",
      "pd.read_sql()"
    ]
  },
  {
    "q": "Which of the following statements returns the last 5 rows of a DataFrame?",
    "c": null,
    "o": [
      "df.tail()",
      "df.last()",
      "df[-5:]",
      "df.end()"
    ]
  },
  {
    "q": "What is the main difference between `merge()` and `join()` in pandas?",
    "c": null,
    "o": [
      "`merge()` works on any columns, `join()` works only on the index by default",
      "`join()` is used only for SQL-style operations",
      "`merge()` cannot specify join type",
      "`join()` accepts multiple DataFrames"
    ]
  },
  {
    "q": "Which of the following will cast a column of float64 values to float32 to save memory?",
    "c": null,
    "o": [
      "df['col'] = df['col'].astype('float32')",
      "df['col'] = df.astype('float')",
      "df['col'].convert_dtypes()",
      "df.astype(float)"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "df = pd.DataFrame({'val': [10, 20, 30, 40]})\ndf.shift(1)",
    "o": [
      "All values shifted down by one, top row becomes NaN",
      "All values shifted up by one, last row becomes NaN",
      "All values doubled",
      "Index reset to start from 1"
    ]
  },
  {
    "q": "How does `.isin()` work in pandas?",
    "c": null,
    "o": [
      "It checks if each element is contained in a given list or Series",
      "It validates the data type of elements",
      "It performs element-wise equality comparison",
      "It filters out NaNs"
    ]
  },
  {
    "q": "What does `df.resample('Q').mean()` do when index is datetime?",
    "c": null,
    "o": [
      "Computes mean for each quarter",
      "Computes quarterly growth",
      "Returns the last value of each quarter",
      "Filters out rows not in Q1"
    ]
  },
  {
    "q": "What does the following return?",
    "c": "df = pd.DataFrame({'x': [1, 2, 2, 3]})\ndf.duplicated()",
    "o": [
      "A boolean Series marking duplicates as True (except first occurrence)",
      "A Series of unique values only",
      "Drops duplicates in-place",
      "Raises ValueError if duplicates exist"
    ]
  },
  {
    "q": "Which of these reshapes a wide DataFrame to a long format?",
    "c": null,
    "o": [
      "pd.melt(df)",
      "df.unstack()",
      "df.pivot()",
      "df.transpose()"
    ]
  },
  {
    "q": "What is the output of the following operation?",
    "c": "df = pd.DataFrame({'A': ['a', 'b', 'c'], 'B': [1, 2, 3]})\ndf.set_index('A', inplace=True)\ndf.reset_index()",
    "o": [
      "Restores 'A' back as a column",
      "Drops column 'A'",
      "Sets new index as range(0, n)",
      "Renames column 'A' to index"
    ]
  },
  {
    "q": "What is the default behavior of `dropna()`?",
    "c": null,
    "o": [
      "Drops rows containing any NaN values",
      "Fills NaNs with zero",
      "Drops only columns with NaN values",
      "Drops rows with all non-numeric types"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "import pandas as pd\ns = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\nprint(s.loc[['a', 'd']])",
    "o": [
      "KeyError: 'd'",
      "[1, NaN]",
      "[1, None]",
      "0    1\n1    NaN"
    ]
  },
  {
    "q": "What is the most efficient way to replace all NaN values with 0 in a DataFrame, while avoiding a copy?",
    "c": null,
    "o": [
      "df.fillna(0, inplace=True)",
      "df = df.fillna(0)",
      "df.replace(np.nan, 0)",
      "df.fill(0)"
    ]
  },
  {
    "q": "Which of the following statements will raise an error while trying to merge two DataFrames with overlapping column names (excluding keys)?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, on='id')",
      "pd.merge(df1, df2, on='id', suffixes=('_left', '_right'))",
      "pd.merge(df1, df2, left_on='id1', right_on='id2')",
      "pd.merge(df1, df2, on='id', suffixes=None)"
    ]
  },
  {
    "q": "When performing groupby operations, which of the following returns the mean of each group and preserves the index name?",
    "c": "df = pd.DataFrame({'A': ['foo', 'bar', 'foo', 'bar'], 'B': [1, 2, 3, 4]})\ngrouped = df.groupby('A')",
    "o": [
      "grouped.mean().rename_axis('A')",
      "grouped.mean().reset_index()",
      "grouped.apply(np.mean)",
      "grouped.agg({'B': 'mean'})"
    ]
  },
  {
    "q": "Which of the following is NOT a valid option for the 'how' parameter in pandas.merge()?",
    "c": null,
    "o": [
      "'cross_outer'",
      "'inner'",
      "'left'",
      "'outer'"
    ]
  },
  {
    "q": "Which method allows you to efficiently convert a string column to datetime while providing error handling?",
    "c": null,
    "o": [
      "pd.to_datetime(df['date'], errors='coerce')",
      "df['date'].astype('datetime')",
      "df['date'].convert('datetime')",
      "df['date'].datetime(errors='coerce')"
    ]
  },
  {
    "q": "Which of the following code snippets demonstrates proper resampling to get monthly mean from a time series with daily frequency?",
    "c": "ts = pd.Series(range(365), index=pd.date_range('2023-01-01', periods=365))",
    "o": [
      "ts.resample('M').mean()",
      "ts.group_by('M').mean()",
      "ts.resample('MS').sum()",
      "ts.groupby(ts.index.month).mean()"
    ]
  },
  {
    "q": "Which operation is typically faster and more memory efficient in Pandas?",
    "c": null,
    "o": [
      "Vectorized operation (e.g., df['a'] + df['b'])",
      "Using df.apply(lambda x: x['a'] + x['b'], axis=1)",
      "Using a for-loop over DataFrame rows",
      "Using df.iterrows() with manual addition"
    ]
  },
  {
    "q": "What happens when you try to assign a value to a slice of a DataFrame without using `.loc` or `.iloc`?",
    "c": "df = pd.DataFrame({'A': [1, 2, 3, 4]})\ndf[df['A'] > 2]['A'] = 10",
    "o": [
      "A SettingWithCopyWarning is raised",
      "The DataFrame is updated as expected",
      "A SyntaxError occurs",
      "It silently fails without warning"
    ]
  },
  {
    "q": "Which option is best to estimate memory usage of each column in a large DataFrame?",
    "c": null,
    "o": [
      "df.memory_usage(deep=True)",
      "sys.getsizeof(df)",
      "df.info(memory_usage='deep')",
      "df.describe(include='all')"
    ]
  },
  {
    "q": "What will the following code output if 'data.csv' has a UTF-16 encoding?",
    "c": "import pandas as pd\ndf = pd.read_csv('data.csv')",
    "o": [
      "UnicodeDecodeError",
      "Successful read with default encoding",
      "ParserWarning",
      "Empty DataFrame"
    ]
  },
  {
    "q": "Which of the following operations may lead to unexpected results due to chained indexing?",
    "c": "df[df['A'] > 0]['B'] = 100",
    "o": [
      "It raises a SettingWithCopyWarning",
      "It works without any issue",
      "It will raise a KeyError",
      "It modifies the original DataFrame"
    ]
  },
  {
    "q": "When joining DataFrames with multi-level indexes, which argument must be set for a proper match?",
    "c": null,
    "o": [
      "left_index=True, right_index=True",
      "on='index'",
      "join_axes=True",
      "merge_index=True"
    ]
  },
  {
    "q": "What does the `convert_dtypes()` method do in pandas?",
    "c": null,
    "o": [
      "Converts columns to best possible dtypes based on the values",
      "Casts all columns to object dtype",
      "Infers column types from column names",
      "Converts only numeric types"
    ]
  },
  {
    "q": "How can you read specific columns from a large Excel file to reduce memory usage?",
    "c": null,
    "o": [
      "pd.read_excel('file.xlsx', usecols=['A', 'C'])",
      "pd.read_excel('file.xlsx', columns=['A', 'C'])",
      "pd.read_excel('file.xlsx').loc[:, ['A', 'C']]",
      "pd.read_excel('file.xlsx', nrows=0)['A', 'C']"
    ]
  },
  {
    "q": "In a time zone-aware Series, what does `tz_localize(None)` do?",
    "c": null,
    "o": [
      "Removes the timezone information",
      "Converts the time zone to UTC",
      "Throws a ValueError",
      "Shifts the timestamps to local time"
    ]
  },
  {
    "q": "Which is more efficient for applying a function column-wise in a DataFrame?",
    "c": null,
    "o": [
      "df.apply(func, axis=0)",
      "df.apply(func, axis=1)",
      "df.iterrows()",
      "df.map(func)"
    ]
  },
  {
    "q": "When using `groupby().agg()`, how can you specify different aggregations per column?",
    "c": null,
    "o": [
      "Using a dictionary: {'col1': 'sum', 'col2': 'mean'}",
      "Passing a list of functions directly",
      "By chaining .sum() and .mean()",
      "Using multiple groupby calls"
    ]
  },
  {
    "q": "What is the output shape of a pivot table if index has 3 unique values, columns has 4, and values have 2 columns?",
    "c": null,
    "o": [
      "(3, 8)",
      "(4, 6)",
      "(3, 4)",
      "(3, 2)"
    ]
  },
  {
    "q": "What happens when you try to read a malformed JSON file with `pd.read_json()` without handling errors?",
    "c": null,
    "o": [
      "ValueError",
      "Returns empty DataFrame",
      "Returns partially loaded DataFrame",
      "Warning is issued and loading continues"
    ]
  },
  {
    "q": "Which operation will result in the DataFrame being sorted by index after concatenation?",
    "c": "pd.concat([df1, df2], axis=1, sort=True)",
    "o": [
      "The resulting DataFrame will be sorted by index",
      "Rows will be ordered by df1's original index",
      "Sorting does not happen unless sort_index() is used",
      "Columns are sorted alphabetically"
    ]
  },
  {
    "q": "What does `df['col'].astype('category')` do internally that can help reduce memory usage?",
    "c": null,
    "o": [
      "It stores data as integer codes with a mapping to actual values",
      "It stores data as compressed object types",
      "It converts strings to fixed-length arrays",
      "It removes duplicated string objects from memory"
    ]
  },
  {
    "q": "Which parameter in `read_sql()` should be used to avoid loading the entire result into memory at once?",
    "c": null,
    "o": [
      "chunksize",
      "buffer_size",
      "iterator",
      "lazy_load"
    ]
  },
  {
    "q": "When does a merge operation result in a Cartesian product?",
    "c": null,
    "o": [
      "When `how='cross'` is used",
      "When keys in both DataFrames match exactly",
      "When `on` is not specified and no common columns exist",
      "When indexes are duplicated"
    ]
  },
  {
    "q": "What does `dropna(thresh=n)` do in a DataFrame?",
    "c": null,
    "o": [
      "Keeps rows with at least `n` non-null values",
      "Drops columns with fewer than `n` nulls",
      "Drops rows with more than `n` nulls",
      "Keeps columns with at least `n` null values"
    ]
  },
  {
    "q": "Which of the following will change the frequency of a time series without aggregating values?",
    "c": null,
    "o": [
      "df.asfreq('M')",
      "df.resample('M').mean()",
      "df.reindex(pd.date_range(...))",
      "df.set_index('date')"
    ]
  },
  {
    "q": "Which is the most memory-efficient data type to store a column of repeated string labels like ['cat', 'dog', 'dog', 'cat']?",
    "c": null,
    "o": [
      "category",
      "object",
      "string",
      "uint8"
    ]
  },
  {
    "q": "What does `explode()` do in a DataFrame context?",
    "c": "df = pd.DataFrame({'A': [[1, 2], [3, 4]]})\ndf.explode('A')",
    "o": [
      "Creates a new row for each element in the list within a column",
      "Splits the DataFrame into multiple smaller DataFrames",
      "Flattens all nested columns",
      "Raises an error because lists aren't allowed"
    ]
  },
  {
    "q": "How do you perform a left join on index from df1 and a column from df2?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, left_index=True, right_on='col')",
      "pd.merge(df1, df2, on='index')",
      "df1.join(df2, on='col')",
      "df1.merge(df2, on=df1.index == df2['col'])"
    ]
  },
  {
    "q": "Which method allows you to apply a custom aggregation function that returns a Series per group?",
    "c": null,
    "o": [
      "grouped.apply(func)",
      "grouped.transform(func)",
      "grouped.aggregate(func)",
      "grouped.map(func)"
    ]
  },
  {
    "q": "Which method should be used to update only overlapping non-NA entries between two DataFrames?",
    "c": null,
    "o": [
      "df1.update(df2)",
      "df1.combine_first(df2)",
      "df1.fillna(df2)",
      "df1.merge(df2)"
    ]
  },
  {
    "q": "How do you convert a multi-index DataFrame to a regular DataFrame by resetting all index levels?",
    "c": null,
    "o": [
      "df.reset_index()",
      "df.index.reset()",
      "df.index.to_flat()",
      "pd.flatten_index(df)"
    ]
  },
  {
    "q": "What will happen if you try to reindex a DataFrame with duplicate labels and `allow_duplicates=False`?",
    "c": "df = pd.DataFrame([[1,2]], columns=['A','B'])\ndf.reindex(['A','A'], axis=1, allow_duplicates=False)",
    "o": [
      "ValueError will be raised",
      "Duplicate columns will be dropped",
      "Reindexing will proceed with duplicates",
      "The operation will fill with NaNs"
    ]
  },
  {
    "q": "Which function is used to efficiently compare two DataFrames and highlight differences?",
    "c": null,
    "o": [
      "df1.compare(df2)",
      "df1.equals(df2)",
      "df1.diff(df2)",
      "df1.ne(df2)"
    ]
  },
  {
    "q": "Which method preserves the column data types during replacement?",
    "c": "df.replace({'col': {np.nan: 0}})",
    "o": [
      "replace() preserves dtype",
      "fillna() always changes dtype",
      "astype() is required to preserve dtype",
      "replace() casts to object"
    ]
  },
  {
    "q": "Which merge behavior best describes `df1.join(df2, how='left')` if both have the same index?",
    "c": null,
    "o": [
      "Join on index with left DataFrame index preserved",
      "Join on matching columns using left join",
      "Join only where indexes are equal",
      "Join creates a Cartesian product"
    ]
  },
  {
    "q": "What does `resample().ffill()` do in time series?",
    "c": null,
    "o": [
      "Fills missing timestamps with previous valid values",
      "Resamples and fills forward with 0",
      "Shifts values to future timestamps",
      "Backfills missing periods"
    ]
  },
  {
    "q": "When writing a DataFrame to SQL using `to_sql()`, which parameter avoids inserting the index as a column?",
    "c": null,
    "o": [
      "index=False",
      "if_exists='skip'",
      "exclude_index=True",
      "index_col=None"
    ]
  },
  {
    "q": "Which function is typically *faster* for row-wise reduction operations across all columns?",
    "c": null,
    "o": [
      "np.sum(df.values, axis=1)",
      "df.sum(axis=1)",
      "df.apply(np.sum, axis=1)",
      "df.aggregate(np.sum, axis=1)"
    ]
  },
  {
    "q": "Which of the following ensures that datetime parsing works with mixed formats?",
    "c": null,
    "o": [
      "pd.to_datetime(series, errors='coerce')",
      "series.astype('datetime64')",
      "pd.to_datetime(series, format='%Y-%m-%d')",
      "series.convert('datetime')"
    ]
  },
  {
    "q": "What does the `drop_duplicates(keep=False)` method do?",
    "c": null,
    "o": [
      "Drops all duplicates, including the original occurrences",
      "Drops only the first duplicate in each set",
      "Keeps all values including duplicates",
      "Raises an exception for duplicate rows"
    ]
  },
  {
    "q": "Which function is used to combine two DataFrames with different columns by filling missing values with NaN?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], sort=True)",
      "df1.merge(df2)",
      "df1.combine(df2)",
      "df1.join(df2, how='outer', on='index')"
    ]
  },
  {
    "q": "Which of the following will change the column order of a DataFrame?",
    "c": "df = pd.DataFrame({'A': [1], 'B': [2], 'C': [3]})\ndf = df[['C', 'A', 'B']]",
    "o": [
      "Column order becomes C, A, B",
      "Column values get sorted",
      "DataFrame shape changes",
      "It raises a KeyError"
    ]
  },
  {
    "q": "Which of the following is true about `isin()`?",
    "c": "df[df['col'].isin([1, 2, 3])]",
    "o": [
      "Filters rows where 'col' has values 1, 2, or 3",
      "Returns the number of matches",
      "Creates a new DataFrame with only matched columns",
      "Returns a new DataFrame with all values converted to boolean"
    ]
  },
  {
    "q": "What will the `memory_usage(deep=True)` method reveal that `deep=False` wont?",
    "c": null,
    "o": [
      "Memory used by object-type columns like strings",
      "Memory used by column headers",
      "Memory of cached intermediate results",
      "Memory used by DataFrame index only"
    ]
  },
  {
    "q": "Which of the following gives the cumulative count of grouped values?",
    "c": "df.groupby('key').cumcount()",
    "o": [
      "Returns 0-based count of each row within its group",
      "Returns total number of elements per group",
      "Returns cumulative sum of values",
      "Returns NaN for non-numeric values"
    ]
  },
  {
    "q": "Which of the following is true about `DataFrame.eval()`?",
    "c": "df.eval('total = col1 + col2')",
    "o": [
      "Allows efficient evaluation of expressions using column names",
      "Only works with numeric columns",
      "Cannot modify the DataFrame in-place",
      "Evaluates Python code strings using `exec()`"
    ]
  },
  {
    "q": "What is the role of `squeeze=True` when reading a CSV?",
    "c": "pd.read_csv('file.csv', squeeze=True)",
    "o": [
      "Returns a Series if the parsed data only contains one column",
      "Compresses the file while reading",
      "Reduces memory footprint",
      "Reads the CSV into a numpy array"
    ]
  },
  {
    "q": "Which of the following functions can return a DataFrame of differences between two DataFrames?",
    "c": "df1.compare(df2)",
    "o": [
      "Returns only the differing cells with from/to values",
      "Returns rows present in df1 but not in df2",
      "Shows mismatched indexes only",
      "Returns boolean array of same shape"
    ]
  },
  {
    "q": "What will happen if you attempt to assign a list to a slice with mismatched length?",
    "c": "df.loc[0:2, 'col'] = [1, 2]",
    "o": [
      "ValueError due to length mismatch",
      "Rows will be padded with NaN",
      "It will broadcast the last value",
      "Assignment will silently fail"
    ]
  },
  {
    "q": "Which of the following operations will NOT preserve the original index order?",
    "c": null,
    "o": [
      "df.sort_values(by='col')",
      "df.reindex(sorted(df.index))",
      "df.loc[::-1]",
      "df.sample(frac=1)"
    ]
  },
  {
    "q": "What will happen when trying to assign a column with mismatched index to a DataFrame?",
    "c": "df['new'] = pd.Series([1, 2, 3], index=[100, 101, 102])",
    "o": [
      "NaNs will be assigned to unmatched indices",
      "Values will be broadcast to all rows",
      "Raises ValueError due to index mismatch",
      "It will overwrite the index of df"
    ]
  },
  {
    "q": "Which function can be used to convert a wide-format DataFrame into long format?",
    "c": null,
    "o": [
      "pd.melt(df)",
      "df.unstack()",
      "df.pivot()",
      "df.transpose()"
    ]
  },
  {
    "q": "What is the effect of `drop(columns=['A', 'B'], errors='ignore')`?",
    "c": null,
    "o": [
      "Drops columns A and B if present, otherwise does nothing",
      "Raises KeyError if either column doesn't exist",
      "Ignores drop operation entirely",
      "Drops all columns except A and B"
    ]
  },
  {
    "q": "What does `DataFrame.rolling(window=3).sum()` compute?",
    "c": null,
    "o": [
      "Sum of values over a sliding window of size 3",
      "Cumulative sum of the first 3 rows",
      "Group-wise sum for groups of 3 rows",
      "3-period resampling of the DataFrame"
    ]
  },
  {
    "q": "Which option will correctly flatten a multi-index DataFrame after groupby aggregation?",
    "c": "df.groupby(['A', 'B']).sum().reset_index()",
    "o": [
      "reset_index() removes multi-index and flattens the result",
      "as_index=False does this automatically",
      "You must use unstack() followed by melt()",
      "flatten_index=True must be passed"
    ]
  },
  {
    "q": "When saving a DataFrame to CSV using `to_csv()`, what will `index_label` do?",
    "c": "df.to_csv('file.csv', index_label='ID')",
    "o": [
      "Adds a label to the index column in the output file",
      "Sorts the index before saving",
      "Adds a new column called 'ID'",
      "Hides the index in the CSV output"
    ]
  },
  {
    "q": "What will the following code do?",
    "c": "df.loc[df['col'].isnull(), 'col'] = df['col'].mean()",
    "o": [
      "Fill NaNs in 'col' with the mean of that column",
      "Remove rows where 'col' is null",
      "Set the entire column to mean value",
      "Replace zeros in the column with the mean"
    ]
  },
  {
    "q": "Which is TRUE about `df.transform()` used on a groupby object?",
    "c": null,
    "o": [
      "It returns a DataFrame with the same shape as the original",
      "It returns one row per group",
      "It modifies the original DataFrame",
      "It always returns a Series"
    ]
  },
  {
    "q": "What does the `method` parameter in `fillna()` control?",
    "c": "df.fillna(method='bfill')",
    "o": [
      "Direction of fill: forward or backward",
      "Strategy to impute using statistics",
      "Interpolation technique between values",
      "Whether to modify in place or not"
    ]
  },
  {
    "q": "Which of the following would prevent a chained assignment warning in pandas?",
    "c": "df.loc[df['A'] > 5, 'B'] = 0",
    "o": [
      "Using `.loc[]` for assignment",
      "Using `df['B'][df['A'] > 5] = 0`",
      "Using `df.where(df['A'] > 5)['B'] = 0`",
      "Using `.apply()` with lambda assignment"
    ]
  },
  {
    "q": "What is the output type of `df['col'].value_counts(normalize=True)`?",
    "c": null,
    "o": [
      "Series with relative frequencies",
      "DataFrame with raw counts",
      "List of values",
      "Tuple of counts and percentages"
    ]
  },
  {
    "q": "Which of the following methods supports writing large DataFrames in chunks to CSV?",
    "c": null,
    "o": [
      "to_csv(..., chunksize=1000)",
      "to_csv(..., split=True)",
      "to_csv(..., buffered=True)",
      "to_csv(...).write_chunks(1000)"
    ]
  },
  {
    "q": "What does `df.reindex_like(df2)` do?",
    "c": null,
    "o": [
      "Aligns both index and columns to match df2",
      "Copies df2 values into df",
      "Drops all unmatched rows and columns",
      "Changes index labels to strings"
    ]
  },
  {
    "q": "Which method is ideal to normalize each row so that the sum is 1?",
    "c": "df.div(df.sum(axis=1), axis=0)",
    "o": [
      "Row-wise division by row-wise sum",
      "Column-wise division by column-wise sum",
      "Apply `normalize=True` in df.sum()",
      "Use `df.transform('normalize')`"
    ]
  },
  {
    "q": "Which of the following expressions checks if two DataFrames are equal in both values and index?",
    "c": null,
    "o": [
      "df1.equals(df2)",
      "(df1 == df2).all().all()",
      "df1.compare(df2).empty",
      "np.array_equal(df1, df2)"
    ]
  },
  {
    "q": "Which parameter is used in `read_csv()` to efficiently read a subset of large CSV files?",
    "c": null,
    "o": [
      "usecols",
      "subset",
      "skipcolumns",
      "readpartial"
    ]
  },
  {
    "q": "Which behavior describes `dropna(axis=1, how='all')`?",
    "c": null,
    "o": [
      "Drops columns where all values are NaN",
      "Drops columns with any NaN values",
      "Drops rows where all columns are NaN",
      "Drops columns based on a threshold"
    ]
  },
  {
    "q": "Which function will convert a datetime Series to just the year as integers?",
    "c": "df['year'] = df['date'].dt.year",
    "o": [
      "Extracts year from datetime as int",
      "Casts datetime to year string",
      "Filters only rows from that year",
      "Truncates all date components"
    ]
  },
  {
    "q": "What is the result of `df.groupby('key', sort=False)`?",
    "c": null,
    "o": [
      "Groups without sorting key values",
      "Sorts keys alphabetically before grouping",
      "Prevents duplicates in keys",
      "Groups and sorts columns"
    ]
  },
  {
    "q": "What will happen if you set a DataFrame column to a NumPy array with mismatched length?",
    "c": "df['new'] = np.array([1, 2, 3])  # df has 10 rows",
    "o": [
      "ValueError due to length mismatch",
      "The array will be broadcast to all rows",
      "Rows will be truncated to 3 rows",
      "Remaining values will be filled with NaN"
    ]
  },
  {
    "q": "Which method is best suited for applying a row-wise operation returning a scalar?",
    "c": null,
    "o": [
      "df.apply(func, axis=1)",
      "df.transform(func)",
      "df.agg(func, axis=1)",
      "df.map(func)"
    ]
  },
  {
    "q": "What does `pd.qcut()` do?",
    "c": null,
    "o": [
      "Bins data into quantile-based buckets",
      "Cuts data into equal-width intervals",
      "Generates quantile summaries",
      "Removes outliers from Series"
    ]
  },
  {
    "q": "What is the output of `df.groupby('A')['B'].transform('mean')`?",
    "c": null,
    "o": [
      "A Series with group-wise mean repeated for each row",
      "A Series of single mean values per group",
      "A DataFrame of group means",
      "A pivot table with grouped B"
    ]
  },
  {
    "q": "Which parameter in `to_excel()` avoids writing the index?",
    "c": null,
    "o": [
      "index=False",
      "include_index=False",
      "index_label=None",
      "drop_index=True"
    ]
  },
  {
    "q": "Which of the following methods can be used to downcast floats to smaller types during conversion?",
    "c": "df.astype({'col': 'float32'})",
    "o": [
      "astype() with specified dtype",
      "downcast=True in fillna()",
      "pd.to_numeric(df['col'], precision='low')",
      "df['col'].compress('float')"
    ]
  },
  {
    "q": "What does `df.pivot_table(index='A', columns='B', values='C', aggfunc='count')` do?",
    "c": null,
    "o": [
      "Creates a table showing counts of C grouped by A and B",
      "Creates a summary table with mean of C",
      "Pivots A and B values to new rows only",
      "Sorts and reshapes C into a multi-index structure"
    ]
  },
  {
    "q": "Which expression gets the last 3 rows of a time-indexed DataFrame for each month?",
    "c": "df.groupby(pd.Grouper(freq='M')).tail(3)",
    "o": [
      "Correctly returns last 3 rows per month",
      "Returns 3 random rows per group",
      "Returns first 3 rows per month",
      "Raises a GroupByError"
    ]
  },
  {
    "q": "Which option is the most memory-efficient way to store integer categorical data?",
    "c": null,
    "o": [
      "astype('category')",
      "astype('object')",
      "astype('str')",
      "convert_dtypes()"
    ]
  },
  {
    "q": "Which method is most appropriate for comparing the structure (columns and dtypes) of two DataFrames?",
    "c": null,
    "o": [
      "(df1.dtypes == df2.dtypes).all() and (df1.columns == df2.columns).all()",
      "df1.equals(df2)",
      "df1.compare(df2)",
      "np.array_equal(df1, df2)"
    ]
  },
  {
    "q": "What will `df[df.A > 5].B.mean()` do?",
    "c": null,
    "o": [
      "Return the mean of column B for rows where A > 5",
      "Return the mean of column A where B > 5",
      "Raise a KeyError",
      "Return NaN if any B values are NaN"
    ]
  },
  {
    "q": "Which chaining behavior can lead to SettingWithCopyWarning?",
    "c": "df[df['A'] > 5]['B'] = 0",
    "o": [
      "You're modifying a copy, not the original DataFrame",
      "You're using an undefined column",
      "The index values are not aligned",
      "This always works and never raises a warning"
    ]
  },
  {
    "q": "What does `df.rolling(window=3, min_periods=1).sum()` compute?",
    "c": null,
    "o": [
      "Rolling sum with at least 1 value",
      "Sum of first 3 rows only",
      "Cumulative sum over all rows",
      "Window sum ignoring missing values"
    ]
  },
  {
    "q": "Which of these reshapes a wide DataFrame to long format?",
    "c": null,
    "o": [
      "pd.melt(df)",
      "df.stack()",
      "df.unstack()",
      "df.pivot(index='A', columns='B')"
    ]
  },
  {
    "q": "Which of the following ensures datetime parsing during CSV read?",
    "c": "pd.read_csv('file.csv', parse_dates=['timestamp'])",
    "o": [
      "parse_dates parameter",
      "dtype={'timestamp': 'datetime64'}",
      "timestamp_as_datetime=True",
      "df['timestamp'].astype(datetime)"
    ]
  },
  {
    "q": "What does `df.sort_values(['A', 'B'], ascending=[True, False])` do?",
    "c": null,
    "o": [
      "Sort A ascending, then B descending",
      "Sort both A and B ascending",
      "Sort both A and B descending",
      "Sort based only on B"
    ]
  },
  {
    "q": "How can you get the row with maximum value in column 'C'?",
    "c": null,
    "o": [
      "df.loc[df['C'].idxmax()]",
      "df.max()['C']",
      "df[df['C'] == df['C'].max()]",
      "df.iloc[df['C'].argmax()]"
    ]
  },
  {
    "q": "What does `df.interpolate(method='linear')` do by default?",
    "c": null,
    "o": [
      "Fills NaNs using linear interpolation along index",
      "Backfills missing values",
      "Interpolates along columns",
      "Fills all NaNs with zeros"
    ]
  },
  {
    "q": "What does `df.at[5, 'col']` do?",
    "c": null,
    "o": [
      "Access single scalar value at label 5, column 'col'",
      "Return all rows with index 5",
      "Return full row at position 5",
      "Raise error if index 5 is not integer"
    ]
  },
  {
    "q": "How to ensure a column of strings is treated as pure category?",
    "c": "df['genre'] = df['genre'].astype('category')",
    "o": [
      "Reduces memory and speeds up grouping",
      "Converts strings to datetime",
      "Stores strings as object dtype",
      "Automatically applies label encoding"
    ]
  },
  {
    "q": "What does `df.groupby(['A', 'B']).size()` return?",
    "c": null,
    "o": [
      "A Series with MultiIndex of counts",
      "A DataFrame with row counts",
      "A pivot table with aggregated values",
      "An error unless 'size' column exists"
    ]
  },
  {
    "q": "What does `df.pivot_table(index='A', columns='B', values='C', aggfunc='sum')` do?",
    "c": null,
    "o": [
      "Creates a matrix of C summed by A and B",
      "Sorts C grouped by A and B",
      "Creates a crosstab of B and C",
      "Aggregates only unique values of C"
    ]
  },
  {
    "q": "How to swap levels in a MultiIndex DataFrame?",
    "c": null,
    "o": [
      "df.swaplevel()",
      "df.reindex()",
      "df.transpose()",
      "df.reset_index()"
    ]
  },
  {
    "q": "Which of the following performs a safe in-place replacement?",
    "c": null,
    "o": [
      "df.replace(to_replace=1, value=100, inplace=True)",
      "df.replace(1, 100)",
      "df.loc[df==1] = 100",
      "df[df==1] = 100"
    ]
  },
  {
    "q": "What does `df.shift(1)` do?",
    "c": null,
    "o": [
      "Shift all rows down by 1 with NaN on top",
      "Shift column labels right by 1",
      "Move rows up by 1",
      "Removes first row and duplicates last"
    ]
  },
  {
    "q": "What does `df.duplicated(keep=False)` return?",
    "c": null,
    "o": [
      "Boolean Series marking all duplicates as True",
      "Only the first duplicate as True",
      "Drops duplicates",
      "Raises error if duplicates found"
    ]
  },
  {
    "q": "How can you convert columns to rows in a MultiIndex column setup?",
    "c": null,
    "o": [
      "df.stack()",
      "df.unstack()",
      "df.transpose()",
      "df.pivot()"
    ]
  },
  {
    "q": "What does `df.dropna(axis=1, how='all')` do?",
    "c": null,
    "o": [
      "Drops columns where all values are NaN",
      "Drops rows where all values are NaN",
      "Drops only a single column with NaNs",
      "Raises error if NaN is present"
    ]
  },
  {
    "q": "How to merge two DataFrames using multiple keys?",
    "c": "pd.merge(df1, df2, on=['A', 'B'])",
    "o": [
      "Use a list for `on` parameter",
      "Merge only on index",
      "Merge using concat",
      "Only a single key can be used"
    ]
  },
  {
    "q": "What does `df.query('A > B')` do?",
    "c": null,
    "o": [
      "Selects rows where A column is greater than B column",
      "Selects columns where A > B",
      "Raises error unless A and B are strings",
      "Always returns an empty DataFrame"
    ]
  },
  {
    "q": "What is the main use of `pd.eval('df.A + df.B')`?",
    "c": null,
    "o": [
      "To compute expressions efficiently on DataFrame columns",
      "To parse SQL queries",
      "To evaluate mathematical functions on Series only",
      "To replace apply() function"
    ]
  },
  {
    "q": "Which method is used to reduce memory usage in a large DataFrame?",
    "c": null,
    "o": [
      "Downcasting numeric types",
      "Converting DataFrame to JSON",
      "Sorting values",
      "Using apply() instead of loops"
    ]
  },
  {
    "q": "What does `df.loc[:, ['A', 'B']]` return?",
    "c": null,
    "o": [
      "All rows with only columns A and B",
      "All columns and only rows with index A and B",
      "Columns starting from A to B",
      "Only first row with columns A and B"
    ]
  },
  {
    "q": "What is a common issue with chained assignment like `df[df['A'] > 0]['B'] = 5`?",
    "c": null,
    "o": [
      "May not modify original DataFrame and can raise SettingWithCopyWarning",
      "Always modifies in place",
      "Only modifies a copy with no warning",
      "Throws syntax error in newer versions"
    ]
  },
  {
    "q": "Which of the following best describes `df['A'].rolling(3).mean()`?",
    "c": null,
    "o": [
      "Computes 3-row moving average of column A",
      "Adds 3 rows to column A",
      "Computes standard deviation over entire A",
      "Returns a constant value for each row"
    ]
  },
  {
    "q": "How do you apply a function to every element of a DataFrame?",
    "c": null,
    "o": [
      "df.applymap(function)",
      "df.map(function)",
      "df.apply(function, axis=1)",
      "df.transform(function)"
    ]
  },
  {
    "q": "What does `df.diff()` compute?",
    "c": null,
    "o": [
      "Difference between consecutive rows",
      "Difference between columns",
      "Standard deviation of each row",
      "Difference between max and min of column"
    ]
  },
  {
    "q": "How to filter rows where column 'A' is in another column 'B'?",
    "c": null,
    "o": [
      "df[df['A'].isin(df['B'])]",
      "df[df['A'] == df['B']]",
      "df.query('A in B')",
      "df.loc['A' in df['B']]"
    ]
  },
  {
    "q": "What happens when a datetime column is used as index?",
    "c": null,
    "o": [
      "Time-based indexing and resampling becomes easier",
      "All rows are dropped",
      "No change in functionality",
      "Index becomes object type"
    ]
  },
  {
    "q": "Which operation is fastest for large data?",
    "c": null,
    "o": [
      "Vectorized operations like `df['A'] + df['B']`",
      "Using nested for loops on DataFrame",
      "Using apply() on rows",
      "Using a list comprehension"
    ]
  },
  {
    "q": "What is the effect of `groupby('A').ngroup()`?",
    "c": null,
    "o": [
      "Assigns a unique group number to each group in column A",
      "Counts the number of groups in column A",
      "Returns the size of each group",
      "Sorts the DataFrame by column A"
    ]
  },
  {
    "q": "Which merge method keeps all rows from the left DataFrame and fills null for unmatched rows from the right?",
    "c": null,
    "o": [
      "left",
      "right",
      "inner",
      "outer"
    ]
  },
  {
    "q": "What is the result of `df.pivot_table(values='sales', index='region', columns='product', aggfunc='sum')`?",
    "c": null,
    "o": [
      "Creates a summarized table of sales by region and product",
      "Sorts DataFrame by sales",
      "Creates a bar chart",
      "Converts all rows into columns"
    ]
  },
  {
    "q": "Which method resets a multi-index DataFrame into a flat DataFrame?",
    "c": null,
    "o": [
      "reset_index()",
      "flatten_index()",
      "reindex()",
      "drop_levels()"
    ]
  },
  {
    "q": "How to check if any value in column 'A' is null?",
    "c": null,
    "o": [
      "df['A'].isnull().any()",
      "df['A'].hasnull()",
      "df['A'].isna().sum() > 0",
      "not df['A'].notnull().all()"
    ]
  },
  {
    "q": "What is the role of `dropna(how='all')`?",
    "c": null,
    "o": [
      "Drops rows where all values are NaN",
      "Drops all NaN columns",
      "Drops rows with any NaN values",
      "Fills missing values with zero"
    ]
  },
  {
    "q": "Which of the following is true about `.at` vs `.loc`?",
    "c": null,
    "o": [
      ".at is faster but only works for single scalar access",
      ".loc is faster for all access patterns",
      ".at allows row slicing",
      ".at supports entire DataFrame operations"
    ]
  },
  {
    "q": "How do you assign a new column 'C' as the difference between 'A' and mean of 'A'?",
    "c": null,
    "o": [
      "df['C'] = df['A'] - df['A'].mean()",
      "df['C'] = df['A'].diff()",
      "df['C'] = df.A.apply(lambda x: x.mean())",
      "df['C'] = df.A.cumsum()"
    ]
  },
  {
    "q": "Which method provides the cumulative sum over rows for a DataFrame column?",
    "c": null,
    "o": [
      "cumsum()",
      "cumprod()",
      "sum()",
      "rolling()"
    ]
  },
  {
    "q": "What does `df.index.name = 'id'` do?",
    "c": null,
    "o": [
      "Gives a name to the index for display or export",
      "Renames the column 'id'",
      "Adds a new column 'id'",
      "Deletes the index"
    ]
  },
  {
    "q": "What does `df['date'] = pd.to_datetime(df['date'])` achieve?",
    "c": null,
    "o": [
      "Converts string-formatted dates to datetime objects",
      "Sorts the date column",
      "Adds a new column with current timestamps",
      "Removes time information from datetime"
    ]
  },
  {
    "q": "What is the output of `df.resample('M').mean()` if the index is datetime?",
    "c": null,
    "o": [
      "Monthly average of all numerical columns",
      "Cumulative monthly values",
      "Number of records per month",
      "Adds missing months as NaNs"
    ]
  },
  {
    "q": "Which method converts a column to a Pandas categorical type?",
    "c": null,
    "o": [
      "astype('category')",
      "pd.category(df['col'])",
      "convert_categorical(df['col'])",
      "df['col'].to_category()"
    ]
  },
  {
    "q": "What is the effect of `df.rolling(3).mean()`?",
    "c": null,
    "o": [
      "Applies a moving average over a 3-row window",
      "Sorts the DataFrame",
      "Returns the global mean",
      "Groups values by 3 rows"
    ]
  },
  {
    "q": "How to fill missing values in column 'A' using forward fill?",
    "c": null,
    "o": [
      "df['A'].fillna(method='ffill')",
      "df['A'].fillna(direction='forward')",
      "df.fill_missing('A')",
      "df['A'].fillna(method='next')"
    ]
  },
  {
    "q": "Which method removes duplicated rows based on all columns?",
    "c": null,
    "o": [
      "df.drop_duplicates()",
      "df.remove_duplicates()",
      "df.duplicated().drop()",
      "df.unique()"
    ]
  },
  {
    "q": "What does `df.interpolate()` typically do?",
    "c": null,
    "o": [
      "Fills missing values by estimating intermediate values",
      "Deletes rows with missing data",
      "Fills NaNs with mean",
      "Rounds float values"
    ]
  },
  {
    "q": "Which method combines DataFrames horizontally with index alignment?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], axis=1)",
      "df1.append(df2)",
      "df1.join(df2, how='inner')",
      "df1.merge(df2)"
    ]
  },
  {
    "q": "Which parameter in `merge()` defines columns to join on?",
    "c": null,
    "o": [
      "on",
      "key",
      "index",
      "join"
    ]
  },
  {
    "q": "What does `df['col'].str.contains('abc')` return?",
    "c": null,
    "o": [
      "Boolean Series where each value indicates if 'abc' is in that row",
      "The number of occurrences of 'abc'",
      "The index of matching rows",
      "All rows matching exactly 'abc'"
    ]
  },
  {
    "q": "What does `df.set_index(['A', 'B'])` do?",
    "c": null,
    "o": [
      "Sets columns 'A' and 'B' as a multi-level index",
      "Sorts the DataFrame by columns A and B",
      "Filters DataFrame by A and B",
      "Drops columns A and B"
    ]
  },
  {
    "q": "Which method resets a multi-level index back to columns?",
    "c": null,
    "o": [
      "df.reset_index()",
      "df.drop_index()",
      "df.index_to_columns()",
      "df.flatten_index()"
    ]
  },
  {
    "q": "What does `df.pivot(index='date', columns='category', values='value')` do?",
    "c": null,
    "o": [
      "Converts long-format data to wide-format using 'category' values as new columns",
      "Creates a multi-index from 'category' and 'value'",
      "Sorts the DataFrame",
      "Stacks the columns vertically"
    ]
  },
  {
    "q": "Which method transforms data from wide format to long format?",
    "c": null,
    "o": [
      "pd.melt()",
      "pd.pivot()",
      "pd.concat()",
      "pd.stack()"
    ]
  },
  {
    "q": "What does `df.stack()` do?",
    "c": null,
    "o": [
      "Converts columns into a new inner level of the index",
      "Flattens multi-index",
      "Unstacks index into columns",
      "Sorts index alphabetically"
    ]
  },
  {
    "q": "Which argument in `groupby()` controls whether the group keys become an index?",
    "c": null,
    "o": [
      "as_index",
      "keys_to_index",
      "index_keys",
      "group_index"
    ]
  },
  {
    "q": "How do you optimize Pandas performance with large numeric data?",
    "c": null,
    "o": [
      "Use appropriate dtypes like float32 instead of float64",
      "Always convert to object type",
      "Avoid NumPy operations",
      "Disable garbage collection"
    ]
  },
  {
    "q": "What is the advantage of using `category` dtype for text columns?",
    "c": null,
    "o": [
      "Reduces memory usage and increases performance for repeated string values",
      "Improves sorting speed for numerical columns",
      "Enables faster NaN filling",
      "Allows conversion to JSON"
    ]
  },
  {
    "q": "What is the result of `df.groupby('A').ngroup()`?",
    "c": null,
    "o": [
      "Assigns a group number to each row based on grouping by column A",
      "Returns the size of each group",
      "Counts number of groups",
      "Drops group keys"
    ]
  },
  {
    "q": "Which Pandas function evaluates string expressions faster than standard Python?",
    "c": null,
    "o": [
      "pd.eval()",
      "df.apply()",
      "df.query()",
      "pd.exec()"
    ]
  },
  {
    "q": "What does `df.interpolate(method='linear')` do?",
    "c": null,
    "o": [
      "Fills missing values using linear interpolation",
      "Drops all missing values",
      "Replaces missing values with zero",
      "Shifts the data forward"
    ]
  },
  {
    "q": "Which method applies a rolling window calculation in Pandas?",
    "c": null,
    "o": [
      "df.rolling(window=3)",
      "df.window(3)",
      "df.aggregate(3)",
      "df.scan(3)"
    ]
  },
  {
    "q": "What does `df.ewm(span=5).mean()` compute?",
    "c": null,
    "o": [
      "Exponentially weighted moving average with a span of 5",
      "Exact weighted average",
      "Simple moving average of 5 rows",
      "Maximum over a 5-row window"
    ]
  },
  {
    "q": "How can you shift time series data forward by 1 period?",
    "c": null,
    "o": [
      "df.shift(1)",
      "df.roll(1)",
      "df.forward(1)",
      "df.offset(1)"
    ]
  },
  {
    "q": "Which function converts a string column to datetime?",
    "c": null,
    "o": [
      "pd.to_datetime(df['date'])",
      "df['date'].as_datetime()",
      "pd.convert_to_date(df['date'])",
      "df.date_to_datetime()"
    ]
  },
  {
    "q": "What is the result of `df.resample('M').sum()` when `df` has a datetime index?",
    "c": null,
    "o": [
      "Monthly sum of values",
      "Sum by minute",
      "Daily rolling sum",
      "Hourly cumulative sum"
    ]
  },
  {
    "q": "Which type of join keeps only the rows with keys in both DataFrames?",
    "c": null,
    "o": [
      "Inner join",
      "Outer join",
      "Left join",
      "Right join"
    ]
  },
  {
    "q": "What does `df.drop_duplicates()` do?",
    "c": null,
    "o": [
      "Removes duplicate rows",
      "Sorts the DataFrame",
      "Drops NA values",
      "Drops all columns with duplicates"
    ]
  },
  {
    "q": "Which method finds outliers using z-score logic?",
    "c": null,
    "o": [
      "(df - df.mean()) / df.std()",
      "df.median() + df.std()",
      "df.sum() - df.mean()",
      "df.rank() > 1"
    ]
  },
  {
    "q": "What does `df.corr()` return?",
    "c": null,
    "o": [
      "Correlation matrix between numeric columns",
      "Covariance values",
      "Standard deviations",
      "P-values of t-tests"
    ]
  },
  {
    "q": "What does `df.groupby('category').agg({'value': 'mean'})` do?",
    "c": null,
    "o": [
      "Groups the DataFrame by 'category' and calculates the mean of 'value'",
      "Sorts the DataFrame by 'value'",
      "Filters only mean rows of 'value'",
      "Counts all 'value' entries"
    ]
  },
  {
    "q": "Which method transforms a wide DataFrame into a long format?",
    "c": null,
    "o": [
      "pd.melt(df)",
      "df.unstack()",
      "df.pivot_table()",
      "df.transpose()"
    ]
  },
  {
    "q": "Which Pandas method is used to perform SQL-like joins?",
    "c": null,
    "o": [
      "pd.merge()",
      "pd.join()",
      "pd.concat()",
      "pd.bind()"
    ]
  },
  {
    "q": "What does `df.pivot_table(index='A', columns='B', values='C', aggfunc='sum')` return?",
    "c": null,
    "o": [
      "A pivot table summing values of column C grouped by A and B",
      "A DataFrame grouped only by column B",
      "A melted DataFrame",
      "A time-indexed resample"
    ]
  },
  {
    "q": "Which method is used to check for duplicated rows?",
    "c": null,
    "o": [
      "df.duplicated()",
      "df.is_duplicate()",
      "df.check_duplicates()",
      "df.has_duplicates()"
    ]
  },
  {
    "q": "What will `df.query('A > 5 and B < 10')` return?",
    "c": null,
    "o": [
      "A filtered DataFrame where A > 5 and B < 10",
      "The count of rows where condition is true",
      "A new column with True/False values",
      "A boolean series only"
    ]
  },
  {
    "q": "Which method resamples data based on a datetime index?",
    "c": null,
    "o": [
      "df.resample('D')",
      "df.group_by_time('D')",
      "df.date_group('D')",
      "df.aggregate_time('D')"
    ]
  },
  {
    "q": "How do you calculate the percentage change between rows?",
    "c": null,
    "o": [
      "df.pct_change()",
      "df.diff_percent()",
      "df.row_change()",
      "df.delta()"
    ]
  },
  {
    "q": "Which method reads a large CSV efficiently in chunks?",
    "c": null,
    "o": [
      "pd.read_csv('file.csv', chunksize=1000)",
      "pd.read_csv('file.csv', batch=1000)",
      "pd.chunk_csv('file.csv')",
      "pd.read_large_csv('file.csv')"
    ]
  },
  {
    "q": "Which method applies a custom function to each element of a Series?",
    "c": null,
    "o": [
      "series.apply(func)",
      "series.aggregate(func)",
      "series.transform(func)",
      "series.reduce(func)"
    ]
  },
  {
    "q": "What does `df.set_index(['col1', 'col2'])` do?",
    "c": null,
    "o": [
      "Creates a MultiIndex using 'col1' and 'col2'",
      "Renames the DataFrame",
      "Drops 'col1' and 'col2'",
      "Sorts the DataFrame by both columns"
    ]
  },
  {
    "q": "Which method is used to fill missing values by propagating the last valid observation?",
    "c": null,
    "o": [
      "df.fillna(method='ffill')",
      "df.fillna(method='bfill')",
      "df.fillna(0)",
      "df.dropna()"
    ]
  },
  {
    "q": "What does `df.loc[:, 'A':'C']` return?",
    "c": null,
    "o": [
      "All rows and columns from A to C",
      "Only rows where column A equals C",
      "A new DataFrame sorted by A and C",
      "Only columns A and C"
    ]
  },
  {
    "q": "Which Pandas method is used for memory optimization analysis?",
    "c": null,
    "o": [
      "df.info(memory_usage='deep')",
      "df.memory()",
      "df.profile()",
      "df.usage()"
    ]
  },
  {
    "q": "What is the result of `df.index.get_level_values(0)` in a MultiIndex DataFrame?",
    "c": null,
    "o": [
      "Returns the first level values of the index",
      "Returns the first row of the DataFrame",
      "Removes the first index level",
      "Sorts the index by the first level"
    ]
  },
  {
    "q": "Which method converts a column of strings to datetime format?",
    "c": null,
    "o": [
      "pd.to_datetime(df['date_column'])",
      "df['date_column'].as_datetime()",
      "df.datetime('date_column')",
      "pd.date_format(df['date_column'])"
    ]
  },
  {
    "q": "Which method is most efficient for row-wise operation across a DataFrame?",
    "c": null,
    "o": [
      "df.itertuples()",
      "df.iterrows()",
      "df.rowwise()",
      "df.apply_row()"
    ]
  },
  {
    "q": "How do you get the number of unique combinations in a MultiIndex?",
    "c": null,
    "o": [
      "len(df.index.unique())",
      "df.nunique()",
      "df.unique_index()",
      "df.index.count_unique()"
    ]
  },
  {
    "q": "What does `df.pivot(index='date', columns='category', values='value')` do?",
    "c": null,
    "o": [
      "Converts rows into columns based on 'category' grouped by 'date'",
      "Groups data only by category",
      "Flattens the DataFrame",
      "Filters only values > 0"
    ]
  },
  {
    "q": "Which method adds a new column that contains the cumulative sum of an existing column?",
    "c": null,
    "o": [
      "df['cum'] = df['val'].cumsum()",
      "df['cum'] = df['val'].sum()",
      "df['cum'] = df['val'].agg('sum')",
      "df['cum'] = df['val'].accumulate()"
    ]
  },
  {
    "q": "What does `df.groupby('A').agg('sum')` do?",
    "c": null,
    "o": [
      "Groups by column 'A' and sums the remaining columns",
      "Sums column 'A' only",
      "Sorts the DataFrame by column 'A'",
      "Creates a pivot table using column 'A'"
    ]
  },
  {
    "q": "Which method is used to convert a DataFrame from long to wide format?",
    "c": null,
    "o": [
      "pivot()",
      "melt()",
      "stack()",
      "explode()"
    ]
  },
  {
    "q": "What is the use of `pd.Categorical()`?",
    "c": null,
    "o": [
      "Creates an efficient representation of categorical data",
      "Creates a new DataFrame",
      "Converts data into numerical format",
      "Encodes dates into categories"
    ]
  },
  {
    "q": "What does `df.resample('M').mean()` do for a datetime-indexed DataFrame?",
    "c": null,
    "o": [
      "Resamples data by month and calculates the mean",
      "Filters only records from March",
      "Rounds datetime values to month",
      "Adds missing months to the DataFrame"
    ]
  },
  {
    "q": "How can you merge two DataFrames on a common column 'key'?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, on='key')",
      "df1 + df2",
      "df1.join(df2, on='key')",
      "pd.concat([df1, df2], key='key')"
    ]
  },
  {
    "q": "Which Pandas method is used to flatten a hierarchical column index?",
    "c": null,
    "o": [
      "df.columns = ['_'.join(col) for col in df.columns]",
      "df.reset_index()",
      "df.stack()",
      "df.flatten_columns()"
    ]
  },
  {
    "q": "What does `df.duplicated().sum()` return?",
    "c": null,
    "o": [
      "Total number of duplicate rows",
      "A DataFrame with duplicates removed",
      "A boolean mask of duplicate values",
      "The index of all duplicates"
    ]
  },
  {
    "q": "Which function is best for reshaping a DataFrame with multiple index levels?",
    "c": null,
    "o": [
      "unstack()",
      "pivot_table()",
      "explode()",
      "dropna()"
    ]
  },
  {
    "q": "How can you select the last 3 rows of a DataFrame?",
    "c": null,
    "o": [
      "df.tail(3)",
      "df.last(3)",
      "df[-3:]",
      "df.take_last(3)"
    ]
  },
  {
    "q": "What does `df['val'].rank()` do?",
    "c": null,
    "o": [
      "Assigns a rank to each value in the 'val' column",
      "Sorts the 'val' column",
      "Groups values by frequency",
      "Normalizes the column"
    ]
  },
  {
    "q": "What does `df.transform(lambda x: x - x.mean())` do?",
    "c": null,
    "o": [
      "Subtracts the mean of each column from its values",
      "Normalizes the DataFrame to 0-1 range",
      "Drops mean values from the DataFrame",
      "Adds the mean to each column"
    ]
  },
  {
    "q": "What will `df.loc[5:10]` return if the DataFrame index is not integer-based?",
    "c": null,
    "o": [
      "A slice based on label index from 5 to 10",
      "Nothing, it will raise an error",
      "A positional slice from row 5 to 10",
      "Only row with index 10"
    ]
  },
  {
    "q": "Which method can broadcast a function over each row individually?",
    "c": null,
    "o": [
      "apply(axis=1)",
      "map()",
      "agg()",
      "pipe()"
    ]
  },
  {
    "q": "How can you optimize memory usage of a DataFrame with numeric columns?",
    "c": null,
    "o": [
      "Convert to float32/int32 types",
      "Set all NaNs to zero",
      "Use object dtype",
      "Apply map() to columns"
    ]
  },
  {
    "q": "What is the result of `df.index.name = 'ID'`?",
    "c": null,
    "o": [
      "Names the index 'ID'",
      "Adds a new column 'ID'",
      "Changes column headers to 'ID'",
      "Renames all values in the index to 'ID'"
    ]
  },
  {
    "q": "What does `df.shift(1)` do?",
    "c": null,
    "o": [
      "Shifts all rows down by one",
      "Shifts columns left",
      "Sorts rows in reverse",
      "Duplicates each row"
    ]
  },
  {
    "q": "Which is true about `explode()` in Pandas?",
    "c": null,
    "o": [
      "It expands lists in a column into multiple rows",
      "It splits strings into characters",
      "It creates a pivot table",
      "It removes outliers"
    ]
  },
  {
    "q": "How do you set multiple columns as index in Pandas?",
    "c": null,
    "o": [
      "df.set_index(['col1', 'col2'])",
      "df.index = ['col1', 'col2']",
      "df.group_index('col1', 'col2')",
      "df.multi_index('col1', 'col2')"
    ]
  },
  {
    "q": "What does `df.eval('A + B')` do?",
    "c": null,
    "o": [
      "Evaluates the expression on columns A and B",
      "Creates a new DataFrame with A and B",
      "Converts strings to numbers",
      "Deletes columns A and B"
    ]
  },
  {
    "q": "Which method quickly shows missing values per column?",
    "c": null,
    "o": [
      "df.isna().sum()",
      "df.dropna()",
      "df.fillna(0)",
      "df.null_count()"
    ]
  },
  {
    "q": "Which function converts a string column to datetime in Pandas?",
    "c": null,
    "o": [
      "pd.to_datetime(df['col'])",
      "df.astype(datetime)",
      "pd.date(df['col'])",
      "df.convert('datetime')"
    ]
  },
  {
    "q": "What does `df['col'].str.contains('abc')` return?",
    "c": null,
    "o": [
      "A boolean Series where values contain 'abc'",
      "The count of 'abc' in each row",
      "Only the first match of 'abc'",
      "The full string if 'abc' is present"
    ]
  },
  {
    "q": "Which Pandas method reshapes DataFrame from wide to long format?",
    "c": null,
    "o": [
      "melt()",
      "pivot()",
      "groupby()",
      "stack()"
    ]
  },
  {
    "q": "What is the output of `df.describe(include='object')`?",
    "c": null,
    "o": [
      "Descriptive stats of string columns",
      "Summary for numeric columns",
      "Unique values only",
      "Full DataFrame stats"
    ]
  },
  {
    "q": "Which method efficiently reads only a few rows from a CSV file?",
    "c": null,
    "o": [
      "pd.read_csv('file.csv', nrows=10)",
      "pd.head_csv('file.csv')",
      "pd.read_csv('file.csv', head=10)",
      "pd.read('file.csv', top=10)"
    ]
  },
  {
    "q": "What is `df.pivot_table(values='A', index='B', aggfunc='sum')` used for?",
    "c": null,
    "o": [
      "Summing 'A' grouped by 'B'",
      "Creating a stacked layout",
      "Merging columns A and B",
      "Filtering rows"
    ]
  },
  {
    "q": "Which argument allows `groupby` to return a DataFrame instead of Series?",
    "c": null,
    "o": [
      "as_index=False",
      "return_frame=True",
      "df_output=True",
      "keepdims=True"
    ]
  },
  {
    "q": "What does `df.duplicated()` return?",
    "c": null,
    "o": [
      "Boolean Series marking duplicate rows",
      "Rows that are duplicates only",
      "The count of duplicates",
      "Drops duplicate rows"
    ]
  },
  {
    "q": "Which is the best way to concatenate multiple DataFrames row-wise?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], axis=0)",
      "df1.merge(df2)",
      "df1.join(df2)",
      "df1.append_rows(df2)"
    ]
  },
  {
    "q": "What is the use of `df.sample(frac=0.5)`?",
    "c": null,
    "o": [
      "Returns 50% random sample of rows",
      "Drops 50% of the rows",
      "Sorts 50% of data",
      "Returns half of the columns"
    ]
  },
  {
    "q": "Which method fills missing values using forward fill in Pandas?",
    "c": null,
    "o": [
      "df.fillna(method='ffill')",
      "df.fill_forward()",
      "df.replace_na(method='forward')",
      "df.ffillna()"
    ]
  },
  {
    "q": "What is the result of `df.index`?",
    "c": null,
    "o": [
      "Index object representing the row labels",
      "Column names of the DataFrame",
      "List of data types",
      "All unique values in the DataFrame"
    ]
  },
  {
    "q": "Which method resamples a time series to monthly frequency?",
    "c": null,
    "o": [
      "df.resample('M')",
      "df.group_by_month()",
      "df.asfreq('M')",
      "df.downsample('month')"
    ]
  },
  {
    "q": "What does `df.T` return?",
    "c": null,
    "o": [
      "The transposed DataFrame",
      "Time delta from index",
      "Top 5 rows",
      "Tuple of columns"
    ]
  },
  {
    "q": "How do you set multiple columns as index?",
    "c": null,
    "o": [
      "df.set_index(['col1', 'col2'])",
      "df.index(['col1', 'col2'])",
      "df.to_index('col1', 'col2')",
      "df.multiindex('col1', 'col2')"
    ]
  },
  {
    "q": "Which function checks if a DataFrame has any missing values?",
    "c": null,
    "o": [
      "df.isnull().values.any()",
      "df.hasnull()",
      "pd.check_missing(df)",
      "df.nan_exists()"
    ]
  },
  {
    "q": "What is the default axis for `df.mean()`?",
    "c": null,
    "o": [
      "axis=0 (column-wise)",
      "axis=1 (row-wise)",
      "axis=None",
      "No default; axis must be specified"
    ]
  },
  {
    "q": "Which method is used to convert timezone-aware datetime?",
    "c": null,
    "o": [
      "dt.tz_convert('UTC')",
      "dt.change_timezone('UTC')",
      "dt.set_timezone('UTC')",
      "dt.convert_tz('UTC')"
    ]
  },
  {
    "q": "What does `df.memory_usage()` return?",
    "c": null,
    "o": [
      "Memory usage of each column",
      "Number of rows and columns",
      "Cache status of DataFrame",
      "Total file size of data source"
    ]
  },
  {
    "q": "What is the result of `df.iloc[0:3, 1:4]`?",
    "c": null,
    "o": [
      "Rows 0 to 2 and columns 1 to 3",
      "Rows 1 to 4 and columns 0 to 3",
      "Rows 0 to 3 and all columns",
      "All rows and columns 1 to 4"
    ]
  },
  {
    "q": "Which method resets the index of a DataFrame?",
    "c": null,
    "o": [
      "df.reset_index()",
      "df.drop_index()",
      "df.clear_index()",
      "df.restart_index()"
    ]
  },
  {
    "q": "Which argument in `merge()` specifies a left join?",
    "c": null,
    "o": [
      "how='left'",
      "type='left'",
      "join='left'",
      "method='left'"
    ]
  },
  {
    "q": "What does `df['col'].astype('category')` do?",
    "c": null,
    "o": [
      "Converts the column to categorical type",
      "Converts the column to numeric",
      "Renames the column",
      "Filters only unique values"
    ]
  },
  {
    "q": "Which method returns the rolling mean of a series?",
    "c": null,
    "o": [
      "series.rolling(window=3).mean()",
      "series.roll_mean(3)",
      "series.window(3).mean()",
      "series.sliding(3).avg()"
    ]
  },
  {
    "q": "What is the purpose of `inplace=True` in many pandas methods?",
    "c": null,
    "o": [
      "Modifies the DataFrame without creating a copy",
      "Runs in the background",
      "Uses less memory",
      "Improves execution speed"
    ]
  },
  {
    "q": "Which method changes column names using a dictionary?",
    "c": null,
    "o": [
      "df.rename(columns={'old': 'new'})",
      "df.change_names({'old': 'new'})",
      "df.replace_cols({'old': 'new'})",
      "df.columns.rename({'old': 'new'})"
    ]
  },
  {
    "q": "How do you get unique values from a column?",
    "c": null,
    "o": [
      "df['col'].unique()",
      "df['col'].values_only()",
      "df['col'].distinct()",
      "df['col'].drop_duplicates()"
    ]
  },
  {
    "q": "Which pandas object type supports labeled multidimensional data?",
    "c": null,
    "o": [
      "Panel (deprecated)",
      "TensorFrame",
      "LabelArray",
      "MultiBlock"
    ]
  },
  {
    "q": "What does `df.pipe(func)` do?",
    "c": null,
    "o": [
      "Applies a function to the DataFrame in method chains",
      "Filters rows based on a pipe condition",
      "Connects DataFrame to a pipeline object",
      "Redirects output to another DataFrame"
    ]
  },
  {
    "q": "Which method gets the first `n` rows of a DataFrame?",
    "c": null,
    "o": [
      "df.head(n)",
      "df.top(n)",
      "df.start(n)",
      "df.begin(n)"
    ]
  },
  {
    "q": "How do you convert a column to datetime in pandas?",
    "c": null,
    "o": [
      "pd.to_datetime(df['col'])",
      "df['col'].as_datetime()",
      "pd.convert_datetime(df['col'])",
      "df['col'].datetime()"
    ]
  },
  {
    "q": "Which method is used to set a column as the index?",
    "c": null,
    "o": [
      "df.set_index('col')",
      "df.set_as_index('col')",
      "df.index('col')",
      "df.assign_index('col')"
    ]
  },
  {
    "q": "What does `df.resample('M')` typically return?",
    "c": null,
    "o": [
      "A monthly resampled time-series DataFrame",
      "A DataFrame grouped by month names",
      "A DataFrame filtered to the last month",
      "A MultiIndex grouped DataFrame"
    ]
  },
  {
    "q": "How can you filter rows between two dates?",
    "c": null,
    "o": [
      "df.loc['2023-01-01':'2023-02-01']",
      "df.between('2023-01-01','2023-02-01')",
      "df.filter('2023-01-01' to '2023-02-01')",
      "df.daterange('2023-01-01','2023-02-01')"
    ]
  },
  {
    "q": "Which function helps combine multiple columns into a single MultiIndex?",
    "c": null,
    "o": [
      "pd.MultiIndex.from_frame(df[['A', 'B']])",
      "pd.Index.merge(df[['A', 'B']])",
      "df.set_columns_multiindex(['A', 'B'])",
      "df.combine_index(['A', 'B'])"
    ]
  },
  {
    "q": "How do you rename all column names to lowercase?",
    "c": null,
    "o": [
      "df.columns = df.columns.str.lower()",
      "df.lower(columns=True)",
      "df.rename_all(lower=True)",
      "df.colnames(lowercase=True)"
    ]
  },
  {
    "q": "Which pandas function can be used to concatenate DataFrames?",
    "c": null,
    "o": [
      "pd.concat([df1, df2])",
      "pd.stack([df1, df2])",
      "df1 + df2",
      "df1.extend(df2)"
    ]
  },
  {
    "q": "What does `df.groupby('col')['val'].agg(['mean', 'sum'])` return?",
    "c": null,
    "o": [
      "A DataFrame with mean and sum for each group in 'col'",
      "Only the mean of each group",
      "A single value per group",
      "A list of aggregated values"
    ]
  },
  {
    "q": "Which method can fill missing values using a previous value?",
    "c": null,
    "o": [
      "df.fillna(method='ffill')",
      "df.fill(method='previous')",
      "df.forward_fill()",
      "df.fillmissing('forward')"
    ]
  },
  {
    "q": "How do you drop duplicate rows from a DataFrame?",
    "c": null,
    "o": [
      "df.drop_duplicates()",
      "df.remove_duplicates()",
      "df.clear_dupes()",
      "df.unique_rows()"
    ]
  },
  {
    "q": "Which method merges two DataFrames based on a common column?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, on='key')",
      "df1.join(df2)",
      "pd.concat([df1, df2], axis=1)",
      "df1.combine(df2, on='key')"
    ]
  },
  {
    "q": "Which pandas function pivots long-format data to wide format?",
    "c": null,
    "o": [
      "df.pivot(index='A', columns='B', values='C')",
      "df.stack()",
      "df.melt()",
      "df.unstack()"
    ]
  },
  {
    "q": "What does `df.rolling(3).mean()` compute?",
    "c": null,
    "o": [
      "3-period rolling mean",
      "3-period exponential mean",
      "Window of 3 maximum values",
      "Cumulative mean up to 3"
    ]
  },
  {
    "q": "Which operation reshapes a DataFrame to a long format?",
    "c": null,
    "o": [
      "pd.melt(df)",
      "df.unstack()",
      "df.stack()",
      "df.flatten()"
    ]
  },
  {
    "q": "Which method resets the index of a DataFrame?",
    "c": null,
    "o": [
      "df.reset_index()",
      "df.index_reset()",
      "df.reindex()",
      "df.clear_index()"
    ]
  },
  {
    "q": "What is the purpose of `dropna(subset=['A'])`?",
    "c": null,
    "o": [
      "Drop rows where column A is NaN",
      "Drop column A",
      "Drop rows where all columns are NaN",
      "Drop duplicate rows with A values"
    ]
  },
  {
    "q": "Which parameter is used to specify join type in `merge()`?",
    "c": null,
    "o": [
      "how='inner'",
      "type='inner'",
      "merge='left'",
      "kind='outer'"
    ]
  },
  {
    "q": "How can you shift values down by one row?",
    "c": null,
    "o": [
      "df.shift(1)",
      "df.move(1)",
      "df.roll(1)",
      "df.delay(1)"
    ]
  },
  {
    "q": "Which method can be used to rank values within each group?",
    "c": null,
    "o": [
      "df.groupby('group')['val'].rank()",
      "df.group('group').value_rank()",
      "df.rank(by='val', group='group')",
      "df.groupby('group').score()"
    ]
  },
  {
    "q": "How do you select rows where a column contains a specific string?",
    "c": null,
    "o": [
      "df[df['col'].str.contains('abc')]",
      "df['col'].find('abc')",
      "df['col'].match('abc')",
      "df.select('col' == 'abc')"
    ]
  },
  {
    "q": "Which method converts a column to datetime?",
    "c": null,
    "o": [
      "pd.to_datetime(df['col'])",
      "df['col'].astype('datetime')",
      "df['col'].to_time()",
      "df['col'].datetime()"
    ]
  },
  {
    "q": "What does `df['date'].dt.year` return?",
    "c": null,
    "o": [
      "The year from each datetime",
      "The full datetime",
      "The month only",
      "It throws an error"
    ]
  },
  {
    "q": "Which format is used by default in `df.to_csv()`?",
    "c": null,
    "o": [
      "Comma-separated",
      "Tab-separated",
      "JSON format",
      "Excel format"
    ]
  },
  {
    "q": "What does `df.memory_usage(deep=True)` show?",
    "c": null,
    "o": [
      "Accurate memory usage including object dtype",
      "Only the float columns' memory usage",
      "Does not include object type memory",
      "Disk usage of the file"
    ]
  },
  {
    "q": "Which method reads an Excel file?",
    "c": null,
    "o": [
      "pd.read_excel('file.xlsx')",
      "pd.read_csv('file.xlsx')",
      "pd.read_file('file.xlsx')",
      "pd.load_excel('file.xlsx')"
    ]
  },
  {
    "q": "How do you categorize a column to save memory?",
    "c": null,
    "o": [
      "df['col'] = df['col'].astype('category')",
      "df['col'] = df['col'].astype('object')",
      "df['col'] = df['col'].categorize()",
      "df['col'].as_category()"
    ]
  },
  {
    "q": "What is `df.asfreq('M')` used for?",
    "c": null,
    "o": [
      "Convert to monthly frequency",
      "Aggregate monthly",
      "Convert to minutes",
      "Resample to days"
    ]
  },
  {
    "q": "Which parameter in `read_csv` can parse dates?",
    "c": null,
    "o": [
      "parse_dates=True",
      "datetime=True",
      "date_parse=True",
      "parse_time=True"
    ]
  },
  {
    "q": "Which function compresses a DataFrame before saving?",
    "c": null,
    "o": [
      "df.to_csv('data.csv.gz', compression='gzip')",
      "df.compress('gzip')",
      "df.to_gzip('data.csv')",
      "df.save('data.csv', compress=True)"
    ]
  },
  {
    "q": "How to combine multiple CSVs into one DataFrame?",
    "c": null,
    "o": [
      "pd.concat([pd.read_csv(f) for f in files])",
      "pd.append_csv(files)",
      "df.merge_csv(files)",
      "pd.combine_csvs(files)"
    ]
  },
  {
    "q": "What does `df.dropna(how='all')` do?",
    "c": null,
    "o": [
      "Removes rows where all values are NaN",
      "Removes columns where any value is NaN",
      "Fills all NaNs with zero",
      "Removes rows with any NaN"
    ]
  },
  {
    "q": "How to apply a custom function to each row?",
    "c": null,
    "o": [
      "df.apply(func, axis=1)",
      "df.map(func)",
      "df.applymap(func)",
      "df.func(axis=1)"
    ]
  },
  {
    "q": "Which of the following provides the fastest lookup on a large dataset?",
    "c": null,
    "o": [
      "Setting an index and using `.loc[]`",
      "Using `.iloc[]`",
      "Using a for loop",
      "Using `.ix[]`"
    ]
  },
  {
    "q": "What does `df.pivot(index='A', columns='B', values='C')` do?",
    "c": null,
    "o": [
      "Reshapes DataFrame with unique B values as columns",
      "Merges columns A and B",
      "Flattens multi-index",
      "Groups by A and B"
    ]
  },
  {
    "q": "How to create a rolling average of a column?",
    "c": null,
    "o": [
      "df['col'].rolling(window=3).mean()",
      "df['col'].average(3)",
      "df['col'].groupby(3).mean()",
      "df['col'].resample(3).mean()"
    ]
  },
  {
    "q": "Which parameter in `groupby()` returns all groups including NaN?",
    "c": null,
    "o": [
      "dropna=False",
      "include_nan=True",
      "show_na=True",
      "keepna=True"
    ]
  },
  {
    "q": "How to perform element-wise multiplication of two DataFrames with the same index and columns?",
    "c": null,
    "o": [
      "df1 * df2",
      "df1.dot(df2)",
      "df1 + df2",
      "df1.multiply(df2, axis=1)"
    ]
  },
  {
    "q": "What is the purpose of `df.select_dtypes(include=['number'])`?",
    "c": null,
    "o": [
      "Select numeric columns",
      "Convert all columns to numeric",
      "Drop numeric columns",
      "Filter rows with numeric values"
    ]
  },
  {
    "q": "What does `df.resample('D').sum()` require?",
    "c": null,
    "o": [
      "Datetime index",
      "Integer index",
      "Categorical column",
      "String column"
    ]
  },
  {
    "q": "What is the result of `df.stack().unstack()`?",
    "c": null,
    "o": [
      "Returns the original DataFrame (mostly)",
      "Flattens the DataFrame permanently",
      "Returns a Series",
      "Reverses the index and column"
    ]
  },
  {
    "q": "What is the purpose of `pd.date_range(start='2020-01-01', periods=5, freq='D')`?",
    "c": null,
    "o": [
      "Generates a DatetimeIndex with daily frequency",
      "Creates a calendar with 5 working days",
      "Generates time deltas",
      "Creates a list of month start dates"
    ]
  },
  {
    "q": "Which method converts a column to datetime?",
    "c": null,
    "o": [
      "pd.to_datetime(df['col'])",
      "df['col'].astype('datetime')",
      "datetime.parse(df['col'])",
      "df['col'].to_datetime()"
    ]
  },
  {
    "q": "In a MultiIndex DataFrame, what does `df.loc[('A', 2020)]` do?",
    "c": null,
    "o": [
      "Accesses rows with index level 0 = 'A' and level 1 = 2020",
      "Selects column A and row 2020",
      "Filters only rows from 2020",
      "Returns a Series with a single value"
    ]
  },
  {
    "q": "How do you convert a Series of strings to NumPy array?",
    "c": null,
    "o": [
      "df['col'].to_numpy()",
      "np.array(df)",
      "df.as_numpy()",
      "pd.to_numpy(df)"
    ]
  },
  {
    "q": "Which frequency string represents 'hourly' in time series?",
    "c": null,
    "o": [
      "'H'",
      "'h'",
      "'hr'",
      "'hour'"
    ]
  },
  {
    "q": "How to change the frequency of a datetime-indexed DataFrame to monthly?",
    "c": null,
    "o": [
      "df.resample('M')",
      "df.groupby('M')",
      "df.to_period('M')",
      "df.pivot('M')"
    ]
  },
  {
    "q": "What does `df.shift(1)` do in time series?",
    "c": null,
    "o": [
      "Shifts all rows down by 1 (introduces NaN at the top)",
      "Shifts columns right",
      "Sorts DataFrame",
      "Shifts all rows up"
    ]
  },
  {
    "q": "How to set a MultiIndex from two existing columns?",
    "c": null,
    "o": [
      "df.set_index(['col1', 'col2'])",
      "df.multi_index(['col1', 'col2'])",
      "df.index(['col1', 'col2'])",
      "df.create_index(['col1', 'col2'])"
    ]
  },
  {
    "q": "How to remove time component from a datetime column?",
    "c": null,
    "o": [
      "df['col'].dt.date",
      "df['col'].astype('date')",
      "df['col'].remove_time()",
      "df['col'].strftime('%d-%m-%Y')"
    ]
  },
  {
    "q": "What does `np.where(df['A'] > 10, 'High', 'Low')` return?",
    "c": null,
    "o": [
      "An array of 'High' or 'Low' based on condition",
      "Indexes of where A > 10",
      "A filtered DataFrame",
      "Boolean mask"
    ]
  },
  {
    "q": "What does `pd.merge(df1, df2, on='id', how='inner')` do?",
    "c": null,
    "o": [
      "Merges rows with matching 'id' in both DataFrames",
      "Joins all rows from df1 and df2",
      "Appends df2 to df1",
      "Filters rows where id is null"
    ]
  },
  {
    "q": "Which method is used to join DataFrames on their index?",
    "c": null,
    "o": [
      "df1.join(df2)",
      "df1.append(df2)",
      "df1.merge(df2)",
      "df1.concat(df2)"
    ]
  },
  {
    "q": "What does `df.rolling(window=3).mean()` calculate?",
    "c": null,
    "o": [
      "Moving average over a window of 3",
      "Mean of every third row",
      "Overall mean multiplied by 3",
      "Rolling sum of 3 values"
    ]
  },
  {
    "q": "How to concatenate DataFrames vertically?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], axis=0)",
      "pd.concat([df1, df2], axis=1)",
      "df1.merge(df2)",
      "df1.join(df2)"
    ]
  },
  {
    "q": "Which method is used to find duplicate rows?",
    "c": null,
    "o": [
      "df.duplicated()",
      "df.find_duplicates()",
      "df.check_duplicates()",
      "df.has_duplicates()"
    ]
  },
  {
    "q": "How to remove all rows with any missing values?",
    "c": null,
    "o": [
      "df.dropna()",
      "df.fillna()",
      "df.clean()",
      "df.remove_nulls()"
    ]
  },
  {
    "q": "What does `df.fillna(method='ffill')` do?",
    "c": null,
    "o": [
      "Fills missing values forward using previous value",
      "Fills missing values with zero",
      "Drops rows with NaN",
      "Fills values using mean"
    ]
  },
  {
    "q": "Which of the following performs a left join?",
    "c": null,
    "o": [
      "pd.merge(df1, df2, how='left')",
      "df1.join(df2, how='left')",
      "pd.merge(df1, df2, left=True)",
      "df1.concat(df2, join='left')"
    ]
  },
  {
    "q": "How to calculate expanding sum in a column?",
    "c": null,
    "o": [
      "df['col'].expanding().sum()",
      "df['col'].cumsum()",
      "df['col'].rolling().sum()",
      "df['col'].sum(expanding=True)"
    ]
  },
  {
    "q": "What does `df['col'].replace(-1, np.nan)` do?",
    "c": null,
    "o": [
      "Replaces -1 with NaN in the column",
      "Drops all -1 values",
      "Changes NaN to -1",
      "Removes the column"
    ]
  },
  {
    "q": "What does `df.groupby('category').sum()` do?",
    "c": null,
    "o": [
      "Groups rows by 'category' and sums numeric columns",
      "Sorts the DataFrame by 'category'",
      "Calculates overall sum of 'category'",
      "Creates a pie chart of the category column"
    ]
  },
  {
    "q": "Which of the following computes the mean after grouping?",
    "c": null,
    "o": [
      "df.groupby('group_col').mean()",
      "df.mean(groupby='group_col')",
      "df.group_by('group_col').average()",
      "groupby(df['group_col']).avg()"
    ]
  },
  {
    "q": "What does `df['col'].value_counts()` return?",
    "c": null,
    "o": [
      "Counts frequency of unique values in 'col'",
      "Counts missing values",
      "Returns the sum of 'col'",
      "Filters duplicates from 'col'"
    ]
  },
  {
    "q": "Which Pandas function is used for basic plotting?",
    "c": null,
    "o": [
      "df.plot()",
      "df.graph()",
      "df.draw()",
      "df.chart()"
    ]
  },
  {
    "q": "What does `df['col'].astype('int')` do?",
    "c": null,
    "o": [
      "Converts column to integer type",
      "Adds an integer column",
      "Casts dataframe to int",
      "Drops NaN from 'col'"
    ]
  },
  {
    "q": "What does `df.memory_usage()` return?",
    "c": null,
    "o": [
      "Memory used by each column",
      "Disk usage",
      "CPU usage statistics",
      "RAM available on the machine"
    ]
  },
  {
    "q": "How can you apply multiple aggregation functions on a groupby object?",
    "c": null,
    "o": [
      "df.groupby('group_col').agg(['mean', 'max'])",
      "df.group('group_col', ['mean', 'max'])",
      "df.aggregate(group_col=['mean', 'max'])",
      "df.groupby('group_col').aggregate(['groupby', 'value'])"
    ]
  },
  {
    "q": "Which is the most memory-efficient dtype for integers?",
    "c": null,
    "o": [
      "int8",
      "int64",
      "int32",
      "float64"
    ]
  },
  {
    "q": "Which of the following is true about `df.describe()`?",
    "c": null,
    "o": [
      "Provides summary stats like count, mean, std, etc.",
      "Describes column data types",
      "Shows column names only",
      "Plots all data in a graph"
    ]
  },
  {
    "q": "Which parameter helps speed up `read_csv()` for large files?",
    "c": null,
    "o": [
      "usecols",
      "slow_mode",
      "plot=True",
      "expand=True"
    ]
  },
  {
    "q": "What does `pd.to_datetime(df['date'])` do?",
    "c": null,
    "o": [
      "Converts the 'date' column to datetime format",
      "Deletes rows with non-date values",
      "Extracts year from 'date'",
      "Creates a new column with current timestamp"
    ]
  },
  {
    "q": "Which function is used to set a datetime column as the index?",
    "c": null,
    "o": [
      "df.set_index('date')",
      "df.index('date')",
      "df.as_index('date')",
      "df.date_index()"
    ]
  },
  {
    "q": "What does `df.resample('M').mean()` do?",
    "c": null,
    "o": [
      "Resamples time series data to monthly frequency and computes the mean",
      "Reshapes the DataFrame to 1 month per row",
      "Filters data to only monthly dates",
      "Resets index and averages the rows"
    ]
  },
  {
    "q": "Which method creates a rolling window calculation?",
    "c": null,
    "o": [
      "df.rolling(window=3).mean()",
      "df.slide(3).average()",
      "df.aggregate(3)",
      "df.mean(window=3)"
    ]
  },
  {
    "q": "What is the purpose of `shift(1)` in time series?",
    "c": null,
    "o": [
      "Shifts data down by 1 row (e.g., to access previous day's value)",
      "Moves rows to the left",
      "Drops the first row",
      "Adds 1 to every value"
    ]
  },
  {
    "q": "Which is a common real-world use of `groupby` with `resample`?",
    "c": null,
    "o": [
      "Summarizing sales by store per month",
      "Sorting rows alphabetically",
      "Comparing two strings",
      "Applying colors to charts"
    ]
  },
  {
    "q": "How do you extract the year from a datetime column?",
    "c": null,
    "o": [
      "df['date'].dt.year",
      "df['date'].extract('year')",
      "df['date'].split('-')[0]",
      "df.date.year()"
    ]
  },
  {
    "q": "Which method is used to interpolate missing time series data?",
    "c": null,
    "o": [
      "df.interpolate()",
      "df.fill_nan()",
      "df.smooth()",
      "df.repair()"
    ]
  },
  {
    "q": "What is the use of `query()` in pandas?",
    "c": null,
    "o": [
      "Filter rows using a string condition",
      "Execute SQL commands",
      "Select random rows",
      "Join multiple DataFrames"
    ]
  },
  {
    "q": "Which of the following makes your Pandas code faster?",
    "c": null,
    "o": [
      "Using `loc` and `query()` over loops",
      "Iterating with `for` loops on rows",
      "Appending rows one by one",
      "Reading the entire file on each operation"
    ]
  },
  {
    "q": "What does `pd.merge(df1, df2, on='id')` do?",
    "c": null,
    "o": [
      "Joins df1 and df2 on the 'id' column",
      "Deletes the 'id' column",
      "Creates a pivot table from df1",
      "Appends df2 to df1"
    ]
  },
  {
    "q": "Which type of join returns only matching rows from both DataFrames?",
    "c": null,
    "o": [
      "Inner join",
      "Left join",
      "Right join",
      "Outer join"
    ]
  },
  {
    "q": "Which argument is used to specify join type in `merge()`?",
    "c": null,
    "o": [
      "how",
      "method",
      "join_type",
      "style"
    ]
  },
  {
    "q": "What does `df['col'].astype('category')` do?",
    "c": null,
    "o": [
      "Converts a column to categorical type",
      "Categorizes DataFrame into groups",
      "Applies clustering",
      "Splits the column into categories"
    ]
  },
  {
    "q": "What is a key benefit of categorical data in pandas?",
    "c": null,
    "o": [
      "Reduced memory usage",
      "Higher color quality",
      "Better random access",
      "Faster merging"
    ]
  },
  {
    "q": "What does `df.pivot(index='A', columns='B', values='C')` do?",
    "c": null,
    "o": [
      "Creates a pivot table with A as index, B as columns, and C as values",
      "Sorts DataFrame by columns B and C",
      "Joins DataFrame A and B",
      "Splits values of C into rows"
    ]
  },
  {
    "q": "How do you convert a pivot table back into a flat table?",
    "c": null,
    "o": [
      "df.reset_index()",
      "df.flatten()",
      "df.merge()",
      "df.transpose()"
    ]
  },
  {
    "q": "Which of the following is used to concatenate DataFrames vertically?",
    "c": null,
    "o": [
      "pd.concat([df1, df2], axis=0)",
      "pd.append(df1, df2, axis=1)",
      "pd.merge(df1, df2, axis=0)",
      "pd.stack(df1, df2)"
    ]
  },
  {
    "q": "Which method is commonly used to remove duplicate rows?",
    "c": null,
    "o": [
      "df.drop_duplicates()",
      "df.unique()",
      "df.remove_duplicated()",
      "df.clear_duplicates()"
    ]
  },
  {
    "q": "How do you filter rows where column 'status' is either 'active' or 'pending'?",
    "c": null,
    "o": [
      "df[df['status'].isin(['active', 'pending'])]",
      "df[df['status'] == 'active' or 'pending']",
      "df.where(status in ['active', 'pending'])",
      "df.filter(status=['active', 'pending'])"
    ]
  },
  {
    "q": "What does `df.groupby('category').sum()` do?",
    "c": null,
    "o": [
      "Groups rows by 'category' and sums numeric columns",
      "Sorts the DataFrame by 'category'",
      "Splits the DataFrame into multiple files",
      "Adds a new column named 'sum'"
    ]
  },
  {
    "q": "Which method reads a CSV file into a pandas DataFrame?",
    "c": null,
    "o": [
      "pd.read_csv()",
      "pd.load_csv()",
      "pd.import_csv()",
      "pd.read_table()"
    ]
  },
  {
    "q": "How do you export a DataFrame to an Excel file?",
    "c": null,
    "o": [
      "df.to_excel('file.xlsx')",
      "df.write_excel('file.xlsx')",
      "df.export('file.xlsx')",
      "df.to_file('file.xlsx')"
    ]
  },
  {
    "q": "Which parameter in `read_csv()` is used to handle missing values?",
    "c": null,
    "o": [
      "na_values",
      "missing_data",
      "null_handler",
      "empty_fill"
    ]
  },
  {
    "q": "What does `df.dropna()` do?",
    "c": null,
    "o": [
      "Removes rows with missing values",
      "Replaces NaNs with 0",
      "Fills NaNs with the previous value",
      "Deletes the DataFrame"
    ]
  },
  {
    "q": "Which method fills missing values with a specified value?",
    "c": null,
    "o": [
      "df.fillna(value)",
      "df.replace_na(value)",
      "df.na_fill(value)",
      "df.fill(value)"
    ]
  },
  {
    "q": "How can you see the number of missing values per column?",
    "c": null,
    "o": [
      "df.isnull().sum()",
      "df.hasna().count()",
      "df.null_count()",
      "df.countna()"
    ]
  },
  {
    "q": "What does `df.groupby(['A', 'B']).mean()` return?",
    "c": null,
    "o": [
      "Mean of numeric columns grouped by both A and B",
      "Grouped strings from A and B",
      "Standard deviation of A and B",
      "Sorted values of A and B"
    ]
  },
  {
    "q": "Which function is used to reset index after groupby operations?",
    "c": null,
    "o": [
      "reset_index()",
      "flatten_index()",
      "clear_index()",
      "restore_index()"
    ]
  },
  {
    "q": "What does `df.replace({'A': {'X': 'Y'}})` do?",
    "c": null,
    "o": [
      "Replaces 'X' with 'Y' in column A",
      "Renames column A to Y",
      "Deletes values equal to 'X'",
      "Adds 'Y' as a new row"
    ]
  },
  {
    "q": "Which function converts a column to datetime format?",
    "c": null,
    "o": [
      "pd.to_datetime()",
      "df.convert_datetime()",
      "df.to_date()",
      "pd.date_format()"
    ]
  },
  {
    "q": "How do you extract the year from a datetime column 'date'?",
    "c": null,
    "o": [
      "df['date'].dt.year",
      "df['date'].year",
      "df.year('date')",
      "df.date.year()"
    ]
  },
  {
    "q": "What does `df.set_index(['A', 'B'])` do?",
    "c": null,
    "o": [
      "Creates a multi-index using columns A and B",
      "Sorts the DataFrame by A and B",
      "Adds A and B as new columns",
      "Removes columns A and B"
    ]
  },
  {
    "q": "Which method removes one level from a multi-index?",
    "c": null,
    "o": [
      "reset_index(level=1)",
      "drop_index(level=1)",
      "collapse_index(1)",
      "flatten_index(1)"
    ]
  },
  {
    "q": "What does `df.index.get_level_values(0)` return in a multi-index?",
    "c": null,
    "o": [
      "Values of the first index level",
      "The column names",
      "The number of levels",
      "The last index value"
    ]
  },
  {
    "q": "What does `df.plot()` do?",
    "c": null,
    "o": [
      "Creates a line plot of the DataFrame",
      "Exports a plot to HTML",
      "Displays histogram by default",
      "Returns a plot object without rendering"
    ]
  },
  {
    "q": "Which library is used along with pandas to create plots?",
    "c": null,
    "o": [
      "matplotlib",
      "seaborn",
      "plotly",
      "tkinter"
    ]
  },
  {
    "q": "How to plot a histogram for column 'age' in pandas?",
    "c": null,
    "o": [
      "df['age'].plot(kind='hist')",
      "df.plot.histogram('age')",
      "df.histplot('age')",
      "df.plot.bar('age')"
    ]
  },
  {
    "q": "Which method helps in creating time series data?",
    "c": null,
    "o": [
      "pd.date_range()",
      "pd.timestamp()",
      "pd.time_series()",
      "pd.datetime_range()"
    ]
  },
  {
    "q": "What is the purpose of `asfreq('M')` on a datetime index?",
    "c": null,
    "o": [
      "Converts frequency to monthly",
      "Assigns monthly labels",
      "Adds month column",
      "Changes time zone to M"
    ]
  },
  {
    "q": "Which method reshapes a DataFrame from long to wide format?",
    "c": null,
    "o": [
      "pivot()",
      "melt()",
      "stack()",
      "unstack()"
    ]
  },
  {
    "q": "Which method reshapes a DataFrame from wide to long format?",
    "c": null,
    "o": [
      "melt()",
      "pivot()",
      "spread()",
      "cast()"
    ]
  },
  {
    "q": "What do you need to specify when using `pivot()`?",
    "c": null,
    "o": [
      "index, columns, values",
      "key, value",
      "group, aggregate",
      "labels, shape"
    ]
  },
  {
    "q": "Which pandas function is used to merge two DataFrames?",
    "c": null,
    "o": [
      "merge()",
      "join()",
      "append()",
      "combine()"
    ]
  },
  {
    "q": "What does `pd.concat()` do?",
    "c": null,
    "o": [
      "Concatenates DataFrames along a particular axis",
      "Merges DataFrames by keys",
      "Performs SQL-like joins",
      "Removes duplicates"
    ]
  },
  {
    "q": "Which of these is NOT a valid 'how' parameter for `merge()`?",
    "c": null,
    "o": [
      "around",
      "inner",
      "outer",
      "left"
    ]
  },
  {
    "q": "What is the purpose of using `inplace=True`?",
    "c": null,
    "o": [
      "Modify the original DataFrame without returning a new one",
      "Create a deep copy of the DataFrame",
      "Display the DataFrame in-place",
      "Keep original DataFrame safe"
    ]
  },
  {
    "q": "What does `df.memory_usage()` return?",
    "c": null,
    "o": [
      "Memory usage of each column",
      "DataFrame shape",
      "Column data types",
      "CPU time used"
    ]
  },
  {
    "q": "What type of join is performed by default using `merge()`?",
    "c": null,
    "o": [
      "inner",
      "outer",
      "left",
      "right"
    ]
  },
  {
    "q": "Which option speeds up performance by changing column data types?",
    "c": null,
    "o": [
      "Downcasting",
      "Pivoting",
      "Exploding",
      "Inflating"
    ]
  },
  {
    "q": "Which function is used to group data in a DataFrame?",
    "c": null,
    "o": [
      "groupby()",
      "aggregate()",
      "split()",
      "transform()"
    ]
  },
  {
    "q": "What does the `groupby()` method return?",
    "c": null,
    "o": [
      "GroupBy object",
      "DataFrame",
      "Series",
      "List"
    ]
  },
  {
    "q": "Which method is used to apply multiple aggregation functions on groups?",
    "c": null,
    "o": [
      "agg()",
      "group()",
      "mean()",
      "all()"
    ]
  },
  {
    "q": "What does the `transform()` method do in a groupby context?",
    "c": null,
    "o": [
      "Returns a DataFrame with the same shape as the original",
      "Removes null values",
      "Changes data types",
      "Filters groups based on condition"
    ]
  },
  {
    "q": "Which aggregation is used to count non-NA values in each group?",
    "c": null,
    "o": [
      "count()",
      "size()",
      "sum()",
      "nunique()"
    ]
  },
  {
    "q": "Which method returns the number of total rows in each group including NA?",
    "c": null,
    "o": [
      "size()",
      "count()",
      "total()",
      "shape()"
    ]
  },
  {
    "q": "Which of the following functions can you use with groupby to compute mean per group?",
    "c": null,
    "o": [
      "mean()",
      "avg()",
      "average()",
      "mid()"
    ]
  },
  {
    "q": "What does `groupby(...).first()` return?",
    "c": null,
    "o": [
      "First non-null row in each group",
      "First value overall",
      "Sorted values",
      "Index only"
    ]
  },
  {
    "q": "What does `groupby(...).nunique()` do?",
    "c": null,
    "o": [
      "Counts unique values in each group",
      "Returns all unique values",
      "Sorts the values",
      "Counts nulls"
    ]
  },
  {
    "q": "Which of these is true about `groupby().apply()`?",
    "c": null,
    "o": [
      "Can apply a custom function to each group",
      "Only works with strings",
      "Does not return a DataFrame",
      "Used for plotting"
    ]
  },
  {
    "q": "Which method removes missing values from a DataFrame?",
    "c": null,
    "o": [
      "dropna()",
      "fillna()",
      "replace()",
      "isnull()"
    ]
  },
  {
    "q": "What does the `fillna(0)` method do?",
    "c": null,
    "o": [
      "Replaces all missing values with 0",
      "Removes all zeros",
      "Replaces 0 with NaN",
      "Fills empty strings"
    ]
  },
  {
    "q": "Which function can you use to detect missing values in Pandas?",
    "c": null,
    "o": [
      "isnull()",
      "notnull()",
      "isna()",
      "All of the above"
    ]
  },
  {
    "q": "Which method replaces values in a DataFrame?",
    "c": null,
    "o": [
      "replace()",
      "fillna()",
      "drop()",
      "remove()"
    ]
  },
  {
    "q": "How do you rename columns in a DataFrame?",
    "c": null,
    "o": [
      "df.rename(columns={...})",
      "df.columns.update(...)",
      "df.modify_cols(...)",
      "df.change_names(...)"
    ]
  },
  {
    "q": "What does `drop_duplicates()` do?",
    "c": null,
    "o": [
      "Removes duplicate rows",
      "Removes duplicate columns",
      "Drops NaNs",
      "Drops column names"
    ]
  },
  {
    "q": "Which method resets the index of a DataFrame?",
    "c": null,
    "o": [
      "reset_index()",
      "reindex()",
      "set_index(None)",
      "drop_index()"
    ]
  },
  {
    "q": "How can you change the data type of a column?",
    "c": null,
    "o": [
      "astype()",
      "convert()",
      "change_type()",
      "modify_type()"
    ]
  },
  {
    "q": "Which function identifies duplicated rows?",
    "c": null,
    "o": [
      "duplicated()",
      "drop_duplicates()",
      "is_duplicate()",
      "find_duplicates()"
    ]
  },
  {
    "q": "Which method is used to filter rows based on a condition?",
    "c": null,
    "o": [
      "query()",
      "filter()",
      "select()",
      "mask()"
    ]
  },
  {
    "q": "Which method is used to group rows in a DataFrame based on column values?",
    "c": null,
    "o": [
      "groupby()",
      "aggregate()",
      "sort_values()",
      "combine()"
    ]
  },
  {
    "q": "Which method computes summary statistics like mean, sum, etc., on groups?",
    "c": null,
    "o": [
      "agg()",
      "apply()",
      "transform()",
      "filter()"
    ]
  },
  {
    "q": "What does `df.sort_values(by='col1')` do?",
    "c": null,
    "o": [
      "Sorts the DataFrame by column 'col1'",
      "Deletes the column 'col1'",
      "Groups by 'col1'",
      "Adds a new sorted column"
    ]
  },
  {
    "q": "Which method sets a column as the index of a DataFrame?",
    "c": null,
    "o": [
      "set_index()",
      "index()",
      "assign_index()",
      "make_index()"
    ]
  },
  {
    "q": "What does `df.loc[0]` return?",
    "c": null,
    "o": [
      "The row with label 0",
      "The first column",
      "The column named '0'",
      "Nothing, it throws an error"
    ]
  },
  {
    "q": "How to access data using a specific integer position?",
    "c": null,
    "o": [
      "iloc[]",
      "loc[]",
      "at[]",
      "ix[]"
    ]
  },
  {
    "q": "Which of the following is used to calculate cumulative sum?",
    "c": null,
    "o": [
      "cumsum()",
      "sum()",
      "cumprod()",
      "total()"
    ]
  },
  {
    "q": "Which method helps apply a custom function to groups?",
    "c": null,
    "o": [
      "apply()",
      "agg()",
      "sum()",
      "map()"
    ]
  },
  {
    "q": "Which method changes the order of rows randomly?",
    "c": null,
    "o": [
      "sample()",
      "shuffle()",
      "randomize()",
      "scramble()"
    ]
  },
  {
    "q": "What is the output of `df.index`?",
    "c": null,
    "o": [
      "The index labels of the DataFrame",
      "Column headers",
      "Only integer row numbers",
      "Data values of the first column"
    ]
  },
  {
    "q": "Which Pandas function is used to merge two DataFrames on a common column?",
    "c": null,
    "o": [
      "merge()",
      "join()",
      "combine()",
      "append()"
    ]
  },
  {
    "q": "Which argument in `merge()` specifies the type of join to perform?",
    "c": null,
    "o": [
      "how",
      "on",
      "type",
      "method"
    ]
  },
  {
    "q": "Which join type keeps only the rows that match in both DataFrames?",
    "c": null,
    "o": [
      "inner",
      "outer",
      "left",
      "right"
    ]
  },
  {
    "q": "Which join keeps all rows from the left DataFrame and matches from the right?",
    "c": null,
    "o": [
      "left",
      "right",
      "inner",
      "outer"
    ]
  },
  {
    "q": "What does the `concat()` function do?",
    "c": null,
    "o": [
      "Combines DataFrames along a particular axis",
      "Deletes columns",
      "Fills missing values",
      "Removes duplicates"
    ]
  },
  {
    "q": "Which function is used to reshape data based on column values?",
    "c": null,
    "o": [
      "pivot()",
      "stack()",
      "unstack()",
      "groupby()"
    ]
  },
  {
    "q": "What does `pivot_table()` do that `pivot()` does not?",
    "c": null,
    "o": [
      "Allows aggregation",
      "Returns Series",
      "Only works with numeric data",
      "Ignores index"
    ]
  },
  {
    "q": "What is the purpose of the `stack()` method?",
    "c": null,
    "o": [
      "Converts columns into rows",
      "Combines multiple DataFrames",
      "Removes duplicate rows",
      "Sorts the index"
    ]
  },
  {
    "q": "Which method is used to reset the index of a DataFrame?",
    "c": null,
    "o": [
      "reset_index()",
      "clear_index()",
      "drop_index()",
      "flatten_index()"
    ]
  },
  {
    "q": "Which method creates a MultiIndex from multiple columns?",
    "c": null,
    "o": [
      "set_index()",
      "merge_index()",
      "create_index()",
      "multi_index()"
    ]
  },
  {
    "q": "Which function is commonly used to read a CSV file into a Pandas DataFrame?",
    "c": null,
    "o": [
      "read_csv()",
      "load_csv()",
      "import_csv()",
      "open_csv()"
    ]
  },
  {
    "q": "Which function writes a DataFrame to a CSV file?",
    "c": null,
    "o": [
      "to_csv()",
      "save_csv()",
      "write_csv()",
      "export_csv()"
    ]
  },
  {
    "q": "What does `isnull()` do in Pandas?",
    "c": null,
    "o": [
      "Returns a DataFrame indicating missing values",
      "Fills missing values",
      "Deletes missing values",
      "Sorts missing values"
    ]
  },
  {
    "q": "Which method is used to remove rows with any missing values?",
    "c": null,
    "o": [
      "dropna()",
      "remove_na()",
      "fillna()",
      "delete_nulls()"
    ]
  },
  {
    "q": "How can missing values be replaced in Pandas?",
    "c": null,
    "o": [
      "Using fillna()",
      "Using replace() only",
      "Using dropna()",
      "Missing values cannot be replaced"
    ]
  },
  {
    "q": "Which method returns basic statistics of numeric columns?",
    "c": null,
    "o": [
      "describe()",
      "info()",
      "summary()",
      "statistics()"
    ]
  },
  {
    "q": "What does `value_counts()` return?",
    "c": null,
    "o": [
      "Counts of unique values in a Series",
      "Summary of all columns",
      "Number of missing values",
      "Total row count"
    ]
  },
  {
    "q": "How to check the data types of each column in a DataFrame?",
    "c": null,
    "o": [
      "dtypes",
      "types",
      "datatypes()",
      "dtype()"
    ]
  },
  {
    "q": "Which argument is used in `read_csv()` to parse a column as datetime?",
    "c": null,
    "o": [
      "parse_dates",
      "datetime_format",
      "to_datetime",
      "date_parse"
    ]
  },
  {
    "q": "Which Pandas function can be used to write a DataFrame to an Excel file?",
    "c": null,
    "o": [
      "to_excel()",
      "write_excel()",
      "save_excel()",
      "export_excel()"
    ]
  },
  {
    "q": "Which method is used to rename columns in a DataFrame?",
    "c": null,
    "o": [
      "rename()",
      "change_columns()",
      "set_columns()",
      "update_names()"
    ]
  },
  {
    "q": "Which operator is used to filter rows based on conditions?",
    "c": null,
    "o": [
      "[] with conditional expressions",
      "filter()",
      "loc() only",
      "query_rows()"
    ]
  },
  {
    "q": "What does the `loc[]` method do?",
    "c": null,
    "o": [
      "Label-based indexing",
      "Integer position indexing",
      "Filters duplicates",
      "Selects random rows"
    ]
  },
  {
    "q": "What does the `iloc[]` method do?",
    "c": null,
    "o": [
      "Integer position-based indexing",
      "Label-based indexing",
      "Selects columns only",
      "Updates column names"
    ]
  },
  {
    "q": "Which function is used to reset the index of a DataFrame?",
    "c": null,
    "o": [
      "reset_index()",
      "drop_index()",
      "clear_index()",
      "restart_index()"
    ]
  },
  {
    "q": "What happens when you use `drop(columns=['col1'])`?",
    "c": null,
    "o": [
      "Column 'col1' is removed from the DataFrame",
      "Rows with missing 'col1' are dropped",
      "Column 'col1' is renamed",
      "Column 'col1' is converted to index"
    ]
  },
  {
    "q": "Which method merges two DataFrames using a common column?",
    "c": null,
    "o": [
      "merge()",
      "join_data()",
      "combine()",
      "add_columns()"
    ]
  },
  {
    "q": "How do you concatenate two DataFrames vertically?",
    "c": null,
    "o": [
      "concat([df1, df2], axis=0)",
      "merge(df1, df2)",
      "join(df1, df2)",
      "concat([df1, df2], axis=1)"
    ]
  },
  {
    "q": "How do you sort a DataFrame by values in a column?",
    "c": null,
    "o": [
      "sort_values(by='column_name')",
      "order_by('column_name')",
      "sort(by='column_name')",
      "sort_column('column_name')"
    ]
  },
  {
    "q": "Which function returns the top n rows of a DataFrame?",
    "c": null,
    "o": [
      "head(n)",
      "top(n)",
      "first(n)",
      "get_top(n)"
    ]
  },
  {
    "q": "What does `df.groupby('column')` return?",
    "c": null,
    "o": [
      "A GroupBy object for aggregation",
      "A sorted DataFrame",
      "A new DataFrame with unique values",
      "An array of column values"
    ]
  },
  {
    "q": "Which method is used to aggregate values in a groupby object?",
    "c": null,
    "o": [
      "agg()",
      "group()",
      "sumby()",
      "split()"
    ]
  },
  {
    "q": "What does `pivot_table()` do?",
    "c": null,
    "o": [
      "Summarizes data with multi-dimensional indexing",
      "Sorts data by columns",
      "Creates a chart",
      "Flattens a DataFrame"
    ]
  },
  {
    "q": "Which method reshapes a DataFrame by converting rows into columns?",
    "c": null,
    "o": [
      "pivot()",
      "explode()",
      "melt()",
      "reshape()"
    ]
  },
  {
    "q": "What does the `melt()` function do in pandas?",
    "c": null,
    "o": [
      "Unpivots a DataFrame from wide to long format",
      "Sorts the DataFrame",
      "Removes missing values",
      "Converts strings to numbers"
    ]
  },
  {
    "q": "Which method returns basic statistical summary of a DataFrame?",
    "c": null,
    "o": [
      "describe()",
      "summary()",
      "info()",
      "profile()"
    ]
  },
  {
    "q": "Which method shows memory usage and column types?",
    "c": null,
    "o": [
      "info()",
      "describe()",
      "memory_report()",
      "types()"
    ]
  },
  {
    "q": "What is the default aggregation function used in `pivot_table()`?",
    "c": null,
    "o": [
      "mean",
      "sum",
      "count",
      "min"
    ]
  },
  {
    "q": "Which method is used to count the frequency of unique values?",
    "c": null,
    "o": [
      "value_counts()",
      "count_values()",
      "frequency()",
      "group_values()"
    ]
  },
  {
    "q": "What does `df.corr()` compute?",
    "c": null,
    "o": [
      "Pairwise correlation of numerical columns",
      "Covariance of numerical columns",
      "Pearson's test",
      "Standard deviation of columns"
    ]
  },
  {
    "q": "Which method is used to fill missing values in a DataFrame?",
    "c": null,
    "o": [
      "fillna()",
      "replace()",
      "dropna()",
      "impute()"
    ]
  },
  {
    "q": "What does `dropna()` do in pandas?",
    "c": null,
    "o": [
      "Removes rows or columns with missing values",
      "Replaces NaN with zero",
      "Fills NaN with mean",
      "Converts NaN to None"
    ]
  },
  {
    "q": "How can you forward fill missing values?",
    "c": null,
    "o": [
      "df.fillna(method='ffill')",
      "df.fillna(method='forward')",
      "df.replace('NaN', 'ff')",
      "df.impute(method='forward')"
    ]
  },
  {
    "q": "Which method allows you to backfill missing values?",
    "c": null,
    "o": [
      "bfill",
      "backfill",
      "reverse",
      "fillback"
    ]
  },
  {
    "q": "What does `isnull()` return?",
    "c": null,
    "o": [
      "A DataFrame of booleans indicating NaN values",
      "The count of NaN values",
      "Replaces nulls with False",
      "Indexes of NaN rows"
    ]
  },
  {
    "q": "Which method converts a column to datetime in pandas?",
    "c": null,
    "o": [
      "pd.to_datetime()",
      "pd.datetime_convert()",
      "df.astype('datetime')",
      "df.convert_to_time()"
    ]
  },
  {
    "q": "What does `resample('M')` do in time series?",
    "c": null,
    "o": [
      "Resamples data to monthly frequency",
      "Sorts by month",
      "Converts to milliseconds",
      "Filters by month"
    ]
  },
  {
    "q": "Which method is used to set a column as index?",
    "c": null,
    "o": [
      "set_index()",
      "assign_index()",
      "to_index()",
      "make_index()"
    ]
  },
  {
    "q": "What is `iloc[]` used for in pandas?",
    "c": null,
    "o": [
      "Integer-location based indexing",
      "Label-based indexing",
      "Row selection by name",
      "Column filtering"
    ]
  },
  {
    "q": "How can you select rows using labels?",
    "c": null,
    "o": [
      "Using loc[]",
      "Using iloc[]",
      "Using at[]",
      "Using index()"
    ]
  },
  {
    "q": "Which pandas function is used to merge two DataFrames based on a common column?",
    "c": null,
    "o": [
      "merge()",
      "join()",
      "concat()",
      "combine()"
    ]
  },
  {
    "q": "How do you concatenate two DataFrames vertically?",
    "c": null,
    "o": [
      "pd.concat([df1, df2])",
      "df1.append(df2)",
      "df1 + df2",
      "df1.extend(df2)"
    ]
  },
  {
    "q": "Which argument is used in `merge()` to specify the column to join on?",
    "c": null,
    "o": [
      "on",
      "key",
      "join_column",
      "index"
    ]
  },
  {
    "q": "What does the `groupby()` function return?",
    "c": null,
    "o": [
      "A GroupBy object",
      "A pivot table",
      "A reshaped DataFrame",
      "A merged DataFrame"
    ]
  },
  {
    "q": "Which function gives the number of non-null entries per group?",
    "c": null,
    "o": [
      "count()",
      "size()",
      "len()",
      "notnull()"
    ]
  },
  {
    "q": "Which pandas function is used to reshape data by pivoting?",
    "c": null,
    "o": [
      "pivot()",
      "reshape()",
      "transform()",
      "reindex()"
    ]
  },
  {
    "q": "What does `agg()` function do?",
    "c": null,
    "o": [
      "Applies one or more aggregation operations on grouped data",
      "Assigns new column",
      "Fills missing data",
      "Concatenates two DataFrames"
    ]
  },
  {
    "q": "Which method unpivots a DataFrame from wide to long format?",
    "c": null,
    "o": [
      "melt()",
      "unstack()",
      "pivot()",
      "explode()"
    ]
  },
  {
    "q": "What is the purpose of the `stack()` method?",
    "c": null,
    "o": [
      "Converts columns to rows (stacking vertically)",
      "Converts rows to columns",
      "Joins DataFrames",
      "Sorts index"
    ]
  },
  {
    "q": "Which function computes the average for each group?",
    "c": null,
    "o": [
      "mean()",
      "avg()",
      "aggregate()",
      "summary()"
    ]
  },
  {
    "q": "Which function is used to fill missing values in a DataFrame?",
    "c": null,
    "o": [
      "fillna()",
      "replace()",
      "dropna()",
      "interpolate()"
    ]
  },
  {
    "q": "What does `dropna()` do?",
    "c": null,
    "o": [
      "Removes rows or columns with missing values",
      "Replaces NaN with zero",
      "Fills missing values using method",
      "Sorts DataFrame"
    ]
  },
  {
    "q": "Which method can be used to interpolate missing values?",
    "c": null,
    "o": [
      "interpolate()",
      "fillna(method='linear')",
      "replace()",
      "complete()"
    ]
  },
  {
    "q": "Which method converts a column to categorical type?",
    "c": null,
    "o": [
      "astype('category')",
      "to_category()",
      "categorize()",
      "as_category()"
    ]
  },
  {
    "q": "What is the benefit of using categorical data in pandas?",
    "c": null,
    "o": [
      "Less memory usage and faster performance",
      "Slower performance but more accuracy",
      "Only for plotting",
      "Allows string indexing"
    ]
  },
  {
    "q": "Which pandas type is used for time series data?",
    "c": null,
    "o": [
      "DatetimeIndex",
      "TimeSeries",
      "Timedelta",
      "PeriodIndex"
    ]
  },
  {
    "q": "Which function converts a column to datetime?",
    "c": null,
    "o": [
      "pd.to_datetime()",
      "pd.datetime()",
      "pd.convert_datetime()",
      "datetime.cast()"
    ]
  },
  {
    "q": "What does `resample()` do in time series?",
    "c": null,
    "o": [
      "Changes frequency of time series data",
      "Resizes DataFrame",
      "Changes dtype",
      "Fills missing values"
    ]
  },
  {
    "q": "How can you find missing timestamps in a datetime index?",
    "c": null,
    "o": [
      "Using `asfreq()` and checking for NaNs",
      "Using `resample()` only",
      "Using `fillna()` directly",
      "Using `dropna()`"
    ]
  },
  {
    "q": "Which method returns the difference between consecutive dates?",
    "c": null,
    "o": [
      "diff()",
      "shift()",
      "lag()",
      "cumsum()"
    ]
  },
  {
    "q": "Which of the following selects the first 5 rows of a DataFrame `df`?",
    "c": null,
    "o": [
      "df.head()",
      "df[:5]",
      "df.loc[:4]",
      "All of the above"
    ]
  },
  {
    "q": "Which method allows selection by label(s) in a DataFrame?",
    "c": null,
    "o": [
      "loc[]",
      "iloc[]",
      "ix[]",
      "at[]"
    ]
  },
  {
    "q": "What does `df.iloc[2:5]` return?",
    "c": null,
    "o": [
      "Rows with integer position 2, 3, and 4",
      "Rows labeled 2 to 5",
      "All columns from index 2 to 5",
      "None of the above"
    ]
  },
  {
    "q": "Which is used for boolean indexing in pandas?",
    "c": null,
    "o": [
      "df[df['col'] > 10]",
      "df.loc[10]",
      "df.iloc[10]",
      "df.filter('col > 10')"
    ]
  },
  {
    "q": "Which function is used to reshape a DataFrame from wide to long format?",
    "c": null,
    "o": [
      "melt()",
      "pivot()",
      "unstack()",
      "stack()"
    ]
  },
  {
    "q": "Which of the following merges DataFrames by columns with common values?",
    "c": null,
    "o": [
      "merge()",
      "concat()",
      "append()",
      "join(axis=1)"
    ]
  },
  {
    "q": "What does `df.pivot_table()` do?",
    "c": null,
    "o": [
      "Creates a spreadsheet-style pivot table",
      "Pivots DataFrame without aggregation",
      "Reorders columns",
      "Concatenates rows"
    ]
  },
  {
    "q": "Which of the following stacks columns as rows?",
    "c": null,
    "o": [
      "stack()",
      "unstack()",
      "transpose()",
      "melt()"
    ]
  },
  {
    "q": "Which function combines DataFrames along a particular axis?",
    "c": null,
    "o": [
      "concat()",
      "merge()",
      "groupby()",
      "pivot()"
    ]
  },
  {
    "q": "What is the default axis for concatenation in `pd.concat()`?",
    "c": null,
    "o": [
      "axis=0 (row-wise)",
      "axis=1 (column-wise)",
      "Depends on index",
      "It must be specified"
    ]
  },
  {
    "q": "Which method is used to group data in pandas?",
    "c": null,
    "o": [
      "groupby()",
      "aggregate()",
      "combine()",
      "pivot_table()"
    ]
  },
  {
    "q": "Which method is used to compute the average of each group after using `groupby()`?",
    "c": null,
    "o": [
      "mean()",
      "sum()",
      "avg()",
      "aggregate()"
    ]
  },
  {
    "q": "How does pandas represent missing data?",
    "c": null,
    "o": [
      "NaN",
      "null",
      "None",
      "Zero"
    ]
  },
  {
    "q": "Which method is used to remove missing values from a DataFrame?",
    "c": null,
    "o": [
      "dropna()",
      "removena()",
      "omitna()",
      "delete()"
    ]
  },
  {
    "q": "What does `fillna(0)` do?",
    "c": null,
    "o": [
      "Replaces all NaN values with 0",
      "Drops rows with NaN values",
      "Fills NaN with mean value",
      "Ignores NaN values"
    ]
  },
  {
    "q": "Which method can be used to resample time series data by frequency?",
    "c": null,
    "o": [
      "resample()",
      "groupby()",
      "asfreq()",
      "cut()"
    ]
  },
  {
    "q": "What is the frequency alias for monthly start in pandas resampling?",
    "c": null,
    "o": [
      "'MS'",
      "'M'",
      "'ME'",
      "'B'"
    ]
  },
  {
    "q": "Which method converts a column to datetime format?",
    "c": null,
    "o": [
      "pd.to_datetime()",
      "pd.as_datetime()",
      "df.convert_to_date()",
      "df.astype('datetime')"
    ]
  },
  {
    "q": "What does `df.shift(1)` do in time series?",
    "c": null,
    "o": [
      "Shifts the data forward by 1 row",
      "Shifts index by 1",
      "Removes the first row",
      "Reverses the DataFrame"
    ]
  },
  {
    "q": "Which parameter of `groupby()` allows applying different functions to different columns?",
    "c": null,
    "o": [
      "agg() with a dictionary",
      "apply()",
      "transform()",
      "map()"
    ]
  },
  {
    "q": "Which function is used to read a CSV file into a DataFrame?",
    "c": null,
    "o": [
      "read_csv()",
      "read_excel()",
      "load_csv()",
      "open_csv()"
    ]
  },
  {
    "q": "Which function is used to write a DataFrame to a CSV file?",
    "c": null,
    "o": [
      "to_csv()",
      "write_csv()",
      "save_csv()",
      "export_csv()"
    ]
  },
  {
    "q": "What does the `pivot()` function do in pandas?",
    "c": null,
    "o": [
      "Reshapes data based on column values",
      "Filters columns by labels",
      "Splits a DataFrame into multiple parts",
      "Sorts the DataFrame by index"
    ]
  },
  {
    "q": "Which method combines multiple DataFrames vertically (row-wise)?",
    "c": null,
    "o": [
      "concat()",
      "merge()",
      "join()",
      "combine_first()"
    ]
  },
  {
    "q": "Which method is used to merge two DataFrames based on a common column?",
    "c": null,
    "o": [
      "merge()",
      "concat()",
      "append()",
      "groupby()"
    ]
  },
  {
    "q": "Which of the following is used to convert a column to a categorical type?",
    "c": null,
    "o": [
      "astype('category')",
      "to_category()",
      "as_categorical()",
      "convert_category()"
    ]
  },
  {
    "q": "What does `df.sort_values(by='col')` do?",
    "c": null,
    "o": [
      "Sorts the DataFrame based on values in column 'col'",
      "Sorts index only",
      "Deletes duplicates from 'col'",
      "Removes nulls from 'col'"
    ]
  },
  {
    "q": "Which method helps in changing the structure from long to wide format?",
    "c": null,
    "o": [
      "pivot()",
      "melt()",
      "stack()",
      "explode()"
    ]
  },
  {
    "q": "Which function is used to convert a wide-format DataFrame to a long-format one?",
    "c": null,
    "o": [
      "melt()",
      "unpivot()",
      "flatten()",
      "explode()"
    ]
  },
  {
    "q": "Which pandas method breaks list-like elements into separate rows?",
    "c": null,
    "o": [
      "explode()",
      "melt()",
      "unstack()",
      "separate()"
    ]
  },
  {
    "q": "Which method resets the index of a DataFrame to default integer values?",
    "c": null,
    "o": [
      "reset_index()",
      "reindex()",
      "drop_index()",
      "set_index()"
    ]
  },
  {
    "q": "What does `df.loc[]` allow you to do?",
    "c": null,
    "o": [
      "Label-based indexing",
      "Integer position indexing",
      "Apply a lambda function",
      "Filter null values"
    ]
  },
  {
    "q": "Which method is used for integer-location based indexing?",
    "c": null,
    "o": [
      "iloc[]",
      "loc[]",
      "ix[]",
      "position[]"
    ]
  },
  {
    "q": "Which method is used to remove rows with missing values?",
    "c": null,
    "o": [
      "dropna()",
      "fillna()",
      "replace_na()",
      "drop_nulls()"
    ]
  },
  {
    "q": "What does the `fillna()` method do?",
    "c": null,
    "o": [
      "Fills missing values",
      "Drops NA values",
      "Finds duplicate rows",
      "Converts NA to boolean"
    ]
  },
  {
    "q": "Which of the following improves pandas performance for large datasets?",
    "c": null,
    "o": [
      "Using categoricals",
      "Using Excel instead of CSV",
      "Avoiding indexing",
      "Using list comprehensions"
    ]
  },
  {
    "q": "Which method returns boolean DataFrame showing where values are NA?",
    "c": null,
    "o": [
      "isna()",
      "isnull()",
      "notna()",
      "hasna()"
    ]
  },
  {
    "q": "What is the purpose of `df.duplicated()`?",
    "c": null,
    "o": [
      "Returns a boolean Series marking duplicates",
      "Deletes duplicate rows",
      "Highlights missing values",
      "Sorts the DataFrame"
    ]
  },
  {
    "q": "Which function converts a string column to datetime objects?",
    "c": null,
    "o": [
      "pd.to_datetime()",
      "datetime.convert()",
      "strptime()",
      "pd.time_cast()"
    ]
  },
  {
    "q": "Which method is used to resample time series data?",
    "c": null,
    "o": [
      "resample()",
      "aggregate()",
      "group_time()",
      "timesplit()"
    ]
  },
  {
    "q": "Which of the following code snippets returns the first 3 rows of a DataFrame `df`?",
    "c": null,
    "o": [
      "df.head(3)",
      "df.first(3)",
      "df.top(3)",
      "df.iloc[:3]"
    ]
  },
  {
    "q": "What does the `df.describe()` function provide?",
    "c": null,
    "o": [
      "Summary statistics",
      "Null value count",
      "Column names",
      "Data types"
    ]
  },
  {
    "q": "Which method will convert the index of a DataFrame into a column?",
    "c": null,
    "o": [
      "reset_index()",
      "reindex()",
      "index_to_column()",
      "flatten_index()"
    ]
  },
  {
    "q": "Which of the following will correctly group DataFrame `df` by 'department' and calculate mean salary?",
    "c": null,
    "o": [
      "df.groupby('department')['salary'].mean()",
      "df.group('department')['salary'].average()",
      "df.groupby('department').avg('salary')",
      "df.group_by('department').mean('salary')"
    ]
  },
  {
    "q": "What will `df.sort_values(by='age', ascending=False)` do?",
    "c": null,
    "o": [
      "Sorts the DataFrame by 'age' in descending order",
      "Sorts the DataFrame by index",
      "Deletes rows with duplicate ages",
      "Filters out rows with null age"
    ]
  },
  {
    "q": "Which method can be used to find unique values in a column `col` of DataFrame `df`?",
    "c": null,
    "o": [
      "df['col'].unique()",
      "df.unique('col')",
      "df['col'].distinct()",
      "df.col.unique_values()"
    ]
  },
  {
    "q": "What is the output type of `df['age'] > 30`?",
    "c": null,
    "o": [
      "A boolean Series",
      "An integer Series",
      "A filtered DataFrame",
      "An index object"
    ]
  },
  {
    "q": "How to select rows in DataFrame `df` where column 'score' is greater than 50?",
    "c": null,
    "o": [
      "df[df['score'] > 50]",
      "df.select('score' > 50)",
      "df.where('score' > 50)",
      "df.score > 50"
    ]
  },
  {
    "q": "What does `df.drop(columns=['A'])` do?",
    "c": null,
    "o": [
      "Drops column 'A'",
      "Drops rows with value 'A'",
      "Renames column 'A'",
      "Sorts by column 'A'"
    ]
  },
  {
    "q": "Which method can fill missing values in column 'rating' with 0?",
    "c": null,
    "o": [
      "df['rating'].fillna(0)",
      "df.fillna(column='rating', value=0)",
      "df['rating'].dropna(0)",
      "df.replace('rating', 0)"
    ]
  },
  {
    "q": "How do you rename column 'old' to 'new' in DataFrame `df`?",
    "c": null,
    "o": [
      "df.rename(columns={'old': 'new'})",
      "df.columns.rename('old', 'new')",
      "df.column_rename('old', 'new')",
      "df.rename_column('old', 'new')"
    ]
  },
  {
    "q": "Which method returns a tuple with the number of rows and columns?",
    "c": null,
    "o": [
      "df.shape",
      "df.size()",
      "df.count()",
      "df.length()"
    ]
  },
  {
    "q": "What will `df.isnull().sum()` return?",
    "c": null,
    "o": [
      "The total nulls per column",
      "A list of null values",
      "A DataFrame with nulls removed",
      "True if any null exists"
    ]
  },
  {
    "q": "Which of the following will return the column names of a DataFrame?",
    "c": null,
    "o": [
      "df.columns",
      "df.get_columns()",
      "df.colnames()",
      "df.names"
    ]
  },
  {
    "q": "How do you select multiple columns 'a' and 'b' from `df`?",
    "c": null,
    "o": [
      "df[['a', 'b']]",
      "df.select('a', 'b')",
      "df['a', 'b']",
      "df.select_columns(['a', 'b'])"
    ]
  },
  {
    "q": "Which of the following is used to concatenate two DataFrames vertically?",
    "c": null,
    "o": [
      "pd.concat([df1, df2])",
      "df1 + df2",
      "df1.append_columns(df2)",
      "pd.merge(df1, df2)"
    ]
  },
  {
    "q": "Which method returns the frequency of unique values in a column?",
    "c": null,
    "o": [
      "df['col'].value_counts()",
      "df['col'].count_unique()",
      "df.value_frequency('col')",
      "df['col'].counts()"
    ]
  },
  {
    "q": "How can you reset the index of a DataFrame `df` without keeping the old index?",
    "c": null,
    "o": [
      "df.reset_index(drop=True)",
      "df.reindex(reset=True)",
      "df.index.reset()",
      "df.set_index(None)"
    ]
  },
  {
    "q": "Which method can be used to check for duplicated rows?",
    "c": null,
    "o": [
      "df.duplicated()",
      "df.check_duplicates()",
      "df.find_duplicates()",
      "df.is_duplicate()"
    ]
  },
  {
    "q": "Which of the following creates a DataFrame from a dictionary?",
    "c": null,
    "o": [
      "pd.DataFrame({'a': [1, 2], 'b': [3, 4]})",
      "pd.create({'a': [1, 2], 'b': [3, 4]})",
      "pd.dict_to_df({'a': [1, 2], 'b': [3, 4]})",
      "pd.make_df({'a': [1, 2], 'b': [3, 4]})"
    ]
  },
  {
    "q": "Which method is used to get unique values from a Series or DataFrame column?",
    "c": null,
    "o": [
      "unique()",
      "distinct()",
      "value_counts()",
      "nunique()"
    ]
  },
  {
    "q": "What does `df.astype('float')` do?",
    "c": null,
    "o": [
      "Converts the DataFrame to float dtype",
      "Casts all columns to string",
      "Removes float columns",
      "Sorts columns numerically"
    ]
  },
  {
    "q": "How can you change the data type of a single column 'col' to int?",
    "c": null,
    "o": [
      "df['col'] = df['col'].astype(int)",
      "df.astype('col', int)",
      "df['col'].convert(int)",
      "df.change_type('col', int)"
    ]
  },
  {
    "q": "Which method removes duplicate rows from a DataFrame?",
    "c": null,
    "o": [
      "drop_duplicates()",
      "remove_duplicates()",
      "unique_rows()",
      "delete_duplicates()"
    ]
  },
  {
    "q": "What does the `query()` method allow you to do?",
    "c": null,
    "o": [
      "Filter DataFrame rows using a query string",
      "Update values based on condition",
      "Sort rows by columns",
      "Merge two DataFrames"
    ]
  },
  {
    "q": "How do you select all rows where column 'age' is greater than 30 using query?",
    "c": null,
    "o": [
      "df.query('age > 30')",
      "df.filter('age > 30')",
      "df.select('age > 30')",
      "df.loc['age > 30']"
    ]
  },
  {
    "q": "Which of the following is true about `apply()` in pandas?",
    "c": null,
    "o": [
      "It applies a function along an axis of the DataFrame",
      "It filters rows by condition",
      "It returns a copy of the DataFrame",
      "It sorts the DataFrame"
    ]
  },
  {
    "q": "How do you apply a lambda function to each element in column 'score'?",
    "c": null,
    "o": [
      "df['score'].apply(lambda x: x + 1)",
      "df.apply(lambda x: x['score'] + 1)",
      "df.map(lambda x: x + 1)",
      "df['score'].map(lambda x: x + 1)"
    ]
  },
  {
    "q": "What does `df.memory_usage()` return?",
    "c": null,
    "o": [
      "Memory usage of each column in bytes",
      "Total memory used by DataFrame",
      "Number of elements in DataFrame",
      "Size of DataFrame in MB"
    ]
  },
  {
    "q": "Which option speeds up operations by using vectorized operations in pandas?",
    "c": null,
    "o": [
      "Using built-in pandas functions instead of loops",
      "Using for-loops for iteration",
      "Using apply() with Python functions",
      "Using list comprehensions"
    ]
  }
]