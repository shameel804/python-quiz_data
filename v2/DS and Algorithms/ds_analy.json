[
  {
    "q": "What is the worst-case time complexity of linear search in an unsorted list?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the space complexity of an algorithm that uses only a constant amount of extra space?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which Python module is commonly used for profiling time and function calls?",
    "c": null,
    "o": [
      "cProfile",
      "profiletime",
      "timing",
      "debugger"
    ]
  },
  {
    "q": "What is the average-case time complexity of binary search in a sorted list?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "import time\nstart = time.time()\nfor i in range(1000000):\n    pass\nend = time.time()\nprint(round(end - start, 2))",
    "o": [
      "Execution time in seconds (approx)",
      "0",
      "1000000",
      "None"
    ]
  },
  {
    "q": "Which of the following optimizes both memory and performance when reading large files?",
    "c": null,
    "o": [
      "Generators",
      "List comprehensions",
      "Using while True loop",
      "Nested loops"
    ]
  },
  {
    "q": "Which option best describes the benefit of using list comprehensions?",
    "c": null,
    "o": [
      "They are faster and more readable",
      "They use more memory",
      "They are slower than traditional loops",
      "They don't work with conditions"
    ]
  },
  {
    "q": "What is the best-case time complexity of insertion sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which function from the time module is used to measure elapsed time in profiling?",
    "c": null,
    "o": [
      "time.time()",
      "time.sleep()",
      "time.clock()",
      "time.now()"
    ]
  },
  {
    "q": "What is the worst-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which of the following data structures has the best average-case time complexity for search?",
    "c": null,
    "o": [
      "Hash Table",
      "Binary Search Tree",
      "Linked List",
      "Array"
    ]
  },
  {
    "q": "Which is true about the time complexity of the following code?",
    "c": "for i in range(n):\n    for j in range(5):\n        print(i, j)",
    "o": [
      "O(n)",
      "O(n^2)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which method helps optimize space usage while iterating over large datasets?",
    "c": null,
    "o": [
      "Using generators",
      "Creating large lists",
      "Using global variables",
      "Using nested loops"
    ]
  },
  {
    "q": "Which of these tools is best suited to analyze function call frequency in Python code?",
    "c": null,
    "o": [
      "cProfile",
      "time.sleep",
      "pdb",
      "sys.trace"
    ]
  },
  {
    "q": "What is the best-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "sum([x*x for x in range(5)])",
    "o": [
      "30",
      "10",
      "25",
      "20"
    ]
  },
  {
    "q": "Which keyword is used in Python to create a generator function?",
    "c": null,
    "o": [
      "yield",
      "return",
      "gen",
      "async"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using list comprehensions with very large datasets?",
    "c": null,
    "o": [
      "High memory usage",
      "Slower execution",
      "Syntax errors",
      "Limited compatibility"
    ]
  },
  {
    "q": "Which of the following Python modules provides line-by-line execution time?",
    "c": null,
    "o": [
      "line_profiler",
      "time",
      "sys",
      "datetime"
    ]
  },
  {
    "q": "Which is true about this generator expression: (x*x for x in range(10))?",
    "c": null,
    "o": [
      "It produces values on demand",
      "It stores all values in memory",
      "It’s faster than all list comprehensions",
      "It raises a TypeError"
    ]
  },
  {
    "q": "What is the average-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following Python features uses less memory by computing values lazily?",
    "c": null,
    "o": [
      "Generator expressions",
      "List comprehensions",
      "Tuples",
      "Dictionaries"
    ]
  },
  {
    "q": "How many times will 'print(i)' be executed?",
    "c": "for i in range(1, 6):\n    for j in range(1, 4):\n        print(i)",
    "o": [
      "15",
      "6",
      "10",
      "9"
    ]
  },
  {
    "q": "Which option is true regarding cProfile?",
    "c": null,
    "o": [
      "It provides a detailed breakdown of function calls and time spent in each.",
      "It only shows memory usage.",
      "It can only be used with Python 2.",
      "It replaces the time module."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def gen():\n    for i in range(3):\n        yield i\n\nfor val in gen():\n    print(val)",
    "o": [
      "0\n1\n2",
      "1\n2\n3",
      "0\n1\n2\n3",
      "None"
    ]
  },
  {
    "q": "Which optimization technique avoids creating the entire list in memory?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "Set comprehension",
      "Dictionary"
    ]
  },
  {
    "q": "What is the space complexity of a recursive function that makes n calls, each storing a local variable?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which code snippet measures execution time of a code block?",
    "c": "import time\nstart = time.time()\n# some code\nend = time.time()\nprint(end - start)",
    "o": [
      "It prints the time in seconds",
      "It prints in milliseconds",
      "It prints memory usage",
      "It prints a datetime object"
    ]
  },
  {
    "q": "Which of the following would be the most memory-efficient for processing a large data stream?",
    "c": null,
    "o": [
      "Generator",
      "List",
      "Set",
      "Tuple"
    ]
  },
  {
    "q": "Which statement is true about list comprehensions in Python?",
    "c": null,
    "o": [
      "They are faster than traditional loops in most cases",
      "They use less memory than generators",
      "They cannot be nested",
      "They are only available in Python 3"
    ]
  },
  {
    "q": "What is the worst-case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which of the following tools can be used to measure how much time each function takes in Python?",
    "c": null,
    "o": [
      "cProfile",
      "linecache",
      "heapq",
      "os.path"
    ]
  },
  {
    "q": "Which of the following is the correct syntax for a generator expression?",
    "c": null,
    "o": [
      "(x*x for x in range(10))",
      "[x*x for x in range(10)]",
      "{x*x for x in range(10)}",
      "<x*x for x in range(10)>"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python dictionary by key?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which built-in Python module provides a decorator for measuring execution time of functions?",
    "c": null,
    "o": [
      "timeit",
      "math",
      "random",
      "os"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "gen = (i*i for i in range(3))\nprint(next(gen))\nprint(next(gen))",
    "o": [
      "0\n1",
      "1\n4",
      "0\n4",
      "1\n2"
    ]
  },
  {
    "q": "Which optimization technique is used when avoiding unnecessary recomputations by storing results?",
    "c": null,
    "o": [
      "Memoization",
      "Multithreading",
      "Pipelining",
      "Loop unrolling"
    ]
  },
  {
    "q": "In big-O notation, which of the following represents constant time complexity?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is a correct way to analyze space complexity?",
    "c": null,
    "o": [
      "Measure memory used relative to input size",
      "Count the number of CPU cycles",
      "Track the number of recursive calls only",
      "Use the print statement to log memory"
    ]
  },
  {
    "q": "Which scenario benefits the most from using a generator instead of a list?",
    "c": null,
    "o": [
      "Processing a large stream of data",
      "Generating a small fixed list",
      "Sorting elements",
      "Counting elements"
    ]
  },
  {
    "q": "Which of the following sorts has the best average-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What does the following generator expression return?",
    "c": "gen = (x for x in range(3))\nprint(list(gen))",
    "o": [
      "[0, 1, 2]",
      "[1, 2, 3]",
      "[0, 1, 2, 3]",
      "generator object"
    ]
  },
  {
    "q": "Which function provides more accurate measurement for small code snippets?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "time.time()",
      "datetime.now()",
      "time.sleep()"
    ]
  },
  {
    "q": "Which data structure provides O(log n) time complexity for insert and delete operations?",
    "c": null,
    "o": [
      "Binary Search Tree",
      "Hash Table",
      "Linked List",
      "Array"
    ]
  },
  {
    "q": "What is the space complexity of a recursive Fibonacci algorithm without memoization?",
    "c": null,
    "o": [
      "O(n)",
      "O(2^n)",
      "O(1)",
      "O(log n)"
    ]
  },
  {
    "q": "Which line profiler shows how much time is spent on each individual line of a Python function?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "timeit",
      "tracemalloc"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "def compute():\n    return sum([i for i in range(5)])\nprint(compute())",
    "o": [
      "10",
      "15",
      "5",
      "0"
    ]
  },
  {
    "q": "Which of the following uses lazy evaluation?",
    "c": null,
    "o": [
      "Generator",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "What is the time complexity of appending an element to a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which built-in module can be used to track memory allocations in Python?",
    "c": null,
    "o": [
      "tracemalloc",
      "gc",
      "psutil",
      "heapq"
    ]
  },
  {
    "q": "Which of the following best describes time complexity?",
    "c": null,
    "o": [
      "It estimates how the runtime of an algorithm grows with input size.",
      "It measures the memory usage of an algorithm.",
      "It counts the number of variables used.",
      "It tracks CPU temperature during execution."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "from time import time\nstart = time()\nfor i in range(1000):\n    pass\nprint(round(time() - start, 4))",
    "o": [
      "Execution time in seconds (approx)",
      "0.0",
      "None",
      "1000"
    ]
  },
  {
    "q": "Which of the following Python features avoids loading all data into memory at once?",
    "c": null,
    "o": [
      "Generators",
      "Sets",
      "Lists",
      "Tuples"
    ]
  },
  {
    "q": "Which sorting algorithm has O(n log n) time complexity in all three cases (best, average, worst)?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which of the following optimizations reduces redundant function calls in recursive algorithms?",
    "c": null,
    "o": [
      "Memoization",
      "Multithreading",
      "Loop unrolling",
      "Garbage collection"
    ]
  },
  {
    "q": "Which of the following will consume the least memory?",
    "c": null,
    "o": [
      "(x for x in range(1000000))",
      "[x for x in range(1000000)]",
      "{x for x in range(1000000)}",
      "set(range(1000000))"
    ]
  },
  {
    "q": "What is the worst-case space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(n log n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following statements is true about profiling tools in Python?",
    "c": null,
    "o": [
      "They help identify performance bottlenecks in code.",
      "They are only used for syntax checking.",
      "They are required for compiling Python code.",
      "They automatically optimize code at runtime."
    ]
  },
  {
    "q": "Which module in Python is most suitable for benchmarking small code snippets?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "line_profiler",
      "gc"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "gen = (x for x in range(4))\nprint(next(gen))\nprint(next(gen))\nprint(sum(gen))",
    "o": [
      "0\n1\n5",
      "1\n2\n3",
      "0\n1\n6",
      "0\n1\n3"
    ]
  },
  {
    "q": "Which of the following best describes space complexity?",
    "c": null,
    "o": [
      "It is the amount of memory an algorithm uses as a function of input size.",
      "It is the time taken by an algorithm.",
      "It is the number of lines in a program.",
      "It is the memory consumed by the compiler."
    ]
  },
  {
    "q": "Which optimization technique avoids holding the entire output in memory?",
    "c": null,
    "o": [
      "Using generators",
      "Using lists",
      "Using recursion",
      "Using global variables"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def mygen():\n    yield 1\n    yield 2\n    yield 3\n\ng = mygen()\nprint(next(g))\nprint(next(g))",
    "o": [
      "1\n2",
      "0\n1",
      "2\n3",
      "1\n3"
    ]
  },
  {
    "q": "Which type of complexity does not depend on input size?",
    "c": null,
    "o": [
      "Constant time complexity (O(1))",
      "Linear complexity (O(n))",
      "Quadratic complexity (O(n^2))",
      "Logarithmic complexity (O(log n))"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "import time\nstart = time.time()\ntime.sleep(1)\nend = time.time()\nprint(round(end - start))",
    "o": [
      "1",
      "0",
      "0.5",
      "2"
    ]
  },
  {
    "q": "Which of the following is NOT a valid use case for Python’s cProfile?",
    "c": null,
    "o": [
      "Measuring GPU usage",
      "Counting function calls",
      "Measuring execution time",
      "Analyzing bottlenecks"
    ]
  },
  {
    "q": "Which algorithm has the same best, average, and worst-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the time complexity of checking whether an item exists in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is true for the output of a list comprehension?",
    "c": null,
    "o": [
      "It returns a list in memory.",
      "It returns a generator.",
      "It always returns a string.",
      "It creates a new tuple."
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "import cProfile\ncProfile.run('sum([i for i in range(1000)])')",
    "o": [
      "Profiles the execution of the sum function",
      "Prints an error",
      "Runs sum in a thread",
      "Displays memory allocation"
    ]
  },
  {
    "q": "Which of the following has the best space complexity for sorting?",
    "c": null,
    "o": [
      "Heap Sort",
      "Merge Sort",
      "Bubble Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def squares():\n    for i in range(2):\n        yield i * i\n\ng = squares()\nprint(list(g))",
    "o": [
      "[0, 1]",
      "[1, 4]",
      "[0, 1, 4]",
      "[1, 2]"
    ]
  },
  {
    "q": "Which of the following is used to reduce the time complexity of recursive solutions?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Nested loops",
      "Using break statements",
      "Reducing indentation"
    ]
  },
  {
    "q": "Which of the following time complexities grows the fastest?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n^2)",
      "O(n log n)",
      "O(n)"
    ]
  },
  {
    "q": "What is the average-case time complexity of searching in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is most memory-efficient for reading one line at a time from a large file?",
    "c": null,
    "o": [
      "Using a generator with open()",
      "Reading the whole file with read()",
      "Using list comprehension with readlines()",
      "Using os.read()"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "import time\nstart = time.perf_counter()\nfor _ in range(100000): pass\nend = time.perf_counter()\nprint(round(end - start, 6))",
    "o": [
      "Execution time in seconds (accurate)",
      "0",
      "None",
      "100000"
    ]
  },
  {
    "q": "Which of the following statements about Python's timeit module is TRUE?",
    "c": null,
    "o": [
      "It is more precise than time.time() for small snippets.",
      "It cannot be used from the command line.",
      "It is only available in Python 2.",
      "It requires external installation."
    ]
  },
  {
    "q": "What does the following list comprehension produce?",
    "c": "[x for x in range(3) if x % 2 == 0]",
    "o": [
      "[0, 2]",
      "[1, 3]",
      "[0, 1, 2]",
      "[2]"
    ]
  },
  {
    "q": "Which is more suitable for performance benchmarking of a single function?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "cProfile.run()",
      "time.sleep()",
      "os.stat()"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using recursion without optimization?",
    "c": null,
    "o": [
      "It can lead to stack overflow.",
      "It always runs faster than iteration.",
      "It reduces memory usage.",
      "It simplifies memoization."
    ]
  },
  {
    "q": "What is the time complexity of this code?",
    "c": "for i in range(n):\n    for j in range(i):\n        print(i, j)",
    "o": [
      "O(n^2)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python function is commonly used for timing code execution in competitive coding?",
    "c": null,
    "o": [
      "time.time()",
      "os.time()",
      "datetime.clock()",
      "clock.time()"
    ]
  },
  {
    "q": "Which technique is used to reduce repeated calculations in recursive functions?",
    "c": null,
    "o": [
      "Memoization",
      "Looping",
      "Sorting",
      "Pipelining"
    ]
  },
  {
    "q": "What is the output of the following generator code?",
    "c": "def double():\n    for i in range(2):\n        yield i*2\n\nprint(list(double()))",
    "o": [
      "[0, 2]",
      "[1, 2]",
      "[2, 4]",
      "[0, 1, 2]"
    ]
  },
  {
    "q": "Which Python module is used for tracing memory allocation?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "resource",
      "syslog"
    ]
  },
  {
    "q": "Which scenario is ideal for using list comprehensions?",
    "c": null,
    "o": [
      "When building a small list from an iterable",
      "When processing massive real-time data streams",
      "When optimizing memory usage",
      "When avoiding all loops"
    ]
  },
  {
    "q": "Which of these is a common pitfall of using list comprehensions on large datasets?",
    "c": null,
    "o": [
      "High memory consumption",
      "Slow speed",
      "Syntax errors",
      "Unsorted output"
    ]
  },
  {
    "q": "Which function is used to limit the profiling to a specific block of code?",
    "c": null,
    "o": [
      "cProfile.run()",
      "timeit.repeat()",
      "linecache.getline()",
      "time.sleep()"
    ]
  },
  {
    "q": "What is the time complexity of the following operation: 'in' check in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following code snippets will use the least memory?",
    "c": "data = (x for x in range(1000000))",
    "o": [
      "Generator expression",
      "List comprehension",
      "Set comprehension",
      "Dictionary comprehension"
    ]
  },
  {
    "q": "Which tool helps identify the number of calls made to each function during program execution?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "heapq",
      "collections"
    ]
  },
  {
    "q": "What is the best-case time complexity of the bubble sort algorithm?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of these is a key advantage of using generators?",
    "c": null,
    "o": [
      "Lower memory consumption",
      "Faster than all other structures",
      "Syntax simplicity",
      "Automatic sorting of data"
    ]
  },
  {
    "q": "What is the time complexity of deleting an element from the middle of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following sorting algorithms does not have O(n log n) time in the best case?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which method in the timeit module returns the best execution time from multiple trials?",
    "c": null,
    "o": [
      "timeit.repeat()",
      "timeit.default_timer()",
      "timeit.main()",
      "timeit.profile()"
    ]
  },
  {
    "q": "What will be the space complexity of a recursive factorial function?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is most efficient for iterating over a large dataset only once?",
    "c": null,
    "o": [
      "Generator",
      "List",
      "Dictionary",
      "Set"
    ]
  },
  {
    "q": "Which technique stores the results of expensive function calls and returns the cached result?",
    "c": null,
    "o": [
      "Memoization",
      "Hashing",
      "Looping",
      "Comprehension"
    ]
  },
  {
    "q": "Which of the following operations on a Python list has O(1) time complexity?",
    "c": null,
    "o": [
      "Accessing an element by index",
      "Inserting at the beginning",
      "Removing a middle element",
      "Searching for a value"
    ]
  },
  {
    "q": "Which of the following Python expressions creates a generator?",
    "c": null,
    "o": [
      "(x for x in range(5))",
      "[x for x in range(5)]",
      "{x for x in range(5)}",
      "{x: x for x in range(5)}"
    ]
  },
  {
    "q": "What is the time complexity of slicing a list in Python like `my_list[:k]`?",
    "c": null,
    "o": [
      "O(k)",
      "O(1)",
      "O(n)",
      "O(log k)"
    ]
  },
  {
    "q": "Which function is most appropriate for line-by-line profiling in Python?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "timeit",
      "tracemalloc"
    ]
  },
  {
    "q": "What is the output of this generator expression?",
    "c": "gen = (i**2 for i in range(3))\nprint(next(gen), next(gen))",
    "o": [
      "0 1",
      "1 4",
      "0 4",
      "1 2"
    ]
  },
  {
    "q": "Which sorting algorithm requires additional space for merging during execution?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which module is designed to trace the memory blocks allocated by Python?",
    "c": null,
    "o": [
      "tracemalloc",
      "resource",
      "gc",
      "profile"
    ]
  },
  {
    "q": "Which is the most efficient way to build a list of squares in Python?",
    "c": null,
    "o": [
      "[x**2 for x in range(10)]",
      "list(map(lambda x: x**2, range(10)))",
      "for x in range(10): result.append(x**2)",
      "[x*x for x in range(10) if True]"
    ]
  },
  {
    "q": "Which of the following Python modules offers low-level memory profiling?",
    "c": null,
    "o": [
      "memory_profiler",
      "timeit",
      "sys",
      "statistics"
    ]
  },
  {
    "q": "What is the time complexity of inserting a new element at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the worst-case time complexity of accessing an element in a Python list by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "def gen():\n    yield from range(2)\nprint(list(gen()))",
    "o": [
      "[0, 1]",
      "[1, 2]",
      "[0, 1, 2]",
      "[2]"
    ]
  },
  {
    "q": "Which technique helps reduce recomputation in dynamic programming?",
    "c": null,
    "o": [
      "Memoization",
      "List comprehension",
      "Nested loops",
      "Sorting"
    ]
  },
  {
    "q": "What is the average-case time complexity of inserting into a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which module is commonly used for benchmarking small code snippets repeatedly?",
    "c": null,
    "o": [
      "timeit",
      "gc",
      "sys",
      "platform"
    ]
  },
  {
    "q": "What is the output of this list comprehension?",
    "c": "[x for x in range(5) if x % 2 == 1]",
    "o": [
      "[1, 3]",
      "[0, 2, 4]",
      "[2, 4]",
      "[1, 2, 3]"
    ]
  },
  {
    "q": "Which of the following improves performance by avoiding full data structure creation?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "Dictionary comprehension",
      "Nested loops"
    ]
  },
  {
    "q": "What is the time complexity of merging two sorted lists of size n each?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which function from the timeit module is used to run a function multiple times?",
    "c": null,
    "o": [
      "timeit.repeat()",
      "timeit.profile()",
      "timeit.benchmark()",
      "timeit.main()"
    ]
  },
  {
    "q": "Which of the following methods would you use to profile the total execution time of a program?",
    "c": null,
    "o": [
      "time.time()",
      "gc.collect()",
      "sys.exit()",
      "os.system()"
    ]
  },
  {
    "q": "Which Python code snippet uses a generator to yield squares of numbers?",
    "c": "def squares(n):\n    for i in range(n):\n        yield i * i",
    "o": [
      "Generator function for squares",
      "List comprehension for squares",
      "A set of square numbers",
      "Function returning a list of squares"
    ]
  },
  {
    "q": "What is the time complexity of creating a list using a list comprehension of size n?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is TRUE about generator expressions in Python?",
    "c": null,
    "o": [
      "They compute values lazily and save memory",
      "They are always faster than list comprehensions",
      "They require more memory than lists",
      "They return a list"
    ]
  },
  {
    "q": "Which tool can help detect lines in your code where the most time is spent?",
    "c": null,
    "o": [
      "line_profiler",
      "timeit",
      "logging",
      "doctest"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "import timeit\nprint(timeit.timeit('sum(range(10))', number=1000))",
    "o": [
      "Execution time for 1000 runs of sum(range(10))",
      "10",
      "1000",
      "0"
    ]
  },
  {
    "q": "Which of the following best defines big-O notation?",
    "c": null,
    "o": [
      "An upper bound on the running time of an algorithm",
      "An exact measure of time taken",
      "A lower bound on space used",
      "The average-case memory usage"
    ]
  },
  {
    "q": "What is the output of this Python code?",
    "c": "gen = (x for x in range(3))\nfor i in gen:\n    print(i)",
    "o": [
      "0\n1\n2",
      "1\n2\n3",
      "0\n1\n2\n3",
      "3\n2\n1"
    ]
  },
  {
    "q": "Which of the following operations has the highest time complexity?",
    "c": null,
    "o": [
      "Bubble Sort (Worst Case)",
      "Accessing a list element by index",
      "Using a generator to iterate",
      "Using sum() on a short list"
    ]
  },
  {
    "q": "What happens when you exhaust a generator using next()?",
    "c": null,
    "o": [
      "It raises StopIteration",
      "It resets automatically",
      "It returns None",
      "It restarts from the beginning"
    ]
  },
  {
    "q": "Which Python tool is used to analyze memory usage per line of code?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "timeit",
      "os.stat"
    ]
  },
  {
    "q": "Which Python technique minimizes memory usage when processing large sequences?",
    "c": null,
    "o": [
      "Using generators",
      "Using nested lists",
      "Using dictionaries",
      "Using list comprehensions"
    ]
  },
  {
    "q": "Which time complexity describes this code: `for i in range(n): print(i)`?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "def gen():\n    yield 10\n    yield 20\n\ng = gen()\nprint(next(g))\nprint(next(g))",
    "o": [
      "10\n20",
      "20\n10",
      "10\n10",
      "20\n20"
    ]
  },
  {
    "q": "Which of the following is an advantage of using `timeit` over `time` module?",
    "c": null,
    "o": [
      "It avoids interference from background processes by running multiple iterations",
      "It is faster",
      "It uses less memory",
      "It automatically generates plots"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "print(sum([x for x in range(4)]))",
    "o": [
      "6",
      "10",
      "3",
      "4"
    ]
  },
  {
    "q": "Which type of profiling would best help detect which function consumes the most execution time?",
    "c": null,
    "o": [
      "Function-level profiling using cProfile",
      "Memory allocation tracing",
      "Syntax checking",
      "Loop unrolling"
    ]
  },
  {
    "q": "Which of the following is true about list comprehensions?",
    "c": null,
    "o": [
      "They are generally faster than traditional loops",
      "They always consume less memory",
      "They are slower than map()",
      "They require generator functions"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "gen = (i for i in range(2))\nprint(sum(gen))",
    "o": [
      "1",
      "0",
      "3",
      "2"
    ]
  },
  {
    "q": "Which optimization is not automatically handled by Python interpreters?",
    "c": null,
    "o": [
      "Loop unrolling",
      "Lazy evaluation in generators",
      "Short-circuit evaluation",
      "Using built-in data structures"
    ]
  },
  {
    "q": "Which complexity class grows faster than all others?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n^2)",
      "O(n log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which profiling tool in Python gives a breakdown of function calls and their execution time?",
    "c": null,
    "o": [
      "cProfile",
      "memory_profiler",
      "tracemalloc",
      "timeit"
    ]
  },
  {
    "q": "What is the space complexity of a function that uses only a constant number of variables?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following expressions returns a generator?",
    "c": null,
    "o": [
      "(x for x in range(5))",
      "[x for x in range(5)]",
      "{x for x in range(5)}",
      "{x: x for x in range(5)}"
    ]
  },
  {
    "q": "What is the time complexity of the following code?",
    "c": "for i in range(n):\n    for j in range(5):\n        print(i, j)",
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which optimization technique can avoid repeated evaluation of the same inputs in a recursive function?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Iteration",
      "List comprehension"
    ]
  },
  {
    "q": "Which Python module is suitable for monitoring memory allocation during code execution?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "math",
      "timeit"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "import timeit\nprint(timeit.timeit('for x in range(10): pass', number=100))",
    "o": [
      "Execution time for the loop run 100 times",
      "1000",
      "10",
      "Nothing"
    ]
  },
  {
    "q": "Which time complexity grows slower than all others listed?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which function-level profiling tool can be run from the command line using `python -m`?",
    "c": null,
    "o": [
      "cProfile",
      "line_profiler",
      "tracemalloc",
      "memory_profiler"
    ]
  },
  {
    "q": "Which of these statements about Python generators is TRUE?",
    "c": null,
    "o": [
      "They do not store all values in memory at once.",
      "They execute faster than lists in all cases.",
      "They automatically cache previous values.",
      "They require more memory than list comprehensions."
    ]
  },
  {
    "q": "Which of the following describes the behavior of a generator after it is exhausted?",
    "c": null,
    "o": [
      "Raises StopIteration",
      "Starts over automatically",
      "Returns None for all further calls",
      "Returns the last value repeatedly"
    ]
  },
  {
    "q": "What is the space complexity of an iterative binary search algorithm?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following would best help reduce memory usage in a data pipeline?",
    "c": null,
    "o": [
      "Using generators instead of lists",
      "Using deep recursion",
      "Using sets instead of tuples",
      "Using nested dictionaries"
    ]
  },
  {
    "q": "Which tool allows profiling of how much memory is used line-by-line in Python?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "line_profiler",
      "psutil"
    ]
  },
  {
    "q": "What is the time complexity of building a list using list comprehension with range(n)?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python optimization technique can prevent memory overflow with large datasets?",
    "c": null,
    "o": [
      "Using generator expressions",
      "Storing all data in a list",
      "Using deeply nested lists",
      "Reading data into memory all at once"
    ]
  },
  {
    "q": "What is the worst-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which profiling tool is best used for measuring function call statistics?",
    "c": null,
    "o": [
      "cProfile",
      "tracemalloc",
      "memory_profiler",
      "timeit"
    ]
  },
  {
    "q": "Which of the following is TRUE about list comprehensions?",
    "c": null,
    "o": [
      "They are generally more concise and faster than loops",
      "They always use less memory than generators",
      "They return a generator",
      "They cannot be nested"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "gen = (i for i in range(3))\nprint(sum(gen))",
    "o": [
      "3",
      "0",
      "6",
      "2"
    ]
  },
  {
    "q": "Which of the following provides the most efficient way to iterate over a large file line by line?",
    "c": null,
    "o": [
      "Using a generator with `open()`",
      "Reading all lines with `readlines()`",
      "Loading into a list and looping",
      "Using `read()` with string split"
    ]
  },
  {
    "q": "What is the time complexity of the built-in `sum()` function for a list of size n?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def gen():\n    for i in range(3):\n        yield i\n\nprint(list(gen()))",
    "o": [
      "[0, 1, 2]",
      "[1, 2, 3]",
      "[0, 2, 3]",
      "[0, 1, 2, 3]"
    ]
  },
  {
    "q": "Which of the following tools is best for measuring time taken by very short snippets of Python code?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "tracemalloc",
      "time.sleep"
    ]
  },
  {
    "q": "Which of these describes best-case time complexity?",
    "c": null,
    "o": [
      "The minimum time taken by an algorithm for any input",
      "The average time across all inputs",
      "The maximum time taken in worst scenario",
      "The space required by the algorithm"
    ]
  },
  {
    "q": "Which of the following is a benefit of using list comprehensions over traditional loops?",
    "c": null,
    "o": [
      "They are generally faster and more concise",
      "They use less memory than generators",
      "They avoid allocation of new memory",
      "They allow parallel execution"
    ]
  },
  {
    "q": "Which algorithm has O(log n) time complexity for search operations?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Bubble Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which of the following indicates that an algorithm uses constant memory?",
    "c": null,
    "o": [
      "O(1) space complexity",
      "O(n) space complexity",
      "O(log n) space complexity",
      "O(n^2) space complexity"
    ]
  },
  {
    "q": "What happens when `next()` is called on an exhausted generator?",
    "c": null,
    "o": [
      "It raises StopIteration",
      "It returns None",
      "It restarts from beginning",
      "It raises a SyntaxError"
    ]
  },
  {
    "q": "Which Python tool provides high-resolution timing and multiple iterations for benchmarking?",
    "c": null,
    "o": [
      "timeit",
      "datetime",
      "time.sleep",
      "platform"
    ]
  },
  {
    "q": "Which of the following code snippets demonstrates a memory-efficient way to compute squares?",
    "c": "squares = (x*x for x in range(1000000))",
    "o": [
      "Generator expression",
      "List comprehension",
      "Nested loops",
      "Map function"
    ]
  },
  {
    "q": "Which of the following is a primary use case for the `cProfile` module?",
    "c": null,
    "o": [
      "Identifying function-level performance bottlenecks",
      "Measuring memory usage line by line",
      "Analyzing time complexity",
      "Generating documentation"
    ]
  },
  {
    "q": "What is the best-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which tool in Python can show how much memory was allocated by each line of code?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "timeit",
      "psutil"
    ]
  },
  {
    "q": "Which of the following data structures offers the fastest lookup time?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "String"
    ]
  },
  {
    "q": "What will the following generator code print?",
    "c": "def gen():\n    yield 'A'\n    yield 'B'\n    yield 'C'\nfor val in gen():\n    print(val)",
    "o": [
      "A\nB\nC",
      "A\nC\nB",
      "C\nB\nA",
      "A B C"
    ]
  },
  {
    "q": "Which of the following is true about space complexity?",
    "c": null,
    "o": [
      "It represents the total memory used as a function of input size",
      "It describes CPU usage",
      "It always increases with input size",
      "It is not important for algorithm optimization"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "gen = (i for i in range(5))\nprint(next(gen))\nprint(next(gen))",
    "o": [
      "0\n1",
      "1\n2",
      "0\n2",
      "1\n3"
    ]
  },
  {
    "q": "Which approach will consume the least memory for a large sequence of computations?",
    "c": null,
    "o": [
      "Using a generator expression",
      "Storing all results in a list",
      "Using nested lists",
      "Creating a string for each result"
    ]
  },
  {
    "q": "Which of the following statements is TRUE regarding `timeit.timeit()`?",
    "c": null,
    "o": [
      "It runs the statement multiple times and returns the total time taken.",
      "It returns the average time of one execution.",
      "It runs the code only once.",
      "It returns the memory used during execution."
    ]
  },
  {
    "q": "Which optimization technique avoids evaluating the second operand if the first is sufficient?",
    "c": null,
    "o": [
      "Short-circuit evaluation",
      "Memoization",
      "Loop unrolling",
      "Recursion"
    ]
  },
  {
    "q": "What is the space complexity of a function that uses recursion to process a list of n items?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following Python constructs is evaluated lazily?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "Set literal",
      "Tuple unpacking"
    ]
  },
  {
    "q": "Which scenario benefits the MOST from using a generator?",
    "c": null,
    "o": [
      "Processing a very large stream of data",
      "Counting items in a small list",
      "Accessing a static list of values",
      "Sorting a list of integers"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def g():\n    yield 1\n    yield 2\n    yield 3\n\nprint(sum(g()))",
    "o": [
      "6",
      "3",
      "1",
      "None"
    ]
  },
  {
    "q": "Which of the following has the highest worst-case time complexity?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Binary Search",
      "Merge Sort",
      "Quick Sort (average case)"
    ]
  },
  {
    "q": "Which built-in function gives the current high-resolution time?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.timezone()",
      "time.clock()",
      "datetime.now()"
    ]
  },
  {
    "q": "Which time complexity is better than O(n) but worse than O(1)?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n log n)",
      "O(n^2)",
      "O(n^3)"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "def gen():\n    for i in range(3):\n        yield i**2\n\nprint(list(gen()))",
    "o": [
      "[0, 1, 4]",
      "[1, 2, 3]",
      "[0, 1, 2]",
      "[1, 4, 9]"
    ]
  },
  {
    "q": "What is the purpose of using the `@profile` decorator in Python?",
    "c": null,
    "o": [
      "To mark a function for memory profiling",
      "To cache the output of a function",
      "To sort the output of the function",
      "To track function execution frequency"
    ]
  },
  {
    "q": "Which of the following optimization techniques is especially useful in recursive algorithms?",
    "c": null,
    "o": [
      "Memoization",
      "Loop unrolling",
      "Inlining",
      "Tail recursion"
    ]
  },
  {
    "q": "What is the output of this code using a generator?",
    "c": "def mygen():\n    for i in range(2):\n        yield i\n\nx = mygen()\nprint(next(x))\nprint(next(x))",
    "o": [
      "0\n1",
      "1\n2",
      "0\n2",
      "1\n3"
    ]
  },
  {
    "q": "What is the time complexity of searching for an item in an unsorted list?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following will create a generator that produces even numbers?",
    "c": null,
    "o": [
      "(x for x in range(100) if x % 2 == 0)",
      "[x for x in range(100) if x % 2 == 0]",
      "{x for x in range(100) if x % 2 == 0}",
      "{x: x for x in range(100) if x % 2 == 0}"
    ]
  },
  {
    "q": "What is the primary difference between a generator and a list comprehension?",
    "c": null,
    "o": [
      "Generators evaluate lazily, lists do not",
      "Generators return lists, lists return iterators",
      "Generators consume more memory",
      "List comprehensions are always slower"
    ]
  },
  {
    "q": "Which of the following best describes average-case time complexity?",
    "c": null,
    "o": [
      "Expected time for random inputs",
      "Maximum time the algorithm takes",
      "Minimum time the algorithm takes",
      "Memory usage in best case"
    ]
  },
  {
    "q": "Which module should you use to measure memory usage in a live Python process?",
    "c": null,
    "o": [
      "psutil",
      "cProfile",
      "gc",
      "dis"
    ]
  },
  {
    "q": "What is the space complexity of a function that only uses a fixed number of variables?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is a sign of inefficient algorithm performance during profiling?",
    "c": null,
    "o": [
      "A small number of functions take a large percentage of total time",
      "Many functions take equal and small time",
      "Total memory usage is under 1 MB",
      "The call count of all functions is 1"
    ]
  },
  {
    "q": "Which of these would you use to profile memory usage over time in Python?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "timeit",
      "linecache"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def numbers():\n    for i in range(3):\n        yield i\n\ng = numbers()\nprint(list(g))",
    "o": [
      "[0, 1, 2]",
      "[1, 2, 3]",
      "[0, 2]",
      "[1, 3]"
    ]
  },
  {
    "q": "Which time complexity is faster than O(n log n) but slower than O(1)?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n^2)",
      "O(n^3)"
    ]
  },
  {
    "q": "Which Python standard library module provides functions for benchmarking short code snippets?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "gc",
      "sys"
    ]
  },
  {
    "q": "Which of these best defines the purpose of algorithm analysis?",
    "c": null,
    "o": [
      "To determine the time and space resources required by an algorithm",
      "To verify syntax correctness",
      "To execute code faster",
      "To avoid writing functions"
    ]
  },
  {
    "q": "Which optimization can improve the performance of a recursive Fibonacci implementation?",
    "c": null,
    "o": [
      "Memoization",
      "Using a while loop",
      "Adding print statements",
      "Reducing input size"
    ]
  },
  {
    "q": "Which of the following helps reduce both memory and time in Python when working with sequences?",
    "c": null,
    "o": [
      "Generator expressions",
      "Set comprehensions",
      "List slicing",
      "Appending to lists"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "def g():\n    yield from [1, 2, 3]\nprint(sum(g()))",
    "o": [
      "6",
      "3",
      "2",
      "1"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is not comparison-based?",
    "c": null,
    "o": [
      "Counting Sort",
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which complexity class describes the time taken by an algorithm that doubles with each added input?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is best used to profile individual function calls in Python?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "dis",
      "os"
    ]
  },
  {
    "q": "Which of the following best describes a generator function?",
    "c": null,
    "o": [
      "A function that yields values one at a time using `yield`",
      "A function that returns a list",
      "A function that returns an iterator directly",
      "A function that uses `return` instead of `yield`"
    ]
  },
  {
    "q": "Which of the following Python optimizations is most suitable for avoiding memory exhaustion?",
    "c": null,
    "o": [
      "Using generator expressions",
      "Using deep copies",
      "Using recursion",
      "Using global variables"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "from timeit import timeit\nprint(timeit('x = [i*i for i in range(100)]', number=100))",
    "o": [
      "Execution time for 100 list comprehension runs",
      "100",
      "10000",
      "A syntax error"
    ]
  },
  {
    "q": "Which of the following complexities indicates an algorithm that gets slower linearly with input?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following statements about `cProfile` is TRUE?",
    "c": null,
    "o": [
      "It shows the number of calls and execution time of each function",
      "It measures memory usage",
      "It benchmarks small snippets of code",
      "It profiles line-by-line memory allocation"
    ]
  },
  {
    "q": "What is the time complexity of checking if an element exists in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following tools provides a snapshot of current memory allocation?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "line_profiler",
      "gc"
    ]
  },
  {
    "q": "What does the following generator expression produce?",
    "c": "gen = (i for i in range(3))\nprint(next(gen), next(gen))",
    "o": [
      "0 1",
      "1 2",
      "0 2",
      "2 3"
    ]
  },
  {
    "q": "Which of these describes the use of `yield` in a generator?",
    "c": null,
    "o": [
      "It pauses the function and resumes on next call",
      "It exits the function permanently",
      "It stores the return value in memory",
      "It converts a function into a class"
    ]
  },
  {
    "q": "Which optimization strategy is typically used to replace nested loops in Python when filtering data?",
    "c": null,
    "o": [
      "List comprehensions with conditions",
      "Using recursion",
      "Using global variables",
      "String concatenation"
    ]
  },
  {
    "q": "Which of the following is the best case time complexity of insertion sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which profiling tool provides detailed statistics on the time spent in each function?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "tracemalloc",
      "gc"
    ]
  },
  {
    "q": "What is the primary benefit of using generators over lists?",
    "c": null,
    "o": [
      "Lower memory consumption",
      "Faster sorting",
      "Immutable data",
      "Automatic indexing"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def fib():\n    a, b = 0, 1\n    for _ in range(3):\n        yield a\n        a, b = b, a + b\n\nprint(list(fib()))",
    "o": [
      "[0, 1, 1]",
      "[1, 1, 2]",
      "[0, 1, 2]",
      "[1, 2, 3]"
    ]
  },
  {
    "q": "Which of these helps in determining the most resource-heavy functions in an application?",
    "c": null,
    "o": [
      "Function-level profiling",
      "Syntax highlighting",
      "Unit testing",
      "String interpolation"
    ]
  },
  {
    "q": "Which optimization is suitable for reducing redundant computations in divide-and-conquer algorithms?",
    "c": null,
    "o": [
      "Memoization",
      "Loop fusion",
      "Dead code elimination",
      "Short-circuiting"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "gen = (i*i for i in range(3))\nprint(sum(gen))",
    "o": [
      "5",
      "6",
      "9",
      "3"
    ]
  },
  {
    "q": "Which of the following indicates an algorithm with exponential growth in time complexity?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n^2)",
      "O(n log n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following is a key feature of Python generators?",
    "c": null,
    "o": [
      "They support lazy evaluation",
      "They store all values in memory",
      "They return a list",
      "They are slower than loops"
    ]
  },
  {
    "q": "Which Python construct is most memory efficient for reading lines from a large file?",
    "c": null,
    "o": [
      "A generator using 'with open() as f: yield from f'",
      "Reading all lines using readlines()",
      "Using nested loops",
      "Using f.read().splitlines()"
    ]
  },
  {
    "q": "Which of the following Python features supports lazy evaluation?",
    "c": null,
    "o": [
      "Generators",
      "Lists",
      "Tuples",
      "Sets"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n^2)",
      "O(1)"
    ]
  },
  {
    "q": "Which of these tools is most appropriate for analyzing where an algorithm spends most of its time?",
    "c": null,
    "o": [
      "cProfile",
      "memory_profiler",
      "doctest",
      "pprint"
    ]
  },
  {
    "q": "What will the following generator code output?",
    "c": "def countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\n\nprint(list(countdown(3)))",
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[3, 1]",
      "[2, 1]"
    ]
  },
  {
    "q": "What is the average-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following is TRUE about `timeit()`?",
    "c": null,
    "o": [
      "It runs code multiple times and returns the total time taken.",
      "It returns the memory usage of a function.",
      "It profiles each function call individually.",
      "It prints the call stack trace."
    ]
  },
  {
    "q": "What does `yield` do inside a Python function?",
    "c": null,
    "o": [
      "Temporarily pauses function execution and saves state",
      "Terminates the function",
      "Returns all results immediately",
      "Prints the current value"
    ]
  },
  {
    "q": "Which sorting algorithm guarantees O(n log n) time in the worst case?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which Python syntax creates a list comprehension that filters even numbers from 0 to 9?",
    "c": null,
    "o": [
      "[x for x in range(10) if x % 2 == 0]",
      "[x for x in range(10) where x % 2 == 0]",
      "{x for x in range(10) if x % 2 == 0}",
      "(x for x in range(10) if x % 2 == 0)"
    ]
  },
  {
    "q": "What is the key difference between `range()` and `xrange()` in Python 2?",
    "c": null,
    "o": [
      "`xrange()` returns a generator-like object and is more memory efficient",
      "`range()` is lazy evaluated",
      "`xrange()` returns a list",
      "There is no difference"
    ]
  },
  {
    "q": "Which space complexity class means the memory usage does not depend on the input size?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following code snippets will produce a generator that yields square numbers?",
    "c": "squares = (x * x for x in range(5))\nprint(next(squares))",
    "o": [
      "0",
      "1",
      "2",
      "None"
    ]
  },
  {
    "q": "Which profiling tool provides line-by-line execution time stats?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "timeit",
      "memory_profiler"
    ]
  },
  {
    "q": "Which complexity class grows slower than O(n log n)?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(2^n)",
      "O(n!)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "gen = (i for i in range(1, 4))\nfor val in gen:\n    print(val, end=' ')",
    "o": [
      "1 2 3 ",
      "0 1 2 ",
      "1 2 ",
      "0 1 2 3 "
    ]
  },
  {
    "q": "Which of the following helps reduce function call overhead in Python?",
    "c": null,
    "o": [
      "Inlining loops or logic",
      "Using decorators",
      "Using classes instead of functions",
      "Importing the `math` module"
    ]
  },
  {
    "q": "What is the time complexity of finding an item in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which profiling tool can help track memory usage over time?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "timeit",
      "sys"
    ]
  },
  {
    "q": "Which of these is NOT a benefit of using generator expressions?",
    "c": null,
    "o": [
      "They allow random access indexing",
      "They are memory efficient",
      "They are lazily evaluated",
      "They can be used in `for` loops"
    ]
  },
  {
    "q": "Which of these complexities represents a divide-and-conquer strategy like Merge Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is most suitable for reading a very large file line by line in Python?",
    "c": null,
    "o": [
      "Using a generator with open()",
      "Using readlines()",
      "Using read() and split()",
      "Using mmap and load all at once"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "def my_gen():\n    yield 10\n    yield 20\n    yield 30\n\nfor val in my_gen():\n    if val == 20:\n        break\n    print(val)",
    "o": [
      "10",
      "10 20",
      "10 30",
      "20"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using list comprehensions over generators?",
    "c": null,
    "o": [
      "Higher memory consumption",
      "Lower readability",
      "Slower performance",
      "Incompatibility with loops"
    ]
  },
  {
    "q": "What is the average case time complexity of searching in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which tool is best suited for analyzing both time and call counts of Python functions?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "gc",
      "doctest"
    ]
  },
  {
    "q": "Which of the following complexities represents linear growth?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which is TRUE about Python's `yield` keyword?",
    "c": null,
    "o": [
      "It creates a generator that can be resumed",
      "It ends the function permanently",
      "It is used only in lambda functions",
      "It returns a list immediately"
    ]
  },
  {
    "q": "Which of the following constructs is best for iterating over a huge dataset efficiently?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "Set comprehension",
      "Dictionary comprehension"
    ]
  },
  {
    "q": "What is the key advantage of generators when processing streaming data?",
    "c": null,
    "o": [
      "They don't load the entire dataset into memory",
      "They are faster in every case",
      "They store intermediate results in lists",
      "They allow random access"
    ]
  },
  {
    "q": "Which of the following time complexities is the most efficient for large input sizes?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is TRUE about time complexity analysis?",
    "c": null,
    "o": [
      "It helps predict algorithm performance for large inputs",
      "It measures the memory used by the program",
      "It depends on the operating system",
      "It is only useful for recursive functions"
    ]
  },
  {
    "q": "Which of these data structures offers O(1) time complexity for insertion and lookup?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "String"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "def demo():\n    yield 1\n    yield 2\n    yield 3\n\nx = demo()\nprint(next(x), next(x))",
    "o": [
      "1 2",
      "2 3",
      "1 3",
      "2 1"
    ]
  },
  {
    "q": "Which of the following statements is FALSE about generators?",
    "c": null,
    "o": [
      "Generators store all values in memory",
      "Generators use `yield`",
      "Generators support iteration",
      "Generators are lazy evaluated"
    ]
  },
  {
    "q": "Which of the following has the worst-case time complexity of O(n^2)?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Binary Search",
      "Counting Sort"
    ]
  },
  {
    "q": "What is the space complexity of a recursive function with depth 'd' and constant work per call?",
    "c": null,
    "o": [
      "O(d)",
      "O(1)",
      "O(log d)",
      "O(d^2)"
    ]
  },
  {
    "q": "Which Python module allows tracking of memory blocks allocated during execution?",
    "c": null,
    "o": [
      "tracemalloc",
      "gc",
      "cProfile",
      "os"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "print(sum(i for i in range(4)))",
    "o": [
      "6",
      "10",
      "3",
      "4"
    ]
  },
  {
    "q": "Which of the following techniques minimizes recomputation of function results?",
    "c": null,
    "o": [
      "Memoization",
      "Loop unrolling",
      "Recursion",
      "Inline functions"
    ]
  },
  {
    "q": "Which of the following is the most efficient in terms of time and memory for reading lines from a file?",
    "c": null,
    "o": [
      "Using a generator expression with `open()`",
      "Reading all lines at once using `readlines()`",
      "Using `read()` and splitting by newline",
      "Reading into a list using a for loop"
    ]
  },
  {
    "q": "Which of the following complexities represents an algorithm that takes the same time regardless of input size?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "def f():\n    yield from [10, 20, 30]\nprint(list(f()))",
    "o": [
      "[10, 20, 30]",
      "[0, 1, 2]",
      "[30, 20, 10]",
      "[10, 30]"
    ]
  },
  {
    "q": "Which optimization technique avoids redundant calculations in recursive solutions?",
    "c": null,
    "o": [
      "Memoization",
      "Loop fusion",
      "Inlining",
      "Recursion"
    ]
  },
  {
    "q": "Which of these modules can be used to profile the memory usage of Python code line by line?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "timeit",
      "sys"
    ]
  },
  {
    "q": "Which of the following best describes Big-O notation?",
    "c": null,
    "o": [
      "An upper bound on time or space complexity",
      "The exact runtime of a program",
      "The lowest possible execution time",
      "A constant measure of speed"
    ]
  },
  {
    "q": "Which of the following is an advantage of using `timeit` over `time` for benchmarking?",
    "c": null,
    "o": [
      "`timeit` minimizes external factors by running code multiple times",
      "`time` provides nanosecond precision",
      "`timeit` only works in scripts",
      "`timeit` runs code only once for accuracy"
    ]
  },
  {
    "q": "What is the output of this code using generator expression?",
    "c": "gen = (x for x in range(3))\nprint(sum(gen))",
    "o": [
      "3",
      "6",
      "5",
      "2"
    ]
  },
  {
    "q": "Which technique uses a function to wrap another function to enhance or monitor behavior?",
    "c": null,
    "o": [
      "Decorators",
      "Memoization",
      "Generators",
      "Comprehensions"
    ]
  },
  {
    "q": "Which complexity class grows faster than O(n log n) but slower than O(n^2)?",
    "c": null,
    "o": [
      "O(n^{1.5})",
      "O(log n)",
      "O(1)",
      "O(n!)"
    ]
  },
  {
    "q": "Which data structure is typically fastest for checking membership?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which of the following sorting algorithms has the best average-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "def stream():\n    yield 1\n    yield 2\n    return 3\n\ns = stream()\nprint(next(s))",
    "o": [
      "1",
      "2",
      "3",
      "StopIteration"
    ]
  },
  {
    "q": "Which of the following is NOT a property of list comprehensions?",
    "c": null,
    "o": [
      "They consume less memory than generators",
      "They produce lists as output",
      "They are more concise than loops",
      "They support filtering with if conditions"
    ]
  },
  {
    "q": "What is the best-case time complexity of binary search?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following modules would you use to trace memory blocks allocated by Python?",
    "c": null,
    "o": [
      "tracemalloc",
      "pprint",
      "doctest",
      "marshal"
    ]
  },
  {
    "q": "Which of these code snippets will create a generator for odd numbers?",
    "c": null,
    "o": [
      "(x for x in range(10) if x % 2 != 0)",
      "[x for x in range(10) if x % 2 == 1]",
      "{x for x in range(10) if x % 2 != 0}",
      "[x for x in range(10) if x % 2 != 0]"
    ]
  },
  {
    "q": "Which time complexity describes an algorithm that halves the input size at each step?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following options will NOT create a generator?",
    "c": null,
    "o": [
      "[x*x for x in range(10)]",
      "(x*x for x in range(10))",
      "def gen(): yield 1",
      "(x for x in range(10))"
    ]
  },
  {
    "q": "Which Python feature allows functions to remember past results to avoid recomputation?",
    "c": null,
    "o": [
      "lru_cache",
      "staticmethod",
      "property",
      "lambda"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef square(n):\n    return n * n\n\nprint(square(3))",
    "o": [
      "9",
      "6",
      "3",
      "None"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element by index in a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following would result in the least memory usage for processing a large data stream?",
    "c": null,
    "o": [
      "A generator",
      "A list",
      "A set",
      "A dictionary"
    ]
  },
  {
    "q": "What does `@lru_cache()` do in Python?",
    "c": null,
    "o": [
      "Caches function outputs to avoid recomputation",
      "Limits recursion depth",
      "Lowers execution time by removing loops",
      "Compresses memory for large inputs"
    ]
  },
  {
    "q": "What will be printed by this generator expression?",
    "c": "gen = (i*i for i in range(4))\nprint(list(gen))",
    "o": [
      "[0, 1, 4, 9]",
      "[1, 4, 9, 16]",
      "[1, 2, 3, 4]",
      "[0, 2, 4, 6]"
    ]
  },
  {
    "q": "Which function is commonly used to measure execution time in small code snippets?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "time.sleep()",
      "os.clock()",
      "gc.collect()"
    ]
  },
  {
    "q": "Which of these Python operations is most time-efficient for checking existence of a value?",
    "c": null,
    "o": [
      "Using a set",
      "Using a list",
      "Using a tuple",
      "Using a loop"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "What is the purpose of `yield from` in a generator function?",
    "c": null,
    "o": [
      "Delegates part of generator's operations to another generator",
      "Yields from a list only",
      "Creates a thread pool",
      "Stops the generator immediately"
    ]
  },
  {
    "q": "Which built-in function provides the most accurate time for benchmarking?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "datetime.now()",
      "os.times()"
    ]
  },
  {
    "q": "Which code snippet uses a generator to yield cubes of numbers?",
    "c": null,
    "o": [
      "(x**3 for x in range(5))",
      "[x**3 for x in range(5)]",
      "{x**3 for x in range(5)}",
      "{x:x**3 for x in range(5)}"
    ]
  },
  {
    "q": "What is the best case time complexity of linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following constructs will yield values one at a time without storing them all in memory?",
    "c": null,
    "o": [
      "Generator",
      "List comprehension",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "Which function decorator in Python enables caching of function results?",
    "c": null,
    "o": [
      "@lru_cache",
      "@staticmethod",
      "@classmethod",
      "@memo"
    ]
  },
  {
    "q": "What is the time complexity of removing an element from the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following Python profiling tools provides cumulative time per function?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "dis",
      "resource"
    ]
  },
  {
    "q": "Which code snippet shows the correct way to implement memoization manually?",
    "c": "cache = {}\ndef fib(n):\n    if n in cache:\n        return cache[n]\n    if n <= 1:\n        result = n\n    else:\n        result = fib(n-1) + fib(n-2)\n    cache[n] = result\n    return result",
    "o": [
      "Manual memoization using a dictionary",
      "Generator-based implementation",
      "Recursion with list cache",
      "Iterative dynamic programming"
    ]
  },
  {
    "q": "Which method provides more accurate CPU timing in Python benchmarking?",
    "c": null,
    "o": [
      "time.process_time()",
      "time.time()",
      "datetime.now()",
      "os.clock()"
    ]
  },
  {
    "q": "What is the time complexity of inserting an item at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following expressions uses generator syntax?",
    "c": null,
    "o": [
      "(x for x in range(10))",
      "[x for x in range(10)]",
      "{x for x in range(10)}",
      "{x: x for x in range(10)}"
    ]
  },
  {
    "q": "Which Python library provides detailed memory usage statistics for each line of code?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "tracemalloc",
      "objgraph"
    ]
  },
  {
    "q": "Which time complexity class represents quadratic growth?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which Python feature allows you to pause and resume a function?",
    "c": null,
    "o": [
      "yield",
      "return",
      "break",
      "continue"
    ]
  },
  {
    "q": "Which of the following is the most memory-efficient way to process millions of items?",
    "c": null,
    "o": [
      "Using a generator",
      "Using a list",
      "Using a tuple",
      "Using a set"
    ]
  },
  {
    "q": "Which of these is NOT a valid reason to use `timeit`?",
    "c": null,
    "o": [
      "To measure memory usage",
      "To benchmark small code snippets",
      "To average execution time over multiple runs",
      "To get precise timing information"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "gen = (x for x in range(3))\nfor x in gen:\n    print(x, end=' ')",
    "o": [
      "0 1 2 ",
      "1 2 3 ",
      "0 2 ",
      "2 1 0 "
    ]
  },
  {
    "q": "Which of the following best describes the `cProfile` module?",
    "c": null,
    "o": [
      "It collects performance statistics about function calls",
      "It tracks memory allocation line-by-line",
      "It is used for writing test cases",
      "It is a command-line debugger"
    ]
  },
  {
    "q": "Which code snippet uses a generator expression correctly to filter odd numbers?",
    "c": null,
    "o": [
      "(x for x in range(10) if x % 2 != 0)",
      "[x for x in range(10) if x % 2 != 0]",
      "{x for x in range(10) if x % 2 != 0}",
      "set(x for x in range(10) if x % 2 != 0)"
    ]
  },
  {
    "q": "Which space complexity represents linear memory usage with respect to input size?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is a major benefit of `yield from` in Python?",
    "c": null,
    "o": [
      "It simplifies delegation to sub-generators",
      "It returns all values in a list",
      "It runs parallel threads",
      "It increases memory usage"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def test():\n    yield 5\n    yield 10\n    yield 15\n\ng = test()\nprint(next(g) + next(g))",
    "o": [
      "15",
      "10",
      "5",
      "25"
    ]
  },
  {
    "q": "Which of the following optimization techniques avoids recalculating results in recursive algorithms?",
    "c": null,
    "o": [
      "Memoization",
      "Loop unrolling",
      "Tail recursion",
      "Recursion depth limiting"
    ]
  },
  {
    "q": "What is the output of this generator code?",
    "c": "def countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\n\nprint(list(countdown(3)))",
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[3, 1]",
      "[2, 1]"
    ]
  },
  {
    "q": "Which Big-O notation represents the slowest growth rate?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "nums = (x for x in range(1, 5))\nprint(next(nums), next(nums))",
    "o": [
      "1 2",
      "2 3",
      "0 1",
      "4 5"
    ]
  },
  {
    "q": "Which of the following allows you to limit how many items are cached by lru_cache?",
    "c": null,
    "o": [
      "maxsize parameter",
      "timeout parameter",
      "depth parameter",
      "capacity argument"
    ]
  },
  {
    "q": "Which complexity class describes linearithmic growth?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which Python standard module is best for benchmarking small bits of code?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "tracemalloc",
      "unittest"
    ]
  },
  {
    "q": "Which of these data structures supports the fastest average-case lookup?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Deque"
    ]
  },
  {
    "q": "Which of the following is an advantage of generator functions?",
    "c": null,
    "o": [
      "They use less memory by yielding items one at a time",
      "They store all results in a list",
      "They execute all operations before yielding",
      "They support indexing like lists"
    ]
  },
  {
    "q": "Which of these best explains the purpose of `yield` in Python?",
    "c": null,
    "o": [
      "It pauses the function and returns a value without losing state",
      "It terminates the loop immediately",
      "It exits the function permanently",
      "It defines a static variable"
    ]
  },
  {
    "q": "What is the main benefit of using generators in Python for large datasets?",
    "c": null,
    "o": [
      "They use less memory by yielding one value at a time",
      "They compute values faster than lists",
      "They store all values in memory at once",
      "They support slicing operations"
    ]
  },
  {
    "q": "Which built-in Python decorator is commonly used to implement memoization?",
    "c": null,
    "o": [
      "@lru_cache",
      "@staticmethod",
      "@property",
      "@memoize"
    ]
  },
  {
    "q": "What is the worst-case time complexity for inserting an element at the beginning of a list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following profiling tools reports the number of calls and time per function?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "gc",
      "sys"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "def double():\n    for i in range(2):\n        yield i * 2\n\ng = double()\nprint(next(g), next(g))",
    "o": [
      "0 2",
      "2 4",
      "1 2",
      "0 1"
    ]
  },
  {
    "q": "Which optimization technique returns the output of previously computed results to save time?",
    "c": null,
    "o": [
      "Memoization",
      "Loop unrolling",
      "Short-circuiting",
      "Inlining"
    ]
  },
  {
    "q": "Which of the following describes O(log n) time complexity?",
    "c": null,
    "o": [
      "Time increases logarithmically with input size",
      "Time grows quadratically with input size",
      "Time remains constant regardless of input size",
      "Time grows linearly with input size"
    ]
  },
  {
    "q": "What is the output of the following generator expression?",
    "c": "squares = (x*x for x in range(3))\nprint(list(squares))",
    "o": [
      "[0, 1, 4]",
      "[1, 4, 9]",
      "[0, 2, 4]",
      "[1, 2, 3]"
    ]
  },
  {
    "q": "Which tool should you use to identify the most time-consuming parts of your code?",
    "c": null,
    "o": [
      "cProfile",
      "time.sleep",
      "tracemalloc",
      "functools"
    ]
  },
  {
    "q": "Which is more suitable when you only need to iterate over data once and don’t need to store it?",
    "c": null,
    "o": [
      "Generator",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "What is the time complexity of traversing all elements in a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of these techniques provides lazy evaluation in Python?",
    "c": null,
    "o": [
      "Generators",
      "Lists",
      "Tuples",
      "Sets"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "def gen():\n    yield from range(3)\n\nprint(list(gen()))",
    "o": [
      "[0, 1, 2]",
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[0, 1, 2, 3]"
    ]
  },
  {
    "q": "Which of the following statements about `@lru_cache` is TRUE?",
    "c": null,
    "o": [
      "It automatically caches the output of a function based on input arguments",
      "It disables caching and forces re-evaluation",
      "It only works on class methods",
      "It is slower than regular recursion"
    ]
  },
  {
    "q": "Which of the following gives the most accurate profiling of function calls?",
    "c": null,
    "o": [
      "cProfile",
      "time",
      "datetime",
      "print statements"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "x = (i for i in range(4))\nprint(sum(x))",
    "o": [
      "6",
      "10",
      "4",
      "3"
    ]
  },
  {
    "q": "Which is NOT an optimization advantage of using generators?",
    "c": null,
    "o": [
      "They support random access",
      "They are memory-efficient",
      "They use lazy evaluation",
      "They can represent infinite sequences"
    ]
  },
  {
    "q": "Which Python module would you use to track memory usage line-by-line in a script?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "gc",
      "timeit"
    ]
  },
  {
    "q": "What is the time complexity of appending an item to a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "from functools import lru_cache\n\n@lru_cache()\ndef square(x):\n    return x * x\n\nprint(square(4))",
    "o": [
      "16",
      "8",
      "4",
      "Error"
    ]
  },
  {
    "q": "Which of the following Python modules provides a decorator for caching function results?",
    "c": null,
    "o": [
      "functools",
      "os",
      "profile",
      "timeit"
    ]
  },
  {
    "q": "What is the main reason to use `timeit` instead of `time.time()`?",
    "c": null,
    "o": [
      "`timeit` reduces the impact of background processes by averaging over many runs",
      "`timeit` is faster",
      "`timeit` gives memory usage",
      "`timeit` works on compiled code only"
    ]
  },
  {
    "q": "What will the following generator produce?",
    "c": "def gen():\n    for i in range(3):\n        yield i**2\n\nprint(list(gen()))",
    "o": [
      "[0, 1, 4]",
      "[1, 4, 9]",
      "[1, 2, 3]",
      "[0, 2, 4]"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using list comprehensions over generators?",
    "c": null,
    "o": [
      "They consume more memory",
      "They are not syntactically supported",
      "They are slower in all cases",
      "They cannot use conditional logic"
    ]
  },
  {
    "q": "Which of these best describes space complexity?",
    "c": null,
    "o": [
      "Amount of memory required relative to input size",
      "Time required to complete the function",
      "Disk space used by files",
      "RAM installed in the system"
    ]
  },
  {
    "q": "What is the time complexity of searching an unsorted list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which tool would be best for identifying memory leaks?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "timeit",
      "argparse"
    ]
  },
  {
    "q": "Which code uses a generator correctly?",
    "c": "def squares():\n    for i in range(3):\n        yield i * i\n\nprint(next(squares()))",
    "o": [
      "0",
      "1",
      "2",
      "None"
    ]
  },
  {
    "q": "What is a key benefit of `yield` over `return` in terms of optimization?",
    "c": null,
    "o": [
      "It pauses function execution without losing state",
      "It ends the function immediately",
      "It is faster in all cases",
      "It returns multiple values at once"
    ]
  },
  {
    "q": "Which of the following statements about list comprehensions is FALSE?",
    "c": null,
    "o": [
      "They use less memory than generators",
      "They are generally faster than for-loops for small datasets",
      "They are concise and readable",
      "They can include conditions"
    ]
  },
  {
    "q": "Which complexity represents the worst-case time for traversing a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the key difference between a generator and a list comprehension?",
    "c": null,
    "o": [
      "Generators use lazy evaluation, list comprehensions do not",
      "Generators are always faster",
      "Generators return a list",
      "List comprehensions can’t use conditions"
    ]
  },
  {
    "q": "Which of the following Python modules is used for tracking peak memory usage?",
    "c": null,
    "o": [
      "memory_profiler",
      "timeit",
      "functools",
      "gc"
    ]
  },
  {
    "q": "Which technique can significantly reduce redundant function calls in recursive algorithms?",
    "c": null,
    "o": [
      "Memoization",
      "Loop unrolling",
      "Lazy loading",
      "Multithreading"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "def my_gen():\n    yield from [1, 2]\n    yield 3\n\nprint(list(my_gen()))",
    "o": [
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[1, 2]",
      "[2, 3]"
    ]
  },
  {
    "q": "Which is the average-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which option correctly uses a generator expression to filter even numbers?",
    "c": null,
    "o": [
      "(x for x in range(6) if x % 2 == 0)",
      "[x for x in range(6) if x % 2 == 0]",
      "{x for x in range(6) if x % 2 == 0}",
      "list(x for x in range(6) if x % 2 == 0)"
    ]
  },
  {
    "q": "Which module can show how much time each function takes, including sub-calls?",
    "c": null,
    "o": [
      "cProfile",
      "time",
      "sys",
      "os"
    ]
  },
  {
    "q": "Which of these is NOT a characteristic of generators?",
    "c": null,
    "o": [
      "They support random indexing",
      "They yield values one at a time",
      "They are memory efficient",
      "They use the `yield` keyword"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "def lazy():\n    yield 10\n    yield 20\n\ng = lazy()\nprint(next(g) + next(g))",
    "o": [
      "30",
      "10",
      "20",
      "Error"
    ]
  },
  {
    "q": "What is the time complexity of searching in a balanced binary search tree (BST)?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is the most efficient in terms of space usage for processing a large sequence?",
    "c": null,
    "o": [
      "Generator",
      "List",
      "Set",
      "Tuple"
    ]
  },
  {
    "q": "What will be the output of the following generator function?",
    "c": "def my_gen():\n    yield 1\n    yield 2\n    yield 3\n\nfor i in my_gen():\n    print(i, end=' ')",
    "o": [
      "1 2 3 ",
      "1 3 2 ",
      "3 2 1 ",
      "1 2 "
    ]
  },
  {
    "q": "Which of the following Python modules helps in analyzing both time and function call frequency?",
    "c": null,
    "o": [
      "cProfile",
      "memory_profiler",
      "functools",
      "time"
    ]
  },
  {
    "q": "Which data structure is the most optimal for checking existence of a key?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Deque"
    ]
  },
  {
    "q": "Which of the following is true about space complexity?",
    "c": null,
    "o": [
      "It is the total amount of memory used by an algorithm relative to input size",
      "It is only affected by loop counters",
      "It only refers to memory allocated on the heap",
      "It is always constant for all algorithms"
    ]
  },
  {
    "q": "Which expression creates a generator that yields squares of even numbers from 0 to 10?",
    "c": null,
    "o": [
      "(x**2 for x in range(11) if x % 2 == 0)",
      "[x**2 for x in range(11) if x % 2 == 0]",
      "{x**2 for x in range(11) if x % 2 == 0}",
      "[x for x in range(11) if x % 2 == 0]"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "from functools import lru_cache\n\n@lru_cache(maxsize=3)\ndef cube(n):\n    return n**3\n\nprint(cube(2))",
    "o": [
      "8",
      "6",
      "4",
      "None"
    ]
  },
  {
    "q": "What will happen if a generator is exhausted and `next()` is called again?",
    "c": null,
    "o": [
      "StopIteration is raised",
      "It restarts the generator",
      "It returns None",
      "It throws a TypeError"
    ]
  },
  {
    "q": "Which function would you use to find the execution time of a specific code snippet repeatedly?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "time.sleep()",
      "datetime.now()",
      "os.times()"
    ]
  },
  {
    "q": "Which of the following best describes Big-O notation?",
    "c": null,
    "o": [
      "It gives the upper bound of an algorithm's running time",
      "It gives the exact execution time of an algorithm",
      "It calculates space used by an algorithm in bytes",
      "It is used only for recursive algorithms"
    ]
  },
  {
    "q": "What is the output of the following generator expression?",
    "c": "g = (x*2 for x in range(4))\nprint(list(g))",
    "o": [
      "[0, 2, 4, 6]",
      "[2, 4, 6, 8]",
      "[1, 2, 3, 4]",
      "[0, 1, 2, 3]"
    ]
  },
  {
    "q": "What will happen if you call `next()` on an already exhausted generator?",
    "c": null,
    "o": [
      "It raises StopIteration",
      "It returns 0",
      "It restarts the generator",
      "It returns None"
    ]
  },
  {
    "q": "Which optimization technique avoids recalculating values in recursive functions?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion depth limiting",
      "Loop unrolling",
      "Branch prediction"
    ]
  },
  {
    "q": "What is the time complexity of a binary search algorithm?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following tools helps you understand the time each function takes in your Python code?",
    "c": null,
    "o": [
      "cProfile",
      "unittest",
      "argparse",
      "heapq"
    ]
  },
  {
    "q": "Which of the following is the correct way to define a generator function?",
    "c": null,
    "o": [
      "Using the `yield` keyword",
      "Using the `return` keyword",
      "Using the `lambda` keyword",
      "Using the `yield return` keyword"
    ]
  },
  {
    "q": "Which scenario is most suitable for using a generator?",
    "c": null,
    "o": [
      "Processing a large file line-by-line",
      "Storing a list of users in memory",
      "Performing matrix operations",
      "Sorting small arrays"
    ]
  },
  {
    "q": "What is the default value of `maxsize` in Python’s `@lru_cache`?",
    "c": null,
    "o": [
      "128",
      "None",
      "256",
      "0"
    ]
  },
  {
    "q": "Which of the following statements about generators is FALSE?",
    "c": null,
    "o": [
      "They can be iterated multiple times automatically",
      "They use lazy evaluation",
      "They do not store all values in memory",
      "They are created using the `yield` keyword"
    ]
  },
  {
    "q": "Which of the following will consume the least amount of memory when iterating over a large sequence?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "What is the time complexity of finding the maximum element in an unsorted list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which method would you use to profile how much memory each line of code consumes?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "timeit",
      "functools"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "def g():\n    yield 1\n    yield 2\n    yield 3\n\na = g()\nnext(a)\nnext(a)\nprint(next(a))",
    "o": [
      "3",
      "2",
      "1",
      "None"
    ]
  },
  {
    "q": "Which of the following Python modules allows you to profile time consumption by functions, including nested calls?",
    "c": null,
    "o": [
      "cProfile",
      "time",
      "os",
      "inspect"
    ]
  },
  {
    "q": "What is the average-case time complexity of inserting a value into a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following allows you to combine the results of multiple generators in a clean and simple way?",
    "c": null,
    "o": [
      "yield from",
      "yield +",
      "yield all",
      "return from"
    ]
  },
  {
    "q": "Which code snippet uses a generator expression to yield only odd numbers?",
    "c": null,
    "o": [
      "(x for x in range(10) if x % 2 == 1)",
      "[x for x in range(10) if x % 2 == 1]",
      "{x for x in range(10) if x % 2 == 1}",
      "x for x in range(10) if x % 2 == 1"
    ]
  },
  {
    "q": "What is the worst-case time complexity for deleting an element from a Python list by value?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the primary use of `functools.lru_cache` in Python?",
    "c": null,
    "o": [
      "To cache function results and improve performance of repeated calls",
      "To limit function execution to a certain number of times",
      "To memoize function definitions",
      "To sort cached elements in LRU order"
    ]
  },
  {
    "q": "What is the key difference between `timeit` and `time` in Python?",
    "c": null,
    "o": [
      "`timeit` is more accurate for benchmarking small code snippets",
      "`time` is faster and always preferred",
      "`time` can be used in loops, `timeit` cannot",
      "`timeit` is a third-party module"
    ]
  },
  {
    "q": "What does the following generator function yield?",
    "c": "def counter():\n    i = 0\n    while i < 3:\n        yield i\n        i += 1\n\nprint(list(counter()))",
    "o": [
      "[0, 1, 2]",
      "[1, 2, 3]",
      "[0, 1, 2, 3]",
      "[1, 2]"
    ]
  },
  {
    "q": "Which Big-O notation represents the best possible scenario for an algorithm?",
    "c": null,
    "o": [
      "Ω (Omega)",
      "O (Big O)",
      "θ (Theta)",
      "π (Pi)"
    ]
  },
  {
    "q": "Which optimization technique improves performance by avoiding repeated function evaluations?",
    "c": null,
    "o": [
      "Caching",
      "Short-circuiting",
      "Pipelining",
      "Loop flattening"
    ]
  },
  {
    "q": "Which of the following does NOT use lazy evaluation?",
    "c": null,
    "o": [
      "List comprehension",
      "Generator expression",
      "map with lambda",
      "yield-based function"
    ]
  },
  {
    "q": "What will be printed by the code below?",
    "c": "def example():\n    yield 'A'\n    yield 'B'\n\nx = example()\nprint(next(x))\nprint(next(x))",
    "o": [
      "A\nB",
      "B\nA",
      "A\nA",
      "B\nB"
    ]
  },
  {
    "q": "Which function from `functools` is used to store results of expensive function calls?",
    "c": null,
    "o": [
      "lru_cache",
      "partial",
      "wraps",
      "reduce"
    ]
  },
  {
    "q": "What is the worst-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which Python feature allows for memory-efficient iteration over a sequence?",
    "c": null,
    "o": [
      "Generator",
      "List",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "Which of the following is true about Python’s `cProfile` module?",
    "c": null,
    "o": [
      "It provides detailed performance statistics for function calls",
      "It only profiles memory usage",
      "It runs only on Windows",
      "It only works with async functions"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def func():\n    yield 10\n    yield 20\n    yield 30\n\nf = func()\nprint(sum(f))",
    "o": [
      "60",
      "30",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following methods is best suited for benchmarking short snippets of code accurately?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "datetime.now()",
      "time.perf_counter()",
      "print(time.time())"
    ]
  },
  {
    "q": "What is the space complexity of storing an array of n integers?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which built-in feature in Python allows profiling of both time and number of function calls?",
    "c": null,
    "o": [
      "cProfile",
      "pdb",
      "timeit",
      "gc"
    ]
  },
  {
    "q": "Which type of list structure would be best when memory is a major constraint?",
    "c": null,
    "o": [
      "Generator",
      "List comprehension",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "What does the `maxsize` parameter in `@lru_cache` control?",
    "c": null,
    "o": [
      "Number of recent calls to cache",
      "Size of function arguments",
      "Memory usage of return values",
      "Execution time limit"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "gen = (i**2 for i in range(3))\nfor val in gen:\n    print(val)",
    "o": [
      "0\n1\n4",
      "1\n2\n3",
      "0\n2\n4",
      "1\n4\n9"
    ]
  },
  {
    "q": "Which of the following is a benefit of using list comprehension?",
    "c": null,
    "o": [
      "More concise and often faster than a loop",
      "Lower memory usage than generators",
      "Can’t use conditions",
      "Slower than regular for-loops"
    ]
  },
  {
    "q": "Which type of complexity does `O(1)` describe?",
    "c": null,
    "o": [
      "Constant time",
      "Linear time",
      "Logarithmic time",
      "Quadratic time"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def numbers():\n    yield 5\n    yield 10\n    yield 15\n\nn = numbers()\nprint(next(n), next(n))",
    "o": [
      "5 10",
      "10 15",
      "5 15",
      "15 10"
    ]
  },
  {
    "q": "Which of the following is a characteristic of algorithms with O(n^2) time complexity?",
    "c": null,
    "o": [
      "Execution time grows quadratically with input size",
      "Execution time grows logarithmically with input size",
      "Execution time stays constant regardless of input size",
      "Execution time grows exponentially"
    ]
  },
  {
    "q": "Which keyword is used in Python to define a generator function?",
    "c": null,
    "o": [
      "yield",
      "return",
      "def",
      "gen"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "def repeat():\n    for i in range(1, 4):\n        yield i\n\nr = repeat()\nprint(list(r))",
    "o": [
      "[1, 2, 3]",
      "[0, 1, 2]",
      "[2, 3, 4]",
      "[1, 2, 3, 4]"
    ]
  },
  {
    "q": "Which scenario is ideal for using list comprehensions?",
    "c": null,
    "o": [
      "When transforming a sequence into a new list with a simple expression",
      "When dealing with infinite sequences",
      "When reading data lazily from a file",
      "When memory usage must be minimized"
    ]
  },
  {
    "q": "Which of the following is true about the `timeit` module?",
    "c": null,
    "o": [
      "It runs the code snippet multiple times to get accurate timing",
      "It measures memory consumption",
      "It profiles recursive functions",
      "It pauses the execution for a given time"
    ]
  },
  {
    "q": "Which data structure has the average-case time complexity O(1) for insertion and lookup?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "def infinite():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\ng = infinite()\nprint(next(g), next(g), next(g))",
    "o": [
      "0 1 2",
      "1 2 3",
      "0 0 0",
      "1 1 1"
    ]
  },
  {
    "q": "Which of the following best defines the purpose of Big-O notation?",
    "c": null,
    "o": [
      "To describe algorithm scalability with input size",
      "To show the exact execution time",
      "To explain algorithm correctness",
      "To compare memory models"
    ]
  },
  {
    "q": "Which of the following profiling tools is part of the Python standard library?",
    "c": null,
    "o": [
      "cProfile",
      "line_profiler",
      "memory_profiler",
      "snakeviz"
    ]
  },
  {
    "q": "What is the space complexity of creating a list with n elements?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which scenario would benefit the most from using a generator instead of a list?",
    "c": null,
    "o": [
      "Reading a large file line by line",
      "Storing all Fibonacci numbers up to 10000",
      "Filtering a short list of integers",
      "Displaying a static list of menu options"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "def test():\n    yield 2\n    return 5\n\nt = test()\nprint(next(t))",
    "o": [
      "2",
      "5",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of these operations has O(1) average time complexity in a Python set?",
    "c": null,
    "o": [
      "Membership test (e.g., `x in s`)",
      "Sorting the set",
      "Iterating over all elements",
      "Converting to a list"
    ]
  },
  {
    "q": "Which of the following optimization techniques avoids recalculating values by storing previous results?",
    "c": null,
    "o": [
      "Memoization",
      "Loop fusion",
      "Tail recursion",
      "Recursion limiting"
    ]
  },
  {
    "q": "Which of the following tools can visualize profiling output from cProfile?",
    "c": null,
    "o": [
      "snakeviz",
      "timeit",
      "argparse",
      "gc"
    ]
  },
  {
    "q": "What is the worst-case time complexity for searching in a hash table with poor hash function?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the following generator expression produce?",
    "c": "gen = (i for i in range(1, 6) if i % 2 == 0)\nprint(list(gen))",
    "o": [
      "[2, 4]",
      "[1, 3, 5]",
      "[2, 3, 4]",
      "[1, 2, 3, 4, 5]"
    ]
  },
  {
    "q": "Which technique is commonly used in profiling to reduce overhead?",
    "c": null,
    "o": [
      "Sampling",
      "Dynamic compilation",
      "Constant folding",
      "Tail-call optimization"
    ]
  },
  {
    "q": "What is the key feature of lazy evaluation in generators?",
    "c": null,
    "o": [
      "Values are produced only when needed",
      "All values are stored in memory",
      "Faster than list comprehensions in all cases",
      "Supports random access"
    ]
  },
  {
    "q": "Which keyword is required to return values one at a time from a generator function?",
    "c": null,
    "o": [
      "yield",
      "return",
      "break",
      "pass"
    ]
  },
  {
    "q": "What will be the output of this generator-based code?",
    "c": "def gen():\n    yield from [10, 20, 30]\n\nfor val in gen():\n    print(val, end=' ')",
    "o": [
      "10 20 30 ",
      "10 30 20 ",
      "30 20 10 ",
      "20 30 40 "
    ]
  },
  {
    "q": "Which of the following profiling methods is most useful for identifying bottlenecks in deeply nested function calls?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "tracemalloc",
      "gc.collect()"
    ]
  },
  {
    "q": "What is the key advantage of `@lru_cache` in recursive functions like Fibonacci?",
    "c": null,
    "o": [
      "It avoids redundant recursive calls",
      "It increases recursion depth",
      "It sorts the output",
      "It simplifies the syntax"
    ]
  },
  {
    "q": "What does the following list comprehension produce?",
    "c": "[x**2 for x in range(5) if x % 2 == 0]",
    "o": [
      "[0, 4, 16]",
      "[1, 4, 9, 16]",
      "[0, 1, 4, 9, 16]",
      "[2, 6, 10]"
    ]
  },
  {
    "q": "What will happen if you repeatedly call `next()` on a generator that has no more values?",
    "c": null,
    "o": [
      "A StopIteration exception is raised",
      "It returns None",
      "It loops back to the first value",
      "It returns the last value"
    ]
  },
  {
    "q": "Which of the following functions provides more fine-grained time measurement?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "datetime.now()",
      "os.times()"
    ]
  },
  {
    "q": "Which optimization technique helps reduce time complexity by eliminating repeated computation?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Loop unrolling",
      "Heapsort"
    ]
  },
  {
    "q": "Which expression correctly creates a generator for the cubes of numbers 0 through 4?",
    "c": null,
    "o": [
      "(x**3 for x in range(5))",
      "[x**3 for x in range(5)]",
      "{x**3 for x in range(5)}",
      "tuple(x**3 for x in range(5))"
    ]
  },
  {
    "q": "In which scenario is using `yield` more beneficial than `return`?",
    "c": null,
    "o": [
      "When returning a large or infinite sequence",
      "When returning a constant value",
      "When returning multiple values at once",
      "When optimizing CPU cache"
    ]
  },
  {
    "q": "What is the best-case time complexity for linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element at a specific index in a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following optimization techniques does NOT reduce memory usage?",
    "c": null,
    "o": [
      "Loop unrolling",
      "Generators",
      "Yield statements",
      "Lazy evaluation"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "def counter():\n    yield 1\n    yield 2\n\nc = counter()\nprint(next(c))\nprint(next(c))",
    "o": [
      "1\n2",
      "1\n1",
      "2\n1",
      "2\n2"
    ]
  },
  {
    "q": "Which Python module can help analyze the line-by-line memory usage of a program?",
    "c": null,
    "o": [
      "memory_profiler",
      "timeit",
      "cProfile",
      "tracemalloc"
    ]
  },
  {
    "q": "Which of the following is true about generators?",
    "c": null,
    "o": [
      "They produce items one at a time and save memory",
      "They store all items in memory",
      "They allow random access to elements",
      "They are slower than list comprehensions"
    ]
  },
  {
    "q": "What is the purpose of the `yield from` syntax in a generator?",
    "c": null,
    "o": [
      "To delegate part of a generator’s operations to another generator",
      "To return a list from a generator",
      "To convert a function into a generator",
      "To precompute values for a generator"
    ]
  },
  {
    "q": "Which complexity class grows the fastest as input size increases?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n^2)",
      "O(n log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which code snippet correctly uses `lru_cache` to cache function results?",
    "c": "from functools import lru_cache\n\n@lru_cache(maxsize=32)\ndef square(n):\n    return n * n\n\nprint(square(4))",
    "o": [
      "16",
      "4",
      "8",
      "Error"
    ]
  },
  {
    "q": "What is the benefit of using `timeit.repeat()` over `timeit.timeit()`?",
    "c": null,
    "o": [
      "It runs multiple timing sessions to analyze consistency",
      "It returns the average time directly",
      "It profiles memory usage",
      "It is deprecated in Python 3"
    ]
  },
  {
    "q": "Which of the following generator expressions filters even numbers and yields their squares?",
    "c": null,
    "o": [
      "(x**2 for x in range(10) if x % 2 == 0)",
      "(x for x in range(10) if x % 2 == 0)",
      "(x**2 for x in range(10))",
      "(x*x for x in range(10) if x % 2)"
    ]
  },
  {
    "q": "Which of the following statements about list comprehensions is true?",
    "c": null,
    "o": [
      "They are generally faster and more concise than equivalent for-loops",
      "They always use less memory than generators",
      "They are only used for filtering lists",
      "They cannot include conditionals"
    ]
  },
  {
    "q": "Which of the following best describes the benefit of using a generator over a list?",
    "c": null,
    "o": [
      "Generators are more memory-efficient for large or infinite data streams",
      "Generators execute faster in all cases",
      "Generators support random indexing",
      "Generators can be converted to lists in constant time"
    ]
  },
  {
    "q": "Which of these has the worst-case time complexity of O(n log n)?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Linear Search",
      "Binary Search"
    ]
  },
  {
    "q": "What does the following generator do?",
    "c": "def numbers():\n    for i in range(2):\n        yield i\n\nx = numbers()\nprint(list(x))",
    "o": [
      "[0, 1]",
      "[1, 2]",
      "[0, 1, 2]",
      "[2, 3]"
    ]
  },
  {
    "q": "Which of the following can help optimize time complexity by precomputing values?",
    "c": null,
    "o": [
      "Memoization",
      "Iteration",
      "Slicing",
      "Recursion"
    ]
  },
  {
    "q": "Which metric does the `timeit` module return?",
    "c": null,
    "o": [
      "Execution time in seconds",
      "Memory usage in bytes",
      "Call count of functions",
      "Execution frequency per second"
    ]
  },
  {
    "q": "What is the benefit of using `@lru_cache` in recursive algorithms?",
    "c": null,
    "o": [
      "Reduces recomputation by storing previous results",
      "Adds threading support",
      "Increases recursion depth limit",
      "Reduces memory usage"
    ]
  },
  {
    "q": "What is the best-case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "What does the following generator return?",
    "c": "def mygen():\n    yield 1\n    yield 2\n    yield 3\n\nprint(sum(mygen()))",
    "o": [
      "6",
      "3",
      "1",
      "Error"
    ]
  },
  {
    "q": "Which of the following Python tools can analyze both time and number of calls to each function?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "gc",
      "functools"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "def gen():\n    yield 1\n    yield 2\n    yield 3\n\ng = gen()\nprint(next(g) + next(g))",
    "o": [
      "3",
      "1",
      "2",
      "6"
    ]
  },
  {
    "q": "Which of the following complexities grows faster than O(n log n)?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which module is most suitable for line-by-line performance analysis?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "timeit",
      "tracemalloc"
    ]
  },
  {
    "q": "Which of these is a major limitation of using lists over generators for large datasets?",
    "c": null,
    "o": [
      "High memory usage",
      "Inability to iterate",
      "Slower indexing",
      "No conditional support"
    ]
  },
  {
    "q": "Which expression creates a generator that yields even numbers from 0 to 10?",
    "c": null,
    "o": [
      "(x for x in range(11) if x % 2 == 0)",
      "[x for x in range(11) if x % 2 == 0]",
      "{x for x in range(11) if x % 2 == 0}",
      "x for x in range(11) if x % 2 == 0"
    ]
  },
  {
    "q": "What does the `maxsize` parameter in `lru_cache` control?",
    "c": null,
    "o": [
      "The number of most recent function calls to cache",
      "The maximum argument size for the function",
      "The memory size limit of the function return values",
      "The number of threads that can access the cache"
    ]
  },
  {
    "q": "What is the typical time complexity of inserting an element at the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does `yield from` do in a generator?",
    "c": null,
    "o": [
      "Delegates part of a generator’s operations to another iterable",
      "Returns all values at once",
      "Creates a list of yielded items",
      "Inverts the generator’s output"
    ]
  },
  {
    "q": "Which of the following is a benefit of using `time.perf_counter()`?",
    "c": null,
    "o": [
      "High-resolution timer ideal for benchmarking",
      "It shows CPU usage",
      "It returns memory allocation",
      "It logs function names"
    ]
  },
  {
    "q": "Which data structure provides O(1) average case for search, insert, and delete?",
    "c": null,
    "o": [
      "Hash table",
      "Binary search tree",
      "Linked list",
      "Stack"
    ]
  },
  {
    "q": "Which complexity class describes an algorithm whose execution time doubles with each additional input?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n!)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "def generate():\n    yield 0\n    yield 1\n    yield 2\n\nx = generate()\nfor i in x:\n    print(i, end=' ')",
    "o": [
      "0 1 2 ",
      "1 2 3 ",
      "0 1 ",
      "2 1 0 "
    ]
  },
  {
    "q": "Which technique improves performance by combining multiple loops into one?",
    "c": null,
    "o": [
      "Loop fusion",
      "Memoization",
      "Recursion",
      "Branch prediction"
    ]
  },
  {
    "q": "What is the primary reason for using a generator instead of a list?",
    "c": null,
    "o": [
      "To save memory by yielding items one at a time",
      "To allow random access",
      "To sort elements automatically",
      "To enable thread safety"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(5))",
    "o": [
      "5",
      "3",
      "8",
      "2"
    ]
  },
  {
    "q": "Which Python function is best for benchmarking a small code snippet?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "time.sleep()",
      "os.clock()",
      "datetime.now()"
    ]
  },
  {
    "q": "Which of the following generator expressions will yield square numbers from 1 to 9?",
    "c": null,
    "o": [
      "(x**2 for x in range(1, 4))",
      "(x for x in range(1, 10))",
      "(x**2 for x in range(1, 10, 3))",
      "(x**0.5 for x in range(1, 10))"
    ]
  },
  {
    "q": "What is the time complexity of checking membership in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which tool in Python is used to track memory blocks allocated by the interpreter?",
    "c": null,
    "o": [
      "tracemalloc",
      "memory_profiler",
      "timeit",
      "gc"
    ]
  },
  {
    "q": "Which of the following expressions returns a generator object?",
    "c": null,
    "o": [
      "(x for x in range(3))",
      "[x for x in range(3)]",
      "{x for x in range(3)}",
      "tuple(x for x in range(3))"
    ]
  },
  {
    "q": "Which of the following techniques ensures that previously computed values are reused to save time?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Iteration",
      "Branching"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "def sequence():\n    for i in range(3):\n        yield i\n\ns = sequence()\nprint(next(s), next(s))",
    "o": [
      "0 1",
      "1 2",
      "0 2",
      "2 3"
    ]
  },
  {
    "q": "Which of the following is not a feature of generators in Python?",
    "c": null,
    "o": [
      "They support random indexing",
      "They are memory efficient",
      "They can be iterated only once",
      "They use the `yield` keyword"
    ]
  },
  {
    "q": "What does `timeit.timeit()` return by default?",
    "c": null,
    "o": [
      "Total execution time in seconds",
      "Execution time per iteration",
      "Execution time in milliseconds",
      "Memory usage in bytes"
    ]
  },
  {
    "q": "Which of the following functions will create a generator that yields values from 0 to 2?",
    "c": null,
    "o": [
      "def g():\n    yield 0\n    yield 1\n    yield 2",
      "def g():\n    return [0, 1, 2]",
      "def g():\n    yield [0, 1, 2]",
      "def g():\n    return range(3)"
    ]
  },
  {
    "q": "What is the space complexity of a recursive factorial function (ignoring tail call optimization)?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n!)"
    ]
  },
  {
    "q": "What tool is best suited for detecting memory leaks in Python?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "timeit",
      "argparse"
    ]
  },
  {
    "q": "Which of the following Python statements creates a memory-efficient iterator?",
    "c": null,
    "o": [
      "(x for x in range(1000000))",
      "[x for x in range(1000000)]",
      "{x for x in range(1000000)}",
      "list(range(1000000))"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def stream():\n    yield 'a'\n    yield 'b'\n    yield 'c'\n\ns = stream()\nprint(len(list(s)))",
    "o": [
      "3",
      "2",
      "1",
      "Error"
    ]
  },
  {
    "q": "Which profiling method in Python helps analyze how many times and how long functions take to execute?",
    "c": null,
    "o": [
      "cProfile",
      "tracemalloc",
      "line_profiler",
      "memory_profiler"
    ]
  },
  {
    "q": "What does the `yield` keyword do in a Python function?",
    "c": null,
    "o": [
      "It returns a generator object and pauses the function state",
      "It terminates the function and returns a value",
      "It raises an exception",
      "It imports a module lazily"
    ]
  },
  {
    "q": "Which of these is most suitable for analyzing which lines of code consume the most memory?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "gc",
      "timeit"
    ]
  },
  {
    "q": "What is the average-case time complexity of binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def gen():\n    yield 'X'\n    yield 'Y'\n    yield 'Z'\n\nprint(''.join(gen()))",
    "o": [
      "XYZ",
      "ZYX",
      "X Y Z",
      "['X', 'Y', 'Z']"
    ]
  },
  {
    "q": "Which of the following reduces both execution time and improves code clarity?",
    "c": null,
    "o": [
      "List comprehensions",
      "Nested loops",
      "Global variables",
      "Recursion"
    ]
  },
  {
    "q": "Which of these functions provides the highest resolution timer for performance testing?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "datetime.datetime.now()",
      "os.times()"
    ]
  },
  {
    "q": "What is the best-case time complexity of insertion sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(1)"
    ]
  },
  {
    "q": "What is the result of this list comprehension?\n[x for x in range(5) if x > 2]",
    "c": null,
    "o": [
      "[3, 4]",
      "[0, 1, 2]",
      "[2, 3, 4]",
      "[1, 2, 3, 4]"
    ]
  },
  {
    "q": "Which of the following helps determine the most time-consuming function in a Python script?",
    "c": null,
    "o": [
      "cProfile",
      "sys.argv",
      "gc.collect()",
      "os.getenv()"
    ]
  },
  {
    "q": "Which of these is NOT an advantage of using generator expressions?",
    "c": null,
    "o": [
      "They support random access",
      "They are memory-efficient",
      "They use lazy evaluation",
      "They allow iteration over infinite sequences"
    ]
  },
  {
    "q": "Which of the following data structures provides O(1) time complexity for append operations?",
    "c": null,
    "o": [
      "Python list (using append)",
      "Python tuple",
      "Set",
      "Deque (from left)"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "def countdown():\n    yield 3\n    yield 2\n    yield 1\n\nprint(list(countdown()))",
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "(3, 2, 1)",
      "{1, 2, 3}"
    ]
  },
  {
    "q": "Which of the following time complexities represents a logarithmic algorithm?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What does `functools.lru_cache()` do internally?",
    "c": null,
    "o": [
      "Caches results of function calls to avoid redundant calculations",
      "Logs function execution times",
      "Tracks recursion depth",
      "Disables garbage collection"
    ]
  },
  {
    "q": "Which tool is used to trace memory blocks allocated by Python code?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "timeit",
      "argparse"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "squares = (x*x for x in range(4))\nprint(next(squares), next(squares))",
    "o": [
      "0 1",
      "1 4",
      "1 2",
      "0 4"
    ]
  },
  {
    "q": "Which space complexity class represents constant memory usage?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of list comprehensions?",
    "c": null,
    "o": [
      "They may consume more memory than generators for large datasets",
      "They are slower than for-loops",
      "They cannot include conditions",
      "They only work with integers"
    ]
  },
  {
    "q": "What does the following comprehension create?\n`[x for x in range(10) if x % 3 == 0]`",
    "c": null,
    "o": [
      "[0, 3, 6, 9]",
      "[3, 6, 9]",
      "[0, 3, 6]",
      "[1, 4, 7]"
    ]
  },
  {
    "q": "What is the main reason to use `yield from` instead of a `for` loop inside a generator?",
    "c": null,
    "o": [
      "To simplify code delegation to sub-generators",
      "To improve performance for all use cases",
      "To allow early stopping",
      "To return multiple values at once"
    ]
  },
  {
    "q": "Which of the following best defines time complexity?",
    "c": null,
    "o": [
      "It describes how the runtime of an algorithm scales with input size",
      "It describes the amount of memory an algorithm uses",
      "It indicates the power usage of an algorithm",
      "It measures disk space needed by the algorithm"
    ]
  },
  {
    "q": "What is the primary use of the `cProfile` module?",
    "c": null,
    "o": [
      "To analyze the performance and call frequency of functions",
      "To measure disk I/O speed",
      "To encrypt Python scripts",
      "To perform type checking at runtime"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "def seq():\n    for i in range(2, 5):\n        yield i\n\nprint(list(seq()))",
    "o": [
      "[2, 3, 4]",
      "[1, 2, 3, 4]",
      "[0, 1, 2]",
      "[3, 4, 5]"
    ]
  },
  {
    "q": "Which optimization technique allows skipping recalculations of previously seen results?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Loop nesting",
      "Randomization"
    ]
  },
  {
    "q": "What is a key advantage of using generator functions in Python?",
    "c": null,
    "o": [
      "They produce values lazily, reducing memory usage",
      "They automatically parallelize computation",
      "They improve accuracy of results",
      "They return sorted results"
    ]
  },
  {
    "q": "What does `@lru_cache` do when used as a decorator?",
    "c": null,
    "o": [
      "Caches the return values of the function for faster repeated calls",
      "Runs the function only once",
      "Limits the recursion depth of a function",
      "Stores arguments in a file"
    ]
  },
  {
    "q": "Which of the following comprehensions will output the squares of odd numbers from 0 to 9?",
    "c": null,
    "o": [
      "[x**2 for x in range(10) if x % 2 == 1]",
      "[x**2 for x in range(10) if x % 2 == 0]",
      "[x for x in range(10)]",
      "(x**2 for x in range(10) if x % 2 == 0)"
    ]
  },
  {
    "q": "What is the space complexity of an algorithm that uses no extra space beyond input variables?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following describes a situation where list comprehensions might be suboptimal?",
    "c": null,
    "o": [
      "When generating a very large list that may not fit in memory",
      "When filtering a small list",
      "When the result needs to be sorted",
      "When dealing with fixed-size output"
    ]
  },
  {
    "q": "What happens when `next()` is called on a generator that has no more items?",
    "c": null,
    "o": [
      "A StopIteration exception is raised",
      "None is returned",
      "The generator restarts",
      "Zero is returned"
    ]
  },
  {
    "q": "Which of the following operations has O(n) time complexity on a Python list?",
    "c": null,
    "o": [
      "Inserting at the beginning",
      "Appending at the end",
      "Accessing by index",
      "Checking length"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "def repeat():\n    yield from 'abc'\n\nprint(list(repeat()))",
    "o": [
      "['a', 'b', 'c']",
      "['abc']",
      "['a', 'c', 'b']",
      "['a b c']"
    ]
  },
  {
    "q": "Which of the following is true about the `timeit` module?",
    "c": null,
    "o": [
      "It avoids common timing traps like system clock adjustments",
      "It measures memory usage",
      "It returns results in milliseconds by default",
      "It replaces cProfile automatically"
    ]
  },
  {
    "q": "Which complexity class represents exponential growth?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n^2)",
      "O(n log n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which technique would you use to return elements one by one instead of building a full list?",
    "c": null,
    "o": [
      "Generator",
      "Set",
      "Tuple",
      "List comprehension"
    ]
  },
  {
    "q": "Which of these will consume the most memory for large datasets?",
    "c": null,
    "o": [
      "[x for x in range(10**6)]",
      "(x for x in range(10**6))",
      "range(10**6)",
      "map(int, range(10**6))"
    ]
  },
  {
    "q": "What is the average-case time complexity for accessing an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the `next()` function do when called on a generator?",
    "c": null,
    "o": [
      "Returns the next value produced by the generator",
      "Starts the generator again",
      "Deletes the generator object",
      "Returns all remaining values as a list"
    ]
  },
  {
    "q": "What is the main reason to prefer generator expressions over list comprehensions in some scenarios?",
    "c": null,
    "o": [
      "Generators are more memory efficient for large sequences",
      "Generators are faster for all use cases",
      "Generators support indexing",
      "Generators can be reversed easily"
    ]
  },
  {
    "q": "Which of the following statements about space complexity is true?",
    "c": null,
    "o": [
      "It measures the amount of memory required by an algorithm",
      "It refers only to the size of the input",
      "It depends only on recursion depth",
      "It is always the same as time complexity"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def letters():\n    yield 'x'\n    yield 'y'\n    yield 'z'\n\nfor c in letters():\n    print(c, end=' ')",
    "o": [
      "x y z ",
      "xyz",
      "['x', 'y', 'z']",
      "x, y, z"
    ]
  },
  {
    "q": "Which of these is the most suitable tool for identifying which functions take the most cumulative time?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "gc",
      "sys"
    ]
  },
  {
    "q": "What is the space complexity of an algorithm that uses a list of size `n` and a constant number of variables?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which expression correctly returns a generator of lowercase letters from 'a' to 'e'?",
    "c": null,
    "o": [
      "(chr(x) for x in range(97, 102))",
      "[chr(x) for x in range(97, 102)]",
      "{chr(x) for x in range(97, 102)}",
      "tuple(chr(x) for x in range(97, 102))"
    ]
  },
  {
    "q": "Which of the following is true about `yield from`?",
    "c": null,
    "o": [
      "It delegates part of a generator’s operations to another iterable",
      "It causes the generator to end immediately",
      "It converts a list into a generator",
      "It creates a new thread"
    ]
  },
  {
    "q": "Which of the following scenarios is ideal for using `timeit`?",
    "c": null,
    "o": [
      "Comparing execution time of two small code snippets",
      "Measuring the memory footprint of an algorithm",
      "Profiling recursive call chains",
      "Inspecting memory leaks"
    ]
  },
  {
    "q": "Which of the following is a benefit of list comprehensions?",
    "c": null,
    "o": [
      "Concise and usually faster than traditional loops",
      "Better for infinite sequences",
      "Always uses less memory than a generator",
      "Preferred for profiling function calls"
    ]
  },
  {
    "q": "Which operation has O(log n) complexity in a balanced binary search tree?",
    "c": null,
    "o": [
      "Search",
      "Traversal",
      "Insertion at end",
      "Access by index"
    ]
  },
  {
    "q": "Which tool should be used to identify the exact lines of code that allocate the most memory?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "timeit",
      "linecache"
    ]
  },
  {
    "q": "What does this generator do?\n`def gen(): yield from range(3)`",
    "c": null,
    "o": [
      "Yields 0, 1, 2",
      "Returns 0, 1, 2 at once",
      "Yields 1, 2, 3",
      "Raises an error"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def values():\n    for i in range(1, 4):\n        yield i * 10\n\nv = values()\nprint(next(v), next(v))",
    "o": [
      "10 20",
      "1 2",
      "10 30",
      "20 30"
    ]
  },
  {
    "q": "Which of the following has the highest time complexity?",
    "c": null,
    "o": [
      "O(n!)",
      "O(n^2)",
      "O(n log n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which Python module is best for identifying memory leaks?",
    "c": null,
    "o": [
      "tracemalloc",
      "timeit",
      "os",
      "platform"
    ]
  },
  {
    "q": "Which is true about generator objects in Python?",
    "c": null,
    "o": [
      "They maintain their state between calls",
      "They store all elements in memory",
      "They cannot be used in loops",
      "They are slower than list comprehensions"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "nums = (x**2 for x in range(3))\nfor n in nums:\n    print(n)",
    "o": [
      "0\n1\n4",
      "1\n4\n9",
      "0\n1\n2",
      "1\n2\n3"
    ]
  },
  {
    "q": "Which tool helps find how often and how long Python functions are executed?",
    "c": null,
    "o": [
      "cProfile",
      "tracemalloc",
      "gc",
      "argparse"
    ]
  },
  {
    "q": "Which of the following Python techniques supports lazy evaluation?",
    "c": null,
    "o": [
      "Generator expressions",
      "List comprehensions",
      "Tuple unpacking",
      "Lambda functions"
    ]
  },
  {
    "q": "Which of the following best describes space complexity?",
    "c": null,
    "o": [
      "Memory required relative to input size",
      "Disk space needed by the application",
      "CPU cycles per operation",
      "Execution time for nested loops"
    ]
  },
  {
    "q": "Which optimization technique should be used when reusing computed results?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Pipelining",
      "Mutation"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def letters():\n    yield from ['a', 'b', 'c']\n\nprint(''.join(letters()))",
    "o": [
      "abc",
      "a b c",
      "[a, b, c]",
      "None"
    ]
  },
  {
    "q": "What is the worst-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these will return a generator object?",
    "c": null,
    "o": [
      "(x for x in range(5))",
      "[x for x in range(5)]",
      "{x for x in range(5)}",
      "tuple(x for x in range(5))"
    ]
  },
  {
    "q": "Which technique avoids repeated function calls with the same parameters?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Iteration",
      "Randomization"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "def f():\n    yield 5\n    yield 10\n\nx = f()\nprint(next(x))",
    "o": [
      "5",
      "10",
      "15",
      "None"
    ]
  },
  {
    "q": "Which of the following profiling tools gives output for each individual line of code?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "timeit",
      "tracemalloc"
    ]
  },
  {
    "q": "What is the time complexity of appending an item to the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is a key characteristic of generators in Python?",
    "c": null,
    "o": [
      "They compute values lazily, only when requested",
      "They store all values in memory",
      "They support random access",
      "They execute immediately and return a list"
    ]
  },
  {
    "q": "What does the `@lru_cache` decorator do?",
    "c": null,
    "o": [
      "Caches function return values to avoid repeated computation",
      "Logs function parameters",
      "Limits function call rate",
      "Reduces recursion depth"
    ]
  },
  {
    "q": "What is the best-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following Python modules is used to trace memory allocation?",
    "c": null,
    "o": [
      "tracemalloc",
      "timeit",
      "argparse",
      "inspect"
    ]
  },
  {
    "q": "Which of the following is a generator function?",
    "c": null,
    "o": [
      "A function that uses the 'yield' keyword",
      "A function that returns a list",
      "A function that contains a return statement",
      "A function that uses recursion"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "gen = (x for x in range(3))\nprint(sum(gen))",
    "o": [
      "3",
      "6",
      "0",
      "1"
    ]
  },
  {
    "q": "Which profiling tool provides a function call tree?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "tracemalloc",
      "line_profiler"
    ]
  },
  {
    "q": "Which of the following Python features allows iteration without storing all values in memory?",
    "c": null,
    "o": [
      "Generators",
      "Lists",
      "Dictionaries",
      "Tuples"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def numbers():\n    yield 1\n    yield 2\n    yield 3\n\nn = numbers()\nprint(len(list(n)))",
    "o": [
      "3",
      "1",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which complexity class describes constant time operations?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which tool is suitable for profiling memory usage line-by-line?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "timeit",
      "gc"
    ]
  },
  {
    "q": "Which optimization technique eliminates the need to calculate results repeatedly for the same inputs?",
    "c": null,
    "o": [
      "Memoization",
      "Multithreading",
      "Generators",
      "Inlining"
    ]
  },
  {
    "q": "What is the worst-case time complexity of binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def run():\n    yield from range(2)\n    yield from range(2, 4)\n\nprint(list(run()))",
    "o": [
      "[0, 1, 2, 3]",
      "[2, 3]",
      "[0, 1]",
      "[1, 2, 3, 4]"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def even_gen():\n    for i in range(4):\n        if i % 2 == 0:\n            yield i\n\nprint(list(even_gen()))",
    "o": [
      "[0, 2]",
      "[1, 3]",
      "[2, 4]",
      "[0, 1, 2, 3]"
    ]
  },
  {
    "q": "Which tool in Python is used to analyze the number of calls made to each function?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "tracemalloc",
      "memory_profiler"
    ]
  },
  {
    "q": "Which of the following expressions creates a list of squares for numbers 0 through 4?",
    "c": null,
    "o": [
      "[x**2 for x in range(5)]",
      "[x*2 for x in range(5)]",
      "(x**2 for x in range(5))",
      "[x**2 for x in range(1, 5)]"
    ]
  },
  {
    "q": "Which of the following is the best use case for a generator?",
    "c": null,
    "o": [
      "Processing a large stream of data without loading everything into memory",
      "Storing intermediate results for quick access",
      "Performing database queries",
      "Creating immutable sequences"
    ]
  },
  {
    "q": "What is the time complexity of inserting an item into a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which space complexity class indicates that memory usage grows linearly with input size?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What does the `yield from` statement do in a generator?",
    "c": null,
    "o": [
      "Delegates part of a generator's operations to another generator or iterable",
      "Returns control to the main program",
      "Yields the result of a function call",
      "Terminates the generator"
    ]
  },
  {
    "q": "Which of the following is true about Python's `range()` function?",
    "c": null,
    "o": [
      "It returns a generator-like object and does not store all values in memory",
      "It returns a list of values",
      "It is slower than creating a list manually",
      "It always returns even numbers"
    ]
  },
  {
    "q": "Which scenario would benefit most from memoization?",
    "c": null,
    "o": [
      "Computing Fibonacci numbers recursively",
      "Iterating over a list of names",
      "Reading a file line by line",
      "Generating random passwords"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "def g():\n    yield 1\n    yield 2\n    return\n\nprint(sum(g()))",
    "o": [
      "3",
      "12",
      "1",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about `timeit` is true?",
    "c": null,
    "o": [
      "It disables garbage collection by default to avoid skewed timing results",
      "It measures memory usage of a function",
      "It can only be used in command-line scripts",
      "It requires manual loop implementations"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "def sample():\n    yield 1\n    yield 2\n    yield 3\n\ns = sample()\nprint(next(s), next(s), next(s))",
    "o": [
      "1 2 3",
      "3 2 1",
      "[1, 2, 3]",
      "1\n2\n3"
    ]
  },
  {
    "q": "Which of these techniques uses the least memory?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "List constructor",
      "Set comprehension"
    ]
  },
  {
    "q": "Which time complexity class describes algorithms that double their workload with each step?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n!)",
      "O(n^2)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "def double():\n    yield from [2, 4, 6]\n\nprint(list(double()))",
    "o": [
      "[2, 4, 6]",
      "[1, 2, 3]",
      "[4, 8, 12]",
      "2 4 6"
    ]
  },
  {
    "q": "What does the `cProfile` module analyze?",
    "c": null,
    "o": [
      "Execution time and call frequency of functions",
      "Memory usage of variables",
      "Exception handling",
      "File I/O performance"
    ]
  },
  {
    "q": "Which of the following expressions creates a memory-efficient iterable?",
    "c": null,
    "o": [
      "(x for x in range(100000))",
      "[x for x in range(100000)]",
      "{x for x in range(100000)}",
      "list(range(100000))"
    ]
  },
  {
    "q": "What is the best-case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following describes a generator's advantage over a list?",
    "c": null,
    "o": [
      "Generators are lazy and more memory efficient",
      "Generators allow element replacement",
      "Generators support slicing",
      "Generators are faster for random access"
    ]
  },
  {
    "q": "Which decorator is used to enable automatic caching in Python?",
    "c": null,
    "o": [
      "@lru_cache",
      "@staticmethod",
      "@cachetools",
      "@memoize"
    ]
  },
  {
    "q": "Which of the following functions returns a high-resolution timer for benchmarking?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.sleep()",
      "time.timezone()",
      "datetime.now()"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def power_gen():\n    for i in range(3):\n        yield i ** 2\n\nprint(sum(power_gen()))",
    "o": [
      "5",
      "6",
      "3",
      "4"
    ]
  },
  {
    "q": "Which of the following operations is typically the most expensive in terms of space?",
    "c": null,
    "o": [
      "Creating a full list of 1 million items",
      "Using a generator to yield 1 million items",
      "Iterating over range(1_000_000)",
      "Using a while loop to print 1 million numbers"
    ]
  },
  {
    "q": "Which of the following decorators enables automatic result caching for functions?",
    "c": null,
    "o": [
      "@functools.lru_cache",
      "@staticmethod",
      "@classmethod",
      "@cached_property"
    ]
  },
  {
    "q": "Which tool is most useful when you want to identify the memory usage of each line of code?",
    "c": null,
    "o": [
      "memory_profiler",
      "timeit",
      "cProfile",
      "pdb"
    ]
  },
  {
    "q": "Which of the following returns a generator object?",
    "c": null,
    "o": [
      "(x for x in range(10))",
      "[x for x in range(10)]",
      "{x for x in range(10)}",
      "list(range(10))"
    ]
  },
  {
    "q": "Which time complexity represents quadratic growth?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(2^n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "def flatten():\n    yield from [1, 2]\n    yield from [3, 4]\n\nprint(list(flatten()))",
    "o": [
      "[1, 2, 3, 4]",
      "[[1, 2], [3, 4]]",
      "[1, 2]",
      "[3, 4]"
    ]
  },
  {
    "q": "Which space complexity class suggests that memory usage doubles with each input increase?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which optimization technique is commonly used to handle repeated recursive calls efficiently?",
    "c": null,
    "o": [
      "Memoization",
      "Multithreading",
      "Loop unrolling",
      "Functional programming"
    ]
  },
  {
    "q": "Which of the following is a valid reason to use generators in Python?",
    "c": null,
    "o": [
      "To handle large datasets without loading everything into memory",
      "To improve random access time",
      "To convert a function into a list",
      "To make the code thread-safe"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "def infinite():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\nprint(next(infinite()))",
    "o": [
      "0",
      "1",
      "infinite loop",
      "Error"
    ]
  },
  {
    "q": "Which method in the `timeit` module can be used to time a function directly?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "timeit.run()",
      "timeit.measure()",
      "timeit.profile()"
    ]
  },
  {
    "q": "Which expression consumes the least memory?",
    "c": null,
    "o": [
      "(x for x in range(10**6))",
      "[x for x in range(10**6)]",
      "{x for x in range(10**6)}",
      "list(range(10**6))"
    ]
  },
  {
    "q": "What is the time complexity of checking if an element exists in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which scenario would benefit the most from using list comprehensions?",
    "c": null,
    "o": [
      "Filtering or transforming a sequence into a list",
      "Processing infinite sequences",
      "Reusing previous values during computation",
      "Streaming large files line by line"
    ]
  },
  {
    "q": "Which line will raise an error?",
    "c": "g = (x for x in range(3))\nprint(next(g))\nprint(next(g))\nprint(next(g))\nprint(next(g))",
    "o": [
      "print(next(g))  # 4th call",
      "print(next(g))  # 1st call",
      "print(next(g))  # 2nd call",
      "print(next(g))  # 3rd call"
    ]
  },
  {
    "q": "Which Python construct is most suitable for defining a memory-efficient data pipeline?",
    "c": null,
    "o": [
      "Generator functions",
      "List comprehensions",
      "Set comprehensions",
      "Dictionary comprehensions"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "def numbers():\n    yield from range(1, 4)\n\nprint(sum(numbers()))",
    "o": [
      "6",
      "10",
      "3",
      "4"
    ]
  },
  {
    "q": "Which complexity best describes an algorithm that reduces the input size by half each time?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n^2)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following best describes the behavior of a generator?",
    "c": null,
    "o": [
      "Produces values on the fly without storing them in memory",
      "Stores all values in a list before returning",
      "Executes all iterations at once",
      "Returns a sorted sequence"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "def test():\n    yield 1\n    return 2\n\nt = test()\nprint(next(t))",
    "o": [
      "1",
      "2",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which tool helps track memory allocation over time?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "gc",
      "timeit"
    ]
  },
  {
    "q": "Which of the following is true about list comprehensions?",
    "c": null,
    "o": [
      "They are more readable and often faster than loops for simple operations",
      "They always use less memory than generator expressions",
      "They can only be used with integers",
      "They do not support conditions"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def add():\n    yield 1\n    yield 2\n    yield 3\n\na = add()\nprint(list(a))",
    "o": [
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[1, 3]",
      "None"
    ]
  },
  {
    "q": "Which space complexity indicates constant space usage regardless of input size?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is NOT a benefit of using generators?",
    "c": null,
    "o": [
      "Supports random access",
      "Lazy evaluation",
      "Reduced memory usage",
      "Can be infinite"
    ]
  },
  {
    "q": "Which technique uses decorators to cache function results based on arguments?",
    "c": null,
    "o": [
      "Memoization",
      "Loop unrolling",
      "Recursion",
      "Garbage collection"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element at a given index in a list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python module is commonly used to measure execution time of small code snippets?",
    "c": null,
    "o": [
      "timeit",
      "time",
      "datetime",
      "sched"
    ]
  },
  {
    "q": "What does Big-O notation describe?",
    "c": null,
    "o": [
      "The worst-case time or space complexity of an algorithm",
      "The exact number of steps an algorithm takes",
      "The average execution time of a function",
      "The best possible input an algorithm can handle"
    ]
  },
  {
    "q": "Which of the following has the lowest time complexity?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which data structure provides average case O(1) time complexity for insert and lookup?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set (ordered)"
    ]
  },
  {
    "q": "What is the worst-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which sorting algorithm is stable and has a time complexity of O(n log n)?",
    "c": null,
    "o": [
      "Merge sort",
      "Quick sort",
      "Heap sort",
      "Selection sort"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the 'space complexity' of an algorithm measure?",
    "c": null,
    "o": [
      "The amount of memory an algorithm uses relative to input size",
      "The number of nested loops",
      "The CPU time consumed",
      "The disk space required to store input"
    ]
  },
  {
    "q": "Which of the following improves performance by avoiding redundant calculations?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Looping",
      "Backtracking"
    ]
  },
  {
    "q": "What is a common trade-off when optimizing code for speed?",
    "c": null,
    "o": [
      "Increased memory usage",
      "Increased readability",
      "Decreased performance",
      "Improved security"
    ]
  },
  {
    "q": "Which of the following notations represents the best-case time complexity?",
    "c": null,
    "o": [
      "Omega (Ω)",
      "Big O (O)",
      "Theta (Θ)",
      "Sigma (Σ)"
    ]
  },
  {
    "q": "If an algorithm has time complexity O(n!), what does it indicate?",
    "c": null,
    "o": [
      "Very poor performance on larger inputs",
      "Constant time regardless of input",
      "Logarithmic growth with input size",
      "Linear growth with input size"
    ]
  },
  {
    "q": "Which optimization technique avoids computing the same result more than once?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Method",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which algorithm optimization technique breaks problems into overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Greedy Algorithms",
      "Branch and Bound"
    ]
  },
  {
    "q": "What is the best time complexity achievable by comparison-based sorting algorithms?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which notation gives the tightest bound on algorithm complexity?",
    "c": null,
    "o": [
      "Theta (Θ)",
      "Big O (O)",
      "Omega (Ω)",
      "Sigma (Σ)"
    ]
  },
  {
    "q": "Which data structure is preferred for implementing memoization?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Set",
      "Queue"
    ]
  },
  {
    "q": "Which of the following helps in optimizing recursive solutions?",
    "c": null,
    "o": [
      "Tail Recursion",
      "Nested Loops",
      "Greedy Strategy",
      "List Comprehension"
    ]
  },
  {
    "q": "Which of the following best defines amortized analysis?",
    "c": null,
    "o": [
      "Average time per operation over a worst-case sequence",
      "Time for the best input",
      "Time for random input",
      "Average time across different algorithms"
    ]
  },
  {
    "q": "Which of these is an optimization problem where the goal is to minimize or maximize some value?",
    "c": null,
    "o": [
      "Knapsack Problem",
      "Binary Search",
      "Bubble Sort",
      "Depth-First Search"
    ]
  },
  {
    "q": "What is the time complexity of binary search in the worst case?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following best describes space complexity?",
    "c": null,
    "o": [
      "Amount of memory used by an algorithm",
      "Time taken by an algorithm to run",
      "Number of operations performed by an algorithm",
      "Memory required for input data only"
    ]
  },
  {
    "q": "What is the average case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which Python module can be used for detailed function-level profiling?",
    "c": null,
    "o": [
      "cProfile",
      "time",
      "sys",
      "os"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python list by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following uses less memory when iterating through large data sets?",
    "c": null,
    "o": [
      "Generators",
      "Lists",
      "Tuples",
      "Sets"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "import time\nstart = time.time()\ntime.sleep(1)\nend = time.time()\nprint(round(end - start))",
    "o": [
      "1",
      "0",
      "2",
      "None"
    ]
  },
  {
    "q": "Which is a more memory-efficient way to build a list of squares from 0 to 9?",
    "c": null,
    "o": [
      "(x*x for x in range(10))",
      "[x*x for x in range(10)]",
      "{x*x for x in range(10)}",
      "map(lambda x: x*x, range(10))"
    ]
  },
  {
    "q": "What is the time complexity of appending to a Python list?",
    "c": null,
    "o": [
      "O(1) amortized",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does cProfile primarily measure?",
    "c": null,
    "o": [
      "Function call times and frequency",
      "Memory usage",
      "Syntax errors",
      "Data types"
    ]
  },
  {
    "q": "Which of the following best describes the worst-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following techniques avoids creating the entire list in memory?",
    "c": null,
    "o": [
      "Generators",
      "List comprehensions",
      "For loops with list.append()",
      "Copying lists"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "import cProfile\n\ndef test():\n    sum = 0\n    for i in range(1000):\n        sum += i\n    return sum\n\ncProfile.run('test()')",
    "o": [
      "Detailed profiling output",
      "0",
      "Error",
      "None"
    ]
  },
  {
    "q": "In Big O notation, which of the following grows fastest as n increases?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n^2)",
      "O(n log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which optimization technique is best when working with large I/O-bound data streams?",
    "c": null,
    "o": [
      "Using generators",
      "Using nested loops",
      "Using recursion",
      "Storing all values in a list"
    ]
  },
  {
    "q": "What is the time complexity of checking if an element exists in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "import time\nstart = time.perf_counter()\nfor _ in range(1000000): pass\nend = time.perf_counter()\nprint(end - start < 1)",
    "o": [
      "True",
      "False",
      "0",
      "1"
    ]
  },
  {
    "q": "Which of the following operations has a time complexity of O(n) in Python lists?",
    "c": null,
    "o": [
      "Removing an element by value",
      "Appending an element",
      "Accessing by index",
      "Using a generator expression"
    ]
  },
  {
    "q": "Which of the following statements about list comprehensions is true?",
    "c": null,
    "o": [
      "They are generally faster and more concise than traditional loops",
      "They use more memory than for loops",
      "They are always slower than map()",
      "They cannot be nested"
    ]
  },
  {
    "q": "Which metric does not typically appear in cProfile output?",
    "c": null,
    "o": [
      "Memory usage",
      "Function name",
      "Total calls",
      "Time per call"
    ]
  },
  {
    "q": "Which of the following best describes the best-case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which profiling function gives more accurate timing in Python?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "time.clock()",
      "time.process_time()"
    ]
  },
  {
    "q": "What is the space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is an advantage of using a generator over a list?",
    "c": null,
    "o": [
      "Lower memory usage",
      "Faster indexing",
      "Immutable elements",
      "Can be reused multiple times"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "def gen():\n    yield 1\n    yield 2\n\nprint(sum(gen()))",
    "o": [
      "3",
      "12",
      "None",
      "[1, 2]"
    ]
  },
  {
    "q": "Which optimization technique replaces nested for-loops with efficient set-based filtering?",
    "c": null,
    "o": [
      "List comprehension with conditionals",
      "Appending in for loop",
      "Using recursion",
      "String concatenation"
    ]
  },
  {
    "q": "Which of the following can help identify performance bottlenecks in a program?",
    "c": null,
    "o": [
      "cProfile",
      "math",
      "random",
      "operator"
    ]
  },
  {
    "q": "What is the average-case time complexity of inserting at the beginning of a list in Python?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to optimize performance in Python?",
    "c": null,
    "o": [
      "Using deep recursion in place of loops",
      "Using built-in functions",
      "Using generators",
      "Using list comprehensions"
    ]
  },
  {
    "q": "What does timeit.default_timer() return?",
    "c": null,
    "o": [
      "The most accurate clock available on the platform",
      "The system uptime",
      "The current local time",
      "The CPU temperature"
    ]
  },
  {
    "q": "Which of the following best describes the time complexity of list slicing in Python (e.g., mylist[a:b])?",
    "c": null,
    "o": [
      "O(k), where k is the slice size",
      "O(1)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of these tools can measure both the number of function calls and the time spent in each function?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "time.sleep",
      "functools"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using generators?",
    "c": null,
    "o": [
      "They can only be iterated once",
      "They consume too much memory",
      "They are slower than lists",
      "They cannot be defined with functions"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "def squares():\n    for i in range(3):\n        yield i * i\n\nprint(next(squares()))",
    "o": [
      "0",
      "1",
      "None",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of the timeit module in Python?",
    "c": null,
    "o": [
      "To measure execution time of small code snippets",
      "To generate delays in code",
      "To handle date and time formatting",
      "To convert time zones"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about list comprehensions?",
    "c": null,
    "o": [
      "They are often faster than traditional for-loops",
      "They always consume more memory",
      "They can only contain one expression",
      "They are not readable"
    ]
  },
  {
    "q": "In algorithm analysis, which complexity dominates as n becomes very large?",
    "c": null,
    "o": [
      "O(n!)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "What does the following code produce?",
    "c": "import time\nstart = time.time()\nsum([i for i in range(100000)])\nend = time.time()\nprint(round(end - start, 2))",
    "o": [
      "Execution time in seconds",
      "Memory usage in MB",
      "The total sum",
      "None"
    ]
  },
  {
    "q": "Which of the following optimization methods avoids unnecessary memory allocation?",
    "c": null,
    "o": [
      "Using generators instead of lists",
      "Using recursion everywhere",
      "Storing large data in global variables",
      "Using large nested dictionaries"
    ]
  },
  {
    "q": "What is the main advantage of amortized analysis?",
    "c": null,
    "o": [
      "It provides an average performance guarantee over a sequence of operations",
      "It finds the exact worst-case scenario",
      "It optimizes memory layout",
      "It minimizes recursion depth"
    ]
  },
  {
    "q": "Which of the following sorting algorithms has the best worst-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "from timeit import timeit\nprint(timeit('sum(range(100))', number=1000))",
    "o": [
      "Execution time in seconds",
      "100",
      "1000",
      "An error"
    ]
  },
  {
    "q": "Which of the following is NOT a goal of code optimization?",
    "c": null,
    "o": [
      "Increasing code readability",
      "Reducing memory usage",
      "Improving runtime performance",
      "Minimizing CPU cycles"
    ]
  },
  {
    "q": "Which data structure gives O(1) time complexity for insert and lookup operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Binary Search Tree",
      "Linked List",
      "Array"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "def squares():\n    return (x*x for x in range(4))\n\nprint(list(squares()))",
    "o": [
      "[0, 1, 4, 9]",
      "(0, 1, 4, 9)",
      "0 1 4 9",
      "[1, 2, 3, 4]"
    ]
  },
  {
    "q": "Which tool would you use to find which functions in your Python program are slowest?",
    "c": null,
    "o": [
      "cProfile",
      "math",
      "sys.argv",
      "time.sleep"
    ]
  },
  {
    "q": "Which of the following has the highest space complexity?",
    "c": null,
    "o": [
      "Matrix multiplication storing full output",
      "Loop printing numbers",
      "Generator that yields elements",
      "List comprehension on a small range"
    ]
  },
  {
    "q": "What is the space complexity of an in-place quicksort implementation?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following is TRUE about generators?",
    "c": null,
    "o": [
      "They yield values one at a time and do not store them in memory",
      "They store all results in memory before returning",
      "They are slower than list comprehensions",
      "They cannot be created using functions"
    ]
  },
  {
    "q": "Which of these will NOT affect the time complexity of an algorithm?",
    "c": null,
    "o": [
      "The variable names used in code",
      "The algorithm's logic",
      "The data structures used",
      "The input size"
    ]
  },
  {
    "q": "Which of the following best describes the best-case time complexity of insertion sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which function is used to measure precise short durations in Python?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.sleep()",
      "time.strftime()",
      "time.ctime()"
    ]
  },
  {
    "q": "Which of the following techniques helps reduce memory usage in data pipelines?",
    "c": null,
    "o": [
      "Using generators",
      "Copying lists frequently",
      "Using nested dictionaries",
      "Storing data in global lists"
    ]
  },
  {
    "q": "What is the average-case time complexity for inserting an element in a hash table (with good hash functions)?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "gen = (x for x in range(3))\nprint(next(gen), next(gen))",
    "o": [
      "0 1",
      "1 2",
      "0 2",
      "[0, 1]"
    ]
  },
  {
    "q": "Which algorithm has the same best, average, and worst-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which of these helps identify which line of code takes the most time to run?",
    "c": null,
    "o": [
      "line_profiler",
      "gc module",
      "doctest",
      "time.sleep"
    ]
  },
  {
    "q": "Which of the following has the lowest space complexity?",
    "c": null,
    "o": [
      "In-place sorting algorithm",
      "Sorting using extra arrays",
      "Storing entire input in memory",
      "Using recursive merge sort"
    ]
  },
  {
    "q": "Which Python keyword is used in a generator function to yield control back?",
    "c": null,
    "o": [
      "yield",
      "return",
      "pass",
      "break"
    ]
  },
  {
    "q": "What is the advantage of amortized time analysis?",
    "c": null,
    "o": [
      "It shows average cost per operation over a sequence",
      "It ignores worst-case performance",
      "It replaces Big-O notation",
      "It assumes constant time always"
    ]
  },
  {
    "q": "Which of the following best describes the worst-case time complexity of inserting in a Python dictionary?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which code snippet will consume less memory when summing squares of numbers from 1 to 1000000?",
    "c": null,
    "o": [
      "sum(x*x for x in range(1000000))",
      "sum([x*x for x in range(1000000)])",
      "sum((x*x for x in range(1000000)))",
      "None of the above"
    ]
  },
  {
    "q": "Which tool provides function-level profiling with call counts and cumulative times?",
    "c": null,
    "o": [
      "cProfile",
      "pdb",
      "unittest",
      "memoryview"
    ]
  },
  {
    "q": "Which of the following expressions creates a generator?",
    "c": null,
    "o": [
      "(x for x in range(10))",
      "[x for x in range(10)]",
      "{x for x in range(10)}",
      "x*x for x in range(10)"
    ]
  },
  {
    "q": "What is the primary benefit of using list comprehensions over traditional loops?",
    "c": null,
    "o": [
      "Faster execution and cleaner syntax",
      "Reduced memory usage",
      "More readable than built-in functions",
      "Better error handling"
    ]
  },
  {
    "q": "What is the time complexity of checking membership in a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is returned by the following code?",
    "c": "from timeit import timeit\nprint(round(timeit('\"-\".join(str(n) for n in range(100))', number=1000), 2))",
    "o": [
      "Execution time in seconds",
      "100",
      "A joined string",
      "None"
    ]
  },
  {
    "q": "Which is true about Python's timeit module?",
    "c": null,
    "o": [
      "It avoids some common timing traps and overheads",
      "It slows down the code execution",
      "It only works with print statements",
      "It must be used with multithreading"
    ]
  },
  {
    "q": "Which scenario benefits most from using a generator?",
    "c": null,
    "o": [
      "Processing large data one item at a time",
      "Sorting a small list",
      "Matrix multiplication",
      "Counting fixed elements"
    ]
  },
  {
    "q": "Which Big-O notation represents a constant time algorithm?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n log n)",
      "O(log n)"
    ]
  },
  {
    "q": "What is the main advantage of using generators over lists?",
    "c": null,
    "o": [
      "They yield items one at a time and use less memory",
      "They allow indexing of elements",
      "They are faster in all cases",
      "They store all results in memory"
    ]
  },
  {
    "q": "Which of the following can help in optimizing nested loop performance?",
    "c": null,
    "o": [
      "Reducing unnecessary computations inside loops",
      "Increasing loop depth",
      "Using global variables",
      "Adding sleep() inside loops"
    ]
  },
  {
    "q": "What does this code snippet do?",
    "c": "import time\nstart = time.perf_counter()\n[x for x in range(1000000)]\nend = time.perf_counter()\nprint(end - start)",
    "o": [
      "Prints execution time in seconds",
      "Prints memory usage",
      "Returns a list",
      "Throws a syntax error"
    ]
  },
  {
    "q": "Which of the following operations is typically most expensive in terms of time?",
    "c": null,
    "o": [
      "Inserting at the beginning of a list",
      "Appending to a list",
      "Accessing a list by index",
      "Iterating a generator"
    ]
  },
  {
    "q": "Which of the following does NOT improve algorithm efficiency?",
    "c": null,
    "o": [
      "Using unnecessary nested loops",
      "Using list comprehensions",
      "Using efficient data structures",
      "Avoiding redundant calculations"
    ]
  },
  {
    "q": "What is the time complexity of the following list comprehension: [x for x in range(n)]?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is typically true about Python's built-in functions like sum(), max()?",
    "c": null,
    "o": [
      "They are optimized and usually faster than custom loops",
      "They are always slower",
      "They consume more memory",
      "They are only for strings"
    ]
  },
  {
    "q": "Which space complexity is best when working with very large data sets?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the purpose of using timeit over time.time() for benchmarking?",
    "c": null,
    "o": [
      "It avoids common timing issues and gives more reliable results",
      "It runs faster",
      "It provides visual graphs",
      "It uses less memory"
    ]
  },
  {
    "q": "Which of the following optimizations would best reduce execution time for large I/O operations?",
    "c": null,
    "o": [
      "Using generators with buffered reading",
      "Storing everything in a global list",
      "Reading the entire file into memory",
      "Using recursion to parse every line"
    ]
  },
  {
    "q": "What is the best-case time complexity of searching an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these is the most memory-efficient way to process lines in a large file?",
    "c": null,
    "o": [
      "Using a generator to read line by line",
      "Reading all lines into a list",
      "Storing lines in a set",
      "Copying the file contents into multiple variables"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "def f():\n    yield 1\n    yield 2\n\nx = f()\nprint(next(x), next(x))",
    "o": [
      "1 2",
      "0 1",
      "None None",
      "Error"
    ]
  },
  {
    "q": "Which of the following time complexities indicates a linear relationship?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which is TRUE about time complexity analysis?",
    "c": null,
    "o": [
      "It estimates the growth of runtime with input size",
      "It gives the exact execution time",
      "It depends on the system clock",
      "It measures memory consumption"
    ]
  },
  {
    "q": "Which of the following is LEAST effective in optimizing Python code?",
    "c": null,
    "o": [
      "Adding unnecessary print statements",
      "Using generators",
      "Minimizing nested loops",
      "Using built-in functions"
    ]
  },
  {
    "q": "Which of the following tools helps track function call count and execution time per function?",
    "c": null,
    "o": [
      "cProfile",
      "gc",
      "time.sleep",
      "itertools"
    ]
  },
  {
    "q": "What is the space complexity of a recursive Fibonacci function without memoization?",
    "c": null,
    "o": [
      "O(n)",
      "O(2^n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following will execute faster in most cases?",
    "c": null,
    "o": [
      "sum(range(1000000))",
      "s = 0\nfor i in range(1000000):\n    s += i",
      "List comprehension with sum",
      "Recursion to sum numbers"
    ]
  },
  {
    "q": "Which complexity class grows slowest as input size increases?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which data structure provides O(log n) time complexity for insertions and deletions?",
    "c": null,
    "o": [
      "Balanced Binary Search Tree",
      "Array",
      "Hash Table",
      "Stack"
    ]
  },
  {
    "q": "Which statement is true regarding list comprehensions?",
    "c": null,
    "o": [
      "They can include conditionals and nested loops",
      "They always use more memory than loops",
      "They are slower than for-loops",
      "They are only available in Python 3.10+"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "def g():\n    for i in range(3):\n        yield i\n\nprint(list(g()))",
    "o": [
      "[0, 1, 2]",
      "[1, 2, 3]",
      "0 1 2",
      "None"
    ]
  },
  {
    "q": "Which of the following is NOT a benefit of using generators?",
    "c": null,
    "o": [
      "They allow random access like lists",
      "They save memory",
      "They support lazy evaluation",
      "They are iterable"
    ]
  },
  {
    "q": "Which Python module is ideal for benchmarking small code snippets with minimal overhead?",
    "c": null,
    "o": [
      "timeit",
      "time",
      "datetime",
      "cProfile"
    ]
  },
  {
    "q": "What is the average-case time complexity for deleting a node in a Binary Search Tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following operations has a constant space complexity (O(1))?",
    "c": null,
    "o": [
      "Swapping two variables",
      "Appending to a list",
      "Recursively calling a function",
      "Creating a list of size n"
    ]
  },
  {
    "q": "What is the time complexity of the following code snippet?",
    "c": "for i in range(n):\n    for j in range(n):\n        print(i, j)",
    "o": [
      "O(n^2)",
      "O(n)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which optimization is most relevant when a program is I/O-bound?",
    "c": null,
    "o": [
      "Use buffered I/O and generators",
      "Add delays between reads",
      "Use nested loops to speed up",
      "Avoid using functions"
    ]
  },
  {
    "q": "Which technique can help reduce both time and space complexity in algorithms?",
    "c": null,
    "o": [
      "Dynamic programming with memoization",
      "Using global variables",
      "Recursion without a base case",
      "Increasing recursion depth"
    ]
  },
  {
    "q": "Which of the following best describes the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which Python function is ideal for measuring very short durations accurately?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "datetime.now()",
      "time.sleep()"
    ]
  },
  {
    "q": "Which type of algorithm uses previously computed results to avoid duplicate calculations?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Greedy Algorithm",
      "Backtracking"
    ]
  },
  {
    "q": "Which approach is best for minimizing space usage when handling large files?",
    "c": null,
    "o": [
      "Using generators and reading line-by-line",
      "Reading the entire file into a list",
      "Splitting the file into chunks and storing each in memory",
      "Loading the file into a Pandas DataFrame"
    ]
  },
  {
    "q": "Which of the following techniques will NOT help optimize nested loops?",
    "c": null,
    "o": [
      "Adding more inner loops",
      "Breaking early when possible",
      "Avoiding redundant calculations",
      "Flattening where applicable"
    ]
  },
  {
    "q": "Which statement about Big-O notation is FALSE?",
    "c": null,
    "o": [
      "It accounts for hardware-level optimizations",
      "It measures the upper bound of time/space",
      "It describes scalability",
      "It ignores constant factors"
    ]
  },
  {
    "q": "Which function would show the number of function calls and total time per function?",
    "c": null,
    "o": [
      "cProfile.run()",
      "time.sleep()",
      "time.perf_counter()",
      "print()"
    ]
  },
  {
    "q": "Which code snippet generates an infinite sequence using a generator?",
    "c": null,
    "o": [
      "def gen():\n    i = 0\n    while True:\n        yield i\n        i += 1",
      "def gen():\n    return [i for i in range(100)]",
      "def gen():\n    yield from range(100)",
      "def gen():\n    return (i for i in range(100))"
    ]
  },
  {
    "q": "Which is the most time-efficient way to filter even numbers from a list?",
    "c": null,
    "o": [
      "[x for x in nums if x % 2 == 0]",
      "for x in nums: if x % 2 == 0: result.append(x)",
      "filter(lambda x: x % 2 == 0, nums)",
      "Loop with append inside try-except"
    ]
  },
  {
    "q": "What is the space complexity of using a generator instead of a list to process n items?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following Big-O notations represents the slowest-growing function?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the primary reason to avoid unnecessary list copies in Python?",
    "c": null,
    "o": [
      "To reduce memory usage and improve speed",
      "To make code easier to debug",
      "To ensure backward compatibility",
      "To maintain index order"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "import time\nstart = time.perf_counter()\nend = time.perf_counter()\nprint(end - start < 0.001)",
    "o": [
      "True",
      "False",
      "0",
      "An exception"
    ]
  },
  {
    "q": "Which sorting algorithm has the same average and worst-case time complexity of O(n log n)?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which approach improves efficiency when filtering items in a large dataset?",
    "c": null,
    "o": [
      "Using generator expressions with filtering logic",
      "Using nested loops for filtering",
      "Copying items to a temporary list first",
      "Converting list to string before filtering"
    ]
  },
  {
    "q": "What is the advantage of using lazy evaluation in Python?",
    "c": null,
    "o": [
      "It defers computation until needed, saving memory",
      "It computes results faster",
      "It guarantees type safety",
      "It pre-computes all values ahead of time"
    ]
  },
  {
    "q": "Which built-in Python function can benchmark short snippets accurately?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "time.sleep()",
      "datetime.now()",
      "gc.collect()"
    ]
  },
  {
    "q": "Which code will consume less memory when processing 1 million items?",
    "c": null,
    "o": [
      "sum(x for x in range(1000000))",
      "sum([x for x in range(1000000)])",
      "total = 0\nfor x in range(1000000): total += x",
      "map(lambda x: x, range(1000000))"
    ]
  },
  {
    "q": "What is the best-case time complexity for linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which profiling method gives line-by-line breakdown of execution time?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "time.sleep()",
      "pdb"
    ]
  },
  {
    "q": "Which of the following is most memory-efficient when working with large sequences?",
    "c": null,
    "o": [
      "Generators",
      "Lists",
      "Tuples",
      "Sets"
    ]
  },
  {
    "q": "Which module provides a simple way to profile Python code performance line-by-line?",
    "c": null,
    "o": [
      "line_profiler",
      "gc",
      "re",
      "datetime"
    ]
  },
  {
    "q": "What will the following code return?",
    "c": "def count():\n    for i in range(3):\n        yield i\n\nprint(sum(count()))",
    "o": [
      "3",
      "6",
      "2",
      "None"
    ]
  },
  {
    "q": "Which data structure is best for quick lookup of items?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Deque"
    ]
  },
  {
    "q": "Which technique allows reducing time complexity by storing previously computed results?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Iteration",
      "Sorting"
    ]
  },
  {
    "q": "Which of the following code snippets uses a generator expression?",
    "c": null,
    "o": [
      "(x*x for x in range(10))",
      "[x*x for x in range(10)]",
      "{x*x for x in range(10)}",
      "x*x for x in range(10)"
    ]
  },
  {
    "q": "Which built-in function is best for benchmarking a one-liner in Python?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "time.sleep()",
      "cProfile.run()",
      "perf_counter()"
    ]
  },
  {
    "q": "Which of the following statements about cProfile is TRUE?",
    "c": null,
    "o": [
      "It shows how many times each function was called and how long it took",
      "It only works with multi-threaded programs",
      "It only measures memory usage",
      "It requires internet access"
    ]
  },
  {
    "q": "What is the average-case time complexity of quick sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "What is the space complexity of an iterative factorial function?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following statements about list comprehensions is TRUE?",
    "c": null,
    "o": [
      "They are generally faster than using a for loop",
      "They always use more memory than loops",
      "They cannot include conditionals",
      "They are slower than generators"
    ]
  },
  {
    "q": "What is the best-case time complexity of binary search on a sorted array?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is most useful for analyzing the time taken by individual function calls?",
    "c": null,
    "o": [
      "cProfile",
      "time.sleep()",
      "logging",
      "assert"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "gen = (x**2 for x in range(4))\nprint(list(gen))",
    "o": [
      "[0, 1, 4, 9]",
      "[1, 2, 3, 4]",
      "(0, 1, 4, 9)",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about space complexity?",
    "c": null,
    "o": [
      "It represents the amount of memory required by an algorithm",
      "It measures the time an algorithm takes to run",
      "It only applies to recursive functions",
      "It depends on CPU speed"
    ]
  },
  {
    "q": "Which is the most efficient way to calculate the sum of numbers from 1 to n in Python?",
    "c": null,
    "o": [
      "n * (n + 1) // 2",
      "sum([i for i in range(1, n+1)])",
      "for loop from 1 to n",
      "Recursion"
    ]
  },
  {
    "q": "Which of these functions provides the most precise time measurement?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "time.sleep()",
      "datetime.now()"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching in a linked list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following optimization methods improves performance by preventing recalculation?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Randomization",
      "Deep copying"
    ]
  },
  {
    "q": "Which statement about generators is FALSE?",
    "c": null,
    "o": [
      "They store all values in memory at once",
      "They yield values one at a time",
      "They are used to save memory",
      "They are created using functions with 'yield'"
    ]
  },
  {
    "q": "What is the space complexity of storing a list of n integers in Python?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which technique is commonly used to analyze the performance of recursive functions?",
    "c": null,
    "o": [
      "Recurrence relations",
      "Greedy analysis",
      "Stack overflow tracking",
      "Loop unrolling"
    ]
  },
  {
    "q": "Which of the following Python constructs provides lazy evaluation?",
    "c": null,
    "o": [
      "Generator expressions",
      "List comprehensions",
      "Set comprehensions",
      "Tuple unpacking"
    ]
  },
  {
    "q": "Which of the following gives a more accurate time profile of a complete Python program?",
    "c": null,
    "o": [
      "cProfile.run()",
      "print(time.time())",
      "time.sleep()",
      "datetime.now()"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element by index in a list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "def gen():\n    yield from range(2)\n\nprint(sum(gen()))",
    "o": [
      "1",
      "2",
      "3",
      "[0, 1]"
    ]
  },
  {
    "q": "Which optimization technique replaces nested loops with mathematical formulas when possible?",
    "c": null,
    "o": [
      "Loop unrolling",
      "Memoization",
      "Greedy algorithm",
      "Profiling"
    ]
  },
  {
    "q": "Which of the following sorting algorithms has the best average-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following will most likely increase the memory footprint of a Python application?",
    "c": null,
    "o": [
      "Using large lists instead of generators",
      "Using lazy evaluation",
      "Profiling with timeit",
      "Using O(1) algorithms"
    ]
  },
  {
    "q": "Which of the following approaches leads to improved time and space performance?",
    "c": null,
    "o": [
      "Avoiding unnecessary intermediate data structures",
      "Copying data between lists",
      "Deep copying dictionaries",
      "Using try/except in tight loops"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is true about generators in Python?",
    "c": null,
    "o": [
      "They produce values one at a time using yield",
      "They store all results in memory",
      "They support random access",
      "They are slower than lists in all cases"
    ]
  },
  {
    "q": "Which method is most suitable for measuring performance of a single Python statement?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "cProfile.run()",
      "time.sleep()",
      "datetime.datetime.now()"
    ]
  },
  {
    "q": "Which of the following algorithms has the same best, average, and worst-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which Python expression creates a generator that yields even numbers from 0 to 10?",
    "c": null,
    "o": [
      "(x for x in range(11) if x % 2 == 0)",
      "[x for x in range(11) if x % 2 == 0]",
      "{x for x in range(11) if x % 2 == 0}",
      "x for x in range(11) if x % 2 == 0"
    ]
  },
  {
    "q": "Which approach is better when working with large data files?",
    "c": null,
    "o": [
      "Using generator functions to read line by line",
      "Reading the whole file into memory",
      "Using recursion for line reads",
      "Sorting the file before reading"
    ]
  },
  {
    "q": "Which of the following data structures has O(1) average-case lookup time?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Binary Search Tree"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "def stream():\n    yield 10\n    yield 20\nx = stream()\nprint(next(x))",
    "o": [
      "10",
      "20",
      "0",
      "None"
    ]
  },
  {
    "q": "Which of the following should be avoided inside tight loops for better performance?",
    "c": null,
    "o": [
      "Heavy function calls or I/O operations",
      "Simple arithmetic operations",
      "Variable assignments",
      "if-else conditions"
    ]
  },
  {
    "q": "What is the primary goal of algorithm optimization?",
    "c": null,
    "o": [
      "Reduce time and/or space complexity",
      "Increase code length",
      "Maximize recursion depth",
      "Avoid using functions"
    ]
  },
  {
    "q": "Which operation is most efficient for removing the last item from a list?",
    "c": null,
    "o": [
      "list.pop()",
      "del list[0]",
      "list.remove(x)",
      "list.clear()"
    ]
  },
  {
    "q": "What is the worst-case time complexity of a linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which Python keyword is required for creating a generator?",
    "c": null,
    "o": [
      "yield",
      "return",
      "async",
      "await"
    ]
  },
  {
    "q": "Which of the following is used to reduce repeated computation in dynamic programming?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy strategy",
      "Recursion",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following code snippets uses list comprehension correctly?",
    "c": null,
    "o": [
      "[x*x for x in range(5)]",
      "(x*x for x in range(5))",
      "{x*x for x in range(5)}",
      "x*x for x in range(5)"
    ]
  },
  {
    "q": "Which function from the timeit module runs a code snippet and returns execution time?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "timeit.repeat()",
      "time.sleep()",
      "perf_counter()"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "def gen():\n    yield 1\n    yield 2\n    yield 3\nprint(sum(gen()))",
    "o": [
      "6",
      "3",
      "1",
      "None"
    ]
  },
  {
    "q": "Which is a good use case for using generators?",
    "c": null,
    "o": [
      "Streaming large amounts of data without loading all at once",
      "Storing and accessing all data in memory",
      "Fast random access to elements",
      "Creating GUI interfaces"
    ]
  },
  {
    "q": "Which optimization technique avoids recomputing overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic programming",
      "Greedy algorithms",
      "Divide and conquer",
      "Linear search"
    ]
  },
  {
    "q": "Which of these operations has O(1) time complexity?",
    "c": null,
    "o": [
      "Accessing an element by index in a list",
      "Inserting in the middle of a list",
      "Sorting a list",
      "Linear search in a list"
    ]
  },
  {
    "q": "Which of the following best describes the goal of time complexity analysis?",
    "c": null,
    "o": [
      "Estimate how an algorithm’s running time increases with input size",
      "Measure actual execution time on a given machine",
      "Determine the programming language efficiency",
      "Analyze syntax errors"
    ]
  },
  {
    "q": "Which of the following is true about lazy evaluation in generators?",
    "c": null,
    "o": [
      "It defers computation until needed",
      "It immediately computes all values",
      "It stores all elements in memory",
      "It does not support iteration"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "def my_gen():\n    for i in range(2):\n        yield i\n\nprint(next(my_gen()))",
    "o": [
      "0",
      "1",
      "[0, 1]",
      "None"
    ]
  },
  {
    "q": "Which algorithm is typically the most time-efficient for sorting large, unordered datasets?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the average-case time complexity for linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which operation has constant space complexity?",
    "c": null,
    "o": [
      "Swapping two variables",
      "Creating a list of n elements",
      "Building a tree of depth n",
      "Recursively summing a list"
    ]
  },
  {
    "q": "Which is the most memory-efficient way to sum large numbers in Python?",
    "c": null,
    "o": [
      "Using a generator expression with sum()",
      "Using a list comprehension with sum()",
      "Appending to a list and then summing",
      "Using recursion"
    ]
  },
  {
    "q": "What does the following code produce?",
    "c": "from timeit import timeit\ntime = timeit('sum(range(10))', number=1000)\nprint(round(time, 4))",
    "o": [
      "Execution time in seconds (rounded to 4 decimals)",
      "1000",
      "sum of numbers",
      "Syntax error"
    ]
  },
  {
    "q": "Which profiling tool should you use to understand where most time is spent in a program?",
    "c": null,
    "o": [
      "cProfile",
      "time.sleep",
      "gc.collect",
      "re.match"
    ]
  },
  {
    "q": "Which function returns high-precision time, suitable for benchmarking?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.sleep()",
      "datetime.date.today()",
      "time.ctime()"
    ]
  },
  {
    "q": "Which of the following operations is the most memory-efficient for processing large input data?",
    "c": null,
    "o": [
      "Using generators",
      "Using list comprehensions",
      "Using nested loops",
      "Using recursion"
    ]
  },
  {
    "q": "Which code snippet creates a generator function?",
    "c": null,
    "o": [
      "def gen():\n    for i in range(5):\n        yield i",
      "def gen():\n    return [i for i in range(5)]",
      "def gen():\n    return (i for i in range(5))",
      "def gen():\n    yield from [0, 1, 2]"
    ]
  },
  {
    "q": "What is the space complexity of an algorithm that uses only a few fixed-size variables?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following Python modules can be used for statistical profiling?",
    "c": null,
    "o": [
      "profile",
      "re",
      "math",
      "time"
    ]
  },
  {
    "q": "Which time complexity represents the fastest-growing function as input size increases?",
    "c": null,
    "o": [
      "O(n!)",
      "O(n^2)",
      "O(n log n)",
      "O(n)"
    ]
  },
  {
    "q": "What will this generator expression produce?\n(x**2 for x in range(3))",
    "c": null,
    "o": [
      "A generator object yielding 0, 1, 4",
      "A list [0, 1, 4]",
      "A tuple (0, 1, 4)",
      "A set {0, 1, 4}"
    ]
  },
  {
    "q": "Which of these is NOT a reason to optimize code?",
    "c": null,
    "o": [
      "To make code harder to read",
      "To reduce memory usage",
      "To speed up performance",
      "To handle large datasets efficiently"
    ]
  },
  {
    "q": "Which function is used to measure time with the highest available resolution?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "time.sleep()",
      "datetime.now()"
    ]
  },
  {
    "q": "Which optimization strategy avoids recalculating previously solved subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Loop unrolling",
      "Greedy approach"
    ]
  },
  {
    "q": "Which of the following gives the least accurate measurement for short code timings?",
    "c": null,
    "o": [
      "time.time()",
      "time.perf_counter()",
      "timeit.timeit()",
      "cProfile"
    ]
  },
  {
    "q": "Which of the following optimizations can reduce both time and space usage?",
    "c": null,
    "o": [
      "Using generators instead of lists",
      "Using nested for-loops",
      "Using recursion instead of iteration",
      "Duplicating data structures"
    ]
  },
  {
    "q": "Which is the most efficient way to create a list of squares of numbers from 0 to 9?",
    "c": null,
    "o": [
      "[x*x for x in range(10)]",
      "list(map(lambda x: x*x, range(10)))",
      "for x in range(10): list.append(x*x)",
      "Using recursion to generate squares"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def square():\n    for i in range(3):\n        yield i * i\nprint(next(square()))",
    "o": [
      "0",
      "1",
      "2",
      "[0, 1, 4]"
    ]
  },
  {
    "q": "Which profiling tool shows function call counts and cumulative time?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "gc",
      "functools"
    ]
  },
  {
    "q": "Which of these has the lowest memory footprint?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "What is the time complexity of checking if a key exists in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which optimization technique works best when problems have overlapping subproblems and optimal substructure?",
    "c": null,
    "o": [
      "Dynamic programming",
      "Greedy algorithms",
      "Brute force",
      "Divide and conquer"
    ]
  },
  {
    "q": "Which of the following leads to more readable and often faster code in Python?",
    "c": null,
    "o": [
      "Using built-in functions and comprehensions",
      "Manually unrolling all loops",
      "Avoiding built-in methods",
      "Using global variables"
    ]
  },
  {
    "q": "Which method is most suitable for measuring performance of multi-line code blocks?",
    "c": null,
    "o": [
      "timeit.timeit(stmt, setup, number)",
      "time.time()",
      "datetime.now()",
      "print()"
    ]
  },
  {
    "q": "Which is the best case time complexity for bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(1)"
    ]
  },
  {
    "q": "Which algorithm typically uses less memory due to in-place sorting?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bucket Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "Which of the following expressions creates a generator object?",
    "c": null,
    "o": [
      "(x for x in range(100))",
      "[x for x in range(100)]",
      "{x for x in range(100)}",
      "tuple(x for x in range(100))"
    ]
  },
  {
    "q": "Which of the following is most likely to improve cache performance?",
    "c": null,
    "o": [
      "Accessing data sequentially",
      "Random data access",
      "Using deeply nested loops",
      "Using recursion over iteration"
    ]
  },
  {
    "q": "What is the space complexity of recursive factorial function?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "def double():\n    yield 2\n    yield 4\nprint(list(double()))",
    "o": [
      "[2, 4]",
      "[4, 2]",
      "2 4",
      "Error"
    ]
  },
  {
    "q": "Which scenario best fits the use of cProfile?",
    "c": null,
    "o": [
      "To analyze performance bottlenecks across multiple functions",
      "To log execution errors",
      "To measure memory usage",
      "To track syntax issues"
    ]
  },
  {
    "q": "Which sorting algorithm guarantees O(n log n) time in all cases?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following is NOT a feature of generators?",
    "c": null,
    "o": [
      "They allow random access to values",
      "They yield values on demand",
      "They consume less memory",
      "They are iterable"
    ]
  },
  {
    "q": "Which Python module can benchmark short expressions accurately in isolated environments?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "time",
      "os"
    ]
  },
  {
    "q": "Which technique is used to improve performance by avoiding function call overhead in loops?",
    "c": null,
    "o": [
      "Inlining",
      "Recursion",
      "Memoization",
      "List comprehension"
    ]
  },
  {
    "q": "Which of these best describes the benefit of using list comprehensions in Python?",
    "c": null,
    "o": [
      "Faster and more readable code",
      "They use more memory than loops",
      "They execute in constant time",
      "They support parallelism by default"
    ]
  },
  {
    "q": "What is the primary difference between a list comprehension and a generator expression?",
    "c": null,
    "o": [
      "List comprehensions return full lists, generators yield items one at a time",
      "Generators are faster and use more memory",
      "List comprehensions are always more efficient",
      "Generator expressions can’t use if conditions"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "def func():\n    yield from [1, 2, 3]\nprint(sum(func()))",
    "o": [
      "6",
      "[1, 2, 3]",
      "Error",
      "1"
    ]
  },
  {
    "q": "Which complexity class grows faster than all others listed?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n^2)",
      "O(n log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which tool provides profiling statistics including total time per function?",
    "c": null,
    "o": [
      "cProfile",
      "time.sleep",
      "os.time",
      "inspect"
    ]
  },
  {
    "q": "Which of the following is TRUE about the time complexity of accessing an element in a Python set?",
    "c": null,
    "o": [
      "Average case is O(1)",
      "Worst case is O(1)",
      "It depends on the value’s hash size",
      "It is O(n log n)"
    ]
  },
  {
    "q": "Which situation is most suitable for using memoization?",
    "c": null,
    "o": [
      "Recursive functions with repeated subproblems",
      "Simple iterative loops",
      "Single-pass algorithms",
      "Sorting algorithms"
    ]
  },
  {
    "q": "Which Python feature allows inspecting function call performance in detail?",
    "c": null,
    "o": [
      "cProfile module",
      "asyncio",
      "setuptools",
      "sys.path"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using recursion without memoization?",
    "c": null,
    "o": [
      "Repeated computation of subproblems",
      "Faster than iteration",
      "Reduces memory usage",
      "Improves cache locality"
    ]
  },
  {
    "q": "Which optimization strategy improves code speed by reducing redundant calculations?",
    "c": null,
    "o": [
      "Storing intermediate results",
      "Increasing recursion depth",
      "Using print statements",
      "Avoiding base cases"
    ]
  },
  {
    "q": "Which of the following best describes 'Big-O Notation'?",
    "c": null,
    "o": [
      "It describes the upper bound of algorithm runtime",
      "It calculates exact runtime of an algorithm",
      "It shows memory usage in real-time",
      "It represents average runtime only"
    ]
  },
  {
    "q": "Which data structure is used internally by Python sets for fast lookup?",
    "c": null,
    "o": [
      "Hash table",
      "Binary search tree",
      "Linked list",
      "Heap"
    ]
  },
  {
    "q": "Which of these expressions creates a memory-efficient Fibonacci generator?",
    "c": null,
    "o": [
      "def fib():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b",
      "def fib():\n    return [0, 1, 1, 2, 3, 5]",
      "def fib():\n    yield from [0, 1, 1, 2, 3, 5]",
      "def fib():\n    a = [0, 1]\n    return a"
    ]
  },
  {
    "q": "What is the main benefit of using timeit over time.time()?",
    "c": null,
    "o": [
      "timeit avoids system clock inaccuracies and warm-up issues",
      "timeit is easier to use in production code",
      "timeit is slower but more readable",
      "timeit does not require importing modules"
    ]
  },
  {
    "q": "Which sorting algorithm can be optimized using insertion sort for small partitions?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "g = (x for x in range(3))\nprint(next(g), next(g))",
    "o": [
      "0 1",
      "1 2",
      "0 2",
      "[0, 1]"
    ]
  },
  {
    "q": "Which of the following best explains 'space complexity'?",
    "c": null,
    "o": [
      "It is the total memory required by the algorithm",
      "It measures CPU load",
      "It refers to disk usage during execution",
      "It only applies to recursive functions"
    ]
  },
  {
    "q": "Which type of algorithm optimization reduces the need to compute the same thing multiple times?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy strategy",
      "Looping",
      "Encapsulation"
    ]
  },
  {
    "q": "Which of the following generator-based function will yield 0, 2, 4?",
    "c": null,
    "o": [
      "def evens():\n    for i in range(5):\n        if i % 2 == 0:\n            yield i",
      "def evens():\n    yield from [0, 2, 4, 6]",
      "def evens():\n    return [i for i in range(5) if i % 2 == 0]",
      "def evens():\n    pass"
    ]
  },
  {
    "q": "What’s the best-case time complexity of insertion sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of these techniques helps reduce memory usage while iterating over large datasets?",
    "c": null,
    "o": [
      "Using generators",
      "Using nested lists",
      "Using recursion",
      "Using global variables"
    ]
  },
  {
    "q": "Which of the following tools would best help analyze time spent in different functions?",
    "c": null,
    "o": [
      "cProfile",
      "logging",
      "traceback",
      "re"
    ]
  },
  {
    "q": "What is the time complexity of appending an element to the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "def foo():\n    yield 5\n    yield 10\nf = foo()\nprint(next(f))",
    "o": [
      "5",
      "10",
      "[5, 10]",
      "None"
    ]
  },
  {
    "q": "Which of the following best describes code optimization?",
    "c": null,
    "o": [
      "Improving efficiency in time or space",
      "Writing code with more comments",
      "Using recursion always",
      "Maximizing the number of variables"
    ]
  },
  {
    "q": "Which expression would you use to create a generator of cubes from 1 to 5?",
    "c": null,
    "o": [
      "(x**3 for x in range(1, 6))",
      "[x**3 for x in range(1, 6)]",
      "{x**3 for x in range(1, 6)}",
      "tuple(x**3 for x in range(1, 6))"
    ]
  },
  {
    "q": "Which case does Big-O typically describe?",
    "c": null,
    "o": [
      "Worst-case",
      "Best-case",
      "Average-case",
      "Best and average together"
    ]
  },
  {
    "q": "Which of the following reduces the number of disk reads in data processing?",
    "c": null,
    "o": [
      "Batching reads with generators",
      "Using print() inside loops",
      "Calling input() repeatedly",
      "Building huge lists in memory"
    ]
  },
  {
    "q": "Which profiling tool is useful for line-by-line execution time?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "timeit",
      "tracemalloc"
    ]
  },
  {
    "q": "Which is an example of an optimization that affects only time complexity?",
    "c": null,
    "o": [
      "Replacing nested loops with hashing",
      "Using float instead of int",
      "Reducing list size",
      "Using yield instead of return"
    ]
  },
  {
    "q": "Which of the following Python techniques helps optimize both speed and memory?",
    "c": null,
    "o": [
      "Using generator expressions",
      "Using global variables",
      "Copying large lists frequently",
      "Adding unnecessary function calls"
    ]
  },
  {
    "q": "What is the time complexity of the following code?",
    "c": "for i in range(n):\n    for j in range(100):\n        pass",
    "o": [
      "O(n)",
      "O(n^2)",
      "O(1)",
      "O(log n)"
    ]
  },
  {
    "q": "What is the primary reason to use list comprehension over a regular for-loop?",
    "c": null,
    "o": [
      "Improved performance and cleaner syntax",
      "It uses recursion internally",
      "It always returns a tuple",
      "It allows modifying the list while iterating"
    ]
  },
  {
    "q": "What does the following generator return?",
    "c": "def squares():\n    for i in range(3):\n        yield i ** 2\n\nprint(list(squares()))",
    "o": [
      "[0, 1, 4]",
      "[1, 4, 9]",
      "(0, 1, 4)",
      "[0, 1, 2]"
    ]
  },
  {
    "q": "Which is true about Python's timeit module?",
    "c": null,
    "o": [
      "It minimizes the effect of background processes on timing",
      "It can only time one function",
      "It’s inaccurate for small code blocks",
      "It prints memory usage"
    ]
  },
  {
    "q": "Which of the following contributes most to high space complexity?",
    "c": null,
    "o": [
      "Creating multiple large lists",
      "Using integer division",
      "Calling input() inside loops",
      "Using break statements"
    ]
  },
  {
    "q": "Which Python data structure typically gives O(1) lookup time?",
    "c": null,
    "o": [
      "dict",
      "list",
      "tuple",
      "set (ordered)"
    ]
  },
  {
    "q": "Which optimization reduces redundant computation by storing prior results?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Heap sort",
      "Divide and conquer"
    ]
  },
  {
    "q": "Which of the following will consume the least memory?",
    "c": null,
    "o": [
      "(x for x in range(1000000))",
      "[x for x in range(1000000)]",
      "{x for x in range(1000000)}",
      "tuple(x for x in range(1000000))"
    ]
  },
  {
    "q": "What is the worst-case time complexity of accessing a value in a Python set?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is the best choice for profiling the runtime of a single Python function?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "cProfile.run()",
      "gc.collect()",
      "os.clock()"
    ]
  },
  {
    "q": "What does this generator function output?",
    "c": "def gen():\n    yield 1\n    yield 2\n    yield 3\nprint(next(gen()))",
    "o": [
      "1",
      "2",
      "3",
      "[1, 2, 3]"
    ]
  },
  {
    "q": "Which of the following is a performance optimization technique?",
    "c": null,
    "o": [
      "Avoiding deep copy of large structures",
      "Increasing recursion depth",
      "Using nested loops",
      "Using eval() frequently"
    ]
  },
  {
    "q": "What is the best-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following will yield better space efficiency when handling very large datasets?",
    "c": null,
    "o": [
      "Streaming data using generators",
      "Storing all data in a list",
      "Using recursion to loop",
      "Reading all data into memory"
    ]
  },
  {
    "q": "Which Python construct supports short-circuit evaluation and may improve performance?",
    "c": null,
    "o": [
      "and / or operators",
      "for loops",
      "while loops",
      "lambda functions"
    ]
  },
  {
    "q": "What is the time complexity of checking membership in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these methods helps identify the line of code where time is being spent?",
    "c": null,
    "o": [
      "line_profiler",
      "timeit",
      "gc",
      "os.system"
    ]
  },
  {
    "q": "What optimization technique is shown here?\n`cache = {}; def fib(n): if n in cache: return cache[n]`",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Branch prediction",
      "Loop unrolling"
    ]
  },
  {
    "q": "Which is a correct example of a generator expression?",
    "c": null,
    "o": [
      "(x for x in range(10))",
      "[x for x in range(10)]",
      "{x for x in range(10)}",
      "tuple(x for x in range(10))"
    ]
  },
  {
    "q": "Which of these has the best average-case time complexity for searching in a sorted list?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Bubble Sort",
      "Depth-First Search"
    ]
  },
  {
    "q": "Which of the following avoids loading the full result into memory?",
    "c": null,
    "o": [
      "Generators",
      "List Comprehension",
      "Set Comprehension",
      "Dictionary"
    ]
  },
  {
    "q": "Which is the space complexity of an algorithm that uses a fixed-size array regardless of input size?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the primary difference between yield and return?",
    "c": null,
    "o": [
      "yield pauses function state; return ends it",
      "return pauses function state; yield ends it",
      "Both yield and return end execution",
      "yield is used for conditional logic"
    ]
  },
  {
    "q": "Which of the following Python features improves performance for repetitive calculations?",
    "c": null,
    "o": [
      "Memoization",
      "Decorators",
      "Recursion",
      "Inheritance"
    ]
  },
  {
    "q": "What will this generator produce?",
    "c": "def even():\n    for i in range(6):\n        if i % 2 == 0:\n            yield i\nprint(list(even()))",
    "o": [
      "[0, 2, 4]",
      "[1, 3, 5]",
      "[2, 4, 6]",
      "[0, 2, 4, 6]"
    ]
  },
  {
    "q": "What’s the key advantage of using cProfile over timeit?",
    "c": null,
    "o": [
      "It analyzes time spent per function",
      "It supports only single-line code",
      "It returns values instead of time",
      "It helps with garbage collection"
    ]
  },
  {
    "q": "Which of the following is an inefficient way to build a large string in Python?",
    "c": null,
    "o": [
      "Concatenating with += inside a loop",
      "Using ''.join() on a list",
      "Using list comprehension with join",
      "Using StringIO"
    ]
  },
  {
    "q": "What is the output of this generator expression?\nprint(sum(x for x in range(4)))",
    "c": null,
    "o": [
      "6",
      "4",
      "3",
      "[0, 1, 2, 3]"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which optimization technique defers computation until its result is needed?",
    "c": null,
    "o": [
      "Lazy evaluation",
      "Greedy evaluation",
      "Immediate execution",
      "Memoization"
    ]
  },
  {
    "q": "Which of the following improves performance by reducing redundant I/O operations?",
    "c": null,
    "o": [
      "Buffering",
      "Recursion",
      "Nested loops",
      "Generators"
    ]
  },
  {
    "q": "Which is the best use of a generator in Python?",
    "c": null,
    "o": [
      "Processing large sequences without storing all values",
      "Storing frequently accessed data in memory",
      "Optimizing file download speed",
      "Implementing recursion"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "def g():\n    yield 'A'\n    yield 'B'\nprint(next(g()))",
    "o": [
      "A",
      "B",
      "[A, B]",
      "None"
    ]
  },
  {
    "q": "Which data structure provides O(log n) time for insert and search?",
    "c": null,
    "o": [
      "Binary Search Tree (BST)",
      "List",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "Which of the following is a downside of deep recursion?",
    "c": null,
    "o": [
      "Stack overflow",
      "Faster computation",
      "Memory leaks",
      "Increased readability"
    ]
  },
  {
    "q": "Which technique is commonly used to avoid repeated computation in recursive solutions?",
    "c": null,
    "o": [
      "Caching",
      "Loop unrolling",
      "Global variables",
      "Garbage collection"
    ]
  },
  {
    "q": "Which function measures the most precise elapsed time for benchmarking?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "datetime.datetime.now()",
      "os.clock()"
    ]
  },
  {
    "q": "Which of these contributes to better cache utilization in loops?",
    "c": null,
    "o": [
      "Accessing elements in sequential memory order",
      "Using random access inside loops",
      "Breaking loops frequently",
      "Recursively calling loops"
    ]
  },
  {
    "q": "Which is a good strategy to reduce time complexity from O(n^2) to O(n)?",
    "c": null,
    "o": [
      "Using hashing",
      "Using nested loops",
      "Increasing loop count",
      "Using larger data types"
    ]
  },
  {
    "q": "Which code snippet uses a generator expression to calculate the sum of squares from 0 to 9?",
    "c": null,
    "o": [
      "sum(x*x for x in range(10))",
      "sum([x*x for x in range(10)])",
      "sum({x*x for x in range(10)})",
      "sum(tuple(x*x for x in range(10)))"
    ]
  },
  {
    "q": "What does time complexity O(log n) imply?",
    "c": null,
    "o": [
      "The algorithm cuts the problem size in half at each step",
      "The algorithm examines every element",
      "The algorithm performs exponentially more steps as input grows",
      "The algorithm has a constant execution time"
    ]
  },
  {
    "q": "Which optimization technique is best suited for avoiding unnecessary function calls?",
    "c": null,
    "o": [
      "Short-circuit evaluation",
      "Recursion",
      "Loop nesting",
      "Global variables"
    ]
  },
  {
    "q": "Which Python keyword is essential for creating a generator function?",
    "c": null,
    "o": [
      "yield",
      "return",
      "lambda",
      "async"
    ]
  },
  {
    "q": "Which of the following profiling tools can analyze both time and function call count?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "functools",
      "sys"
    ]
  },
  {
    "q": "Which time complexity describes binary search on a sorted list?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What’s the space complexity of a function that uses recursion with depth proportional to input size?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def items():\n    for i in range(2):\n        yield i\nprint(list(items()))",
    "o": [
      "[0, 1]",
      "[1, 2]",
      "(0, 1)",
      "[0, 1, 2]"
    ]
  },
  {
    "q": "Which expression consumes the least memory for large ranges?",
    "c": null,
    "o": [
      "(x for x in range(1000000))",
      "[x for x in range(1000000)]",
      "{x for x in range(1000000)}",
      "tuple(x for x in range(1000000))"
    ]
  },
  {
    "q": "Which of the following is a key advantage of using built-in functions like `map()` or `sum()` in Python?",
    "c": null,
    "o": [
      "They are implemented in C and are usually faster",
      "They reduce memory usage by default",
      "They use recursion internally",
      "They allow changing variable scopes"
    ]
  },
  {
    "q": "Which of the following helps identify slow functions in large Python programs?",
    "c": null,
    "o": [
      "cProfile",
      "time.sleep",
      "random.seed",
      "functools.partial"
    ]
  },
  {
    "q": "Which technique allows reusing previously computed results to optimize performance?",
    "c": null,
    "o": [
      "Memoization",
      "Inheritance",
      "Dynamic typing",
      "Recursion"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\nprint(next(countdown(3)))",
    "o": [
      "3",
      "2",
      "[3, 2, 1]",
      "None"
    ]
  },
  {
    "q": "Which of the following uses less memory for large computations?",
    "c": null,
    "o": [
      "Generator",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "Which tool is best for benchmarking small code snippets in isolation?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "line_profiler",
      "psutil"
    ]
  },
  {
    "q": "What is the time complexity of merging two sorted lists of size n each?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which built-in function can be used to apply a function to every item of an iterable?",
    "c": null,
    "o": [
      "map()",
      "filter()",
      "reduce()",
      "lambda"
    ]
  },
  {
    "q": "Which expression creates a memory-efficient infinite sequence of even numbers?",
    "c": null,
    "o": [
      "def evens():\n    i = 0\n    while True:\n        yield i\n        i += 2",
      "range(0, 1000000, 2)",
      "[x for x in range(1000000) if x % 2 == 0]",
      "set(range(0, 1000000, 2))"
    ]
  },
  {
    "q": "What does the Big-O notation O(n log n) commonly represent?",
    "c": null,
    "o": [
      "Efficient sorting algorithms",
      "Simple loops",
      "Constant time operations",
      "Exponential complexity"
    ]
  },
  {
    "q": "Which statement about list comprehensions is TRUE?",
    "c": null,
    "o": [
      "They are generally faster than equivalent for-loops",
      "They use more memory than for-loops",
      "They can't use conditions",
      "They are slower but more readable"
    ]
  },
  {
    "q": "Which of the following Python tools can be used to measure peak memory usage?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "timeit",
      "gc"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "gen = (i for i in range(5) if i % 2 == 0)\nprint(list(gen))",
    "o": [
      "[0, 2, 4]",
      "[1, 3]",
      "[0, 1, 2, 3, 4]",
      "[2, 4]"
    ]
  },
  {
    "q": "Which of the following methods is most appropriate for reducing algorithmic time complexity?",
    "c": null,
    "o": [
      "Using efficient data structures like sets or dictionaries",
      "Writing longer code",
      "Using more nested loops",
      "Increasing recursion depth"
    ]
  },
  {
    "q": "What does time complexity O(1) signify?",
    "c": null,
    "o": [
      "Constant time regardless of input size",
      "Linear growth in time",
      "Logarithmic performance",
      "Dependent on input size"
    ]
  },
  {
    "q": "Which of the following is an example of lazy evaluation?",
    "c": null,
    "o": [
      "Using generator expressions",
      "Using list comprehensions",
      "Evaluating if-else blocks",
      "Reading from a file line-by-line into a list"
    ]
  },
  {
    "q": "What will the following generator produce?",
    "c": "def countdown(n):\n    while n:\n        yield n\n        n -= 1\nprint(list(countdown(3)))",
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[0, 1, 2]",
      "[2, 1, 0]"
    ]
  },
  {
    "q": "Which Python built-in is best for filtering items from a list based on a condition?",
    "c": null,
    "o": [
      "filter()",
      "map()",
      "sum()",
      "range()"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following is LEAST likely to help optimize performance?",
    "c": null,
    "o": [
      "Using deeply nested loops unnecessarily",
      "Using sets for fast membership testing",
      "Using built-in functions",
      "Applying memoization"
    ]
  },
  {
    "q": "Which code snippet is an example of memoization?",
    "c": "cache = {}\ndef fib(n):\n    if n in cache:\n        return cache[n]\n    if n < 2:\n        result = n\n    else:\n        result = fib(n-1) + fib(n-2)\n    cache[n] = result\n    return result",
    "o": [
      "It stores results to avoid redundant computation",
      "It increases recursion depth",
      "It uses iteration over recursion",
      "It returns a generator"
    ]
  },
  {
    "q": "Which of these best explains the time complexity of nested loops?",
    "c": "for i in range(n):\n    for j in range(n):\n        pass",
    "o": [
      "O(n^2)",
      "O(n)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which approach is more memory-efficient when processing large logs line-by-line?",
    "c": null,
    "o": [
      "Using a generator function to yield each line",
      "Reading the entire file into a list",
      "Storing all lines in a dictionary",
      "Appending lines to a string"
    ]
  },
  {
    "q": "Which of the following profiles memory usage line-by-line?",
    "c": null,
    "o": [
      "memory_profiler",
      "line_profiler",
      "timeit",
      "cProfile"
    ]
  },
  {
    "q": "Which of the following operations is most expensive in terms of time complexity?",
    "c": null,
    "o": [
      "Searching in a list",
      "Accessing a dictionary key",
      "Iterating a generator",
      "Appending to a list"
    ]
  },
  {
    "q": "Which data structure helps reduce the time complexity of lookups from O(n) to O(1)?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Stack"
    ]
  },
  {
    "q": "What is the result of this generator expression?",
    "c": "print(sum(x for x in range(1, 5)))",
    "o": [
      "10",
      "[1, 2, 3, 4]",
      "15",
      "None"
    ]
  },
  {
    "q": "Which of the following can reduce both time and space complexity?",
    "c": null,
    "o": [
      "Using generators instead of lists",
      "Using recursion instead of loops",
      "Storing data in global variables",
      "Using list slicing extensively"
    ]
  },
  {
    "q": "Which of the following has the lowest time complexity?",
    "c": null,
    "o": [
      "Accessing an element by index in a list",
      "Searching a value in a list",
      "Sorting a list",
      "Copying a list"
    ]
  },
  {
    "q": "Which is the most efficient way to generate squares of numbers 0 through 9?",
    "c": null,
    "o": [
      "[x*x for x in range(10)]",
      "list(map(lambda x: x*x, range(10)))",
      "for x in range(10): print(x*x)",
      "set(x*x for x in range(10))"
    ]
  },
  {
    "q": "What is the average-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following avoids storing the entire result set in memory?",
    "c": null,
    "o": [
      "Using generator expressions",
      "Using list comprehensions",
      "Using sets",
      "Using dictionaries"
    ]
  },
  {
    "q": "Which optimization technique is ideal for reducing duplicate calculations in recursive functions?",
    "c": null,
    "o": [
      "Memoization",
      "Loop unrolling",
      "Lambda functions",
      "Stacking"
    ]
  },
  {
    "q": "Which Python module is most appropriate for CPU profiling?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "memory_profiler",
      "psutil"
    ]
  },
  {
    "q": "What is the time complexity of checking the existence of a key in a dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these would likely use less memory for iterating over a million items?",
    "c": null,
    "o": [
      "(x for x in range(10**6))",
      "[x for x in range(10**6)]",
      "{x for x in range(10**6)}",
      "tuple(x for x in range(10**6))"
    ]
  },
  {
    "q": "What does the 'yield' keyword do in Python?",
    "c": null,
    "o": [
      "Returns a value and suspends function state",
      "Terminates the function completely",
      "Creates a static variable",
      "Calls a function recursively"
    ]
  },
  {
    "q": "Which technique helps avoid recomputing intermediate results in dynamic programming?",
    "c": null,
    "o": [
      "Caching",
      "List comprehension",
      "Set operations",
      "Recursion"
    ]
  },
  {
    "q": "What is the time complexity of building a list with list comprehension?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which expression creates an infinite lazy sequence of natural numbers?",
    "c": null,
    "o": [
      "def naturals():\n    n = 0\n    while True:\n        yield n\n        n += 1",
      "range(0, 1000000)",
      "[x for x in range(100)]",
      "{x for x in range(100)}"
    ]
  },
  {
    "q": "Which code snippet will print only the even numbers using a generator?",
    "c": null,
    "o": [
      "g = (x for x in range(10) if x % 2 == 0)\nprint(list(g))",
      "g = [x for x in range(10) if x % 2 == 1]\nprint(g)",
      "print(filter(lambda x: x % 2, range(10)))",
      "print(x for x in range(10) if x % 2)"
    ]
  },
  {
    "q": "Which of the following results in better time complexity when checking item existence?",
    "c": null,
    "o": [
      "Using a set",
      "Using a list",
      "Using a tuple",
      "Using a string"
    ]
  },
  {
    "q": "Which function is more suitable for measuring high-resolution time in Python?",
    "c": null,
    "o": [
      "time.perf_counter()",
      "time.time()",
      "datetime.now()",
      "time.clock()"
    ]
  },
  {
    "q": "Which of the following would reduce the time complexity of finding duplicates in a list?",
    "c": null,
    "o": [
      "Using a set to track seen items",
      "Sorting the list repeatedly",
      "Using nested loops",
      "Using recursion"
    ]
  },
  {
    "q": "What is the output of this generator code?",
    "c": "def g():\n    for i in range(3):\n        yield i\nx = g()\nprint(next(x))",
    "o": [
      "0",
      "1",
      "2",
      "[0, 1, 2]"
    ]
  },
  {
    "q": "Which of the following is NOT a valid benefit of list comprehensions?",
    "c": null,
    "o": [
      "They use less memory than generators",
      "They produce concise code",
      "They execute faster than for-loops",
      "They are easy to read for simple logic"
    ]
  },
  {
    "q": "Which Python feature allows you to avoid loading all data at once from a file?",
    "c": null,
    "o": [
      "Using a generator to yield lines",
      "Using readlines()",
      "Using open().read()",
      "Using json.load()"
    ]
  },
  {
    "q": "Which of the following will help reduce the number of function calls?",
    "c": null,
    "o": [
      "Inlining loops or logic where possible",
      "Adding more nested functions",
      "Using deep recursion",
      "Using lambda expressions"
    ]
  },
  {
    "q": "What is the space complexity of creating a list using list comprehension with n items?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which scenario is best suited for using the `filter()` function?",
    "c": null,
    "o": [
      "When you want to extract elements based on a condition",
      "When you want to transform all elements",
      "When you want to sort a list",
      "When you want to reduce elements to a single value"
    ]
  },
  {
    "q": "Which of the following can reduce function call overhead in tight loops?",
    "c": null,
    "o": [
      "Using local variables for lookups",
      "Using global variables only",
      "Using deeply nested functions",
      "Using print statements frequently"
    ]
  },
  {
    "q": "Which of the following helps identify which lines of a function consume the most time?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "timeit",
      "functools"
    ]
  },
  {
    "q": "Which of the following Python operations is considered O(1)?",
    "c": null,
    "o": [
      "Accessing a list element by index",
      "Searching for an element in a list",
      "Sorting a list",
      "Appending to the start of a list"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "def get_items():\n    yield from [1, 2, 3]\nprint(next(get_items()))",
    "o": [
      "1",
      "2",
      "[1, 2, 3]",
      "(1, 2, 3)"
    ]
  },
  {
    "q": "Which scenario is a good candidate for using `itertools`?",
    "c": null,
    "o": [
      "To build efficient iterators for large datasets",
      "To sort a small list quickly",
      "To print formatted strings",
      "To perform file I/O"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching for an item in an unsorted list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python function is used to reduce a sequence to a single value?",
    "c": null,
    "o": [
      "reduce()",
      "filter()",
      "map()",
      "range()"
    ]
  },
  {
    "q": "What does the following generator expression do?",
    "c": "gen = (x for x in range(5) if x % 2)\nprint(list(gen))",
    "o": [
      "[1, 3]",
      "[0, 2, 4]",
      "[2, 4]",
      "[1, 2, 3]"
    ]
  },
  {
    "q": "What optimization strategy is shown in this code?\n\nif x and expensive_check(x):",
    "c": null,
    "o": [
      "Short-circuit evaluation",
      "Memoization",
      "Loop unrolling",
      "Eager evaluation"
    ]
  },
  {
    "q": "Which operation is most optimized in Python sets compared to lists?",
    "c": null,
    "o": [
      "Membership test (in)",
      "Iteration",
      "Sorting",
      "Indexing"
    ]
  },
  {
    "q": "Which Python feature can help reduce memory leaks in long-running applications?",
    "c": null,
    "o": [
      "Garbage collection",
      "Infinite loops",
      "List comprehension",
      "Recursive functions"
    ]
  },
  {
    "q": "What is the main benefit of using `yield` in a function?",
    "c": null,
    "o": [
      "It allows generating values one at a time, saving memory",
      "It automatically caches the results",
      "It executes the function faster than return",
      "It increases the recursion limit"
    ]
  },
  {
    "q": "Which of these provides the most accurate profiling for CPU-bound functions?",
    "c": null,
    "o": [
      "cProfile",
      "time.sleep()",
      "memory_profiler",
      "functools.lru_cache"
    ]
  },
  {
    "q": "Which of the following has a space complexity of O(1)?",
    "c": "def print_first(arr):\n    print(arr[0])",
    "o": [
      "It uses constant space regardless of input size",
      "It uses space proportional to input",
      "It uses space equal to the array size",
      "It grows with input logarithmically"
    ]
  },
  {
    "q": "What does the `functools.lru_cache` decorator help with?",
    "c": null,
    "o": [
      "Avoiding repeated computation by caching results",
      "Creating generator expressions",
      "Handling infinite recursion",
      "Sorting data efficiently"
    ]
  },
  {
    "q": "Which of these best describes space complexity?",
    "c": null,
    "o": [
      "Amount of memory used relative to input size",
      "Number of recursive calls made",
      "Number of CPU instructions used",
      "Time needed to access disk"
    ]
  },
  {
    "q": "Which of the following Python expressions uses a generator?",
    "c": null,
    "o": [
      "(x**2 for x in range(5))",
      "[x**2 for x in range(5)]",
      "{x**2 for x in range(5)}",
      "tuple(x**2 for x in range(5))"
    ]
  },
  {
    "q": "Which of the following is NOT typically used for performance profiling in Python?",
    "c": null,
    "o": [
      "math.factorial",
      "cProfile",
      "line_profiler",
      "timeit"
    ]
  },
  {
    "q": "What is a primary downside of recursion for large inputs?",
    "c": null,
    "o": [
      "Stack overflow",
      "Faster execution",
      "Smaller memory footprint",
      "Improved readability"
    ]
  },
  {
    "q": "Which scenario is best for using `map()` in Python?",
    "c": null,
    "o": [
      "Applying the same transformation to all items in a list",
      "Filtering a list by a condition",
      "Summing a list of numbers",
      "Sorting elements in a list"
    ]
  },
  {
    "q": "Which built-in Python module supports memoization through decorators?",
    "c": null,
    "o": [
      "functools",
      "math",
      "os",
      "gc"
    ]
  },
  {
    "q": "What does the following generator do?",
    "c": "def gen():\n    yield 1\n    yield 2\n    yield 3\nprint(sum(gen()))",
    "o": [
      "6",
      "123",
      "[1, 2, 3]",
      "Error"
    ]
  },
  {
    "q": "What is the time complexity of searching in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following can reduce both time and space complexity in large data pipelines?",
    "c": null,
    "o": [
      "Generators",
      "List comprehensions",
      "Deep recursion",
      "Global variables"
    ]
  },
  {
    "q": "Which code uses a generator expression to calculate the product of numbers 1 to 4?",
    "c": null,
    "o": [
      "import math\nmath.prod(x for x in range(1, 5))",
      "math.prod([x for x in range(1, 5)])",
      "sum(x for x in range(1, 5))",
      "reduce(lambda x, y: x * y, range(1, 5))"
    ]
  },
  {
    "q": "Which Python tool shows the cumulative time spent in each function?",
    "c": null,
    "o": [
      "cProfile",
      "time.perf_counter()",
      "memory_profiler",
      "gc.collect()"
    ]
  },
  {
    "q": "What is the main advantage of `itertools` in algorithm optimization?",
    "c": null,
    "o": [
      "It provides memory-efficient iterator building blocks",
      "It speeds up recursion",
      "It automatically caches all data",
      "It enables GPU acceleration"
    ]
  },
  {
    "q": "Which of the following is most likely to cause a stack overflow?",
    "c": null,
    "o": [
      "Deep recursion",
      "List comprehension",
      "Generator usage",
      "Set creation"
    ]
  },
  {
    "q": "Which time complexity is considered most scalable for large inputs?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which Python expression creates a list of cubes from 1 to 5 using list comprehension?",
    "c": null,
    "o": [
      "[x**3 for x in range(1, 6)]",
      "[x*3 for x in range(1, 6)]",
      "(x**3 for x in range(1, 6))",
      "cube(x for x in range(1, 6))"
    ]
  },
  {
    "q": "Which of the following is an efficient way to test performance of a single statement?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "os.time()",
      "psutil"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of algorithm analysis?",
    "c": null,
    "o": [
      "To evaluate performance and resource usage",
      "To generate pseudocode automatically",
      "To convert Python code to machine code",
      "To visualize recursion trees"
    ]
  },
  {
    "q": "What is the worst-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which generator expression will yield all odd numbers below 10?",
    "c": null,
    "o": [
      "(x for x in range(10) if x % 2 != 0)",
      "(x for x in range(10) if x % 2 == 0)",
      "[x for x in range(10) if x % 2]",
      "{x for x in range(10) if x % 2 != 0}"
    ]
  },
  {
    "q": "Which technique avoids creating unnecessary intermediate data structures?",
    "c": null,
    "o": [
      "Generator expressions",
      "List slicing",
      "Lambda expressions",
      "Copying lists"
    ]
  },
  {
    "q": "Which statement about list comprehensions is FALSE?",
    "c": null,
    "o": [
      "They are more memory-efficient than generators",
      "They are generally faster than for-loops",
      "They are used to construct new lists",
      "They provide concise syntax"
    ]
  },
  {
    "q": "Which of the following tools helps track memory usage over time in a Python script?",
    "c": null,
    "o": [
      "memory_profiler",
      "timeit",
      "line_profiler",
      "cProfile"
    ]
  },
  {
    "q": "Which data structure is most efficient for lookups and inserts?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set (ordered)"
    ]
  },
  {
    "q": "What is the space complexity of a recursive function that stores no intermediate results?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which operation has O(n log n) time complexity in the average case?",
    "c": null,
    "o": [
      "Merge Sort",
      "Linear Search",
      "Binary Search",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following can improve the performance of repeated expensive computations?",
    "c": null,
    "o": [
      "Caching results",
      "Using nested loops",
      "Using recursion",
      "Using global variables"
    ]
  },
  {
    "q": "Which Python module can be used to cache function results automatically?",
    "c": null,
    "o": [
      "functools",
      "collections",
      "heapq",
      "random"
    ]
  },
  {
    "q": "Which of the following gives the best performance for large-scale data filtering?",
    "c": null,
    "o": [
      "Using generators with conditions",
      "Using nested for-loops",
      "Using list concatenation",
      "Using deep recursion"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "def gen():\n    yield 'A'\n    yield 'B'\nprint(list(gen()))",
    "o": [
      "['A', 'B']",
      "['B', 'A']",
      "'A', 'B'",
      "['A', 'B', 'C']"
    ]
  },
  {
    "q": "Which of these approaches has the least memory overhead?",
    "c": null,
    "o": [
      "Using generator functions",
      "Using list comprehensions",
      "Using nested dictionaries",
      "Using multiple global variables"
    ]
  },
  {
    "q": "Which of the following will most likely cause time complexity to increase rapidly?",
    "c": null,
    "o": [
      "Nested loops over large datasets",
      "Single-level iteration",
      "Generator-based iteration",
      "List slicing"
    ]
  },
  {
    "q": "Which Python function can be used to measure execution time of small code snippets?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "time.sleep()",
      "cProfile.run()",
      "datetime.now()"
    ]
  },
  {
    "q": "Which of the following sorts data using a divide-and-conquer approach?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Linear Sort"
    ]
  },
  {
    "q": "Which is a valid use of the time complexity O(n^2)?",
    "c": null,
    "o": [
      "Comparing all pairs in a list",
      "Appending items to a list",
      "Finding max in a list",
      "Searching in a set"
    ]
  },
  {
    "q": "Which tool provides function-level profiling details such as number of calls and cumulative time?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "psutil",
      "os"
    ]
  },
  {
    "q": "Which Python optimization technique avoids loading all data into memory at once?",
    "c": null,
    "o": [
      "Streaming with generators",
      "List slicing",
      "Using default arguments",
      "Manual garbage collection"
    ]
  },
  {
    "q": "Which of the following code patterns creates an infinite generator?",
    "c": "def count_up():\n    i = 0\n    while True:\n        yield i\n        i += 1",
    "o": [
      "It generates an infinite sequence starting from 0",
      "It stops at 1000",
      "It raises an error after 10 iterations",
      "It returns a list of values"
    ]
  },
  {
    "q": "What is the average-case time complexity of binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following profiles memory usage line-by-line in a Python script?",
    "c": null,
    "o": [
      "memory_profiler",
      "cProfile",
      "timeit",
      "gc"
    ]
  },
  {
    "q": "Which approach avoids unnecessary list construction during iteration?",
    "c": null,
    "o": [
      "Using generator expressions",
      "Using list comprehensions",
      "Using copy.copy()",
      "Using nested loops"
    ]
  },
  {
    "q": "Which of the following operations on Python lists has O(n) time complexity?",
    "c": null,
    "o": [
      "Removing an element from the beginning",
      "Accessing an element by index",
      "Appending to the end",
      "Replacing an element"
    ]
  },
  {
    "q": "What is the main reason to prefer `range()` over `list(range())` in loops?",
    "c": null,
    "o": [
      "range is a generator-like object and uses less memory",
      "list(range()) is not allowed in loops",
      "range is faster because it is a list",
      "range allows random access, list does not"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "def evens():\n    for i in range(6):\n        if i % 2 == 0:\n            yield i\nprint(list(evens()))",
    "o": [
      "[0, 2, 4]",
      "[1, 3, 5]",
      "[2, 4, 6]",
      "[0, 2, 4, 6]"
    ]
  },
  {
    "q": "Which of the following techniques is best when dealing with a large file line-by-line?",
    "c": null,
    "o": [
      "Using a generator to yield each line",
      "Reading the entire file at once into a list",
      "Storing all lines in memory",
      "Using recursive file reading"
    ]
  },
  {
    "q": "Which decorator from functools is used to enable result caching?",
    "c": null,
    "o": [
      "lru_cache",
      "wraps",
      "partial",
      "reduce"
    ]
  },
  {
    "q": "Which of these data structures is most suitable for fast lookup operations?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "String"
    ]
  },
  {
    "q": "Which of the following is the most efficient for iterating large datasets?",
    "c": null,
    "o": [
      "Using a generator function",
      "Using a while loop",
      "Using a list comprehension",
      "Using recursion"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "print(any(x > 3 for x in [1, 2, 3, 4]))",
    "o": [
      "True",
      "False",
      "[True, False]",
      "Error"
    ]
  },
  {
    "q": "Which of these has the best time complexity for searching for an element?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Deque"
    ]
  },
  {
    "q": "Which of the following techniques can reduce time complexity in recursive algorithms?",
    "c": null,
    "o": [
      "Memoization",
      "Using global variables",
      "Increasing recursion depth",
      "Calling functions inside loops"
    ]
  },
  {
    "q": "Which tool is best suited for analyzing function call count and total time spent?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "gc",
      "memory_profiler"
    ]
  },
  {
    "q": "Which is the correct way to define a memory-efficient iterable?",
    "c": null,
    "o": [
      "(x for x in range(1000000))",
      "[x for x in range(1000000)]",
      "{x for x in range(1000000)}",
      "tuple(x for x in range(1000000))"
    ]
  },
  {
    "q": "Which of the following Python data types maintains insertion order since Python 3.7?",
    "c": null,
    "o": [
      "dict",
      "set",
      "tuple",
      "frozenset"
    ]
  },
  {
    "q": "Which expression will calculate the sum of squares using the least memory?",
    "c": null,
    "o": [
      "sum(x**2 for x in range(10000))",
      "sum([x**2 for x in range(10000)])",
      "sum({x**2 for x in range(10000)})",
      "sum(map(lambda x: x**2, list(range(10000))))"
    ]
  },
  {
    "q": "Which of the following is true about `timeit`?",
    "c": null,
    "o": [
      "It executes code in isolation to provide accurate timing",
      "It visualizes profiling data",
      "It measures memory usage",
      "It debugs recursive functions"
    ]
  },
  {
    "q": "Which optimization method replaces repetitive function calls with precomputed values?",
    "c": null,
    "o": [
      "Caching",
      "Loop unrolling",
      "Inlining",
      "Lazy evaluation"
    ]
  },
  {
    "q": "Which is the most memory-efficient method for reading a large file line by line?",
    "c": null,
    "o": [
      "Using a generator with open()",
      "Using readlines()",
      "Using open().read()",
      "Storing all lines in a list"
    ]
  },
  {
    "q": "Which of the following expressions uses the least memory?",
    "c": null,
    "o": [
      "(x*x for x in range(100000))",
      "[x*x for x in range(100000)]",
      "{x*x for x in range(100000)}",
      "list(map(lambda x: x*x, range(100000)))"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python module helps detect performance bottlenecks by function?",
    "c": null,
    "o": [
      "cProfile",
      "memory_profiler",
      "heapq",
      "os"
    ]
  },
  {
    "q": "Which method is preferred for large and lazy sequences?",
    "c": null,
    "o": [
      "Generator expressions",
      "List comprehensions",
      "Dictionary comprehension",
      "Set comprehension"
    ]
  },
  {
    "q": "Which of these operations is typically O(1) in Python dictionaries?",
    "c": null,
    "o": [
      "Key lookup",
      "Key deletion",
      "Sorting keys",
      "Copying dictionary"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "gen = (x for x in range(3))\nprint(next(gen))",
    "o": [
      "0",
      "1",
      "[0, 1, 2]",
      "Error"
    ]
  },
  {
    "q": "Which profiling method introduces the least overhead during code execution?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "line_profiler",
      "memory_profiler"
    ]
  },
  {
    "q": "Which of the following will help reduce both runtime and memory usage?",
    "c": null,
    "o": [
      "Using generators instead of lists",
      "Using deepcopy() extensively",
      "Using global variables",
      "Using large nested loops"
    ]
  },
  {
    "q": "Which algorithm has a worst-case time complexity of O(n^2)?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Binary Search",
      "Quick Sort (on average)"
    ]
  },
  {
    "q": "Which of the following is true about space complexity?",
    "c": null,
    "o": [
      "It refers to the amount of memory used relative to input size",
      "It refers only to the size of variables in RAM",
      "It includes the size of input only, not intermediate storage",
      "It is always constant in Python"
    ]
  },
  {
    "q": "Which built-in function would you use to apply a transformation to each item in a list lazily?",
    "c": null,
    "o": [
      "map()",
      "filter()",
      "reduce()",
      "sum()"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is NOT stable?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the benefit of using `time.perf_counter()` over `time.time()`?",
    "c": null,
    "o": [
      "Higher resolution timer for benchmarking",
      "It shows date and time",
      "It uses less memory",
      "It returns a string timestamp"
    ]
  },
  {
    "q": "Which of the following is a performance benefit of using local variables in functions?",
    "c": null,
    "o": [
      "Faster access than global variables",
      "They persist across function calls",
      "They consume less memory than constants",
      "They can be shared across modules"
    ]
  },
  {
    "q": "What is the time complexity of inserting at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following avoids computing all elements upfront?",
    "c": null,
    "o": [
      "Generators",
      "Lists",
      "Tuples",
      "Dictionaries"
    ]
  },
  {
    "q": "Which of the following is used to get line-by-line memory usage statistics in Python?",
    "c": null,
    "o": [
      "memory_profiler",
      "tracemalloc",
      "gc",
      "timeit"
    ]
  },
  {
    "q": "Which Python standard library provides tools for building efficient iterators?",
    "c": null,
    "o": [
      "itertools",
      "collections",
      "os",
      "random"
    ]
  },
  {
    "q": "Which of the following will improve time complexity from O(n^2) to O(n)?",
    "c": null,
    "o": [
      "Using a set to track seen items instead of nested loops",
      "Sorting the list before searching",
      "Using recursion instead of iteration",
      "Adding more print statements for debugging"
    ]
  },
  {
    "q": "What is the main advantage of using `yield` over `return` in a function?",
    "c": null,
    "o": [
      "It produces values lazily, saving memory",
      "It is faster than return",
      "It supports multithreading automatically",
      "It works only with numeric data"
    ]
  },
  {
    "q": "Which of the following describes the average-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following would be best to process a large stream of data efficiently?",
    "c": null,
    "o": [
      "Generators",
      "Lists",
      "Tuples",
      "Sets"
    ]
  },
  {
    "q": "Which optimization technique helps minimize function calls and stack usage in recursion?",
    "c": null,
    "o": [
      "Tail recursion",
      "Global variables",
      "Using more loops",
      "Using large data structures"
    ]
  },
  {
    "q": "Which of the following code profiling tools is most accurate for small code snippets?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "memory_profiler",
      "os.times()"
    ]
  },
  {
    "q": "Which of these Python tools allows for efficient memory usage when chaining operations?",
    "c": null,
    "o": [
      "itertools",
      "math",
      "os",
      "heapq"
    ]
  },
  {
    "q": "Which has the highest memory efficiency when filtering large sequences?",
    "c": null,
    "o": [
      "filter() with a generator",
      "List comprehension",
      "Copying lists before filtering",
      "Using recursion"
    ]
  },
  {
    "q": "What is the time complexity of accessing a value in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following approaches is best for reducing memory usage in loops?",
    "c": null,
    "o": [
      "Use generator expressions instead of list comprehensions",
      "Declare variables globally",
      "Store results in a list",
      "Use deeply nested loops"
    ]
  },
  {
    "q": "Which technique is effective for optimizing repeated computations with the same inputs?",
    "c": null,
    "o": [
      "Memoization",
      "Loop unrolling",
      "Using global variables",
      "Using nested functions"
    ]
  },
  {
    "q": "Which method provides better performance for checking membership in large datasets?",
    "c": null,
    "o": [
      "Using a set",
      "Using a list",
      "Using a tuple",
      "Using a dictionary with values only"
    ]
  },
  {
    "q": "Which of the following code snippets uses a generator to produce Fibonacci numbers?",
    "c": "def fib():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b",
    "o": [
      "It yields Fibonacci numbers indefinitely",
      "It returns the 10th Fibonacci number",
      "It raises StopIteration immediately",
      "It prints the sequence instead of yielding"
    ]
  },
  {
    "q": "What is the best-case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following functions does NOT return a lazy iterator?",
    "c": null,
    "o": [
      "sorted()",
      "map()",
      "filter()",
      "zip()"
    ]
  },
  {
    "q": "Which code snippet demonstrates list comprehension?",
    "c": "squares = [x**2 for x in range(5)]",
    "o": [
      "[0, 1, 4, 9, 16]",
      "(0, 1, 4, 9, 16)",
      "{0, 1, 4, 9, 16}",
      "[1, 2, 3, 4, 5]"
    ]
  },
  {
    "q": "What is the space complexity of the recursive factorial function (without optimization)?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which Python feature is ideal for deferring execution until value is needed?",
    "c": null,
    "o": [
      "Generator",
      "Function call",
      "Lambda function",
      "List comprehension"
    ]
  },
  {
    "q": "Which tool is used to profile the number of function calls and execution time?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "heapq",
      "functools"
    ]
  },
  {
    "q": "Which technique will reduce both runtime and memory in large file processing?",
    "c": null,
    "o": [
      "Using `yield` to process line-by-line",
      "Reading all lines with readlines()",
      "Loading entire file into memory",
      "Using global variables to store content"
    ]
  },
  {
    "q": "Which of the following is NOT an optimization technique?",
    "c": null,
    "o": [
      "Using recursion without base case",
      "Memoization",
      "List comprehensions",
      "Generator expressions"
    ]
  },
  {
    "q": "Which of the following will consume the least memory when calculating squares?",
    "c": null,
    "o": [
      "(x**2 for x in range(100000))",
      "[x**2 for x in range(100000)]",
      "{x**2 for x in range(100000)}",
      "set(map(lambda x: x**2, range(100000)))"
    ]
  },
  {
    "q": "What does `cProfile` primarily measure?",
    "c": null,
    "o": [
      "Function call statistics and timing",
      "Memory allocation line-by-line",
      "CPU core temperature",
      "Memory leaks in C extensions"
    ]
  },
  {
    "q": "What is the time complexity of the `in` operation in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the major benefit of using `functools.lru_cache()`?",
    "c": null,
    "o": [
      "Avoids redundant function computations by caching results",
      "Increases memory usage deliberately",
      "Creates a new thread for each function",
      "Makes a function asynchronous"
    ]
  },
  {
    "q": "Which Python module is best suited for creating memory-efficient iterators?",
    "c": null,
    "o": [
      "itertools",
      "math",
      "datetime",
      "json"
    ]
  },
  {
    "q": "Which technique best avoids performance loss due to repeated I/O operations?",
    "c": null,
    "o": [
      "Buffering or batching the I/O",
      "Using nested loops for each read",
      "Calling `open()` multiple times",
      "Reading and writing simultaneously"
    ]
  },
  {
    "q": "Which method avoids unnecessary recomputation of expensive results?",
    "c": null,
    "o": [
      "Memoization",
      "Randomization",
      "Recursion",
      "Hashing"
    ]
  },
  {
    "q": "Which of the following operations on a list is O(n) in time complexity?",
    "c": null,
    "o": [
      "list.pop(0)",
      "list.append()",
      "list[-1]",
      "list.insert(-1, 0)"
    ]
  },
  {
    "q": "What is the primary use of generator functions?",
    "c": null,
    "o": [
      "Yield values one at a time using lazy evaluation",
      "Run in separate threads",
      "Return lists immediately",
      "Optimize database queries"
    ]
  },
  {
    "q": "Which is the best way to profile memory usage in a Python script?",
    "c": null,
    "o": [
      "memory_profiler",
      "timeit",
      "os.path",
      "linecache"
    ]
  },
  {
    "q": "What is the key characteristic of generators that improves performance?",
    "c": null,
    "o": [
      "They yield items one by one without storing the entire sequence in memory",
      "They run in parallel threads",
      "They cache all results for reuse",
      "They automatically write output to disk"
    ]
  },
  {
    "q": "What is the best-case time complexity of a linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python expression avoids creating a full list in memory?",
    "c": null,
    "o": [
      "sum(x for x in range(1000000))",
      "sum([x for x in range(1000000)])",
      "list(map(lambda x: x, range(1000000)))",
      "reduce(lambda a,b: a+b, range(1000000))"
    ]
  },
  {
    "q": "Which tool is most appropriate for benchmarking short Python expressions?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "memory_profiler",
      "os.times"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of recursion in Python?",
    "c": null,
    "o": [
      "It can hit the recursion limit and cause stack overflow",
      "It always uses less memory than iteration",
      "It runs faster than iteration",
      "It is not allowed in Python"
    ]
  },
  {
    "q": "Which of the following has constant space complexity?",
    "c": "def print_last(lst):\n    print(lst[-1])",
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these methods is most efficient for filtering large sequences?",
    "c": null,
    "o": [
      "filter() with a generator",
      "list comprehension with condition",
      "storing items in a temporary list",
      "nested if-statements"
    ]
  },
  {
    "q": "Which algorithm has the best average-case time complexity among the following?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which method is used to profile both time and function call counts in Python?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "psutil",
      "pprint"
    ]
  },
  {
    "q": "Which of the following will not consume additional memory when used in a for-loop?",
    "c": null,
    "o": [
      "range()",
      "list()",
      "tuple()",
      "set()"
    ]
  },
  {
    "q": "Which of the following is a primary advantage of using `filter()` with a lambda function?",
    "c": null,
    "o": [
      "It filters elements without building a new list in memory",
      "It automatically sorts the result",
      "It converts all elements to strings",
      "It creates a deep copy of the input"
    ]
  },
  {
    "q": "Which function decorator is commonly used to cache expensive function calls?",
    "c": null,
    "o": [
      "@lru_cache",
      "@memoize",
      "@staticmethod",
      "@cache_result"
    ]
  },
  {
    "q": "Which sorting algorithm performs best on nearly sorted data?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Bubble Sort",
      "Selection Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "gen = (x*2 for x in range(3))\nprint(list(gen))",
    "o": [
      "[0, 2, 4]",
      "[1, 2, 3]",
      "[0, 1, 2]",
      "[2, 4, 6]"
    ]
  },
  {
    "q": "Which Python built-in type is hash-based and allows O(1) average-case lookups?",
    "c": null,
    "o": [
      "dict",
      "list",
      "tuple",
      "set (ordered)"
    ]
  },
  {
    "q": "Which space complexity class indicates constant memory usage regardless of input size?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following will use the least memory when doubling numbers in a range?",
    "c": null,
    "o": [
      "(x*2 for x in range(1000))",
      "[x*2 for x in range(1000)]",
      "{x*2 for x in range(1000)}",
      "map(lambda x: x*2, list(range(1000)))"
    ]
  },
  {
    "q": "What is the average-case time complexity of searching for an element in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which code snippet lazily calculates square numbers?",
    "c": null,
    "o": [
      "(x**2 for x in range(5))",
      "[x**2 for x in range(5)]",
      "{x**2 for x in range(5)}",
      "set(map(lambda x: x**2, range(5)))"
    ]
  },
  {
    "q": "Which time complexity is best for scalable search algorithms?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n^2)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following methods is preferred for performance when removing duplicates from a list?",
    "c": null,
    "o": [
      "Using set() to convert the list",
      "Using nested loops to compare elements",
      "Sorting and then removing duplicates manually",
      "Appending only unique items to a new list"
    ]
  },
  {
    "q": "Which operation has the highest time complexity?",
    "c": null,
    "o": [
      "Sorting a list using bubble sort",
      "Accessing an element in a dictionary",
      "Appending to a list",
      "Using a generator to loop through a sequence"
    ]
  },
  {
    "q": "What is the benefit of using `enumerate()` in a loop?",
    "c": null,
    "o": [
      "Provides both index and value without manually tracking the counter",
      "Speeds up the loop by using multiple cores",
      "Reduces memory usage by converting lists to sets",
      "Avoids the need for recursion"
    ]
  },
  {
    "q": "What is the main drawback of using recursion for deep problems in Python?",
    "c": null,
    "o": [
      "It may exceed the maximum recursion depth",
      "It uses fewer variables than iteration",
      "It forces functions to return None",
      "It cannot handle lists"
    ]
  },
  {
    "q": "Which built-in function can be used to reduce a sequence to a single value?",
    "c": null,
    "o": [
      "reduce()",
      "filter()",
      "map()",
      "sum()"
    ]
  },
  {
    "q": "Which of the following best describes the use of `yield`?",
    "c": null,
    "o": [
      "Temporarily returns control and remembers state for next iteration",
      "Immediately exits the function with a return value",
      "Stops the function and clears memory",
      "Creates a new thread"
    ]
  },
  {
    "q": "What is the output of this generator expression?",
    "c": "gen = (x for x in range(4) if x % 2 == 0)\nprint(list(gen))",
    "o": [
      "[0, 2]",
      "[1, 3]",
      "[0, 1, 2, 3]",
      "[2, 4]"
    ]
  },
  {
    "q": "Which of the following profiles only CPU time per function?",
    "c": null,
    "o": [
      "cProfile",
      "memory_profiler",
      "gc",
      "psutil"
    ]
  },
  {
    "q": "Which of the following is the most memory-efficient for looping over a million integers?",
    "c": null,
    "o": [
      "range(1000000)",
      "list(range(1000000))",
      "[i for i in range(1000000)]",
      "{i for i in range(1000000)}"
    ]
  },
  {
    "q": "Which approach would improve the speed of searching in a list of 1 million items?",
    "c": null,
    "o": [
      "Convert the list to a set before searching",
      "Sort the list and use linear search",
      "Use nested loops to match elements",
      "Search using a for-loop only"
    ]
  },
  {
    "q": "What is the primary reason to use `itertools.islice()` instead of slicing a list directly?",
    "c": null,
    "o": [
      "It avoids creating intermediate lists and saves memory",
      "It modifies the original list",
      "It supports negative indexing",
      "It sorts the list while slicing"
    ]
  },
  {
    "q": "Which of these techniques can convert a loop with repeated calculations into a more efficient structure?",
    "c": null,
    "o": [
      "Memoization",
      "String concatenation",
      "Recursion",
      "Exception handling"
    ]
  },
  {
    "q": "Which time complexity class grows the fastest?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n!)",
      "O(n^2)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary difference between a generator and a list comprehension?",
    "c": null,
    "o": [
      "Generators are lazy, list comprehensions are eager",
      "Generators are slower",
      "List comprehensions cannot be nested",
      "Generators store all values in memory"
    ]
  },
  {
    "q": "Which tool would you use to measure line-by-line execution time in Python?",
    "c": null,
    "o": [
      "line_profiler",
      "cProfile",
      "tracemalloc",
      "functools"
    ]
  },
  {
    "q": "Which of these methods is NOT used for algorithm optimization in Python?",
    "c": null,
    "o": [
      "Using print statements for debugging",
      "Using generators instead of lists",
      "Caching repeated results",
      "Avoiding nested loops when possible"
    ]
  },
  {
    "q": "What is the output of the following generator expression?",
    "c": "gen = (i**3 for i in range(3))\nprint(next(gen))",
    "o": [
      "0",
      "1",
      "8",
      "[0, 1, 8]"
    ]
  },
  {
    "q": "Which Python module helps track memory allocation over time?",
    "c": null,
    "o": [
      "tracemalloc",
      "timeit",
      "threading",
      "pickle"
    ]
  },
  {
    "q": "Which approach will most likely result in O(n^2) time complexity?",
    "c": null,
    "o": [
      "Using nested loops over an unsorted list",
      "Using binary search",
      "Using a set for lookups",
      "Using dictionary for mapping"
    ]
  },
  {
    "q": "Which method provides both memory efficiency and lazy evaluation?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "Set comprehension",
      "Tuple unpacking"
    ]
  },
  {
    "q": "Which of the following improves performance by avoiding repeated evaluations?",
    "c": null,
    "o": [
      "Storing results in a variable",
      "Using `del` to delete variables",
      "Using `eval()` frequently",
      "Using nested `for` loops"
    ]
  },
  {
    "q": "What is the main advantage of using `zip()` with large datasets?",
    "c": null,
    "o": [
      "It returns an iterator without generating full lists in memory",
      "It creates a new list immediately",
      "It stores tuples in memory before yielding",
      "It supports slicing"
    ]
  },
  {
    "q": "Which space complexity is ideal for algorithms running on embedded systems?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which optimization technique is used in dynamic programming?",
    "c": null,
    "o": [
      "Overlapping subproblems and memoization",
      "Loop unrolling",
      "Using generators",
      "Parallel processing"
    ]
  },
  {
    "q": "What is the benefit of using `yield` over building a list in a loop?",
    "c": null,
    "o": [
      "Saves memory by producing items one at a time",
      "Faster variable assignment",
      "Supports threading automatically",
      "Allows in-place list sorting"
    ]
  },
  {
    "q": "Which of the following is true for the `range()` function in Python 3?",
    "c": null,
    "o": [
      "It returns a generator-like object without storing all values",
      "It returns a list",
      "It consumes more memory than lists",
      "It sorts values as they are generated"
    ]
  },
  {
    "q": "What is the worst-case time complexity for inserting in the middle of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which function helps identify the line where most execution time is spent?",
    "c": null,
    "o": [
      "line_profiler",
      "gc.collect()",
      "dir()",
      "globals()"
    ]
  },
  {
    "q": "Which of the following makes a function memory-efficient when generating large sequences?",
    "c": null,
    "o": [
      "Using `yield`",
      "Using `append()` in loops",
      "Storing values in a list",
      "Recursively returning values"
    ]
  },
  {
    "q": "Which method will help avoid creating temporary lists in loops?",
    "c": null,
    "o": [
      "Using generator expressions",
      "Using nested lists",
      "Using map() with list",
      "List comprehensions only"
    ]
  },
  {
    "q": "Which of the following helps improve performance by reusing the result of previous function calls?",
    "c": null,
    "o": [
      "Caching",
      "Multithreading",
      "Exception handling",
      "Garbage collection"
    ]
  },
  {
    "q": "What is the time complexity of appending an element to the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following optimizes performance by avoiding unnecessary computations?",
    "c": null,
    "o": [
      "Short-circuit evaluation",
      "String concatenation in loops",
      "Deep copy of objects",
      "Using global variables"
    ]
  },
  {
    "q": "Which method is best for profiling time consumption of short statements?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "memory_profiler",
      "gc"
    ]
  },
  {
    "q": "Which of the following generates values on demand without storing them in memory?",
    "c": null,
    "o": [
      "Generators",
      "Lists",
      "Tuples",
      "Dictionaries"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "gen = (x for x in range(5) if x % 2)\nprint(list(gen))",
    "o": [
      "[1, 3]",
      "[0, 2, 4]",
      "[1, 2, 3]",
      "[0, 1, 2, 3, 4]"
    ]
  },
  {
    "q": "What is the best-case time complexity of binary search?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is the most suitable for processing a very large file?",
    "c": null,
    "o": [
      "Using a generator with `yield`",
      "Reading the entire file into a list",
      "Using a while loop with `read()`",
      "Opening and closing the file repeatedly"
    ]
  },
  {
    "q": "Which of the following modules supports efficient functional-style programming?",
    "c": null,
    "o": [
      "itertools",
      "math",
      "os",
      "random"
    ]
  },
  {
    "q": "What does `functools.lru_cache` do in Python?",
    "c": null,
    "o": [
      "Caches function results to avoid recomputation",
      "Limits the recursion depth",
      "Improves garbage collection",
      "Adds logging to recursive functions"
    ]
  },
  {
    "q": "What is the primary reason for preferring generator expressions over list comprehensions for large datasets?",
    "c": null,
    "o": [
      "They are more memory-efficient",
      "They are always faster",
      "They support negative indexing",
      "They automatically parallelize computation"
    ]
  },
  {
    "q": "Which of the following operations is typically the slowest in terms of time complexity?",
    "c": null,
    "o": [
      "Nested loop over a list",
      "Appending to a list",
      "Dictionary lookup",
      "Using range() in a for loop"
    ]
  },
  {
    "q": "Which tool can you use to monitor function call count and cumulative time in Python?",
    "c": null,
    "o": [
      "cProfile",
      "gc",
      "functools",
      "heapq"
    ]
  },
  {
    "q": "What is the result of using `set()` to store and search values compared to `list()`?",
    "c": null,
    "o": [
      "Set offers faster average-case lookup time",
      "List provides constant-time lookup",
      "Set uses more memory than list",
      "List is unordered, but set is ordered"
    ]
  },
  {
    "q": "Which is the space complexity of an algorithm that only uses a fixed number of variables?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which Python method is best suited to avoid recalculating expensive function results?",
    "c": null,
    "o": [
      "functools.lru_cache",
      "itertools.chain",
      "map()",
      "timeit.repeat"
    ]
  },
  {
    "q": "What does the following generator do?",
    "c": "def counter():\n    i = 0\n    while True:\n        yield i\n        i += 1",
    "o": [
      "Generates an infinite sequence of integers",
      "Returns a list of 10 elements",
      "Raises StopIteration immediately",
      "Only returns even numbers"
    ]
  },
  {
    "q": "Which operation on a list has O(n) complexity in the worst case?",
    "c": null,
    "o": [
      "Inserting at the beginning",
      "Appending to the end",
      "Accessing the last element",
      "Accessing a specific index"
    ]
  },
  {
    "q": "Which approach avoids excessive memory usage when processing each line of a file?",
    "c": null,
    "o": [
      "Using a generator to read lines one by one",
      "Reading the entire file with readlines()",
      "Storing all lines in a list",
      "Using list comprehension with open()"
    ]
  },
  {
    "q": "What is the key optimization benefit of using `enumerate()`?",
    "c": null,
    "o": [
      "Avoids using manual counters in loops",
      "Makes the loop faster using multithreading",
      "Converts all values to integers",
      "Sorts the list before iteration"
    ]
  },
  {
    "q": "Which of the following is the most efficient way to compute the sum of squares from 1 to n?",
    "c": null,
    "o": [
      "sum(x*x for x in range(1, n+1))",
      "sum([x*x for x in range(1, n+1)])",
      "reduce(lambda a, b: a + b*b, range(1, n+1))",
      "map(lambda x: x*x, range(1, n+1))"
    ]
  },
  {
    "q": "Which of the following is an optimization provided by the `timeit` module?",
    "c": null,
    "o": [
      "Accurate benchmarking of small code snippets",
      "Identifying memory leaks",
      "Listing function call stats",
      "Displaying source code"
    ]
  },
  {
    "q": "Which algorithm is most affected by worst-case O(n^2) time complexity?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Quick Sort (average case)",
      "Binary Search"
    ]
  },
  {
    "q": "Which of the following has the lowest memory overhead for iterating?",
    "c": null,
    "o": [
      "Using a generator",
      "Using a list",
      "Using a set",
      "Using a tuple"
    ]
  },
  {
    "q": "Which Python module is useful for lazy evaluation of chained operations?",
    "c": null,
    "o": [
      "itertools",
      "math",
      "sys",
      "pprint"
    ]
  },
  {
    "q": "What is the output of the following expression?",
    "c": "sum([i for i in range(5)])",
    "o": [
      "10",
      "15",
      "5",
      "0"
    ]
  },
  {
    "q": "Which of the following avoids holding all elements in memory?",
    "c": null,
    "o": [
      "Using a generator expression",
      "Using list comprehension",
      "Reading an entire file into a list",
      "Storing results in a global list"
    ]
  },
  {
    "q": "Which technique will reduce the number of I/O operations in a loop?",
    "c": null,
    "o": [
      "Batch processing",
      "Calling print() inside the loop",
      "Using eval() on input",
      "Clearing the buffer repeatedly"
    ]
  },
  {
    "q": "Which of these has constant time complexity on average for lookup?",
    "c": null,
    "o": [
      "dict",
      "list",
      "tuple",
      "set (ordered)"
    ]
  },
  {
    "q": "Which approach improves time and space for large file processing?",
    "c": null,
    "o": [
      "Using a generator to yield one line at a time",
      "Reading all lines into memory",
      "Loading entire file into a dictionary",
      "Using map() with list conversion"
    ]
  },
  {
    "q": "Which data structure provides the fastest average-case lookup time?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Deque"
    ]
  },
  {
    "q": "What is the best-case time complexity of insertion sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(1)"
    ]
  },
  {
    "q": "Which Python module provides decorators for caching function outputs?",
    "c": null,
    "o": [
      "functools",
      "cProfile",
      "itertools",
      "os"
    ]
  },
  {
    "q": "What is the main advantage of `yield from` over `yield`?",
    "c": null,
    "o": [
      "It simplifies yielding all values from a subgenerator",
      "It returns a list instead of a generator",
      "It consumes more memory",
      "It requires less indentation"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "def gen():\n    yield from range(3)\nprint(list(gen()))",
    "o": [
      "[0, 1, 2]",
      "[1, 2, 3]",
      "[0, 2, 4]",
      "[3, 2, 1]"
    ]
  },
  {
    "q": "Which is NOT a common performance optimization technique?",
    "c": null,
    "o": [
      "Using recursion without base case",
      "Using generators",
      "Avoiding repeated calculations",
      "Profiling slow functions"
    ]
  },
  {
    "q": "Which has the lowest memory usage during iteration?",
    "c": null,
    "o": [
      "range() in Python 3",
      "list(range(n))",
      "set(range(n))",
      "[i for i in range(n)]"
    ]
  },
  {
    "q": "What does `cProfile` output include?",
    "c": null,
    "o": [
      "Function call counts and cumulative time",
      "Memory usage per variable",
      "CPU temperature",
      "List of modules used"
    ]
  },
  {
    "q": "Which approach will avoid memory overhead while reading a large file?",
    "c": null,
    "o": [
      "Using a generator to yield lines",
      "Using `readlines()` method",
      "Converting the file to a list",
      "Appending lines to a list"
    ]
  },
  {
    "q": "Which data structure should be avoided when frequent insertion/removal is required at the beginning?",
    "c": null,
    "o": [
      "List",
      "Deque",
      "Linked List",
      "Queue"
    ]
  },
  {
    "q": "Which optimization technique avoids unnecessary function calls by reusing results?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Loop unrolling",
      "Precompilation"
    ]
  },
  {
    "q": "Which built-in function in Python is used to reduce a sequence to a single value?",
    "c": null,
    "o": [
      "reduce()",
      "map()",
      "filter()",
      "sum()"
    ]
  },
  {
    "q": "What is the time complexity of checking if an element exists in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is most efficient when processing a continuous stream of data?",
    "c": null,
    "o": [
      "Using generators",
      "Storing data in a list",
      "Using recursion",
      "Using global variables"
    ]
  },
  {
    "q": "Which Python module is best for profiling memory usage over time?",
    "c": null,
    "o": [
      "tracemalloc",
      "cProfile",
      "gc",
      "itertools"
    ]
  },
  {
    "q": "What is the advantage of list comprehension over using a loop?",
    "c": null,
    "o": [
      "It is more concise and generally faster",
      "It uses recursion internally",
      "It supports tail-call optimization",
      "It requires less indentation"
    ]
  },
  {
    "q": "Which method avoids recomputation in recursive functions like Fibonacci?",
    "c": null,
    "o": [
      "Using @lru_cache",
      "Using nested loops",
      "Using slicing",
      "Using string formatting"
    ]
  },
  {
    "q": "Which code pattern is preferred to iterate over a list with indices?",
    "c": null,
    "o": [
      "for i, val in enumerate(my_list):",
      "for i in range(len(my_list)):",
      "while i < len(my_list):",
      "for val in my_list: print(my_list.index(val))"
    ]
  },
  {
    "q": "Which of these practices can lead to performance degradation?",
    "c": null,
    "o": [
      "Unnecessary use of global variables",
      "Using generators",
      "Caching results",
      "Lazy evaluation"
    ]
  },
  {
    "q": "What is the primary goal of using a profiler?",
    "c": null,
    "o": [
      "Identify bottlenecks in code",
      "Sort large datasets",
      "Debug syntax errors",
      "Track exceptions"
    ]
  },
  {
    "q": "Which of the following helps in reducing both time and space complexity?",
    "c": null,
    "o": [
      "Using generators instead of lists",
      "Storing data in nested dictionaries",
      "Using deeply nested loops",
      "Avoiding function definitions"
    ]
  },
  {
    "q": "Which built-in Python function can be used for efficient mapping of operations on iterable elements?",
    "c": null,
    "o": [
      "map()",
      "filter()",
      "reduce()",
      "enumerate()"
    ]
  },
  {
    "q": "Which operation is the most memory-efficient when doubling elements in a sequence?",
    "c": null,
    "o": [
      "(x*2 for x in range(1000))",
      "[x*2 for x in range(1000)]",
      "{x*2 for x in range(1000)}",
      "set(map(lambda x: x*2, range(1000)))"
    ]
  },
  {
    "q": "Which tool helps to measure both time spent and number of calls for each function?",
    "c": null,
    "o": [
      "cProfile",
      "timeit",
      "functools",
      "sys"
    ]
  },
  {
    "q": "Which method is preferred for counting elements efficiently?",
    "c": null,
    "o": [
      "collections.Counter",
      "list.count()",
      "Using a dictionary manually",
      "Using a set"
    ]
  },
  {
    "q": "What is the output of the following generator?",
    "c": "def squares():\n    for i in range(3):\n        yield i*i\nprint(list(squares()))",
    "o": [
      "[0, 1, 4]",
      "[1, 2, 3]",
      "[0, 1, 2]",
      "[1, 4, 9]"
    ]
  },
  {
    "q": "Which method allows you to limit the number of cached items in @lru_cache?",
    "c": null,
    "o": [
      "Setting maxsize parameter",
      "Setting ttl parameter",
      "Using functools.partial",
      "Using cache.clear()"
    ]
  },
  {
    "q": "Which of these leads to higher space complexity?",
    "c": null,
    "o": [
      "Using lists instead of generators",
      "Using range() instead of list",
      "Using generator expressions",
      "Using yield instead of return"
    ]
  },
  {
    "q": "What is the average-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which practice helps reduce time complexity in recursive algorithms?",
    "c": null,
    "o": [
      "Memoization",
      "Adding print statements",
      "Increasing stack depth",
      "Using while loops instead"
    ]
  },
  {
    "q": "Which of the following is the most efficient for checking membership in a large dataset?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "deque"
    ]
  },
  {
    "q": "Which optimization reduces the number of I/O operations in a large loop?",
    "c": null,
    "o": [
      "Buffering output and writing in batches",
      "Using print inside every loop iteration",
      "Opening and closing files repeatedly",
      "Using recursion for output"
    ]
  },
  {
    "q": "Which approach improves memory efficiency in processing huge CSV files?",
    "c": null,
    "o": [
      "Reading line by line with a generator",
      "Reading the whole file at once",
      "Using pandas.read_csv with default params",
      "Loading into a list directly"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which space complexity class is the worst among the following?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(log n)",
      "O(n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following is a lazy iterator?",
    "c": null,
    "o": [
      "range() in Python 3",
      "list()",
      "set()",
      "tuple()"
    ]
  },
  {
    "q": "Which of the following functions is best suited for benchmarking a single-line expression?",
    "c": null,
    "o": [
      "timeit",
      "cProfile",
      "tracemalloc",
      "inspect"
    ]
  },
  {
    "q": "Which type of algorithm typically uses the least amount of memory?",
    "c": null,
    "o": [
      "In-place algorithm",
      "Recursive algorithm",
      "Divide and conquer algorithm",
      "Greedy algorithm"
    ]
  },
  {
    "q": "Which Python built-in type is most efficient for first-in, first-out operations?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "tuple",
      "set"
    ]
  },
  {
    "q": "Which of these is most useful for reducing time complexity in overlapping subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "Multithreading",
      "Garbage collection",
      "File I/O buffering"
    ]
  },
  {
    "q": "Which of the following will consume the least memory when doubling numbers from 0 to 9999?",
    "c": null,
    "o": [
      "(x*2 for x in range(10000))",
      "[x*2 for x in range(10000)]",
      "list(map(lambda x: x*2, range(10000)))",
      "{x*2 for x in range(10000)}"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing a LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "List",
      "Tuple"
    ]
  },
  {
    "q": "Which space complexity is best for algorithms running on low-memory devices?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "gen = (i for i in range(4))\nfor val in gen:\n    print(val, end=' ')",
    "o": [
      "0 1 2 3",
      "1 2 3 4",
      "0 2 4 6",
      "[0, 1, 2, 3]"
    ]
  },
  {
    "q": "Which module allows you to inspect time taken per function call in Python?",
    "c": null,
    "o": [
      "cProfile",
      "line_profiler",
      "gc",
      "psutil"
    ]
  },
  {
    "q": "Which of these functions returns an iterator instead of a list in Python 3?",
    "c": null,
    "o": [
      "map()",
      "list()",
      "filter() with list()",
      "reversed() with list"
    ]
  },
  {
    "q": "Which time complexity is ideal for searching an item in an unsorted list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What does `@functools.lru_cache` do?",
    "c": null,
    "o": [
      "Caches results of function calls to speed up repeated calls",
      "Lowers memory usage by removing recursion",
      "Enables lazy evaluation",
      "Limits recursion depth"
    ]
  },
  {
    "q": "Which technique reduces unnecessary calls in recursive functions?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion depth limit",
      "Tail call optimization",
      "Loop unrolling"
    ]
  },
  {
    "q": "Which generator-related function produces infinite counters in Python?",
    "c": null,
    "o": [
      "itertools.count()",
      "range()",
      "enumerate()",
      "map()"
    ]
  },
  {
    "q": "Which is the primary benefit of using list comprehension over traditional loops?",
    "c": null,
    "o": [
      "Better performance and concise code",
      "Automatic parallel execution",
      "Less memory usage in all cases",
      "Prevents syntax errors"
    ]
  },
  {
    "q": "What is the main advantage of using `yield` in a function?",
    "c": null,
    "o": [
      "It allows generating values lazily",
      "It runs the function in a separate thread",
      "It increases memory usage",
      "It makes the function faster"
    ]
  },
  {
    "q": "Which function is used to calculate execution time of a code snippet repeatedly to get accurate results?",
    "c": null,
    "o": [
      "timeit.timeit()",
      "time.time()",
      "datetime.now()",
      "cProfile.run()"
    ]
  },
  {
    "q": "What will be the output of this generator expression?",
    "c": "gen = (x for x in range(4) if x % 2 == 0)\nprint(list(gen))",
    "o": [
      "[0, 2]",
      "[1, 3]",
      "[2, 4]",
      "[0, 1, 2, 3]"
    ]
  },
  {
    "q": "Which technique helps identify which lines of code consume the most execution time?",
    "c": null,
    "o": [
      "line_profiler",
      "pdb",
      "unittest",
      "gc"
    ]
  },
  {
    "q": "What is the typical time complexity of accessing an element in a Python tuple?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following code patterns is the most memory-efficient way to loop over a range?",
    "c": null,
    "o": [
      "for i in range(n):",
      "for i in list(range(n)):",
      "for i in tuple(range(n)):",
      "for i in [x for x in range(n)]:"
    ]
  },
  {
    "q": "What does `itertools.islice()` do?",
    "c": null,
    "o": [
      "Returns a lazy slice from an iterator",
      "Sorts the elements of a list",
      "Converts a list to a set",
      "Returns the last n items"
    ]
  },
  {
    "q": "Which of the following is an advantage of using `functools.lru_cache`?",
    "c": null,
    "o": [
      "Reduces function calls with repeated inputs",
      "Improves garbage collection",
      "Reduces CPU usage to zero",
      "Increases recursion depth limit"
    ]
  },
  {
    "q": "Which of the following is the most efficient method to get the square of numbers in a large range?",
    "c": null,
    "o": [
      "(x**2 for x in range(1000000))",
      "[x**2 for x in range(1000000)]",
      "list(map(lambda x: x**2, range(1000000)))",
      "{x**2 for x in range(1000000)}"
    ]
  },
  {
    "q": "Which time complexity is better in practice for sorting large datasets?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n^3)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of these Python features supports lazy evaluation by default?",
    "c": null,
    "o": [
      "range() in Python 3",
      "list comprehensions",
      "sorted()",
      "sum()"
    ]
  },
  {
    "q": "Which of the following helps minimize repeated code execution?",
    "c": null,
    "o": [
      "Caching",
      "Recursion",
      "Loop unrolling",
      "Multithreading"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "import time\nstart = time.time()\nfor i in range(1000000):\n    pass\nend = time.time()\nprint(round(end - start, 3))",
    "o": [
      "Execution time in seconds (approx)",
      "0",
      "An error",
      "Number of iterations"
    ]
  },
  {
    "q": "Which of the following is a profiling tool that comes built-in with Python?",
    "c": null,
    "o": [
      "cProfile",
      "memory_profiler",
      "line_profiler",
      "py-spy"
    ]
  },
  {
    "q": "Which construct is best for iterating over a large range of numbers without memory overhead?",
    "c": null,
    "o": [
      "range()",
      "list(range())",
      "tuple(range())",
      "[x for x in range()]"
    ]
  },
  {
    "q": "Which is the worst-case time complexity for linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which function decorator is used to automatically memoize function output?",
    "c": null,
    "o": [
      "@lru_cache",
      "@staticmethod",
      "@property",
      "@dataclass"
    ]
  },
  {
    "q": "Which of the following is NOT a benefit of using generators?",
    "c": null,
    "o": [
      "Preloads all data into memory",
      "Reduces memory usage",
      "Supports iteration over large data",
      "Lazy evaluation"
    ]
  },
  {
    "q": "What is the average time complexity of accessing an element in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is optimal for implementing a queue with O(1) enqueue and dequeue?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "tuple",
      "set"
    ]
  },
  {
    "q": "Which of the following operations has O(1) time complexity in a Python dictionary?",
    "c": null,
    "o": [
      "Key lookup",
      "Sorted keys",
      "Iterating over keys",
      "Removing all elements"
    ]
  },
  {
    "q": "Which of the following helps analyze how much memory a Python object consumes?",
    "c": null,
    "o": [
      "sys.getsizeof()",
      "cProfile.run()",
      "gc.collect()",
      "timeit.default_timer()"
    ]
  },
  {
    "q": "Which function is used to create an infinite iterator in Python?",
    "c": null,
    "o": [
      "itertools.count()",
      "range()",
      "enumerate()",
      "map()"
    ]
  },
  {
    "q": "Which is more memory efficient: a generator expression or a list comprehension?",
    "c": null,
    "o": [
      "Generator expression",
      "List comprehension",
      "Both are equal",
      "Depends on the number of items"
    ]
  },
  {
    "q": "What is the space complexity of storing a list of n elements?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which function decorator in `functools` provides built-in memoization?",
    "c": null,
    "o": [
      "@lru_cache",
      "@wraps",
      "@partial",
      "@cachetools"
    ]
  },
  {
    "q": "What will be the output of this generator?",
    "c": "def countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\nprint(list(countdown(3)))",
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[0, 1, 2]",
      "[3, 2, 1, 0]"
    ]
  },
  {
    "q": "Which of the following helps reduce memory usage while iterating over large datasets?",
    "c": null,
    "o": [
      "Using generators",
      "Using recursion",
      "Using list comprehensions",
      "Storing in a global list"
    ]
  },
  {
    "q": "Which Python built-in method allows checking the current memory size of an object?",
    "c": null,
    "o": [
      "sys.getsizeof()",
      "sizeof()",
      "os.memory()",
      "mem.get()"
    ]
  },
  {
    "q": "Which of the following would be the best choice to read a large file without loading it entirely into memory?",
    "c": null,
    "o": [
      "Using a generator to yield lines",
      "Reading all lines using readlines()",
      "Using a list comprehension",
      "Using pandas.read_csv()"
    ]
  },
  {
    "q": "Which complexity class grows the fastest as input size increases?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n!)",
      "O(n^2)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which is the main advantage of using `enumerate()` instead of a manual counter in a loop?",
    "c": null,
    "o": [
      "Cleaner syntax and fewer errors",
      "Faster performance in all cases",
      "It creates a reversed index",
      "It returns a list"
    ]
  },
  {
    "q": "Which of the following statements about `timeit` is TRUE?",
    "c": null,
    "o": [
      "It provides accurate benchmarking by disabling garbage collection temporarily",
      "It only works with functions, not expressions",
      "It cannot be used with loops",
      "It returns memory usage stats"
    ]
  },
  {
    "q": "Which code will create an infinite sequence starting from 5?",
    "c": "import itertools\ngen = itertools.count(5)\nprint(next(gen))",
    "o": [
      "5",
      "0",
      "1",
      "None"
    ]
  },
  {
    "q": "Which tool allows profiling of a Python program to check where time is spent?",
    "c": null,
    "o": [
      "cProfile",
      "unittest",
      "doctest",
      "pip"
    ]
  },
  {
    "q": "Which space complexity is better for an algorithm designed to run on low-memory systems?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following improves performance for functions with repeated calls using same parameters?",
    "c": null,
    "o": [
      "functools.lru_cache",
      "itertools.cycle",
      "gc.collect",
      "time.sleep"
    ]
  },
  {
    "q": "What is the output of this generator expression?",
    "c": "gen = (x for x in range(4) if x % 2)\nprint(list(gen))",
    "o": [
      "[1, 3]",
      "[0, 2]",
      "[0, 1, 2, 3]",
      "[2, 4]"
    ]
  },
  {
    "q": "Which is a lazy way to square all numbers from 1 to 100?",
    "c": null,
    "o": [
      "(x**2 for x in range(1, 101))",
      "[x**2 for x in range(1, 101)]",
      "list(map(lambda x: x**2, range(1, 101)))",
      "{x**2 for x in range(1, 101)}"
    ]
  }
]