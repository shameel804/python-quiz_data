[
  {
    "q": "Which module provides a space-efficient array implementation in Python with fixed types?",
    "c": null,
    "o": [
      "array",
      "list",
      "collections",
      "numpy"
    ]
  },
  {
    "q": "How do you create a NumPy array from a Python list?",
    "c": "import numpy as np\narr = np.array([1, 2, 3])",
    "o": [
      "np.array([1, 2, 3])",
      "np.list([1, 2, 3])",
      "array([1, 2, 3])",
      "np.create_array([1, 2, 3])"
    ]
  },
  {
    "q": "Which data structure follows Last-In-First-Out (LIFO) principle?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Binary Tree"
    ]
  },
  {
    "q": "What is the output of this stack operation?",
    "c": "stack = []\nstack.append(10)\nstack.append(20)\nprint(stack.pop())",
    "o": [
      "20",
      "10",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which data structure follows First-In-First-Out (FIFO) principle?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which module can be used to implement a double-ended queue in Python?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "array"
    ]
  },
  {
    "q": "Which of the following is used to implement a circular queue?",
    "c": null,
    "o": [
      "Array with modulo indexing",
      "Doubly Linked List",
      "Stack",
      "Set"
    ]
  },
  {
    "q": "Which operation inserts a new node at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "Insert at head",
      "Insert at tail",
      "Insert at middle",
      "Append"
    ]
  },
  {
    "q": "Which linked list allows bidirectional traversal?",
    "c": null,
    "o": [
      "Doubly linked list",
      "Singly linked list",
      "Circular linked list",
      "Stack"
    ]
  },
  {
    "q": "Which traversal visits nodes in the order: left subtree, root, right subtree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which binary tree property defines a Binary Search Tree (BST)?",
    "c": null,
    "o": [
      "Left < Root < Right",
      "Left > Root > Right",
      "Each node has 2 children",
      "Tree is balanced"
    ]
  },
  {
    "q": "Which data structure is used in Depth First Search (DFS)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Array"
    ]
  },
  {
    "q": "Which representation uses adjacency lists for graphs?",
    "c": null,
    "o": [
      "Dictionary of lists",
      "2D matrix",
      "List of lists",
      "Set of tuples"
    ]
  },
  {
    "q": "Which module is used for heap operations in Python?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "collections",
      "heap"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a min-heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python data type is most commonly used to implement a hash table?",
    "c": null,
    "o": [
      "dict",
      "set",
      "list",
      "tuple"
    ]
  },
  {
    "q": "What is a common method to handle hash collisions?",
    "c": null,
    "o": [
      "Chaining",
      "Recursion",
      "Sorting",
      "Partitioning"
    ]
  },
  {
    "q": "Which NumPy function returns the shape (rows, columns) of an array?",
    "c": null,
    "o": [
      "array.shape",
      "array.length",
      "array.size()",
      "array.dimension()"
    ]
  },
  {
    "q": "Which of the following is NOT a valid operation on a Python stack implemented using a list?",
    "c": null,
    "o": [
      "insert(0, value)",
      "append(value)",
      "pop()",
      "[-1]"
    ]
  },
  {
    "q": "What is the result of this queue operation?",
    "c": "from collections import deque\nq = deque([1, 2, 3])\nq.appendleft(0)\nprint(q)",
    "o": [
      "deque([0, 1, 2, 3])",
      "deque([1, 2, 3, 0])",
      "deque([3, 2, 1, 0])",
      "deque([1, 2, 3])"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element at index i in an array?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is true about circular queues?",
    "c": null,
    "o": [
      "They reuse empty slots efficiently using modulo arithmetic.",
      "They require doubly linked lists.",
      "They always increase in size.",
      "They are implemented using stacks."
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nnode = Node(5)\nprint(node.data)",
    "o": [
      "5",
      "None",
      "Error",
      "Node"
    ]
  },
  {
    "q": "Which of the following tree types is used for efficient searching and insertion?",
    "c": null,
    "o": [
      "Binary Search Tree",
      "Full Binary Tree",
      "AVL Tree",
      "Complete Binary Tree"
    ]
  },
  {
    "q": "What is the space complexity of an adjacency matrix for a graph with n nodes?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n)",
      "O(log n)",
      "O(n + e) where e is the number of edges"
    ]
  },
  {
    "q": "Which heap type always keeps the smallest element at the root?",
    "c": null,
    "o": [
      "Min Heap",
      "Max Heap",
      "Binary Heap",
      "AVL Heap"
    ]
  },
  {
    "q": "Which method retrieves the smallest element from a min-heap using heapq?",
    "c": "import heapq\nheap = [2, 3, 1]\nheapq.heapify(heap)\nprint(heapq.heappop(heap))",
    "o": [
      "1",
      "2",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following hash functions is used by Python internally for dictionaries?",
    "c": null,
    "o": [
      "hash()",
      "md5()",
      "sha256()",
      "crc32()"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "my_dict = {'a': 1, 'b': 2}\nprint(my_dict.get('c', 3))",
    "o": [
      "3",
      "None",
      "Error",
      "0"
    ]
  },
  {
    "q": "What is a drawback of chaining in hash tables?",
    "c": null,
    "o": [
      "Extra space for linked lists",
      "Does not handle collisions",
      "Requires sorting",
      "Works only with integers"
    ]
  },
  {
    "q": "Which method is best for resolving hash collisions in open addressing?",
    "c": null,
    "o": [
      "Linear probing",
      "Recursion",
      "Sorting keys",
      "Pre-hashing"
    ]
  },
  {
    "q": "What is the main advantage of using a deque over a list in Python?",
    "c": null,
    "o": [
      "Faster appends and pops from both ends",
      "Less memory",
      "Supports random access",
      "Faster insert in middle"
    ]
  },
  {
    "q": "Which of these algorithms is used in Breadth-First Search (BFS)?",
    "c": null,
    "o": [
      "Queue-based traversal",
      "Stack-based traversal",
      "Recursive traversal",
      "Hash-based traversal"
    ]
  },
  {
    "q": "Which NumPy function is used to create an array filled with zeros?",
    "c": null,
    "o": [
      "np.zeros()",
      "np.blank()",
      "np.empty()",
      "np.zero_array()"
    ]
  },
  {
    "q": "Which NumPy method returns the total number of elements in an array?",
    "c": null,
    "o": [
      "array.size",
      "array.length",
      "array.shape",
      "len(array)"
    ]
  },
  {
    "q": "Which list operation is commonly used to simulate a stack in Python?",
    "c": null,
    "o": [
      "append() and pop()",
      "insert() and remove()",
      "extend() and slice()",
      "clear() and index()"
    ]
  },
  {
    "q": "Which method removes the rightmost item in a deque?",
    "c": "from collections import deque\nd = deque([1, 2, 3])\nd.pop()\nprint(d)",
    "o": [
      "deque([1, 2])",
      "deque([2, 3])",
      "deque([1, 2, 3])",
      "Error"
    ]
  },
  {
    "q": "Which is a valid way to create a circular queue using a list?",
    "c": null,
    "o": [
      "Using modulo (%) for index wrap-around",
      "Using a doubly linked list",
      "Using nested loops",
      "Using stack operations"
    ]
  },
  {
    "q": "What is the time complexity to insert at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is NOT a type of tree traversal?",
    "c": null,
    "o": [
      "Backorder",
      "Preorder",
      "Postorder",
      "Inorder"
    ]
  },
  {
    "q": "Which traversal uses a queue data structure?",
    "c": null,
    "o": [
      "Level-order",
      "Preorder",
      "Inorder",
      "Postorder"
    ]
  },
  {
    "q": "Which of the following is TRUE about graphs?",
    "c": null,
    "o": [
      "Graphs may have cycles",
      "Graphs always have a root",
      "All graphs are trees",
      "Graphs must be directed"
    ]
  },
  {
    "q": "Which structure is preferred for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency list",
      "Adjacency matrix",
      "Incidence matrix",
      "Edge matrix"
    ]
  },
  {
    "q": "What will be the result of this heap operation?",
    "c": "import heapq\nheap = []\nheapq.heappush(heap, 4)\nheapq.heappush(heap, 2)\nprint(heap[0])",
    "o": [
      "2",
      "4",
      "6",
      "IndexError"
    ]
  },
  {
    "q": "Which of the following ensures the heap property is maintained?",
    "c": null,
    "o": [
      "heapq.heapify()",
      "sort()",
      "reverse()",
      "pop()"
    ]
  },
  {
    "q": "Which hashing technique keeps all elements in the same array?",
    "c": null,
    "o": [
      "Open addressing",
      "Chaining",
      "Double hashing",
      "External hashing"
    ]
  },
  {
    "q": "What is a typical cause of hash collisions?",
    "c": null,
    "o": [
      "Different keys generating same hash index",
      "Incorrect indentation",
      "Large input arrays",
      "Floating point operations"
    ]
  },
  {
    "q": "Which Python built-in can be used to compute the hash of a key?",
    "c": null,
    "o": [
      "hash()",
      "map()",
      "id()",
      "key()"
    ]
  },
  {
    "q": "Which Python collection type automatically avoids duplicate keys?",
    "c": null,
    "o": [
      "dict",
      "list",
      "deque",
      "tuple"
    ]
  },
  {
    "q": "Which method is used in NumPy to create an identity matrix?",
    "c": null,
    "o": [
      "np.eye()",
      "np.ones()",
      "np.identity_matrix()",
      "np.diagonal()"
    ]
  },
  {
    "q": "What is the output of this NumPy operation?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr.shape)",
    "o": [
      "(2, 2)",
      "(4,)",
      "(2,)",
      "(1, 4)"
    ]
  },
  {
    "q": "Which list operations simulate a stack (LIFO) in Python?",
    "c": null,
    "o": [
      "append() and pop()",
      "insert() and remove()",
      "push() and pop()",
      "enqueue() and dequeue()"
    ]
  },
  {
    "q": "What is the final content of the stack?",
    "c": "stack = []\nstack.append(5)\nstack.append(8)\nstack.pop()\nstack.append(3)\nprint(stack)",
    "o": [
      "[5, 3]",
      "[5, 8, 3]",
      "[8, 3]",
      "[3]"
    ]
  },
  {
    "q": "Which of the following best describes a double-ended queue?",
    "c": null,
    "o": [
      "A queue that allows insertion and deletion from both ends",
      "A queue with two priorities",
      "A circular queue",
      "A queue with two linked lists"
    ]
  },
  {
    "q": "Which queue type gives priority to certain elements?",
    "c": null,
    "o": [
      "Priority Queue",
      "Circular Queue",
      "Double-ended Queue",
      "Simple Queue"
    ]
  },
  {
    "q": "Which statement inserts at the end of a singly linked list?",
    "c": null,
    "o": [
      "Traverse to end and set last.next = new_node",
      "Set head = new_node",
      "Insert at index 0",
      "Set new_node.next = None"
    ]
  },
  {
    "q": "What is the primary difference between singly and doubly linked lists?",
    "c": null,
    "o": [
      "Doubly linked lists store backward references",
      "Singly linked lists store extra data",
      "Doubly linked lists are slower",
      "Singly linked lists have two pointers"
    ]
  },
  {
    "q": "Which traversal order processes the current node before its subtrees?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which binary tree guarantees balance after insertions/deletions?",
    "c": null,
    "o": [
      "AVL Tree",
      "BST",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a weighted graph?",
    "c": null,
    "o": [
      "Dijkstra’s algorithm",
      "DFS",
      "BFS",
      "Prim's algorithm"
    ]
  },
  {
    "q": "What is the worst-case time complexity of BFS on a graph with n vertices and e edges?",
    "c": null,
    "o": [
      "O(n + e)",
      "O(n^2)",
      "O(log n)",
      "O(n*e)"
    ]
  },
  {
    "q": "Which function converts a list into a heap in-place using the heapq module?",
    "c": null,
    "o": [
      "heapify()",
      "buildheap()",
      "minheap()",
      "heapsort()"
    ]
  },
  {
    "q": "Which heap operation retrieves but does NOT remove the smallest element?",
    "c": null,
    "o": [
      "heap[0]",
      "heappop()",
      "heap.remove(0)",
      "peek()"
    ]
  },
  {
    "q": "Which of the following is TRUE about Python dictionaries?",
    "c": null,
    "o": [
      "They maintain insertion order (since Python 3.7+)",
      "They do not handle collisions",
      "They cannot be nested",
      "They only accept string keys"
    ]
  },
  {
    "q": "What happens when you assign a new value to an existing key in a Python dict?",
    "c": null,
    "o": [
      "It overwrites the old value",
      "It appends the value",
      "It adds a duplicate key",
      "It throws an error"
    ]
  },
  {
    "q": "What is the primary advantage of using NumPy arrays over Python lists?",
    "c": null,
    "o": [
      "Faster numerical operations",
      "More readable syntax",
      "Support for mixed data types",
      "Automatic memory management"
    ]
  },
  {
    "q": "What is the output of this NumPy code?",
    "c": "import numpy as np\narr = np.arange(4).reshape(2, 2)\nprint(arr[1][0])",
    "o": [
      "2",
      "1",
      "3",
      "0"
    ]
  },
  {
    "q": "Which of the following is true about the stack data structure?",
    "c": null,
    "o": [
      "Only the top element can be accessed or removed",
      "Elements can be inserted at both ends",
      "It allows random access of elements",
      "All elements must be unique"
    ]
  },
  {
    "q": "What is the output of this queue operation using deque?",
    "c": "from collections import deque\nq = deque()\nq.append(1)\nq.append(2)\nq.popleft()\nprint(q)",
    "o": [
      "deque([2])",
      "deque([1])",
      "deque([])",
      "deque([1, 2])"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing an undo feature?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is true about a priority queue?",
    "c": null,
    "o": [
      "Elements are served based on their priority, not insertion order",
      "It always removes the largest element",
      "It maintains the same order as insertion",
      "It only works with numbers"
    ]
  },
  {
    "q": "Which pointer is `null` in the last node of a singly linked list?",
    "c": null,
    "o": [
      "next",
      "prev",
      "head",
      "tail"
    ]
  },
  {
    "q": "Which of the following can result in a memory leak in a linked list?",
    "c": null,
    "o": [
      "Losing reference to a node without deleting it",
      "Appending too many nodes",
      "Using recursion in traversal",
      "Traversing backward in a singly linked list"
    ]
  },
  {
    "q": "Which condition holds true for a valid Binary Search Tree?",
    "c": null,
    "o": [
      "All left descendants are < node and right descendants are > node",
      "Every level is completely filled",
      "All nodes must have 0 or 2 children",
      "All nodes must be unique integers"
    ]
  },
  {
    "q": "Which traversal is suitable for printing nodes in sorted order from a BST?",
    "c": null,
    "o": [
      "Inorder",
      "Postorder",
      "Preorder",
      "Level-order"
    ]
  },
  {
    "q": "What data structure does BFS use internally to track nodes?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which of the following graphs can be represented using an adjacency list with fewer entries?",
    "c": null,
    "o": [
      "Sparse graph",
      "Dense graph",
      "Complete graph",
      "Cyclic graph"
    ]
  },
  {
    "q": "What is the output of this heap operation?",
    "c": "import heapq\nh = [1, 3, 5, 7]\nheapq.heappush(h, 0)\nprint(h[0])",
    "o": [
      "0",
      "1",
      "5",
      "7"
    ]
  },
  {
    "q": "Which is the correct way to use heappop()?",
    "c": "import heapq\nh = [3, 2, 1]\nheapq.heapify(h)\nprint(heapq.heappop(h))",
    "o": [
      "1",
      "2",
      "3",
      "None"
    ]
  },
  {
    "q": "Which hashing method stores all keys in an array and resolves collisions without using chains?",
    "c": null,
    "o": [
      "Open addressing",
      "Chaining",
      "Hash spreading",
      "Bucket hashing"
    ]
  },
  {
    "q": "What is the output of this dictionary operation?",
    "c": "my_dict = {'x': 5, 'y': 10}\nprint('z' in my_dict)",
    "o": [
      "False",
      "True",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which NumPy method is used to flatten a multi-dimensional array?",
    "c": null,
    "o": [
      "flatten()",
      "reshape(-1)",
      "resize()",
      "ravel()"
    ]
  },
  {
    "q": "What is the result of this NumPy slicing operation?",
    "c": "import numpy as np\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[1:4])",
    "o": [
      "[20 30 40]",
      "[10 20 30 40]",
      "[10 20 30]",
      "[30 40 50]"
    ]
  },
  {
    "q": "Which operation is performed first in a stack?",
    "c": null,
    "o": [
      "Last inserted",
      "First inserted",
      "Middle element",
      "Random element"
    ]
  },
  {
    "q": "What is the output of this stack simulation?",
    "c": "stack = [1, 2, 3]\nstack.pop()\nstack.pop()\nprint(stack)",
    "o": [
      "[1]",
      "[1, 2]",
      "[2, 3]",
      "[]"
    ]
  },
  {
    "q": "What will be the result of this queue implementation?",
    "c": "from collections import deque\nq = deque([10, 20])\nq.appendleft(5)\nq.append(30)\nprint(list(q))",
    "o": [
      "[5, 10, 20, 30]",
      "[10, 20, 5, 30]",
      "[30, 20, 10, 5]",
      "[5, 30, 10, 20]"
    ]
  },
  {
    "q": "What is the time complexity of accessing the last element of a linked list (no tail pointer)?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is not an application of a linked list?",
    "c": null,
    "o": [
      "Direct indexing",
      "Dynamic memory allocation",
      "Stacks and queues",
      "Polynomial representation"
    ]
  },
  {
    "q": "Which of the following is a non-linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "Array",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "What will be printed by this inorder traversal of BST?",
    "c": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n# Create nodes\nroot = Node(10)\nroot.left = Node(5)\nroot.right = Node(15)\n\n# Inorder Traversal\n# left -> root -> right\n\ndef inorder(node):\n    if node:\n        inorder(node.left)\n        print(node.val, end=' ')\n        inorder(node.right)\n\ninorder(root)",
    "o": [
      "5 10 15",
      "10 5 15",
      "15 10 5",
      "5 15 10"
    ]
  },
  {
    "q": "Which data structure is used in recursion internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Table"
    ]
  },
  {
    "q": "Which traversal ensures visiting all nodes level-by-level?",
    "c": null,
    "o": [
      "Level-order",
      "Postorder",
      "Inorder",
      "DFS"
    ]
  },
  {
    "q": "What will the adjacency matrix contain for an undirected graph?",
    "c": null,
    "o": [
      "Symmetric values across the diagonal",
      "Zeros in all entries",
      "Only 1s and 0s above diagonal",
      "All values are equal"
    ]
  },
  {
    "q": "What does heapq.nlargest(n, iterable) return?",
    "c": null,
    "o": [
      "n largest elements from iterable in descending order",
      "n smallest elements in ascending order",
      "Sorted iterable",
      "None"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "import heapq\nnums = [1, 9, 3, 7]\nheapq.heapify(nums)\nprint(heapq.nlargest(2, nums))",
    "o": [
      "[9, 7]",
      "[7, 9]",
      "[1, 3]",
      "[1, 7]"
    ]
  },
  {
    "q": "What is the worst-case time complexity of hash table insertion with chaining?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which is an invalid key type for a Python dictionary?",
    "c": null,
    "o": [
      "list",
      "int",
      "str",
      "tuple"
    ]
  },
  {
    "q": "Which of the following NumPy functions returns evenly spaced values within a given interval?",
    "c": null,
    "o": [
      "np.linspace()",
      "np.arange()",
      "np.space()",
      "np.equalspace()"
    ]
  },
  {
    "q": "What is the result of this NumPy operation?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4])\nprint(arr * 2)",
    "o": [
      "[2 4 6 8]",
      "[1 2 3 4 1 2 3 4]",
      "[1 2 3 4]",
      "[2 2 2 2]"
    ]
  },
  {
    "q": "Which operation is not allowed in a stack?",
    "c": null,
    "o": [
      "Insert at bottom",
      "Push",
      "Pop",
      "Peek"
    ]
  },
  {
    "q": "Which queue is most efficient for CPU scheduling where processes have different priorities?",
    "c": null,
    "o": [
      "Priority Queue",
      "Circular Queue",
      "Simple Queue",
      "Double-ended Queue"
    ]
  },
  {
    "q": "Which method of deque removes the first element?",
    "c": "from collections import deque\nd = deque([1, 2, 3])\nd.popleft()\nprint(d)",
    "o": [
      "deque([2, 3])",
      "deque([1, 2])",
      "deque([1, 2, 3])",
      "deque([3])"
    ]
  },
  {
    "q": "Which pointer is used to traverse backward in a doubly linked list?",
    "c": null,
    "o": [
      "prev",
      "back",
      "left",
      "link"
    ]
  },
  {
    "q": "Which tree traversal visits the root node last?",
    "c": null,
    "o": [
      "Postorder",
      "Preorder",
      "Inorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following is NOT a valid binary tree type?",
    "c": null,
    "o": [
      "Flat Binary Tree",
      "Complete Binary Tree",
      "Full Binary Tree",
      "Balanced Binary Tree"
    ]
  },
  {
    "q": "Which of these is a valid property of a min-heap?",
    "c": null,
    "o": [
      "Parent node is smaller than its children",
      "Tree is always balanced",
      "Left child is greater than right child",
      "Children have the same value"
    ]
  },
  {
    "q": "What is the function of heapq.heappushpop()?",
    "c": null,
    "o": [
      "Pushes a new item and pops the smallest one in a single step",
      "Removes the largest item",
      "Reverses the heap",
      "Removes all duplicate values"
    ]
  },
  {
    "q": "Which scenario results in poor hash function performance?",
    "c": null,
    "o": [
      "Too many keys hashing to the same index",
      "Large keys",
      "Storing floats instead of integers",
      "Using built-in functions"
    ]
  },
  {
    "q": "What does the 'in' operator check when used with a dictionary?",
    "c": null,
    "o": [
      "Presence of a key",
      "Presence of a value",
      "Key-value pair exists",
      "Hash function is valid"
    ]
  },
  {
    "q": "Which structure is best for implementing undo/redo functionality in an application?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Array"
    ]
  },
  {
    "q": "Which of the following is a limitation of using arrays for queues?",
    "c": null,
    "o": [
      "Fixed size",
      "Random access not allowed",
      "All elements must be strings",
      "Cannot traverse in reverse"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "from heapq import *\nh = [3, 1, 4]\nheapify(h)\nheappush(h, 2)\nprint(h[0])",
    "o": [
      "1",
      "2",
      "3",
      "4"
    ]
  },
  {
    "q": "Which data structure allows constant time average case for insert, delete, and search?",
    "c": null,
    "o": [
      "Hash Table",
      "Heap",
      "Stack",
      "Binary Tree"
    ]
  },
  {
    "q": "What will be the output of the following NumPy expression?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4])\nprint(np.mean(arr))",
    "o": [
      "2.5",
      "2",
      "3",
      "10"
    ]
  },
  {
    "q": "Which of the following is FALSE about NumPy arrays?",
    "c": null,
    "o": [
      "They can store elements of multiple data types",
      "They support broadcasting",
      "They are more memory efficient than lists",
      "They allow vectorized operations"
    ]
  },
  {
    "q": "Which of these operations is invalid for a stack?",
    "c": null,
    "o": [
      "Insert at index 2",
      "Pop top element",
      "Push element",
      "Peek at top"
    ]
  },
  {
    "q": "Which scenario best uses a circular queue?",
    "c": null,
    "o": [
      "Buffer handling in real-time systems",
      "DFS traversal",
      "Undo feature in editors",
      "Finding the maximum in a dataset"
    ]
  },
  {
    "q": "What is the result of this deque operation?",
    "c": "from collections import deque\nd = deque([1, 2, 3])\nd.appendleft(0)\nd.pop()\nprint(d)",
    "o": [
      "deque([0, 1, 2])",
      "deque([1, 2, 3])",
      "deque([0, 2, 3])",
      "deque([1, 2])"
    ]
  },
  {
    "q": "Which of the following is true for a doubly linked list?",
    "c": null,
    "o": [
      "Each node has a pointer to both next and previous nodes",
      "Each node points only to the next node",
      "All nodes must be integers",
      "Nodes are stored in contiguous memory"
    ]
  },
  {
    "q": "Which of the following tree traversals can be implemented without recursion using a queue?",
    "c": null,
    "o": [
      "Level-order",
      "Inorder",
      "Postorder",
      "Preorder"
    ]
  },
  {
    "q": "Which condition breaks the binary search tree property?",
    "c": null,
    "o": [
      "Right child < parent",
      "Left child < parent",
      "All left nodes smaller than root",
      "Right child > parent"
    ]
  },
  {
    "q": "Which traversal visits nodes in the order: root, left, right?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which data structure is most suitable for topological sorting in a DAG?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Table",
      "Heap"
    ]
  },
  {
    "q": "Which type of graph traversal is used to detect cycles in a graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Topological sort",
      "Prim's algorithm"
    ]
  },
  {
    "q": "What is the result of this heapq operation?",
    "c": "import heapq\nh = [9, 4, 7]\nheapq.heapify(h)\nheapq.heappush(h, 3)\nprint(h[0])",
    "o": [
      "3",
      "4",
      "7",
      "9"
    ]
  },
  {
    "q": "Which heap operation removes and returns the smallest element?",
    "c": null,
    "o": [
      "heappop()",
      "heapremove()",
      "popmin()",
      "delete()"
    ]
  },
  {
    "q": "Which technique resolves collisions by storing a list of items at each index?",
    "c": null,
    "o": [
      "Chaining",
      "Linear probing",
      "Rehashing",
      "Double hashing"
    ]
  },
  {
    "q": "Which of the following keys is not allowed in a Python dictionary?",
    "c": null,
    "o": [
      "[1, 2]",
      "3",
      "'name'",
      "(1, 2)"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching in a hash table with poor hash function?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which NumPy function converts a list to a NumPy array?",
    "c": null,
    "o": [
      "np.array()",
      "np.tolist()",
      "np.convert()",
      "np.makearray()"
    ]
  },
  {
    "q": "Which of these operations will raise an IndexError in a stack?",
    "c": "stack = []\nstack.pop()",
    "o": [
      "stack.pop() on empty stack",
      "stack.append(1)",
      "stack[-1]",
      "stack.clear()"
    ]
  },
  {
    "q": "What is the time complexity of enqueue and dequeue in a queue implemented using deque?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following queue implementations is best suited for CPU scheduling?",
    "c": null,
    "o": [
      "Priority Queue",
      "Simple Queue",
      "Stack",
      "Deque"
    ]
  },
  {
    "q": "What is the correct way to reverse a singly linked list?",
    "c": null,
    "o": [
      "Iteratively change next pointers to previous node",
      "Sort the list in descending order",
      "Swap data in first and last node",
      "Use a stack to store and re-insert nodes"
    ]
  },
  {
    "q": "Which tree traversal visits all children before visiting the root?",
    "c": null,
    "o": [
      "Postorder",
      "Preorder",
      "Inorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following trees is always balanced?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Search Tree",
      "Heap",
      "Ternary Tree"
    ]
  },
  {
    "q": "Which data structure is used in DFS traversal of graphs?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Table"
    ]
  },
  {
    "q": "Which of the following correctly describes an adjacency matrix?",
    "c": null,
    "o": [
      "2D array representing edges between nodes",
      "List of lists where each list stores neighbors",
      "Matrix where rows are keys and columns are values",
      "Heap-based representation of graph"
    ]
  },
  {
    "q": "What does heapify() do to a list?",
    "c": null,
    "o": [
      "Converts it into a valid heap structure",
      "Sorts it in ascending order",
      "Clears duplicates",
      "Reverses the list"
    ]
  },
  {
    "q": "What is the output of the following heapq operation?",
    "c": "import heapq\nh = [6, 2, 9]\nheapq.heapify(h)\nheapq.heappushpop(h, 1)\nprint(h)",
    "o": [
      "[2, 6, 9]",
      "[1, 2, 9]",
      "[6, 2, 9]",
      "[1, 6, 9]"
    ]
  },
  {
    "q": "What happens when a duplicate key is inserted into a dictionary?",
    "c": "d = {'a': 1, 'a': 2}\nprint(d['a'])",
    "o": [
      "2",
      "1",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is true about hash tables?",
    "c": null,
    "o": [
      "They allow fast average-case insertions and lookups",
      "They store values in sorted order",
      "They require fixed key types",
      "They guarantee no collisions"
    ]
  },
  {
    "q": "Which hashing method checks the next available slot linearly?",
    "c": null,
    "o": [
      "Linear Probing",
      "Chaining",
      "Quadratic Probing",
      "Double Hashing"
    ]
  },
  {
    "q": "What is the result of the following operation?",
    "c": "my_dict = {'a': 1, 'b': 2}\nprint(my_dict.get('c'))",
    "o": [
      "None",
      "KeyError",
      "0",
      "False"
    ]
  },
  {
    "q": "Which of the following operations has the highest time complexity in a hash table?",
    "c": null,
    "o": [
      "Resizing the hash table",
      "Inserting a new key",
      "Deleting a key",
      "Looking up a key"
    ]
  },
  {
    "q": "Which NumPy function returns the cumulative sum of elements?",
    "c": null,
    "o": [
      "np.cumsum()",
      "np.sumall()",
      "np.accumulate()",
      "np.addsum()"
    ]
  },
  {
    "q": "Which of the following operations is not supported directly by a Python list used as a stack?",
    "c": null,
    "o": [
      "Insert in the middle",
      "Push at end",
      "Pop from end",
      "Peek at top"
    ]
  },
  {
    "q": "Which queue type uses a circular array to overcome the limitation of a fixed-size queue?",
    "c": null,
    "o": [
      "Circular Queue",
      "Double-ended Queue",
      "Priority Queue",
      "Stack Queue"
    ]
  },
  {
    "q": "What is the main benefit of using a deque over a list for queue operations?",
    "c": null,
    "o": [
      "O(1) time for append and popleft",
      "More memory usage",
      "Allows sorting automatically",
      "Supports only FIFO"
    ]
  },
  {
    "q": "Which node is the tail in a singly linked list?",
    "c": null,
    "o": [
      "The node whose next pointer is null",
      "The first node",
      "The node with the smallest value",
      "The node just before head"
    ]
  },
  {
    "q": "Which of the following statements is true about doubly linked lists?",
    "c": null,
    "o": [
      "Each node stores references to both previous and next nodes",
      "Only backward traversal is allowed",
      "They use less memory than singly linked lists",
      "They are implemented using arrays"
    ]
  },
  {
    "q": "What is the height of a complete binary tree with n nodes?",
    "c": null,
    "o": [
      "⌊log₂(n)⌋",
      "n",
      "n/2",
      "n log n"
    ]
  },
  {
    "q": "Which tree traversal is used for evaluating postfix expressions?",
    "c": null,
    "o": [
      "Postorder",
      "Preorder",
      "Inorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following graphs is acyclic by definition?",
    "c": null,
    "o": [
      "Tree",
      "Complete graph",
      "Cyclic graph",
      "Weighted graph"
    ]
  },
  {
    "q": "Which graph representation is most efficient in terms of space for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency list",
      "Adjacency matrix",
      "Edge list",
      "Weighted matrix"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a binary heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which operation maintains the heap property after a deletion?",
    "c": null,
    "o": [
      "heapify()",
      "pop()",
      "remove()",
      "sort()"
    ]
  },
  {
    "q": "Which of the following can cause clustering in open addressing?",
    "c": null,
    "o": [
      "Linear probing",
      "Chaining",
      "Hash function using modulo",
      "Separate slots for each key"
    ]
  },
  {
    "q": "Which is true about Python’s built-in hash() function?",
    "c": null,
    "o": [
      "It returns an integer hash value for immutable types",
      "It always returns a unique value",
      "It works only on strings",
      "It modifies the object"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "my_dict = {'a': 1, 'b': 2}\nprint(my_dict.pop('a'))",
    "o": [
      "1",
      "2",
      "KeyError",
      "None"
    ]
  },
  {
    "q": "What happens if you search for a non-existent key using `dict['missing']`?",
    "c": null,
    "o": [
      "Raises KeyError",
      "Returns None",
      "Returns 0",
      "Appends the key"
    ]
  },
  {
    "q": "Which NumPy method returns a copy of an array with elements sorted?",
    "c": null,
    "o": [
      "np.sort()",
      "np.order()",
      "np.arrange()",
      "np.align()"
    ]
  },
  {
    "q": "What is the output of the following NumPy expression?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr[0, 1])",
    "o": [
      "2",
      "1",
      "3",
      "4"
    ]
  },
  {
    "q": "Which of the following operations is not typically supported in a stack?",
    "c": null,
    "o": [
      "Random access",
      "Push",
      "Pop",
      "Peek"
    ]
  },
  {
    "q": "Which method removes the last element from a Python deque?",
    "c": "from collections import deque\nd = deque([1, 2, 3])\nd.pop()\nprint(d)",
    "o": [
      "deque([1, 2])",
      "deque([2, 3])",
      "deque([1, 2, 3])",
      "deque([1])"
    ]
  },
  {
    "q": "What is the correct term for the first element inserted into a queue?",
    "c": null,
    "o": [
      "Front",
      "Rear",
      "Top",
      "Bottom"
    ]
  },
  {
    "q": "In a singly linked list, which operation requires traversal of the entire list?",
    "c": null,
    "o": [
      "Deletion at the end",
      "Insertion at head",
      "Traversal from head",
      "Access head value"
    ]
  },
  {
    "q": "Which of the following is an advantage of linked lists over arrays?",
    "c": null,
    "o": [
      "Dynamic size allocation",
      "Faster random access",
      "Constant time lookup",
      "Less memory usage"
    ]
  },
  {
    "q": "Which traversal technique is used in Breadth-First Search (BFS)?",
    "c": null,
    "o": [
      "Level-order traversal",
      "Inorder traversal",
      "Postorder traversal",
      "Preorder traversal"
    ]
  },
  {
    "q": "In a Binary Search Tree, where is the smallest value found?",
    "c": null,
    "o": [
      "Leftmost node",
      "Rightmost node",
      "Root",
      "Middle node"
    ]
  },
  {
    "q": "What will be the result of the following BFS traversal?",
    "c": "graph = {\n  'A': ['B', 'C'],\n  'B': ['D', 'E'],\n  'C': ['F'],\n  'D': [],\n  'E': [],\n  'F': []\n}\n# BFS from A -> ?",
    "o": [
      "A B C D E F",
      "A C B D E F",
      "A B D E C F",
      "B A C D E F"
    ]
  },
  {
    "q": "Which property must be true in a min-heap?",
    "c": null,
    "o": [
      "Parent <= children",
      "Parent >= children",
      "All nodes have two children",
      "Left child <= right child"
    ]
  },
  {
    "q": "Which function retrieves the smallest element from a min-heap without removing it?",
    "c": null,
    "o": [
      "heap[0]",
      "heappop()",
      "heappushpop()",
      "peekmin()"
    ]
  },
  {
    "q": "What does double hashing use to calculate the next index?",
    "c": null,
    "o": [
      "Two hash functions",
      "Two arrays",
      "Chained buckets",
      "Prime numbers only"
    ]
  },
  {
    "q": "What happens when you assign a value to an existing key in a Python dictionary?",
    "c": null,
    "o": [
      "The old value is overwritten",
      "The key is removed",
      "A new key is added",
      "The dictionary becomes unordered"
    ]
  },
  {
    "q": "Which of the following keys is hashable and can be used in a dictionary?",
    "c": null,
    "o": [
      "(1, 2)",
      "[1, 2]",
      "{1, 2}",
      "{'a': 1}"
    ]
  },
  {
    "q": "Which Python dictionary method returns all key-value pairs as tuples?",
    "c": null,
    "o": [
      "items()",
      "values()",
      "keys()",
      "pairs()"
    ]
  },
  {
    "q": "Which NumPy function is used to compute the standard deviation of an array?",
    "c": null,
    "o": [
      "np.std()",
      "np.var()",
      "np.deviation()",
      "np.stdev()"
    ]
  },
  {
    "q": "What is the result of this stack operation?",
    "c": "stack = [1, 2, 3]\nstack.append(4)\nprint(stack.pop())",
    "o": [
      "4",
      "3",
      "2",
      "1"
    ]
  },
  {
    "q": "Which queue type allows insertion and deletion at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Priority Queue",
      "Circular Queue",
      "Simple Queue"
    ]
  },
  {
    "q": "What will be the output of the following deque operations?",
    "c": "from collections import deque\nd = deque()\nd.append(10)\nd.appendleft(5)\nprint(d)",
    "o": [
      "deque([5, 10])",
      "deque([10, 5])",
      "deque([10])",
      "deque([5])"
    ]
  },
  {
    "q": "Which of the following operations takes O(n) time in a singly linked list?",
    "c": null,
    "o": [
      "Deleting the last node",
      "Inserting at head",
      "Accessing the head node",
      "Appending at the end if tail pointer exists"
    ]
  },
  {
    "q": "In a doubly linked list, how many references does each node have?",
    "c": null,
    "o": [
      "Two",
      "One",
      "Three",
      "None"
    ]
  },
  {
    "q": "Which of these is a full binary tree?",
    "c": null,
    "o": [
      "Every node has 0 or 2 children",
      "Every node has 2 children",
      "All leaves are at the same level",
      "Each node has at most 3 children"
    ]
  },
  {
    "q": "Which traversal method is used in depth-first traversal?",
    "c": null,
    "o": [
      "Preorder, Inorder, Postorder",
      "Level-order only",
      "BFS",
      "Circular traversal"
    ]
  },
  {
    "q": "In a graph, what does a cycle represent?",
    "c": null,
    "o": [
      "A path that starts and ends at the same node",
      "A path that connects all nodes",
      "A node with no neighbors",
      "Disconnected components"
    ]
  },
  {
    "q": "Which graph traversal is guaranteed to find the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra's algorithm",
      "Prim's algorithm"
    ]
  },
  {
    "q": "Which Python function is used to create a heap from a list?",
    "c": null,
    "o": [
      "heapq.heapify()",
      "heapq.makeheap()",
      "heapq.sort()",
      "heapq.push()"
    ]
  },
  {
    "q": "What is the space complexity of a binary heap with n elements?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is NOT a method of handling hash collisions?",
    "c": null,
    "o": [
      "Binary search",
      "Chaining",
      "Linear probing",
      "Double hashing"
    ]
  },
  {
    "q": "What is the purpose of a hash function in a hash table?",
    "c": null,
    "o": [
      "To calculate index from key",
      "To sort data",
      "To store duplicate keys",
      "To increase table size"
    ]
  },
  {
    "q": "Which method removes all items from a dictionary?",
    "c": null,
    "o": [
      "clear()",
      "pop()",
      "del dict",
      "empty()"
    ]
  },
  {
    "q": "Which method safely retrieves a value from a dictionary, returning None if key doesn't exist?",
    "c": null,
    "o": [
      "get()",
      "pop()",
      "lookup()",
      "fetch()"
    ]
  },
  {
    "q": "Which NumPy function stacks arrays vertically (row-wise)?",
    "c": null,
    "o": [
      "np.vstack()",
      "np.hstack()",
      "np.stack()",
      "np.append()"
    ]
  },
  {
    "q": "What is the result of this NumPy array slicing?",
    "c": "import numpy as np\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr[:, 1])",
    "o": [
      "[2 5]",
      "[1 4]",
      "[3 6]",
      "[2 3 5 6]"
    ]
  },
  {
    "q": "Which of the following is a LIFO data structure?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Priority Queue"
    ]
  },
  {
    "q": "What will be printed after these stack operations?",
    "c": "stack = []\nstack.append(10)\nstack.append(20)\nstack.pop()\nprint(stack[-1])",
    "o": [
      "10",
      "20",
      "0",
      "IndexError"
    ]
  },
  {
    "q": "Which queue structure is best when you need both FIFO and LIFO operations?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Circular Queue",
      "Simple Queue"
    ]
  },
  {
    "q": "What is the time complexity to search for a value in a singly linked list?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the result of this linked list operation?",
    "c": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nn1 = Node(1)\nn2 = Node(2)\nn1.next = n2\nprint(n1.next.val)",
    "o": [
      "2",
      "1",
      "None",
      "Error"
    ]
  },
  {
    "q": "What defines a balanced binary tree?",
    "c": null,
    "o": [
      "The height difference between left and right subtrees is at most 1",
      "All leaves are at the same depth",
      "All internal nodes have two children",
      "No duplicate values allowed"
    ]
  },
  {
    "q": "Which traversal method is most suitable to copy a binary tree?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "What is the best case time complexity of BFS in a graph with V vertices and E edges?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E^2)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which heap operation maintains the heap property after inserting a new element?",
    "c": null,
    "o": [
      "Heapify-up",
      "Heapify-down",
      "Extract",
      "Build"
    ]
  },
  {
    "q": "What is the root value of a max heap?",
    "c": null,
    "o": [
      "Maximum element",
      "Minimum element",
      "Median element",
      "Random element"
    ]
  },
  {
    "q": "Which technique ensures fewer collisions in hash tables?",
    "c": null,
    "o": [
      "Using a prime number for table size",
      "Using float keys only",
      "Using sorted arrays",
      "Avoiding strings"
    ]
  },
  {
    "q": "Which statement is true about keys in a Python dictionary?",
    "c": null,
    "o": [
      "Keys must be immutable",
      "Keys can be any data type",
      "Keys must be sorted",
      "Keys are always strings"
    ]
  },
  {
    "q": "What does the `update()` method do in a Python dictionary?",
    "c": null,
    "o": [
      "Adds or overwrites key-value pairs",
      "Deletes existing keys",
      "Sorts the dictionary",
      "Clears all values"
    ]
  },
  {
    "q": "Which of these causes the most collisions in a poorly designed hash function?",
    "c": null,
    "o": [
      "Too many similar keys",
      "Large table size",
      "High load factor",
      "Use of immutable keys"
    ]
  },
  {
    "q": "Which NumPy method flattens a multi-dimensional array into a 1D array?",
    "c": null,
    "o": [
      "np.ravel()",
      "np.flatten()",
      "np.flat()",
      "np.reshape(-1)"
    ]
  },
  {
    "q": "What is the result of this NumPy broadcasting operation?",
    "c": "import numpy as np\na = np.array([1, 2, 3])\nb = 2\nprint(a + b)",
    "o": [
      "[3 4 5]",
      "[1 2 3 2]",
      "[2 4 6]",
      "[1 2 3]"
    ]
  },
  {
    "q": "Which Python method is used to peek at the top of a stack without removing it?",
    "c": null,
    "o": [
      "stack[-1]",
      "stack.peek()",
      "stack.top()",
      "stack.view()"
    ]
  },
  {
    "q": "Which operation is invalid for a queue?",
    "c": null,
    "o": [
      "Accessing middle element in O(1)",
      "Enqueue",
      "Dequeue",
      "Checking if queue is empty"
    ]
  },
  {
    "q": "Which deque method inserts an item to the right end?",
    "c": null,
    "o": [
      "append()",
      "appendleft()",
      "extendleft()",
      "insert()"
    ]
  },
  {
    "q": "Which of the following is true for singly linked lists?",
    "c": null,
    "o": [
      "Each node contains data and a reference to the next node",
      "Each node stores references to previous and next nodes",
      "You can traverse backwards easily",
      "Random access is O(1)"
    ]
  },
  {
    "q": "Which of the following is not a valid tree traversal method?",
    "c": null,
    "o": [
      "Crossorder",
      "Inorder",
      "Preorder",
      "Postorder"
    ]
  },
  {
    "q": "Which traversal method uses a queue and visits nodes level by level?",
    "c": null,
    "o": [
      "Level-order",
      "Inorder",
      "Postorder",
      "Preorder"
    ]
  },
  {
    "q": "What is the minimum number of edges in a connected undirected graph with n nodes?",
    "c": null,
    "o": [
      "n - 1",
      "n",
      "n + 1",
      "2n"
    ]
  },
  {
    "q": "Which traversal algorithm guarantees visiting all vertices reachable from the source in shortest path order (unweighted)?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra",
      "Bellman-Ford"
    ]
  },
  {
    "q": "Which of the following heap operations has the highest time complexity?",
    "c": null,
    "o": [
      "heapify()",
      "heappush()",
      "heappop()",
      "peek()"
    ]
  },
  {
    "q": "Which of these maintains the min-heap property?",
    "c": "from heapq import heapify\narr = [7, 1, 5, 3]\nheapify(arr)\nprint(arr[0])",
    "o": [
      "1",
      "3",
      "5",
      "7"
    ]
  },
  {
    "q": "What is the purpose of the modulus operator in a hash function?",
    "c": null,
    "o": [
      "To map keys within the bounds of table size",
      "To find duplicates",
      "To ensure alphabetical sorting",
      "To convert values to strings"
    ]
  },
  {
    "q": "Which of the following causes a KeyError in Python dictionaries?",
    "c": null,
    "o": [
      "Accessing a non-existent key using square brackets",
      "Using get() with a missing key",
      "Using del on an existing key",
      "Checking membership with 'in'"
    ]
  },
  {
    "q": "What does the expression `'name' in my_dict` check for?",
    "c": null,
    "o": [
      "Whether 'name' is a key in the dictionary",
      "Whether 'name' is a value in the dictionary",
      "Whether 'name' is a function",
      "Whether 'name' is a method"
    ]
  },
  {
    "q": "What is the best-case time complexity of searching in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which NumPy function returns the shape of an array?",
    "c": null,
    "o": [
      "np.shape()",
      "np.size()",
      "np.form()",
      "np.dim()"
    ]
  },
  {
    "q": "What is the output of this NumPy operation?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr.shape)",
    "o": [
      "(2, 2)",
      "(4,)",
      "(1, 4)",
      "(2,)"
    ]
  },
  {
    "q": "What does the pop operation do in a stack?",
    "c": null,
    "o": [
      "Removes and returns the top element",
      "Adds an element at the bottom",
      "Returns the size",
      "Clears all elements"
    ]
  },
  {
    "q": "What is the result of this stack implementation?",
    "c": "stack = [5, 6, 7]\nstack.append(8)\nstack.pop()\nprint(stack)",
    "o": [
      "[5, 6, 7]",
      "[5, 6, 7, 8]",
      "[6, 7, 8]",
      "[5, 6]"
    ]
  },
  {
    "q": "Which of the following is true about priority queues?",
    "c": null,
    "o": [
      "They dequeue elements based on priority, not insertion order",
      "They use LIFO behavior",
      "They can’t be implemented with heaps",
      "They are slower than stacks"
    ]
  },
  {
    "q": "What is the output of this deque code?",
    "c": "from collections import deque\nd = deque([1, 2, 3])\nd.popleft()\nprint(d)",
    "o": [
      "deque([2, 3])",
      "deque([1, 2])",
      "deque([3])",
      "deque([])"
    ]
  },
  {
    "q": "What is the best use case for a circular queue?",
    "c": null,
    "o": [
      "Buffer or task scheduling",
      "Storing sorted elements",
      "Stack emulation",
      "Tree traversal"
    ]
  },
  {
    "q": "Which node in a singly linked list has a 'next' pointer as null?",
    "c": null,
    "o": [
      "Tail node",
      "Head node",
      "Middle node",
      "First node"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing recursion internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which of these is not a valid binary tree traversal?",
    "c": null,
    "o": [
      "Random-order",
      "Inorder",
      "Preorder",
      "Postorder"
    ]
  },
  {
    "q": "What is the output of this heap operation?",
    "c": "import heapq\nh = [10, 3, 5]\nheapq.heapify(h)\nheapq.heappop(h)\nprint(h[0])",
    "o": [
      "5",
      "3",
      "10",
      "0"
    ]
  },
  {
    "q": "Which of the following is not true about heaps?",
    "c": null,
    "o": [
      "They support constant time insertion",
      "They are complete binary trees",
      "They support efficient min/max operations",
      "They are used to implement priority queues"
    ]
  },
  {
    "q": "Which method inserts a key-value pair into a Python dictionary?",
    "c": null,
    "o": [
      "dict[key] = value",
      "dict.add(key, value)",
      "dict.insert(key, value)",
      "dict.put(key, value)"
    ]
  },
  {
    "q": "What is the default return value of `dict.get(key)` if the key doesn’t exist?",
    "c": null,
    "o": [
      "None",
      "KeyError",
      "0",
      "False"
    ]
  },
  {
    "q": "What is the effect of `del dict[key]`?",
    "c": null,
    "o": [
      "Removes the key-value pair",
      "Clears the dictionary",
      "Throws error always",
      "Deletes the entire dictionary object"
    ]
  },
  {
    "q": "Which of the following hash collision resolution techniques stores multiple values in a single index?",
    "c": null,
    "o": [
      "Chaining",
      "Linear probing",
      "Quadratic probing",
      "Open addressing"
    ]
  },
  {
    "q": "Which NumPy function is used to generate an array of zeros?",
    "c": null,
    "o": [
      "np.zeros()",
      "np.blank()",
      "np.empty()",
      "np.nulls()"
    ]
  },
  {
    "q": "What is the output of the following NumPy code?",
    "c": "import numpy as np\narr = np.zeros((2, 3))\nprint(arr.shape)",
    "o": [
      "(2, 3)",
      "(3, 2)",
      "(6,)",
      "(1, 6)"
    ]
  },
  {
    "q": "Which Python data structure uses LIFO order for operations?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Heap"
    ]
  },
  {
    "q": "What is the output of the following stack operations?",
    "c": "stack = []\nstack.append(1)\nstack.append(2)\nstack.append(3)\nprint(stack.pop())",
    "o": [
      "3",
      "2",
      "1",
      "Error"
    ]
  },
  {
    "q": "Which data structure allows insertion and deletion from both ends?",
    "c": null,
    "o": [
      "Deque",
      "Queue",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "What is the primary advantage of circular queues over linear queues?",
    "c": null,
    "o": [
      "Efficient memory usage",
      "Easier implementation",
      "No overflow",
      "No need for pointers"
    ]
  },
  {
    "q": "In a singly linked list, how is the end of the list identified?",
    "c": null,
    "o": [
      "When next pointer is null",
      "When node data is zero",
      "When node has no index",
      "When the node has two pointers"
    ]
  },
  {
    "q": "Which operation is faster in a linked list compared to an array?",
    "c": null,
    "o": [
      "Insertion at the beginning",
      "Random access",
      "Sorting",
      "Reversing"
    ]
  },
  {
    "q": "In a binary search tree, which node has the maximum value?",
    "c": null,
    "o": [
      "Rightmost node",
      "Leftmost node",
      "Root node",
      "Middle node"
    ]
  },
  {
    "q": "What is the time complexity of inorder traversal of a binary tree?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is best for implementing BFS on a graph?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Dictionary"
    ]
  },
  {
    "q": "In an undirected graph with n nodes, what is the maximum number of edges?",
    "c": null,
    "o": [
      "n(n-1)/2",
      "n(n+1)/2",
      "2n",
      "n^2"
    ]
  },
  {
    "q": "What property does a min heap maintain?",
    "c": null,
    "o": [
      "Every parent is less than or equal to its children",
      "Every parent is greater than its children",
      "All elements are sorted",
      "Only leaf nodes are ordered"
    ]
  },
  {
    "q": "What does the `heapq.heappop()` function do?",
    "c": null,
    "o": [
      "Removes and returns the smallest element",
      "Adds an element to the heap",
      "Removes the last element",
      "Sorts the heap"
    ]
  },
  {
    "q": "Which technique for resolving hash collisions links multiple elements at the same index?",
    "c": null,
    "o": [
      "Chaining",
      "Linear probing",
      "Double hashing",
      "Rehashing"
    ]
  },
  {
    "q": "Which method gives the list of keys from a Python dictionary?",
    "c": null,
    "o": [
      "dict.keys()",
      "dict.getkeys()",
      "dict.keylist()",
      "dict.allkeys()"
    ]
  },
  {
    "q": "Which NumPy function is used to create a sequence of evenly spaced values?",
    "c": null,
    "o": [
      "np.arange()",
      "np.linspace()",
      "np.range()",
      "np.sequence()"
    ]
  },
  {
    "q": "What is the output of the following code using NumPy?",
    "c": "import numpy as np\narr = np.arange(0, 5, 2)\nprint(arr)",
    "o": [
      "[0 2 4]",
      "[0 1 2 3 4]",
      "[2 4 6 8]",
      "[0 2 3 5]"
    ]
  },
  {
    "q": "What is the time complexity of pushing an item onto a stack implemented using Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which method would you use to implement stack behavior in Python?",
    "c": null,
    "o": [
      "append() and pop()",
      "insert() and delete()",
      "enqueue() and dequeue()",
      "add() and remove()"
    ]
  },
  {
    "q": "What is the major advantage of deque over list for queue operations?",
    "c": null,
    "o": [
      "Faster append and pop from both ends",
      "Less memory usage",
      "Support for random indexing",
      "Automatic sorting"
    ]
  },
  {
    "q": "Which operation is typically O(1) in a circular queue?",
    "c": null,
    "o": [
      "Insertion at rear",
      "Random access",
      "Search for element",
      "Delete from middle"
    ]
  },
  {
    "q": "Which condition signifies that a circular queue is full?",
    "c": null,
    "o": [
      "(rear + 1) % size == front",
      "front == rear",
      "front == -1",
      "rear == size"
    ]
  },
  {
    "q": "Which of the following linked list types allows traversal in both directions?",
    "c": null,
    "o": [
      "Doubly linked list",
      "Singly linked list",
      "Circular singly linked list",
      "Self-referencing list"
    ]
  },
  {
    "q": "What is the best data structure to use when you need constant time insertion and deletion at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Array",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "What is the total number of edges in a complete binary tree with n nodes?",
    "c": null,
    "o": [
      "n - 1",
      "n",
      "2n",
      "log n"
    ]
  },
  {
    "q": "What will an inorder traversal of a binary search tree return?",
    "c": null,
    "o": [
      "Sorted list of values",
      "Postfix expression",
      "Reversed list of values",
      "Random list of values"
    ]
  },
  {
    "q": "Which of the following is true about graphs?",
    "c": null,
    "o": [
      "Graphs can have cycles",
      "Graphs are always trees",
      "Graphs must be directed",
      "Graphs can't have duplicate nodes"
    ]
  },
  {
    "q": "Which graph traversal uses a stack either explicitly or through recursion?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra",
      "Kruskal"
    ]
  },
  {
    "q": "Which data structure is used to implement a priority queue efficiently?",
    "c": null,
    "o": [
      "Heap",
      "Deque",
      "Linked list",
      "Array"
    ]
  },
  {
    "q": "What is the output of this heap operation?",
    "c": "import heapq\nh = [1, 3, 5]\nheapq.heappush(h, 0)\nprint(h[0])",
    "o": [
      "0",
      "1",
      "3",
      "5"
    ]
  },
  {
    "q": "Which method is used to get all key-value pairs in a Python dictionary?",
    "c": null,
    "o": [
      "items()",
      "values()",
      "keys()",
      "elements()"
    ]
  },
  {
    "q": "Which NumPy function is used to reshape an array?",
    "c": null,
    "o": [
      "reshape()",
      "reform()",
      "transform()",
      "resize()"
    ]
  },
  {
    "q": "What is the output of this NumPy reshape operation?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4, 5, 6])\nprint(arr.reshape(2, 3))",
    "o": [
      "[[1 2 3]\n [4 5 6]]",
      "[[1 2]\n [3 4]\n [5 6]]",
      "[1 2 3 4 5 6]",
      "[[1 2 3 4 5 6]]"
    ]
  },
  {
    "q": "What is the typical space complexity of a stack?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which method can be used to reverse a stack using recursion?",
    "c": null,
    "o": [
      "Use recursion and pop-push logic",
      "Use sorted() function",
      "Loop and insert at top",
      "Using slicing"
    ]
  },
  {
    "q": "What is the main drawback of using Python list as a queue?",
    "c": null,
    "o": [
      "Dequeue operation is O(n)",
      "Append operation fails",
      "Elements get sorted",
      "Queue becomes LIFO"
    ]
  },
  {
    "q": "Which of the following is used to implement a queue efficiently in Python?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "In a circular queue, how is the rear updated after an insertion?",
    "c": null,
    "o": [
      "(rear + 1) % size",
      "rear + 1",
      "rear - 1",
      "(rear - 1) % size"
    ]
  },
  {
    "q": "Which of the following allows constant-time insertion and deletion from both ends?",
    "c": null,
    "o": [
      "Deque",
      "List",
      "Stack",
      "Tuple"
    ]
  },
  {
    "q": "Which pointer is not used in singly linked list?",
    "c": null,
    "o": [
      "Previous",
      "Next",
      "Head",
      "Tail"
    ]
  },
  {
    "q": "Which binary tree traversal is best for evaluating expression trees?",
    "c": null,
    "o": [
      "Postorder",
      "Inorder",
      "Preorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following trees is always balanced?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Search Tree",
      "N-ary Tree",
      "Ternary Tree"
    ]
  },
  {
    "q": "Which of the following is not a valid graph representation?",
    "c": null,
    "o": [
      "Stack list",
      "Adjacency list",
      "Adjacency matrix",
      "Edge list"
    ]
  },
  {
    "q": "Which of these algorithms is used for traversing or searching a graph?",
    "c": null,
    "o": [
      "DFS",
      "Sort",
      "Heapify",
      "Reverse"
    ]
  },
  {
    "q": "Which operation in a min-heap restores heap property after deletion?",
    "c": null,
    "o": [
      "Heapify-down",
      "Heapify-up",
      "Insert",
      "Balance"
    ]
  },
  {
    "q": "Which of these is not a feature of a min-heap?",
    "c": null,
    "o": [
      "All nodes are sorted",
      "Parent is less than children",
      "Complete binary tree",
      "Fast minimum access"
    ]
  },
  {
    "q": "What happens if you try to access a missing key using `my_dict['missing']`?",
    "c": null,
    "o": [
      "Raises KeyError",
      "Returns None",
      "Returns empty string",
      "Returns 0"
    ]
  },
  {
    "q": "Which NumPy method is used to join two or more arrays?",
    "c": null,
    "o": [
      "concatenate()",
      "merge()",
      "combine()",
      "link()"
    ]
  },
  {
    "q": "What will be the shape of the array after this operation?",
    "c": "import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6]])\nresult = np.concatenate((a, b), axis=0)\nprint(result.shape)",
    "o": [
      "(3, 2)",
      "(2, 3)",
      "(1, 4)",
      "(4, 1)"
    ]
  },
  {
    "q": "Which data structure is best for tracking function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which operation removes the front item in a queue?",
    "c": null,
    "o": [
      "Dequeue",
      "Enqueue",
      "Pop",
      "Insert"
    ]
  },
  {
    "q": "What is the result of this queue operation?",
    "c": "from collections import deque\nq = deque()\nq.append(10)\nq.append(20)\nprint(q.popleft())",
    "o": [
      "10",
      "20",
      "0",
      "IndexError"
    ]
  },
  {
    "q": "Which of the following allows traversal of a linked list from tail to head?",
    "c": null,
    "o": [
      "Doubly Linked List",
      "Singly Linked List",
      "Circular Singly Linked List",
      "None of the above"
    ]
  },
  {
    "q": "Which of these is true about a circular singly linked list?",
    "c": null,
    "o": [
      "Last node points back to head",
      "Every node has a previous pointer",
      "It uses a tail node only",
      "It allows random access"
    ]
  },
  {
    "q": "Which of the following is a property of a binary search tree?",
    "c": null,
    "o": [
      "Left child < root < right child",
      "All child nodes are equal",
      "Parent is always greater than child",
      "All nodes have exactly 2 children"
    ]
  },
  {
    "q": "Which tree traversal is most suitable to get a sorted list from a BST?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following is used to find connected components in a graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra",
      "Heapify",
      "Inorder"
    ]
  },
  {
    "q": "Which of these is not a property of a graph adjacency matrix?",
    "c": null,
    "o": [
      "Efficient for sparse graphs",
      "Uses O(V^2) space",
      "Can represent weighted graphs",
      "Supports fast edge lookup"
    ]
  },
  {
    "q": "Which of these is a max-heap property?",
    "c": null,
    "o": [
      "Parent node is greater than or equal to child nodes",
      "All leaf nodes are sorted",
      "The tree is a BST",
      "Root has minimum value"
    ]
  },
  {
    "q": "What does `heapq.heappush()` do?",
    "c": null,
    "o": [
      "Inserts an element while maintaining heap order",
      "Removes the top of the heap",
      "Sorts the list",
      "Deletes the heap"
    ]
  },
  {
    "q": "Which of the following is used to resolve collisions in hash tables using open addressing?",
    "c": null,
    "o": [
      "Linear Probing",
      "Chaining",
      "Separate Indexing",
      "Key Rehashing"
    ]
  },
  {
    "q": "Which dictionary method returns the value for a specified key, or a default if not found?",
    "c": null,
    "o": [
      "get()",
      "fetch()",
      "lookup()",
      "find()"
    ]
  },
  {
    "q": "What happens when you use `dict.pop('key')` on a missing key without a default?",
    "c": null,
    "o": [
      "Raises KeyError",
      "Returns None",
      "Returns empty dict",
      "Ignores the key"
    ]
  },
  {
    "q": "Which NumPy function is used to compute the sum of array elements along a given axis?",
    "c": null,
    "o": [
      "np.sum()",
      "np.add()",
      "np.total()",
      "np.reduce()"
    ]
  },
  {
    "q": "What is the result of the following NumPy operation?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(np.sum(arr, axis=0))",
    "o": [
      "[4 6]",
      "[1 3]",
      "[10 6]",
      "[3 7]"
    ]
  },
  {
    "q": "What is the primary advantage of using a linked list over an array?",
    "c": null,
    "o": [
      "Dynamic size and ease of insertion/deletion",
      "Faster access time",
      "Fixed memory usage",
      "Supports random access"
    ]
  },
  {
    "q": "Which operation in a queue has a time complexity of O(1)?",
    "c": null,
    "o": [
      "Enqueue and Dequeue",
      "Searching for an element",
      "Accessing a specific element",
      "Sorting the queue"
    ]
  },
  {
    "q": "What will be the output of the following code in Python using a queue?",
    "c": "from collections import deque\nq = deque([1, 2, 3])\nq.append(4)\nq.popleft()\nprint(q)",
    "o": [
      "deque([2, 3, 4])",
      "deque([1, 2, 3])",
      "deque([1, 3, 4])",
      "deque([2, 4])"
    ]
  },
  {
    "q": "What happens when you try to insert a duplicate value into a set?",
    "c": null,
    "o": [
      "The duplicate value is ignored",
      "The set raises an error",
      "The set accepts the duplicate",
      "The first value is overwritten"
    ]
  },
  {
    "q": "What is the average time complexity for accessing an element in a linked list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which operation in a doubly linked list requires O(1) time complexity?",
    "c": null,
    "o": [
      "Insertion at the head or tail",
      "Traversal",
      "Search for an element",
      "Insertion in the middle"
    ]
  },
  {
    "q": "Which type of binary tree ensures that all the left child nodes are smaller than the root node, and all the right child nodes are greater?",
    "c": null,
    "o": [
      "Binary Search Tree (BST)",
      "Binary Tree",
      "AVL Tree",
      "Heap"
    ]
  },
  {
    "q": "Which operation in a binary search tree (BST) is most commonly used for searching an element?",
    "c": null,
    "o": [
      "Traverse in Inorder",
      "Traverse in Postorder",
      "Search by comparing keys",
      "Inserting elements"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the result of applying BFS (Breadth-First Search) to a graph?",
    "c": null,
    "o": [
      "Nodes are visited level by level",
      "Nodes are visited deeply before going to the next level",
      "Nodes are visited in random order",
      "Nodes are visited based on node value"
    ]
  },
  {
    "q": "What is the main disadvantage of using adjacency matrix to represent a graph?",
    "c": null,
    "o": [
      "Space complexity of O(V^2)",
      "It can only represent directed graphs",
      "It is slow for graph traversal",
      "It does not support weighted graphs"
    ]
  },
  {
    "q": "Which heap property must be maintained in a max-heap?",
    "c": null,
    "o": [
      "Parent node is greater than or equal to its children",
      "Parent node is smaller than or equal to its children",
      "Root node must be the largest element",
      "Every parent node must be smaller than its children"
    ]
  },
  {
    "q": "Which of the following is not a valid way to handle hash collisions in hash tables?",
    "c": null,
    "o": [
      "Chaining",
      "Linear Probing",
      "Bucketizing",
      "Rehashing"
    ]
  },
  {
    "q": "What is the worst-case time complexity for search, insert, and delete operations in a hash table with open addressing?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which NumPy function returns the cumulative sum of elements?",
    "c": null,
    "o": [
      "np.cumsum()",
      "np.sum()",
      "np.accumulate()",
      "np.cumprod()"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4])\nprint(np.cumsum(arr))",
    "o": [
      "[ 1  3  6 10]",
      "[1 2 3 4]",
      "[10 9 7 4]",
      "[4 7 9 10]"
    ]
  },
  {
    "q": "Which operation is used to add an element at the front of a deque in Python?",
    "c": null,
    "o": [
      "appendleft()",
      "prepend()",
      "insert()",
      "pushfront()"
    ]
  },
  {
    "q": "In a stack, which operation retrieves and removes the top item?",
    "c": null,
    "o": [
      "pop()",
      "peek()",
      "top()",
      "remove()"
    ]
  },
  {
    "q": "Which condition implies that a circular queue is empty?",
    "c": null,
    "o": [
      "front == -1",
      "rear + 1 == front",
      "rear == front",
      "front > rear"
    ]
  },
  {
    "q": "What is the purpose of the tail pointer in a doubly linked list?",
    "c": null,
    "o": [
      "To allow constant time insertion at the end",
      "To allow binary search",
      "To count number of nodes",
      "To convert to array"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the head of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the maximum number of nodes in a binary tree of height h (0-based)?",
    "c": null,
    "o": [
      "2^(h+1) - 1",
      "2^h",
      "h",
      "2h"
    ]
  },
  {
    "q": "Which traversal method visits left, root, and then right subtree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of these is a self-balancing binary search tree?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Heap",
      "Trie",
      "B-Tree"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Min Heap + Adjacency List",
      "Stack + Matrix",
      "Deque + Adjacency Matrix",
      "List + BFS Queue"
    ]
  },
  {
    "q": "Which of the following graph representations uses less memory for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Edge Matrix",
      "Incidence Matrix"
    ]
  },
  {
    "q": "What does the `heapq.nlargest(n, iterable)` function do?",
    "c": null,
    "o": [
      "Returns the n largest elements from the iterable",
      "Returns the largest value in heap",
      "Sorts the iterable in descending order",
      "Pops n elements from max heap"
    ]
  },
  {
    "q": "What is the output of the following heap operation?",
    "c": "import heapq\nh = [4, 2, 8]\nheapq.heapify(h)\nprint(h)",
    "o": [
      "[2, 4, 8]",
      "[4, 2, 8]",
      "[8, 4, 2]",
      "[2, 8, 4]"
    ]
  },
  {
    "q": "Which hash table collision resolution method searches sequentially for the next empty slot?",
    "c": null,
    "o": [
      "Linear Probing",
      "Chaining",
      "Double Hashing",
      "Bucket Hashing"
    ]
  },
  {
    "q": "Which of the following is not a valid dictionary method in Python?",
    "c": null,
    "o": [
      "find()",
      "get()",
      "items()",
      "update()"
    ]
  },
  {
    "q": "Which NumPy function is used to return the indices of non-zero elements?",
    "c": null,
    "o": [
      "np.nonzero()",
      "np.where()",
      "np.find()",
      "np.nonnull()"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "import numpy as np\narr = np.array([0, 1, 0, 2, 3])\nprint(np.nonzero(arr))",
    "o": [
      "(array([1, 3, 4]),)",
      "[1, 3, 4]",
      "(array([0, 2]),)",
      "array([1, 3, 4])"
    ]
  },
  {
    "q": "Which method removes the last element from a Python list?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "del",
      "discard()"
    ]
  },
  {
    "q": "Which operation in a stack gives the topmost value without removing it?",
    "c": null,
    "o": [
      "peek",
      "pop",
      "top",
      "shift"
    ]
  },
  {
    "q": "In a circular queue, which pointer wraps around to the beginning of the array?",
    "c": null,
    "o": [
      "rear",
      "front",
      "head",
      "tail"
    ]
  },
  {
    "q": "Which of the following is NOT true about linked lists?",
    "c": null,
    "o": [
      "They support constant-time insertion at head",
      "They use contiguous memory",
      "They are dynamic in size",
      "They are linear data structures"
    ]
  },
  {
    "q": "What happens if we try to access the `.next` of the last node in a singly linked list?",
    "c": null,
    "o": [
      "It returns None",
      "It raises IndexError",
      "It restarts from the head",
      "It raises TypeError"
    ]
  },
  {
    "q": "Which binary tree traversal visits nodes in the order: root → left → right?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which tree data structure maintains balance using rotations?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Heap",
      "Trie",
      "Segment Tree"
    ]
  },
  {
    "q": "In DFS traversal, which data structure is used internally to keep track of visited nodes?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Dictionary"
    ]
  },
  {
    "q": "Which graph representation allows efficient edge lookups between two nodes?",
    "c": null,
    "o": [
      "Adjacency Matrix",
      "Adjacency List",
      "Edge List",
      "Incidence Matrix"
    ]
  },
  {
    "q": "Which of these best describes a heap?",
    "c": null,
    "o": [
      "A complete binary tree where each parent has a specific order relation with its children",
      "A tree where all values are unique",
      "A self-balancing BST",
      "A type of trie with two children per node"
    ]
  },
  {
    "q": "Which heap operation has a worst-case time complexity of O(log n)?",
    "c": null,
    "o": [
      "Insertion",
      "Accessing the root",
      "Heapify",
      "Creating a heap from scratch"
    ]
  },
  {
    "q": "Which dictionary method will return a value and remove the key-value pair?",
    "c": null,
    "o": [
      "pop()",
      "get()",
      "clear()",
      "popitem()"
    ]
  },
  {
    "q": "Which hash function property helps in uniformly distributing keys?",
    "c": null,
    "o": [
      "Uniformity",
      "Surjectivity",
      "Identity",
      "Collision Resistance"
    ]
  },
  {
    "q": "Which of the following is true about collision handling using chaining?",
    "c": null,
    "o": [
      "Each bucket contains a linked list of values",
      "Each bucket contains only one value",
      "Values are moved to the next bucket",
      "Each collision creates a new hash function"
    ]
  },
  {
    "q": "What will be the result of the following NumPy operation?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4, 5])\nprint(arr[::-1])",
    "o": [
      "[5 4 3 2 1]",
      "[1 2 3 4 5]",
      "[1 3 5]",
      "[5 3 1]"
    ]
  },
  {
    "q": "Which of the following operations is not allowed in a stack?",
    "c": null,
    "o": [
      "Insert at bottom",
      "Push",
      "Pop",
      "Peek"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a queue implemented with deque?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "from collections import deque\nq = deque([1, 2, 3])\nq.appendleft(0)\nprint(list(q))",
    "o": [
      "[0, 1, 2, 3]",
      "[1, 2, 3, 0]",
      "[3, 2, 1, 0]",
      "[0, 3, 2, 1]"
    ]
  },
  {
    "q": "Which part of a singly linked list node stores the address of the next node?",
    "c": null,
    "o": [
      "Next pointer",
      "Data field",
      "Head",
      "Tail"
    ]
  },
  {
    "q": "Which traversal is used for breadth-first traversal of a tree?",
    "c": null,
    "o": [
      "Level-order",
      "Inorder",
      "Postorder",
      "Preorder"
    ]
  },
  {
    "q": "Which of these operations can unbalance a binary search tree?",
    "c": null,
    "o": [
      "Inserting sorted elements",
      "Searching for elements",
      "Traversing the tree",
      "Deleting leaf nodes only"
    ]
  },
  {
    "q": "What is the maximum number of edges in a directed graph with n vertices and no self-loops?",
    "c": null,
    "o": [
      "n(n - 1)",
      "n(n + 1)",
      "n^2",
      "n(n - 1)/2"
    ]
  },
  {
    "q": "Which heap is used to implement a priority queue with the smallest element having the highest priority?",
    "c": null,
    "o": [
      "Min Heap",
      "Max Heap",
      "Binary Search Tree",
      "AVL Tree"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "import heapq\nh = []\nheapq.heappush(h, 10)\nheapq.heappush(h, 5)\nprint(heapq.heappop(h))",
    "o": [
      "5",
      "10",
      "0",
      "None"
    ]
  },
  {
    "q": "What is the key difference between chaining and open addressing in hash tables?",
    "c": null,
    "o": [
      "Chaining uses linked lists; open addressing stores elements in the table itself",
      "Chaining requires double hashing; open addressing does not",
      "Chaining only works with strings; open addressing with numbers",
      "Open addressing uses binary trees instead of arrays"
    ]
  },
  {
    "q": "What is the result of `dict.update({'a': 1, 'b': 2})` if 'a' already exists?",
    "c": null,
    "o": [
      "It updates the value of 'a' to 1",
      "It raises a KeyError",
      "It appends a new 'a'",
      "It removes the old value of 'a'"
    ]
  },
  {
    "q": "Which hashing technique minimizes clustering?",
    "c": null,
    "o": [
      "Double Hashing",
      "Linear Probing",
      "Chaining",
      "Rehashing"
    ]
  },
  {
    "q": "Which of the following will create a max heap using Python’s `heapq` module?",
    "c": null,
    "o": [
      "Insert negative values and invert during retrieval",
      "Use heapq.create_max()",
      "heapq.heapify(h, reverse=True)",
      "Use list.reverse() after heapify"
    ]
  },
  {
    "q": "Which dictionary method returns a view of all key-value pairs?",
    "c": null,
    "o": [
      "items()",
      "keys()",
      "values()",
      "all()"
    ]
  },
  {
    "q": "Which of the following is a limitation of using NumPy arrays?",
    "c": null,
    "o": [
      "All elements must be of the same data type",
      "They cannot store numbers",
      "They do not support iteration",
      "They require Python 2.x"
    ]
  },
  {
    "q": "Which NumPy function is used to generate an identity matrix?",
    "c": null,
    "o": [
      "np.eye()",
      "np.identity()",
      "np.unit()",
      "np.ones()"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "import numpy as np\narr = np.eye(3)\nprint(arr[1][1])",
    "o": [
      "1.0",
      "0",
      "True",
      "3"
    ]
  },
  {
    "q": "What is the term for removing all elements from a stack?",
    "c": null,
    "o": [
      "Stack clearing",
      "Stack deletion",
      "Pop all",
      "Push reset"
    ]
  },
  {
    "q": "Which of the following statements about queues is true?",
    "c": null,
    "o": [
      "They follow First-In-First-Out order",
      "They allow insertion at both ends",
      "They are LIFO structures",
      "They support random access"
    ]
  },
  {
    "q": "Which of the following will raise an IndexError when using deque?",
    "c": "from collections import deque\nq = deque()\nq.pop()",
    "o": [
      "popping from an empty deque",
      "adding beyond the capacity",
      "using appendleft on empty deque",
      "clearing the deque"
    ]
  },
  {
    "q": "Which type of linked list has its last node pointing to the first node?",
    "c": null,
    "o": [
      "Circular Linked List",
      "Singly Linked List",
      "Doubly Linked List",
      "Multi-linked List"
    ]
  },
  {
    "q": "Which operation is not possible in O(1) time in singly linked list?",
    "c": null,
    "o": [
      "Delete last node",
      "Insert at head",
      "Traverse from head",
      "Create node"
    ]
  },
  {
    "q": "What is the height of a balanced binary tree with 7 nodes?",
    "c": null,
    "o": [
      "2",
      "3",
      "4",
      "1"
    ]
  },
  {
    "q": "Which of the following traversals is used to delete a tree safely?",
    "c": null,
    "o": [
      "Postorder",
      "Inorder",
      "Preorder",
      "Level-order"
    ]
  },
  {
    "q": "What is the best traversal to find the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Inorder",
      "Topological"
    ]
  },
  {
    "q": "Which representation of a graph is best suited for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Edge Matrix",
      "Distance Matrix"
    ]
  },
  {
    "q": "Which heap method will remove and return the smallest element?",
    "c": null,
    "o": [
      "heappop()",
      "heapremove()",
      "heapdelete()",
      "getmin()"
    ]
  },
  {
    "q": "What happens when you push an item into a full max-heap?",
    "c": null,
    "o": [
      "It grows if dynamic, else raises error",
      "It overwrites the last element",
      "It resets the heap",
      "It changes to a min-heap"
    ]
  },
  {
    "q": "Which of the following is true about Python’s hash function?",
    "c": null,
    "o": [
      "It can produce negative integers",
      "It always returns a float",
      "It produces sequential integers",
      "It only works on strings"
    ]
  },
  {
    "q": "Which hashing method spreads out the keys using two hash functions?",
    "c": null,
    "o": [
      "Double Hashing",
      "Chaining",
      "Linear Probing",
      "Hash Bucketing"
    ]
  },
  {
    "q": "Which method is used to remove the last item from a Python dictionary?",
    "c": null,
    "o": [
      "popitem()",
      "pop()",
      "remove()",
      "del()"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "d = {'x': 1, 'y': 2}\nd.popitem()\nprint(d)",
    "o": [
      "{'x': 1}",
      "{'y': 2}",
      "{}",
      "KeyError"
    ]
  },
  {
    "q": "Which NumPy function is used to flatten a multidimensional array?",
    "c": null,
    "o": [
      "flatten()",
      "reshape()",
      "collapse()",
      "ravel()"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr.flatten())",
    "o": [
      "[1 2 3 4]",
      "[[1 2] [3 4]]",
      "[[1 2 3 4]]",
      "[4 3 2 1]"
    ]
  },
  {
    "q": "Which of these operations is allowed on a stack?",
    "c": null,
    "o": [
      "Push at top",
      "Insert at index",
      "Pop at bottom",
      "Sort the stack"
    ]
  },
  {
    "q": "What is the worst-case time complexity of stack operations?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python module provides support for priority queues using heaps?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "collections",
      "bisect"
    ]
  },
  {
    "q": "Which traversal method uses a queue internally?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Inorder",
      "Postorder"
    ]
  },
  {
    "q": "What is the height of a complete binary tree with 15 nodes?",
    "c": null,
    "o": [
      "3",
      "4",
      "5",
      "15"
    ]
  },
  {
    "q": "Which graph algorithm is used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with visited and recursion stack",
      "BFS with queue",
      "Topological sort",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which operation cannot be performed in O(1) time on a deque?",
    "c": null,
    "o": [
      "Accessing middle element",
      "Appending to front",
      "Popping from back",
      "Checking length"
    ]
  },
  {
    "q": "Which of these is a feature of hash tables?",
    "c": null,
    "o": [
      "Fast average-case lookup",
      "Sorted keys",
      "Linear memory usage for all datasets",
      "O(n log n) search time"
    ]
  },
  {
    "q": "What does `dict.setdefault('x', 0)` do if 'x' is not present?",
    "c": null,
    "o": [
      "Adds key 'x' with value 0",
      "Throws KeyError",
      "Returns None",
      "Deletes key 'x'"
    ]
  },
  {
    "q": "What is a limitation of open addressing in hash tables?",
    "c": null,
    "o": [
      "Deletion is complex",
      "Needs extra memory for linked lists",
      "Doesn't support rehashing",
      "All slots must be unique"
    ]
  },
  {
    "q": "Which binary heap operation takes O(n) time?",
    "c": null,
    "o": [
      "Building a heap from an unsorted array",
      "Insert",
      "Delete min",
      "Heapify down"
    ]
  },
  {
    "q": "Which of the following is used to store multiple elements in a single hash bucket in separate chaining?",
    "c": null,
    "o": [
      "Linked List",
      "Binary Tree",
      "Array",
      "Tuple"
    ]
  },
  {
    "q": "Which data structure is typically used to implement recursion internally in programming languages?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Array"
    ]
  },
  {
    "q": "Which of the following correctly initializes a NumPy array of zeros with shape (2, 3)?",
    "c": null,
    "o": [
      "np.zeros((2, 3))",
      "np.zeros[2][3]",
      "np.zero(2,3)",
      "np.array.zeros(2,3)"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "from collections import deque\nq = deque([10, 20, 30])\nq.rotate(1)\nprint(list(q))",
    "o": [
      "[30, 10, 20]",
      "[20, 30, 10]",
      "[10, 20, 30]",
      "[20, 10, 30]"
    ]
  },
  {
    "q": "What is the time complexity of searching in an unsorted array?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which operation in a binary search tree is performed first in a preorder traversal?",
    "c": null,
    "o": [
      "Visit root",
      "Visit left subtree",
      "Visit right subtree",
      "Visit leaves only"
    ]
  },
  {
    "q": "What is the space complexity of storing a graph with V vertices and E edges using an adjacency list?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E^2)",
      "O(V * E)"
    ]
  },
  {
    "q": "Which NumPy function returns the number of dimensions of an array?",
    "c": null,
    "o": [
      "ndim",
      "shape",
      "size",
      "dimension()"
    ]
  },
  {
    "q": "Which type of heap ensures that the parent node is always greater than or equal to child nodes?",
    "c": null,
    "o": [
      "Max Heap",
      "Min Heap",
      "Binary Search Tree",
      "Balanced Tree"
    ]
  },
  {
    "q": "Which method is used to retrieve the value associated with a key in a Python dictionary without raising an error?",
    "c": null,
    "o": [
      "get()",
      "fetch()",
      "lookup()",
      "find()"
    ]
  },
  {
    "q": "Which graph traversal method uses a stack (explicitly or implicitly)?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra",
      "Kruskal"
    ]
  },
  {
    "q": "What is the output of this operation?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr.T)",
    "o": [
      "[[1 3]\n [2 4]]",
      "[[1 2]\n [3 4]]",
      "[[4 3]\n [2 1]]",
      "[[2 1]\n [4 3]]"
    ]
  },
  {
    "q": "Which of these can lead to clustering in open addressing hash tables?",
    "c": null,
    "o": [
      "Linear Probing",
      "Double Hashing",
      "Chaining",
      "Quadratic Probing"
    ]
  },
  {
    "q": "Which tree traversal method is best for copying a tree?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which statement about NumPy broadcasting is TRUE?",
    "c": null,
    "o": [
      "Smaller arrays are automatically expanded to match the shape of larger ones during operations",
      "Broadcasting only works on arrays of the same size",
      "It only works for 1D arrays",
      "It slows down performance"
    ]
  },
  {
    "q": "What is the time complexity of deleting a node in a doubly linked list, given the node pointer?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following algorithms is best suited for finding the shortest path in a weighted graph with no negative weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "BFS",
      "DFS",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "Which Python built-in data type behaves like a hash table?",
    "c": null,
    "o": [
      "dict",
      "list",
      "tuple",
      "set"
    ]
  },
  {
    "q": "Which of the following is not a valid way to initialize a NumPy array?",
    "c": null,
    "o": [
      "np.array((1, 2, 3))",
      "np.array([1, 2, 3])",
      "np.array{1, 2, 3}",
      "np.array([[1, 2], [3, 4]])"
    ]
  },
  {
    "q": "Which data structure is best suited for undo operations in editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Linked List"
    ]
  },
  {
    "q": "Which queue allows insertion and deletion from both ends?",
    "c": null,
    "o": [
      "Deque",
      "Priority Queue",
      "Simple Queue",
      "Circular Queue"
    ]
  },
  {
    "q": "Which pointer is used to traverse a doubly linked list backward?",
    "c": null,
    "o": [
      "prev",
      "next",
      "left",
      "tail"
    ]
  },
  {
    "q": "What is the minimum number of nodes in a binary tree of height h?",
    "c": null,
    "o": [
      "h + 1",
      "2h",
      "2^h",
      "log h"
    ]
  },
  {
    "q": "Which tree traversal results in sorted order for a binary search tree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "What is the degree of a graph?",
    "c": null,
    "o": [
      "Number of edges incident to a vertex",
      "Number of vertices",
      "Maximum edge weight",
      "Total path length"
    ]
  },
  {
    "q": "What is the result of the following Python code?",
    "c": "import heapq\nh = [20, 10, 30]\nheapq.heapify(h)\nheapq.heappush(h, 5)\nprint(h[0])",
    "o": [
      "5",
      "10",
      "20",
      "30"
    ]
  },
  {
    "q": "Which of the following is NOT a valid collision resolution technique in hashing?",
    "c": null,
    "o": [
      "Index Partitioning",
      "Chaining",
      "Linear Probing",
      "Double Hashing"
    ]
  },
  {
    "q": "What is the time complexity to find the minimum element in a Min-Heap?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following dictionary methods returns a list of keys?",
    "c": null,
    "o": [
      "keys()",
      "items()",
      "values()",
      "get()"
    ]
  },
  {
    "q": "Which NumPy function returns the shape of an array?",
    "c": null,
    "o": [
      "arr.shape",
      "arr.size",
      "arr.dim",
      "arr.form()"
    ]
  },
  {
    "q": "Which queue is best suited for task scheduling based on urgency?",
    "c": null,
    "o": [
      "Priority Queue",
      "Simple Queue",
      "Circular Queue",
      "Double-ended Queue"
    ]
  },
  {
    "q": "What is the result of this graph traversal code?",
    "c": "visited = set()\n\ndef dfs(node):\n    if node not in visited:\n        print(node)\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)",
    "o": [
      "Performs Depth-First Search",
      "Performs Breadth-First Search",
      "Performs Topological Sort",
      "Performs Minimum Spanning Tree"
    ]
  },
  {
    "q": "What is the space complexity of an adjacency matrix representation for a graph with V vertices?",
    "c": null,
    "o": [
      "O(V^2)",
      "O(V)",
      "O(V + E)",
      "O(E)"
    ]
  },
  {
    "q": "Which of the following is a characteristic of circular queues?",
    "c": null,
    "o": [
      "Last position is connected back to the first",
      "It allows insertion only at the rear",
      "It supports priority-based deletion",
      "It is implemented using linked lists only"
    ]
  },
  {
    "q": "What will be the output of this code snippet?",
    "c": "from collections import deque\nd = deque([1, 2, 3])\nd.popleft()\nprint(d)",
    "o": [
      "deque([2, 3])",
      "deque([1, 2])",
      "[2, 3]",
      "[1, 2]"
    ]
  },
  {
    "q": "What does `np.arange(0, 10, 2)` return?",
    "c": null,
    "o": [
      "[0 2 4 6 8]",
      "[1 3 5 7 9]",
      "[0 1 2 3 4 5 6 7 8 9]",
      "[2 4 6 8 10]"
    ]
  },
  {
    "q": "In a doubly linked list, which operation can be done in O(1) time if the node pointer is known?",
    "c": null,
    "o": [
      "Deletion",
      "Search",
      "Find middle",
      "Sort"
    ]
  },
  {
    "q": "What will be the result of the following?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr.shape)",
    "o": [
      "(2, 2)",
      "[2, 2]",
      "4",
      "(4,)"
    ]
  },
  {
    "q": "Which Python module provides a class for implementing double-ended queues?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "deque"
    ]
  },
  {
    "q": "Which data structure uses a 'priority' value to determine the order of removal?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Circular Queue",
      "Deque"
    ]
  },
  {
    "q": "Which traversal method uses recursion to visit all child nodes before the root?",
    "c": null,
    "o": [
      "Postorder",
      "Preorder",
      "Inorder",
      "Level-order"
    ]
  },
  {
    "q": "In which situation is a binary heap preferred over a binary search tree?",
    "c": null,
    "o": [
      "When quick access to the minimum/maximum element is needed",
      "When frequent deletions are required",
      "When elements need to be stored in sorted order",
      "When searching for a specific value frequently"
    ]
  },
  {
    "q": "Which hash table technique allows multiple values to be stored at one index?",
    "c": null,
    "o": [
      "Chaining",
      "Linear Probing",
      "Double Hashing",
      "Open Addressing"
    ]
  },
  {
    "q": "What is the result of using the `get()` method on a dictionary with a non-existent key?",
    "c": null,
    "o": [
      "None",
      "KeyError",
      "False",
      "0"
    ]
  },
  {
    "q": "Which type of binary tree is used in Huffman coding?",
    "c": null,
    "o": [
      "Min Heap (Binary Tree)",
      "Binary Search Tree",
      "AVL Tree",
      "Segment Tree"
    ]
  },
  {
    "q": "What is the maximum number of children a node can have in a binary tree?",
    "c": null,
    "o": [
      "2",
      "1",
      "3",
      "Unlimited"
    ]
  },
  {
    "q": "Which of the following is true for BFS in a graph?",
    "c": null,
    "o": [
      "It explores all neighbors before going to the next level",
      "It uses recursion",
      "It is implemented using stack",
      "It is used for finding strongly connected components"
    ]
  },
  {
    "q": "What does `heapify()` function in the `heapq` module do?",
    "c": null,
    "o": [
      "Transforms a list into a valid heap",
      "Sorts a list in descending order",
      "Deletes the smallest element from a heap",
      "Adds an element into a heap"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "d = {'a': 10, 'b': 20}\nprint(d.get('c', 0))",
    "o": [
      "0",
      "None",
      "KeyError",
      "c"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4])\nprint(arr[1:3])",
    "o": [
      "[2 3]",
      "[1 2 3]",
      "[3 4]",
      "[2 3 4]"
    ]
  },
  {
    "q": "Which of the following data structures is most efficient for implementing undo functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which function is used to add an item to the front of a deque?",
    "c": null,
    "o": [
      "appendleft()",
      "append()",
      "insert(0, item)",
      "push()"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "from collections import deque\nq = deque([10, 20, 30])\nq.pop()\nprint(q)",
    "o": [
      "deque([10, 20])",
      "deque([10, 30])",
      "deque([20, 30])",
      "deque([30, 20])"
    ]
  },
  {
    "q": "In a singly linked list, which operation is the most time-consuming?",
    "c": null,
    "o": [
      "Deleting the last node",
      "Inserting at the head",
      "Traversing to the head",
      "Accessing the first element"
    ]
  },
  {
    "q": "What is the minimum number of nodes in a complete binary tree of height 3?",
    "c": null,
    "o": [
      "4",
      "2",
      "1",
      "7"
    ]
  },
  {
    "q": "Which traversal strategy ensures that the tree is visited level-by-level?",
    "c": null,
    "o": [
      "Level-order",
      "Postorder",
      "Inorder",
      "Preorder"
    ]
  },
  {
    "q": "Which of the following is used to represent a graph most efficiently when the graph is dense?",
    "c": null,
    "o": [
      "Adjacency Matrix",
      "Adjacency List",
      "Edge List",
      "Incidence Matrix"
    ]
  },
  {
    "q": "Which Python module provides built-in support for heaps?",
    "c": null,
    "o": [
      "heapq",
      "heap",
      "priority",
      "binarytree"
    ]
  },
  {
    "q": "What is the time complexity of inserting into a binary min-heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is not a valid way to handle hash collisions?",
    "c": null,
    "o": [
      "Binary Search",
      "Chaining",
      "Open Addressing",
      "Double Hashing"
    ]
  },
  {
    "q": "Which method returns the number of elements in a dictionary?",
    "c": null,
    "o": [
      "len()",
      "count()",
      "size()",
      "length()"
    ]
  },
  {
    "q": "Which NumPy function is used to create an array with evenly spaced values over a specified range?",
    "c": null,
    "o": [
      "np.linspace()",
      "np.range()",
      "np.spread()",
      "np.equalspace()"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "d = {'x': 1, 'y': 2}\nprint(list(d.items()))",
    "o": [
      "[('x', 1), ('y', 2)]",
      "['x', 'y']",
      "[1, 2]",
      "{'x': 1, 'y': 2}"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "import heapq\nnums = [3, 1, 4]\nheapq.heapify(nums)\nprint(nums[0])",
    "o": [
      "1",
      "3",
      "4",
      "0"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching for an element in a hash table?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following NumPy functions creates an array filled with ones?",
    "c": null,
    "o": [
      "np.ones()",
      "np.full()",
      "np.ones_like()",
      "np.zeros()"
    ]
  },
  {
    "q": "Which data structure provides constant time complexity for insertion and deletion from both ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "What is the primary advantage of using a doubly linked list over a singly linked list?",
    "c": null,
    "o": [
      "Traversal in both directions",
      "Less memory usage",
      "Easier sorting",
      "Faster insert at the end"
    ]
  },
  {
    "q": "Which of the following trees is always balanced?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Search Tree",
      "B-Tree",
      "N-ary Tree"
    ]
  },
  {
    "q": "Which graph representation uses more space for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency Matrix",
      "Adjacency List",
      "Edge List",
      "Vertex Set"
    ]
  },
  {
    "q": "Which traversal of a binary search tree results in descending order?",
    "c": null,
    "o": [
      "Reverse Inorder",
      "Postorder",
      "Preorder",
      "Level-order"
    ]
  },
  {
    "q": "Which algorithm is most suitable to find connected components in an undirected graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "Which Python function is used to return all the keys from a dictionary?",
    "c": null,
    "o": [
      "keys()",
      "items()",
      "values()",
      "get()"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "import numpy as np\narr = np.array([1, 2, 3])\nprint(arr * 2)",
    "o": [
      "[2 4 6]",
      "[1 2 3 1 2 3]",
      "[1 2 3 2]",
      "Error"
    ]
  },
  {
    "q": "Which operation on a heap has O(log n) complexity?",
    "c": null,
    "o": [
      "Insertion",
      "Find minimum",
      "Heapify",
      "Access first element"
    ]
  },
  {
    "q": "Which of these is NOT a valid NumPy function?",
    "c": null,
    "o": [
      "np.roundup()",
      "np.round()",
      "np.floor()",
      "np.ceil()"
    ]
  },
  {
    "q": "Which technique in hash tables involves storing colliding elements in linked lists?",
    "c": null,
    "o": [
      "Chaining",
      "Linear Probing",
      "Quadratic Probing",
      "Double Hashing"
    ]
  },
  {
    "q": "Which of the following is true about stacks?",
    "c": null,
    "o": [
      "They follow LIFO order",
      "They follow FIFO order",
      "They allow insertion from both ends",
      "They use priority-based access"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "d = {'x': 1, 'y': 2}\nd['z'] = 3\nprint(len(d))",
    "o": [
      "3",
      "2",
      "1",
      "Error"
    ]
  },
  {
    "q": "Which of the following structures is ideal for implementing BFS?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Deque",
      "Set"
    ]
  },
  {
    "q": "Which queue type stores items in order of priority?",
    "c": null,
    "o": [
      "Priority Queue",
      "Circular Queue",
      "Simple Queue",
      "Double-ended Queue"
    ]
  },
  {
    "q": "Which Python module provides a simple FIFO queue implementation?",
    "c": null,
    "o": [
      "queue",
      "heapq",
      "collections",
      "bisect"
    ]
  },
  {
    "q": "Which of the following graph traversal techniques guarantees the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra",
      "Prim"
    ]
  },
  {
    "q": "What does `np.reshape()` do in NumPy?",
    "c": null,
    "o": [
      "Changes the shape of an array without changing its data",
      "Sorts the array",
      "Adds new elements",
      "Deletes elements"
    ]
  },
  {
    "q": "Which of these is NOT a characteristic of stacks?",
    "c": null,
    "o": [
      "Allows access to middle elements",
      "Follows Last-In-First-Out order",
      "Supports push and pop operations",
      "Used in recursion"
    ]
  },
  {
    "q": "Which tree traversal method visits the root before its subtrees?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which is the correct way to remove and return the smallest item from a min-heap in Python?",
    "c": null,
    "o": [
      "heapq.heappop(heap)",
      "heap.pop(0)",
      "heap.remove(0)",
      "heap.pop()"
    ]
  },
  {
    "q": "In which scenario is a circular queue preferred over a linear queue?",
    "c": null,
    "o": [
      "To reuse empty spaces after dequeue",
      "To allow priority scheduling",
      "To process tasks from both ends",
      "To access middle elements"
    ]
  },
  {
    "q": "Which method is used to add a key-value pair to a dictionary?",
    "c": null,
    "o": [
      "dict[key] = value",
      "dict.add(key, value)",
      "dict.insert(key, value)",
      "dict.push(key, value)"
    ]
  },
  {
    "q": "Which of these operations is fastest for accessing an element by index?",
    "c": null,
    "o": [
      "Array",
      "Linked List",
      "Deque",
      "Set"
    ]
  },
  {
    "q": "Which of the following data structures does not allow duplicates?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Array",
      "Deque"
    ]
  },
  {
    "q": "Which NumPy function is used to join two or more arrays along an axis?",
    "c": null,
    "o": [
      "concatenate()",
      "combine()",
      "append()",
      "join()"
    ]
  },
  {
    "q": "What is the key difference between a binary tree and a binary search tree?",
    "c": null,
    "o": [
      "BST has ordered nodes",
      "Binary tree uses less memory",
      "Binary tree is faster",
      "BST has at most one child"
    ]
  },
  {
    "q": "Which heap operation is used to rearrange a list into a valid heap?",
    "c": null,
    "o": [
      "heapify()",
      "heappush()",
      "heapmerge()",
      "reheap()"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "a = [10, 20, 30]\na.pop()\nprint(a)",
    "o": [
      "[10, 20]",
      "[20, 30]",
      "[10, 30]",
      "[10, 20, 30]"
    ]
  },
  {
    "q": "Which hashing technique reduces clustering better than linear probing?",
    "c": null,
    "o": [
      "Quadratic Probing",
      "Chaining",
      "Linear Probing",
      "Modulo Hashing"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "import numpy as np\narr = np.array([1, 2, 3])\nprint(arr[-1])",
    "o": [
      "3",
      "1",
      "-1",
      "Error"
    ]
  },
  {
    "q": "Which of the following Python collections supports LIFO behavior?",
    "c": null,
    "o": [
      "stack = []",
      "queue.Queue()",
      "collections.deque() with appendleft()",
      "set()"
    ]
  },
  {
    "q": "What is the default behavior of `heapq` in Python?",
    "c": null,
    "o": [
      "Implements a Min-Heap",
      "Implements a Max-Heap",
      "Implements a Priority Queue with FIFO behavior",
      "Implements a Binary Search Tree"
    ]
  },
  {
    "q": "Which operation takes O(n) time on a singly linked list?",
    "c": null,
    "o": [
      "Accessing the last element",
      "Accessing the first element",
      "Inserting at head",
      "Deleting the head"
    ]
  },
  {
    "q": "Which of the following is NOT a property of a binary search tree (BST)?",
    "c": null,
    "o": [
      "All left subtree nodes are greater than root",
      "Left subtree has values < root",
      "Right subtree has values > root",
      "No duplicate values (typically)"
    ]
  },
  {
    "q": "Which algorithm is used for topological sorting of a directed acyclic graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "from collections import deque\nq = deque()\nq.append(1)\nq.appendleft(2)\nprint(q)",
    "o": [
      "deque([2, 1])",
      "deque([1, 2])",
      "[2, 1]",
      "[1, 2]"
    ]
  },
  {
    "q": "Which of these is a valid use case for a priority queue?",
    "c": null,
    "o": [
      "Task scheduling by importance",
      "Undo functionality",
      "Traversing graphs level-by-level",
      "Browsing history stack"
    ]
  },
  {
    "q": "What is the maximum number of nodes in a binary tree of height h?",
    "c": null,
    "o": [
      "2^(h+1) - 1",
      "2^h - 1",
      "h",
      "h * log h"
    ]
  },
  {
    "q": "Which of these is NOT a valid dictionary method in Python?",
    "c": null,
    "o": [
      "insert()",
      "get()",
      "keys()",
      "items()"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr[1][0])",
    "o": [
      "3",
      "1",
      "4",
      "2"
    ]
  },
  {
    "q": "What is the worst-case time complexity of inserting into a hash table with linear probing?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is a limitation of using arrays over linked lists?",
    "c": null,
    "o": [
      "Fixed size",
      "Slow traversal",
      "Wastes memory for each node",
      "Cannot be indexed"
    ]
  },
  {
    "q": "Which tree has a balance factor property to keep it height-balanced?",
    "c": null,
    "o": [
      "AVL Tree",
      "B-Tree",
      "Binary Tree",
      "Trie"
    ]
  },
  {
    "q": "What does the following dictionary method return?",
    "c": "d = {'a': 1, 'b': 2}\nprint(d.get('c'))",
    "o": [
      "None",
      "KeyError",
      "0",
      "c"
    ]
  },
  {
    "q": "Which of the following graphs must not have cycles?",
    "c": null,
    "o": [
      "Directed Acyclic Graph (DAG)",
      "Weighted Graph",
      "Undirected Graph",
      "Complete Graph"
    ]
  },
  {
    "q": "Which NumPy function would you use to get the total number of elements in an array?",
    "c": null,
    "o": [
      "size",
      "len()",
      "ndim",
      "count()"
    ]
  },
  {
    "q": "Which data structure is used for implementing a LRU cache efficiently?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Array + Stack",
      "Queue + Stack",
      "Heap + Array"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "import heapq\narr = [4, 1, 7]\nheapq.heappush(arr, 2)\nprint(arr[0])",
    "o": [
      "1",
      "2",
      "4",
      "7"
    ]
  },
  {
    "q": "Which type of graph traversal guarantees visiting each node at the minimum depth first?",
    "c": null,
    "o": [
      "Breadth-First Search",
      "Depth-First Search",
      "Topological Sort",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which NumPy function can be used to change the number of dimensions of an array?",
    "c": null,
    "o": [
      "reshape()",
      "resize()",
      "flatten()",
      "copy()"
    ]
  },
  {
    "q": "Which data structure supports both stack and queue operations?",
    "c": null,
    "o": [
      "Deque",
      "Priority Queue",
      "Linked List",
      "Set"
    ]
  },
  {
    "q": "What is the purpose of a sentinel node in a linked list?",
    "c": null,
    "o": [
      "To simplify edge-case handling",
      "To store maximum value",
      "To mark the midpoint",
      "To reduce memory usage"
    ]
  },
  {
    "q": "What will be the result of this code?",
    "c": "from collections import deque\nq = deque([1, 2, 3])\nq.rotate(-1)\nprint(q)",
    "o": [
      "deque([2, 3, 1])",
      "deque([3, 1, 2])",
      "deque([1, 2, 3])",
      "deque([1, 3, 2])"
    ]
  },
  {
    "q": "Which method removes a specific key from a dictionary and returns its value?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "discard()",
      "del()"
    ]
  },
  {
    "q": "What is the maximum number of nodes in a binary tree with depth d (root at depth 0)?",
    "c": null,
    "o": [
      "2^(d+1) - 1",
      "2^d - 1",
      "d",
      "d * 2"
    ]
  },
  {
    "q": "Which of the following traversal strategies visits all nodes at the same depth before going deeper?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Inorder",
      "Postorder"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "d = {'a': 1, 'b': 2}\nd.update({'c': 3})\nprint(d)",
    "o": [
      "{'a': 1, 'b': 2, 'c': 3}",
      "{'a': 1, 'b': 2}",
      "{'c': 3}",
      "['a', 'b', 'c']"
    ]
  },
  {
    "q": "Which of the following methods adds an element to the end of a Python list?",
    "c": null,
    "o": [
      "append()",
      "push()",
      "insert()",
      "add()"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using hash tables?",
    "c": null,
    "o": [
      "Potential for collisions",
      "Slower lookup than arrays",
      "No support for strings as keys",
      "Requires sorting before use"
    ]
  },
  {
    "q": "Which of these is used to store hierarchical data efficiently?",
    "c": null,
    "o": [
      "Tree",
      "Heap",
      "Hash Table",
      "Array"
    ]
  },
  {
    "q": "Which queue type is typically implemented with a circular buffer?",
    "c": null,
    "o": [
      "Circular Queue",
      "Simple Queue",
      "Deque",
      "Priority Queue"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "import numpy as np\narr = np.array([[5, 10], [15, 20]])\nprint(arr[0, 1])",
    "o": [
      "10",
      "5",
      "15",
      "20"
    ]
  },
  {
    "q": "Which of the following is the best data structure to implement recursion internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Array"
    ]
  },
  {
    "q": "What is the time complexity of inserting a node at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following Python statements correctly creates a 2D NumPy array?",
    "c": null,
    "o": [
      "np.array([[1, 2], [3, 4]])",
      "np.array((1, 2), (3, 4))",
      "np.array{[1, 2], [3, 4]}",
      "np.array((1, 2, 3, 4))"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "from collections import deque\nq = deque([1, 2, 3])\nq.append(4)\nprint(q)",
    "o": [
      "deque([1, 2, 3, 4])",
      "deque([4, 1, 2, 3])",
      "deque([1, 2, 3])",
      "[1, 2, 3, 4]"
    ]
  },
  {
    "q": "Which traversal method is best suited for copying a binary tree?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which graph representation is most space-efficient for a graph with very few edges?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Incidence Matrix",
      "Edge Matrix"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "import heapq\narr = [5, 1, 3]\nheapq.heapify(arr)\nheapq.heappush(arr, 2)\nprint(heapq.heappop(arr))",
    "o": [
      "1",
      "2",
      "3",
      "5"
    ]
  },
  {
    "q": "Which of the following is NOT an application of a hash table?",
    "c": null,
    "o": [
      "Sorting a list of numbers",
      "Implementing dictionaries",
      "Symbol tables in compilers",
      "Caching data"
    ]
  },
  {
    "q": "What is the time complexity of traversing all elements in an array?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which NumPy function is used to flatten a multi-dimensional array?",
    "c": null,
    "o": [
      "flatten()",
      "flat()",
      "reshape(1, -1)",
      "ravel()"
    ]
  },
  {
    "q": "Which of the following is true about binary heaps?",
    "c": null,
    "o": [
      "They are complete binary trees",
      "They are always balanced",
      "They store elements in sorted order",
      "They require AVL rotations"
    ]
  },
  {
    "q": "What is the best case time complexity of searching an element in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "d = {'apple': 5, 'banana': 3}\nd['apple'] += 1\nprint(d['apple'])",
    "o": [
      "6",
      "5",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which queue is most appropriate for round-robin scheduling in operating systems?",
    "c": null,
    "o": [
      "Circular Queue",
      "Simple Queue",
      "Priority Queue",
      "Deque"
    ]
  },
  {
    "q": "Which tree traversal is used in expression tree evaluation?",
    "c": null,
    "o": [
      "Postorder",
      "Preorder",
      "Inorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following ensures constant-time access by key?",
    "c": null,
    "o": [
      "Hash Table",
      "Binary Search Tree",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "What is the default data type of a NumPy array if not specified?",
    "c": null,
    "o": [
      "float64",
      "int32",
      "object",
      "str"
    ]
  },
  {
    "q": "Which method is used to add an element to a Python set?",
    "c": null,
    "o": [
      "add()",
      "append()",
      "insert()",
      "push()"
    ]
  },
  {
    "q": "Which of the following is not a property of a min-heap?",
    "c": null,
    "o": [
      "Parent is always smaller than child",
      "Left and right children are unordered",
      "Heap is a complete binary tree",
      "Elements are stored in sorted order"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "from collections import deque\nq = deque([1, 2, 3])\nq.pop()\nprint(len(q))",
    "o": [
      "2",
      "3",
      "1",
      "0"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing undo/redo functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Table"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "import numpy as np\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr[:, 1])",
    "o": [
      "[2 5]",
      "[1 2]",
      "[4 5]",
      "[2 3]"
    ]
  },
  {
    "q": "Which data structure is used by the Python `heapq` module?",
    "c": null,
    "o": [
      "List (as a binary heap)",
      "Tree",
      "Dictionary",
      "Tuple"
    ]
  },
  {
    "q": "Which of the following graph algorithms uses a priority queue internally?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "DFS",
      "BFS",
      "Topological Sort"
    ]
  },
  {
    "q": "Which hash collision resolution method uses another hash function?",
    "c": null,
    "o": [
      "Double Hashing",
      "Chaining",
      "Linear Probing",
      "Quadratic Probing"
    ]
  },
  {
    "q": "Which data structure is typically used for level-order traversal of trees?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Deque",
      "Set"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "d = {'x': 10, 'y': 20}\nd.clear()\nprint(d)",
    "o": [
      "{}",
      "{'x': 0, 'y': 0}",
      "{None}",
      "Error"
    ]
  },
  {
    "q": "Which NumPy function can be used to create an identity matrix?",
    "c": null,
    "o": [
      "np.eye()",
      "np.ones()",
      "np.identity()",
      "np.full()"
    ]
  },
  {
    "q": "Which data structure uses a key-value pair for storage?",
    "c": null,
    "o": [
      "Hash Table",
      "List",
      "Stack",
      "Set"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in an array using its index?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is true about NumPy arrays?",
    "c": null,
    "o": [
      "They are faster and use less memory than Python lists",
      "They are slower than Python lists",
      "They store values as strings",
      "They don't support slicing"
    ]
  },
  {
    "q": "Which graph traversal algorithm can be implemented using recursion?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra",
      "Kruskal"
    ]
  },
  {
    "q": "What does the `heapq.nlargest(n, iterable)` function return?",
    "c": null,
    "o": [
      "A list of the n largest elements from the iterable",
      "The largest element from the iterable",
      "Sorted version of the iterable",
      "A heapified list of n largest elements"
    ]
  },
  {
    "q": "Which of the following operations is the most expensive in a singly linked list?",
    "c": null,
    "o": [
      "Deleting the last node",
      "Inserting at the beginning",
      "Traversing the list",
      "Accessing the first element"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4])\nprint(arr[::2])",
    "o": [
      "[1 3]",
      "[1 2 3 4]",
      "[2 4]",
      "[1 2]"
    ]
  },
  {
    "q": "Which of the following algorithms uses a stack internally?",
    "c": null,
    "o": [
      "Depth-First Search",
      "Breadth-First Search",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which is NOT true about hash tables?",
    "c": null,
    "o": [
      "They store data in sorted order",
      "They offer average O(1) lookup time",
      "Collisions can occur",
      "They use a hash function"
    ]
  },
  {
    "q": "What is the worst-case time complexity of deleting a node in a binary search tree?",
    "c": null,
    "o": [
      "O(h)",
      "O(1)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which NumPy function can generate an array of random values?",
    "c": null,
    "o": [
      "np.random.rand()",
      "np.gen()",
      "np.array.random()",
      "np.matrix.rand()"
    ]
  },
  {
    "q": "Which traversal method is used in BFS?",
    "c": null,
    "o": [
      "Level-order",
      "Postorder",
      "Preorder",
      "Inorder"
    ]
  },
  {
    "q": "What will the following dictionary method return?",
    "c": "d = {'a': 10, 'b': 20}\nprint(d.pop('a'))",
    "o": [
      "10",
      "{'b': 20}",
      "None",
      "KeyError"
    ]
  },
  {
    "q": "Which of these is NOT a valid application of a deque?",
    "c": null,
    "o": [
      "Fast random access",
      "Sliding window",
      "Undo feature",
      "Palindrome checking"
    ]
  },
  {
    "q": "What is the key idea behind open addressing in hash tables?",
    "c": null,
    "o": [
      "Storing all entries in the table itself and probing for empty slots",
      "Chaining elements using linked lists",
      "Using multiple hash functions to resolve collisions",
      "Using a binary tree for storing keys"
    ]
  },
  {
    "q": "Which method adds an element to the beginning of a deque?",
    "c": null,
    "o": [
      "appendleft()",
      "append()",
      "insert(0)",
      "push()"
    ]
  },
  {
    "q": "Which structure is best for implementing a phone contact book for fast lookup?",
    "c": null,
    "o": [
      "Hash Table",
      "Stack",
      "Queue",
      "List"
    ]
  },
  {
    "q": "Which NumPy function returns the cumulative sum of elements along a given axis?",
    "c": null,
    "o": [
      "np.cumsum()",
      "np.sum()",
      "np.total()",
      "np.aggregate()"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "import numpy as np\narr = np.array([[1,2],[3,4]])\nprint(arr.shape)",
    "o": [
      "(2, 2)",
      "[2, 2]",
      "4",
      "(4,)"
    ]
  },
  {
    "q": "Which Python structure is most suitable for implementing a task scheduler with priorities?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Set",
      "Array"
    ]
  },
  {
    "q": "What is the primary purpose of the `heapq.heapify()` function in Python?",
    "c": null,
    "o": [
      "Convert a list into a valid heap structure",
      "Sort a list in ascending order",
      "Find the maximum value in a list",
      "Insert an element into a heap"
    ]
  },
  {
    "q": "Which of the following tree traversals results in sorted order for a Binary Search Tree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these graph representations is most efficient for checking the existence of an edge between two vertices?",
    "c": null,
    "o": [
      "Adjacency Matrix",
      "Adjacency List",
      "Edge List",
      "Vertex Set"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "import numpy as np\narr = np.array([4, 2, 9, 1])\nprint(np.sort(arr))",
    "o": [
      "[1 2 4 9]",
      "[4 2 9 1]",
      "[9 4 2 1]",
      "[1, 2, 4, 9, arr]"
    ]
  },
  {
    "q": "Which method is used to remove all elements from a Python set?",
    "c": null,
    "o": [
      "clear()",
      "remove()",
      "discard()",
      "del()"
    ]
  },
  {
    "q": "Which of these is a major advantage of using linked lists over arrays?",
    "c": null,
    "o": [
      "Dynamic size",
      "Constant-time access by index",
      "Less memory per element",
      "Better cache performance"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "q = []\nq.append(10)\nq.append(20)\nq.pop(0)\nprint(q)",
    "o": [
      "[20]",
      "[10]",
      "[10, 20]",
      "[]"
    ]
  },
  {
    "q": "Which tree structure is best suited for representing hierarchical file systems?",
    "c": null,
    "o": [
      "N-ary Tree",
      "Binary Tree",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "What is the typical space complexity of an adjacency matrix for a graph with V vertices?",
    "c": null,
    "o": [
      "O(V^2)",
      "O(V)",
      "O(log V)",
      "O(2V)"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "d = {'x': 1, 'y': 2}\nd.update({'x': 3})\nprint(d['x'])",
    "o": [
      "3",
      "1",
      "2",
      "None"
    ]
  },
  {
    "q": "Which of the following is NOT a property of a deque?",
    "c": null,
    "o": [
      "Fast access to middle element",
      "Insertion at both ends",
      "Deletion from both ends",
      "Implemented using doubly linked list"
    ]
  },
  {
    "q": "Which operation on a hash table may degrade to O(n) in the worst case?",
    "c": null,
    "o": [
      "Search",
      "Insert",
      "Delete",
      "All of the above"
    ]
  },
  {
    "q": "Which function in NumPy returns evenly spaced numbers over a specified interval?",
    "c": null,
    "o": [
      "linspace()",
      "arange()",
      "range()",
      "slice()"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "import numpy as np\nx = np.zeros((2, 3))\nprint(x.shape)",
    "o": [
      "(2, 3)",
      "(3, 2)",
      "(6,)",
      "2x3"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a depth-limited search in AI?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "import heapq\narr = [7, 3, 5]\nheapq.heapify(arr)\nheapq.heappush(arr, 2)\nprint(arr[0])",
    "o": [
      "2",
      "3",
      "5",
      "7"
    ]
  },
  {
    "q": "Which of the following is the correct property of a binary heap?",
    "c": null,
    "o": [
      "Every parent node is smaller than or equal to its children (Min-Heap)",
      "It must be a binary search tree",
      "It allows duplicate values only at the root",
      "It is always a balanced BST"
    ]
  },
  {
    "q": "What does the `popitem()` method do in a Python dictionary?",
    "c": null,
    "o": [
      "Removes and returns the last inserted key-value pair",
      "Deletes all items",
      "Pops an item randomly",
      "Removes the first inserted item"
    ]
  },
  {
    "q": "Which of these structures allows O(1) insertion and deletion at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "List"
    ]
  },
  {
    "q": "What is the output of this NumPy code?",
    "c": "import numpy as np\nx = np.arange(6).reshape(2, 3)\nprint(x[1][2])",
    "o": [
      "5",
      "2",
      "3",
      "4"
    ]
  },
  {
    "q": "Which method in a list removes the first occurrence of a value?",
    "c": null,
    "o": [
      "remove()",
      "pop()",
      "delete()",
      "discard()"
    ]
  },
  {
    "q": "Which tree allows efficient prefix search operations?",
    "c": null,
    "o": [
      "Trie",
      "BST",
      "AVL Tree",
      "B-Tree"
    ]
  },
  {
    "q": "What will this code return?",
    "c": "s = set([1, 2, 3])\ns.discard(4)\nprint(s)",
    "o": [
      "{1, 2, 3}",
      "KeyError",
      "{1, 2}",
      "None"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra",
      "Prim"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "import numpy as np\nx = np.array([[1, 2], [3, 4]])\nprint(x.T)",
    "o": [
      "[[1 3]\n [2 4]]",
      "[[1 2]\n [3 4]]",
      "[[2 1]\n [4 3]]",
      "[[4 3]\n [2 1]]"
    ]
  },
  {
    "q": "Which of these is NOT a valid use case for a hash table?",
    "c": null,
    "o": [
      "Maintaining sorted order",
      "Caching",
      "Fast lookups",
      "Counting occurrences"
    ]
  },
  {
    "q": "Which of these tree types is self-balancing?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Search Tree",
      "Trie",
      "Heap"
    ]
  },
  {
    "q": "Which Python module provides a double-ended queue with thread-safe operations?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "array"
    ]
  },
  {
    "q": "Which NumPy function flattens a multi-dimensional array into a 1D array?",
    "c": null,
    "o": [
      "flatten()",
      "reshape(1, -1)",
      "merge()",
      "combine()"
    ]
  },
  {
    "q": "What is the time complexity of heapify() on an unsorted array of n elements?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which of the following is a characteristic of circular queues?",
    "c": null,
    "o": [
      "They reuse freed memory",
      "They use linked lists",
      "They always resize on full",
      "They cannot wrap around"
    ]
  },
  {
    "q": "Which of the following operations is the most efficient for accessing an element in an array?",
    "c": null,
    "o": [
      "Access by index",
      "Search by value",
      "Insert at beginning",
      "Delete by value"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "from collections import deque\nq = deque([10, 20, 30])\nq.popleft()\nprint(q)",
    "o": [
      "deque([20, 30])",
      "deque([10, 20])",
      "deque([10, 30])",
      "[10, 20, 30]"
    ]
  },
  {
    "q": "Which of the following does not allow duplicate values?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary (values)"
    ]
  },
  {
    "q": "What is the maximum number of nodes in a complete binary tree of height h?",
    "c": null,
    "o": [
      "2^(h+1) - 1",
      "2^h",
      "2h - 1",
      "h^2"
    ]
  },
  {
    "q": "Which NumPy function converts a multi-dimensional array to a one-dimensional array without copying data?",
    "c": null,
    "o": [
      "ravel()",
      "flatten()",
      "reshape()",
      "view()"
    ]
  },
  {
    "q": "Which traversal is used to evaluate an expression in a binary expression tree?",
    "c": null,
    "o": [
      "Postorder",
      "Inorder",
      "Preorder",
      "Level-order"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "import heapq\narr = [10, 1, 5]\nheapq.heapify(arr)\nprint(heapq.heappop(arr))",
    "o": [
      "1",
      "5",
      "10",
      "[1, 5, 10]"
    ]
  },
  {
    "q": "What is the main advantage of using adjacency list over adjacency matrix in graph representation?",
    "c": null,
    "o": [
      "Better space efficiency for sparse graphs",
      "Faster lookup of edges",
      "Better support for weighted edges",
      "Supports only directed graphs"
    ]
  },
  {
    "q": "Which data structure is used in the implementation of BFS (Breadth-First Search)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Hash Map"
    ]
  },
  {
    "q": "Which structure is most suitable for managing the browser history (back and forward navigation)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which of these is used to avoid collisions in hashing?",
    "c": null,
    "o": [
      "Chaining",
      "Stacking",
      "Queuing",
      "Clustering"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "d = {'a': 100, 'b': 200}\nprint(list(d.keys()))",
    "o": [
      "['a', 'b']",
      "[100, 200]",
      "dict_keys(['a', 'b'])",
      "['b', 'a']"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "Array",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which structure is optimal for implementing the undo feature in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Table",
      "Set"
    ]
  },
  {
    "q": "Which method is used to sort a NumPy array in-place?",
    "c": null,
    "o": [
      "sort()",
      "sorted()",
      "order()",
      "arrange()"
    ]
  },
  {
    "q": "Which property defines a Max-Heap?",
    "c": null,
    "o": [
      "Every parent node is greater than or equal to its children",
      "Only leaf nodes are sorted",
      "Left child is always greater than right",
      "Heap is always a complete BST"
    ]
  },
  {
    "q": "Which Python module provides support for arrays of basic values such as characters and numbers?",
    "c": null,
    "o": [
      "array",
      "collections",
      "heapq",
      "queue"
    ]
  },
  {
    "q": "What is the time complexity of searching for a value in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "import numpy as np\nx = np.array([1, 2, 3, 4])\nprint(x[-2])",
    "o": [
      "3",
      "2",
      "4",
      "1"
    ]
  },
  {
    "q": "Which data structure is best suited to implement recursion internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Array"
    ]
  },
  {
    "q": "Which traversal method is used in topological sorting of a directed acyclic graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Inorder",
      "Level-order"
    ]
  },
  {
    "q": "What is the main characteristic of a circular queue?",
    "c": null,
    "o": [
      "It wraps around to reuse empty space",
      "It uses two stacks",
      "It does not allow duplicate values",
      "It maintains elements in sorted order"
    ]
  },
  {
    "q": "Which one of these is not a collision resolution strategy in hashing?",
    "c": null,
    "o": [
      "Dynamic Resizing",
      "Chaining",
      "Linear Probing",
      "Quadratic Probing"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "d = {'x': 1, 'y': 2, 'z': 3}\nd.pop('y')\nprint(len(d))",
    "o": [
      "2",
      "3",
      "1",
      "0"
    ]
  },
  {
    "q": "Which of the following best describes a NumPy array?",
    "c": null,
    "o": [
      "Homogeneous, multidimensional data structure",
      "Heterogeneous, multidimensional container",
      "Homogeneous list of lists",
      "Object-oriented container of Python types"
    ]
  },
  {
    "q": "What is the primary use of a min-heap?",
    "c": null,
    "o": [
      "To quickly retrieve the smallest element",
      "To implement LIFO behavior",
      "To build balanced trees",
      "To store hash codes"
    ]
  },
  {
    "q": "What does `np.argmax()` return?",
    "c": null,
    "o": [
      "Index of the maximum element",
      "Value of the maximum element",
      "Sorted version of the array",
      "Sum of all elements"
    ]
  },
  {
    "q": "Which operation is faster in a doubly linked list compared to a singly linked list?",
    "c": null,
    "o": [
      "Deletion from the end",
      "Traversal from the beginning",
      "Insertion at the head",
      "Accessing by index"
    ]
  },
  {
    "q": "What is the time complexity to insert an element in a heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "s = set([1, 2, 3, 2, 1])\nprint(len(s))",
    "o": [
      "3",
      "5",
      "2",
      "4"
    ]
  },
  {
    "q": "Which of the following is best for implementing a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Array",
      "Stack",
      "Deque"
    ]
  },
  {
    "q": "Which of the following is NOT true about a stack?",
    "c": null,
    "o": [
      "It allows access to all elements directly",
      "It follows LIFO",
      "Top element is the most recently inserted",
      "Only the top element can be accessed"
    ]
  },
  {
    "q": "Which of the following is a limitation of an array in Python?",
    "c": null,
    "o": [
      "Fixed type of elements",
      "Dynamic resizing",
      "Stores heterogeneous data",
      "Faster than NumPy"
    ]
  },
  {
    "q": "What does the following NumPy code print?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr[1, 0])",
    "o": [
      "3",
      "1",
      "2",
      "4"
    ]
  },
  {
    "q": "Which data structure is best suited for the implementation of a LRU cache?",
    "c": null,
    "o": [
      "Deque + HashMap",
      "Stack + Heap",
      "List + Set",
      "Array + Queue"
    ]
  },
  {
    "q": "Which Python module offers a thread-safe FIFO queue?",
    "c": null,
    "o": [
      "queue",
      "heapq",
      "collections",
      "array"
    ]
  },
  {
    "q": "What is the best-case time complexity of searching in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is true about a priority queue?",
    "c": null,
    "o": [
      "Highest or lowest priority element is removed first",
      "It follows LIFO",
      "It removes elements in insertion order",
      "It is slower than regular queue"
    ]
  },
  {
    "q": "Which of the following is NOT true about binary search trees?",
    "c": null,
    "o": [
      "Every left child has a smaller value than the node",
      "They allow duplicates without modification",
      "Inorder traversal gives sorted order",
      "Right child has larger value than the node"
    ]
  },
  {
    "q": "Which of the following can be used to implement adjacency list for graphs?",
    "c": null,
    "o": [
      "Dictionary of lists",
      "2D array",
      "Set of sets",
      "Heap"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "import numpy as np\narr = np.array([10, 20, 30, 40])\nprint(arr[arr > 25])",
    "o": [
      "[30 40]",
      "[10 20]",
      "[10 20 30 40]",
      "[25 30 40]"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a balanced AVL tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these is a correct way to define a NumPy array with integers only?",
    "c": null,
    "o": [
      "np.array([1, 2, 3], dtype=int)",
      "np.array((1, 2, 3), dtype=str)",
      "np.array({'a': 1, 'b': 2})",
      "np.array(1, 2, 3)"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "from collections import deque\nq = deque()\nq.appendleft(10)\nq.append(20)\nprint(q)",
    "o": [
      "deque([10, 20])",
      "deque([20, 10])",
      "[10, 20]",
      "[20, 10]"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of hashing?",
    "c": null,
    "o": [
      "Efficient key-based access",
      "Sorting elements quickly",
      "Compressing data",
      "Encrypting passwords"
    ]
  },
  {
    "q": "Which queue operation removes an element?",
    "c": null,
    "o": [
      "dequeue",
      "enqueue",
      "peek",
      "insert"
    ]
  },
  {
    "q": "Which tree is typically used to implement a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "BST",
      "Trie",
      "AVL Tree"
    ]
  },
  {
    "q": "Which of the following is a key advantage of using NumPy arrays over Python lists?",
    "c": null,
    "o": [
      "Faster operations on large data sets",
      "Supports mixed data types",
      "Can store dictionaries",
      "Built-in graphical interface"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing the 'undo' functionality in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4, 5])\nprint(arr[1:4])",
    "o": [
      "[2 3 4]",
      "[1 2 3 4]",
      "[1 4]",
      "[2 3 5]"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching for an element in a hash table?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which tree traversal technique uses a queue internally?",
    "c": null,
    "o": [
      "Level-order",
      "Inorder",
      "Preorder",
      "Postorder"
    ]
  },
  {
    "q": "Which of these operations is not supported by a Python deque?",
    "c": null,
    "o": [
      "Random access",
      "append()",
      "appendleft()",
      "pop()"
    ]
  },
  {
    "q": "Which module would you use to create a max heap in Python?",
    "c": null,
    "o": [
      "Use heapq with negated values",
      "collections",
      "array",
      "queue.PriorityQueue"
    ]
  },
  {
    "q": "Which data structure is most efficient for finding the median from a stream of numbers?",
    "c": null,
    "o": [
      "Two Heaps (min and max)",
      "Queue",
      "Stack",
      "Hash Table"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "from collections import deque\nq = deque([1, 2, 3])\nq.rotate(1)\nprint(q)",
    "o": [
      "deque([3, 1, 2])",
      "deque([1, 2, 3])",
      "deque([2, 3, 1])",
      "deque([1, 3, 2])"
    ]
  },
  {
    "q": "What is the primary advantage of an adjacency list over an adjacency matrix?",
    "c": null,
    "o": [
      "It uses less space for sparse graphs",
      "It is easier to implement",
      "It stores edges in sorted order",
      "It supports weighted edges only"
    ]
  },
  {
    "q": "Which of the following data structures allows elements to be inserted and removed from both ends?",
    "c": null,
    "o": [
      "Deque",
      "Queue",
      "Stack",
      "Priority Queue"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "import numpy as np\narr = np.arange(1, 10).reshape(3, 3)\nprint(arr[:, 1])",
    "o": [
      "[2 5 8]",
      "[1 4 7]",
      "[3 6 9]",
      "[1 2 3]"
    ]
  },
  {
    "q": "Which data structure is used to implement DFS (Depth First Search)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Heap"
    ]
  },
  {
    "q": "Which of the following statements is true about a binary heap?",
    "c": null,
    "o": [
      "It is a complete binary tree",
      "It is always a balanced binary search tree",
      "It allows O(1) access to the maximum element in a min-heap",
      "It maintains sorted order at all times"
    ]
  },
  {
    "q": "Which of the following is the default behavior of `heapq` in Python?",
    "c": null,
    "o": [
      "Implements a min-heap",
      "Implements a max-heap",
      "Implements a balanced BST",
      "Implements a priority queue with priorities"
    ]
  },
  {
    "q": "Which of the following data structures can dynamically resize and still provide O(1) amortized insert at the end?",
    "c": null,
    "o": [
      "Python list",
      "Linked list",
      "Array from array module",
      "Tuple"
    ]
  },
  {
    "q": "Which of the following is NOT a valid application of hash tables?",
    "c": null,
    "o": [
      "Maintaining sorted data",
      "Caching/memoization",
      "Counting frequency of elements",
      "Implementing dictionaries"
    ]
  },
  {
    "q": "What does this NumPy code output?",
    "c": "import numpy as np\narr = np.array([[10, 20], [30, 40]])\nprint(arr.mean())",
    "o": [
      "25.0",
      "30.0",
      "20.0",
      "[25]"
    ]
  },
  {
    "q": "Which of the following tree structures is optimized for string/prefix search?",
    "c": null,
    "o": [
      "Trie",
      "AVL Tree",
      "Heap",
      "Binary Tree"
    ]
  },
  {
    "q": "Which of the following data structures provides O(1) time for insertion, deletion, and lookup in average case?",
    "c": null,
    "o": [
      "Hash Table",
      "Queue",
      "Array",
      "Stack"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "stack = []\nstack.append(1)\nstack.append(2)\nstack.pop()\nprint(stack)",
    "o": [
      "[1]",
      "[2]",
      "[]",
      "[1, 2]"
    ]
  },
  {
    "q": "Which of the following traversal orders results in postfix notation for an expression tree?",
    "c": null,
    "o": [
      "Postorder",
      "Inorder",
      "Preorder",
      "Level-order"
    ]
  },
  {
    "q": "What is the key characteristic of a circular queue?",
    "c": null,
    "o": [
      "The rear and front can wrap around to the beginning of the array",
      "It only allows even numbers",
      "It is implemented using a stack",
      "It does not allow empty slots"
    ]
  },
  {
    "q": "Which of the following Python modules provides a thread-safe priority queue?",
    "c": null,
    "o": [
      "queue.PriorityQueue",
      "heapq",
      "collections",
      "array"
    ]
  },
  {
    "q": "Which graph representation allows fast enumeration of all neighbors of a node?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Edge List",
      "Incidence Matrix"
    ]
  },
  {
    "q": "What is the result of this NumPy operation?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr.sum(axis=0))",
    "o": [
      "[4 6]",
      "[3 4]",
      "[1 2 3 4]",
      "10"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "from array import array\na = array('i', [10, 20, 30])\na.append(40)\nprint(a[3])",
    "o": [
      "40",
      "30",
      "10",
      "20"
    ]
  },
  {
    "q": "Which of these best describes a doubly linked list?",
    "c": null,
    "o": [
      "A list where each node has a reference to both previous and next nodes",
      "A list where nodes are linked in one direction only",
      "A circular list with one tail pointer",
      "A stack with two heads"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following describes a complete binary tree?",
    "c": null,
    "o": [
      "All levels except possibly the last are completely filled",
      "All nodes have exactly two children",
      "Each node contains data in sorted order",
      "Each level has an odd number of nodes"
    ]
  },
  {
    "q": "Which graph traversal algorithm visits all vertices reachable from a source vertex using a stack (explicit or implicit)?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What is the output of this NumPy code?",
    "c": "import numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(arr[1][1])",
    "o": [
      "4",
      "2",
      "3",
      "1"
    ]
  },
  {
    "q": "Which of the following is not a basic operation supported by a priority queue?",
    "c": null,
    "o": [
      "Find median",
      "Insert an element",
      "Remove highest priority element",
      "Peek highest priority element"
    ]
  },
  {
    "q": "Which method would you use to get the keys from a Python dictionary?",
    "c": null,
    "o": [
      "keys()",
      "values()",
      "items()",
      "get()"
    ]
  },
  {
    "q": "What is the default axis used by NumPy’s `sum()` function on a 2D array?",
    "c": null,
    "o": [
      "Flattened (axis=None)",
      "Columns (axis=0)",
      "Rows (axis=1)",
      "No operation performed"
    ]
  },
  {
    "q": "Which of the following is true for a min-heap?",
    "c": null,
    "o": [
      "The root node has the smallest value",
      "The leaf nodes have the smallest values",
      "All levels are fully filled",
      "It is always sorted in level order"
    ]
  },
  {
    "q": "Which of the following would be most appropriate for implementing an autocomplete feature?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Deque",
      "Graph"
    ]
  },
  {
    "q": "What does the `pop()` method do in a Python list?",
    "c": null,
    "o": [
      "Removes and returns the last element",
      "Returns the first element without removing it",
      "Deletes the list",
      "Clears all elements"
    ]
  },
  {
    "q": "Which of the following is the correct way to represent a directed graph in Python?",
    "c": null,
    "o": [
      "Dictionary of lists with directed edges",
      "Set of unordered pairs",
      "Tuple of nodes",
      "Heap-based priority structure"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "from collections import deque\nd = deque([1, 2, 3])\nd.appendleft(0)\nprint(list(d))",
    "o": [
      "[0, 1, 2, 3]",
      "[1, 2, 3, 0]",
      "[3, 2, 1, 0]",
      "[0, 3, 2, 1]"
    ]
  },
  {
    "q": "What is the average time complexity of inserting an element into a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the result of this NumPy code?",
    "c": "import numpy as np\narr = np.array([1, 2, 3])\nprint(arr * 2)",
    "o": [
      "[2 4 6]",
      "[1 2 3 1 2 3]",
      "[1 2 3 2]",
      "Error"
    ]
  },
  {
    "q": "What is the key difference between a singly linked list and a doubly linked list?",
    "c": null,
    "o": [
      "Doubly linked list stores references to both previous and next nodes",
      "Singly linked list uses arrays internally",
      "Singly linked list supports faster traversal",
      "Doubly linked list does not support insertion"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "import numpy as np\narr = np.array([1, 2, 3, 4])\nprint(arr[::-1])",
    "o": [
      "[4 3 2 1]",
      "[1 2 3 4]",
      "[2 3 4 1]",
      "[1 3 2 4]"
    ]
  },
  {
    "q": "Which traversal of a binary search tree gives the nodes in ascending order?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following is NOT an application of stacks?",
    "c": null,
    "o": [
      "Finding shortest path in graph",
      "Undo feature in text editors",
      "Expression evaluation",
      "Backtracking algorithms"
    ]
  },
  {
    "q": "Which of the following data structures is best for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Deque"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "from heapq import heappush, heappop\nheap = []\nheappush(heap, 5)\nheappush(heap, 2)\nheappush(heap, 7)\nprint(heappop(heap))",
    "o": [
      "2",
      "5",
      "7",
      "[2, 5, 7]"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element by index in a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "d = {'a': 1, 'b': 2}\nd.update({'c': 3})\nprint(d['c'])",
    "o": [
      "3",
      "2",
      "1",
      "KeyError"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of a graph?",
    "c": null,
    "o": [
      "Every node must be connected to all others",
      "It may be directed or undirected",
      "It can contain cycles",
      "It is made up of vertices and edges"
    ]
  },
  {
    "q": "What is the purpose of the `heapify()` function from the `heapq` module?",
    "c": null,
    "o": [
      "To convert a list into a valid heap in-place",
      "To pop the smallest element",
      "To delete all elements",
      "To sort the heap"
    ]
  },
  {
    "q": "Which of the following is true about the `insert()` method in a Python list?",
    "c": null,
    "o": [
      "It inserts an element at a specific position",
      "It removes an element",
      "It appends at the end",
      "It only works on sorted lists"
    ]
  },
  {
    "q": "Which of these data structures allows efficient LRU (Least Recently Used) cache implementation?",
    "c": null,
    "o": [
      "OrderedDict + HashMap",
      "Heap + Queue",
      "List + Set",
      "Stack + Graph"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "import numpy as np\narr = np.array([[5, 10], [15, 20]])\nprint(arr.max(axis=1))",
    "o": [
      "[10 20]",
      "[20 15]",
      "[5 15]",
      "[10 15]"
    ]
  },
  {
    "q": "Which of the following data structures uses hashing?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Deque",
      "Array"
    ]
  },
  {
    "q": "Which traversal order of a binary tree visits the root node before its children?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following structures allows constant-time insertion and deletion at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "List"
    ]
  },
  {
    "q": "Which of the following structures is most suitable to store hierarchical data like a file system?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "Hash Table",
      "Queue"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "import numpy as np\nx = np.array([[1, 2], [3, 4]])\nprint(x.shape)",
    "o": [
      "(2, 2)",
      "(4,)",
      "2",
      "[2, 2]"
    ]
  },
  {
    "q": "What is the key characteristic of a stack?",
    "c": null,
    "o": [
      "Last In First Out (LIFO)",
      "First In First Out (FIFO)",
      "Sorted Order",
      "Random Access"
    ]
  },
  {
    "q": "Which of the following operations is costly in a singly linked list?",
    "c": null,
    "o": [
      "Deletion from the end",
      "Insertion at the head",
      "Traversal from the head",
      "Accessing the first node"
    ]
  },
  {
    "q": "What is the main advantage of using a heap for implementing a priority queue?",
    "c": null,
    "o": [
      "Efficient access to the highest (or lowest) priority element",
      "Sorted traversal of elements",
      "Constant time lookup",
      "Support for graph algorithms"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "d = {'apple': 3, 'banana': 5}\nd['apple'] += 2\nprint(d['apple'])",
    "o": [
      "5",
      "3",
      "2",
      "0"
    ]
  },
  {
    "q": "Which data structure is used in the implementation of a breadth-first search?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Deque",
      "Set"
    ]
  },
  {
    "q": "Which NumPy function is used to get the number of dimensions of an array?",
    "c": null,
    "o": [
      "ndim",
      "shape",
      "size",
      "rank"
    ]
  },
  {
    "q": "What is the time complexity of deleting an element from a min-heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these best describes how a hash table handles key collisions?",
    "c": null,
    "o": [
      "By using chaining or probing",
      "By removing duplicates",
      "By overwriting the existing key",
      "By storing all values in a list"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "import numpy as np\na = np.array([10, 20, 30, 40])\nprint(a[:2])",
    "o": [
      "[10 20]",
      "[30 40]",
      "[10 20 30]",
      "[20 30]"
    ]
  },
  {
    "q": "Which of the following describes a circular queue?",
    "c": null,
    "o": [
      "Queue where rear connects back to front to reuse space",
      "Queue that allows only one element",
      "Queue that reverses input",
      "Queue where elements are sorted automatically"
    ]
  },
  {
    "q": "Which graph representation takes O(V^2) space?",
    "c": null,
    "o": [
      "Adjacency matrix",
      "Adjacency list",
      "Edge list",
      "Set of sets"
    ]
  },
  {
    "q": "Which data structure maintains insertion order and allows key-based access?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "List",
      "Deque"
    ]
  },
  {
    "q": "Which of the following operations is fastest on a Python set?",
    "c": null,
    "o": [
      "Membership test",
      "Sorting",
      "Indexing",
      "Popping element by index"
    ]
  },
  {
    "q": "Which of the following traversal algorithms is best suited for finding the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Inorder Traversal",
      "Postorder Traversal"
    ]
  },
  {
    "q": "Which Python module provides an efficient way to create arrays of a specified type?",
    "c": null,
    "o": [
      "array",
      "list",
      "collections",
      "numpy"
    ]
  },
  {
    "q": "In NumPy, what is the primary advantage of using a NumPy array over a standard Python list for numerical operations?",
    "c": null,
    "o": [
      "Better performance and memory efficiency for large datasets",
      "Supports diverse data types within a single array",
      "Easier to append and insert elements",
      "Automatically handles multi-dimensional data without explicit reshaping"
    ]
  },
  {
    "q": "What principle does a Stack follow?",
    "c": null,
    "o": [
      "LIFO (Last-In, First-Out)",
      "FIFO (First-In, First-Out)",
      "LILO (Last-In, Last-Out)",
      "FILO (First-In, Last-Out)"
    ]
  },
  {
    "q": "Which operation is used to add an element to the top of a stack?",
    "c": null,
    "o": [
      "push",
      "pop",
      "peek",
      "enqueue"
    ]
  },
  {
    "q": "What principle does a Queue follow?",
    "c": null,
    "o": [
      "FIFO (First-In, First-Out)",
      "LIFO (Last-In, First-Out)",
      "LILO (Last-In, Last-Out)",
      "FILO (First-In, Last-Out)"
    ]
  },
  {
    "q": "Which Python collection type is optimized for fast appends and pops from both ends, making it suitable for implementing a deque (double-ended queue)?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "tuple",
      "array.array"
    ]
  },
  {
    "q": "Which type of linked list allows traversal in both forward and backward directions?",
    "c": null,
    "o": [
      "Doubly Linked List",
      "Singly Linked List",
      "Circular Linked List",
      "Skip List"
    ]
  },
  {
    "q": "In a singly linked list, what information does each node typically store?",
    "c": null,
    "o": [
      "Data and a pointer to the next node",
      "Data and a pointer to the previous node",
      "Data only",
      "Data and pointers to both next and previous nodes"
    ]
  },
  {
    "q": "What is the maximum number of children a node can have in a Binary Tree?",
    "c": null,
    "o": [
      "2",
      "1",
      "3",
      "Any number"
    ]
  },
  {
    "q": "Which tree traversal visits the root node in between the left and right subtrees?",
    "c": null,
    "o": [
      "Inorder traversal",
      "Preorder traversal",
      "Postorder traversal",
      "Breadth-first traversal"
    ]
  },
  {
    "q": "Which data structure is typically used to represent a graph in terms of its connections?",
    "c": null,
    "o": [
      "Adjacency List or Adjacency Matrix",
      "Linked List",
      "Array",
      "Hash Table"
    ]
  },
  {
    "q": "Which graph traversal algorithm explores as far as possible along each branch before backtracking?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "In a Max-Heap, what is always true about the value of a parent node compared to its children?",
    "c": null,
    "o": [
      "It is greater than or equal to its children",
      "It is less than or equal to its children",
      "It is always equal to its children",
      "There is no specific relationship"
    ]
  },
  {
    "q": "Which Python module provides an implementation of the heap queue algorithm?",
    "c": null,
    "o": [
      "heapq",
      "collections",
      "queue",
      "math"
    ]
  },
  {
    "q": "What is the primary purpose of a hash function in a hash table?",
    "c": null,
    "o": [
      "To map keys to array indices",
      "To sort the data",
      "To resolve collisions",
      "To store values directly"
    ]
  },
  {
    "q": "Which of the following is a common method for handling collisions in a hash table?",
    "c": null,
    "o": [
      "Separate Chaining",
      "Binary Search",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following is typically a fixed-size data structure in Python, provided by a specific module for efficient storage of homogeneous data?",
    "c": null,
    "o": [
      "array.array",
      "list",
      "tuple",
      "set"
    ]
  },
  {
    "q": "What is the primary characteristic of a NumPy array that makes it highly efficient for numerical operations compared to Python lists?",
    "c": null,
    "o": [
      "Homogeneous data type and C-based implementation",
      "Dynamic sizing and heterogeneous data types",
      "Built-in sorting capabilities",
      "Automatic memory management for all data types"
    ]
  },
  {
    "q": "Which application commonly uses a Stack data structure?",
    "c": null,
    "o": [
      "Function call management in programming languages",
      "Printer spooling",
      "CPU scheduling",
      "Network routing"
    ]
  },
  {
    "q": "What is the operation called to remove an element from a Stack?",
    "c": null,
    "o": [
      "pop",
      "push",
      "peek",
      "dequeue"
    ]
  },
  {
    "q": "In a Priority Queue, what determines the order in which elements are dequeued?",
    "c": null,
    "o": [
      "Their assigned priority",
      "Their arrival time (FIFO)",
      "Their last insertion time (LIFO)",
      "Their memory address"
    ]
  },
  {
    "q": "Which data structure is often used to implement a Priority Queue efficiently?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Linked List",
      "Array"
    ]
  },
  {
    "q": "What is the time complexity for inserting a node at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "If you need to frequently add and remove elements from both ends of a list, which data structure would be most efficient?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "tuple",
      "array.array"
    ]
  },
  {
    "q": "In a Binary Search Tree (BST), what property holds true for all nodes in the left subtree of a given node?",
    "c": null,
    "o": [
      "Their values are less than the node's value",
      "Their values are greater than the node's value",
      "Their values are equal to the node's value",
      "Their values are arbitrary"
    ]
  },
  {
    "q": "Which tree traversal strategy typically visits all nodes at one level before moving to the next level?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Preorder traversal",
      "Inorder traversal"
    ]
  },
  {
    "q": "What is a 'cycle' in the context of a graph?",
    "c": null,
    "o": [
      "A path that starts and ends at the same vertex",
      "A connection between two vertices",
      "A vertex with no outgoing edges",
      "A graph with no vertices"
    ]
  },
  {
    "q": "Which algorithm is commonly used to find the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "What is the primary operation in a Min-Heap?",
    "c": null,
    "o": [
      "Extracting the minimum element",
      "Extracting the maximum element",
      "Sorting all elements",
      "Searching for a specific element"
    ]
  },
  {
    "q": "Given a list `[3, 1, 4, 1, 5, 9, 2, 6]`, if you apply `heapq.heapify()`, what will be the smallest element accessible?",
    "c": "\nimport heapq\nmy_list = [3, 1, 4, 1, 5, 9, 2, 6]\nheapq.heapify(my_list)\nprint(my_list[0])\n",
    "o": [
      "1",
      "2",
      "3",
      "4"
    ]
  },
  {
    "q": "What is a 'collision' in a hash table?",
    "c": null,
    "o": [
      "When two different keys map to the same index",
      "When the hash table runs out of memory",
      "When a key is not found",
      "When the hash function is too slow"
    ]
  },
  {
    "q": "Which collision resolution technique involves finding the next available empty slot in the hash table?",
    "c": null,
    "o": [
      "Linear Probing (Open Addressing)",
      "Separate Chaining",
      "Quadratic Hashing",
      "Double Hashing"
    ]
  },
  {
    "q": "Which of the following is true about Python's built-in `list` compared to `array.array`?",
    "c": null,
    "o": [
      "Lists can store heterogeneous data types, while `array.array` stores homogeneous types.",
      "Lists are more memory-efficient than `array.array` for large numerical datasets.",
      "`array.array` offers more flexible sizing than lists.",
      "Lists provide faster arithmetic operations than `array.array`."
    ]
  },
  {
    "q": "What is the primary benefit of using vectorized operations with NumPy arrays?",
    "c": null,
    "o": [
      "Significant performance improvement due to underlying C implementations.",
      "Automatic type conversion for all operations.",
      "Reduced memory consumption for string manipulation.",
      "Simplified debugging of complex numerical algorithms."
    ]
  },
  {
    "q": "Consider a scenario where you need to check if parentheses in a mathematical expression are balanced. Which data structure is most suitable for this task?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "What happens if you try to `pop` an element from an empty stack?",
    "c": null,
    "o": [
      "An error (e.g., `IndexError` or custom empty stack exception) is raised.",
      "It returns `None`.",
      "The stack remains unchanged.",
      "It returns the last element added to the stack."
    ]
  },
  {
    "q": "A Circular Queue is an improvement over a simple linear queue because it:",
    "c": null,
    "o": [
      "Utilizes space more efficiently by reusing dequeued slots.",
      "Allows for elements to be inserted at any position.",
      "Can store elements of different data types.",
      "Provides faster searching capabilities."
    ]
  },
  {
    "q": "If you are implementing a 'producer-consumer' problem, where one process adds items and another removes them, which data structure is most appropriate?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Linked List",
      "Tree"
    ]
  },
  {
    "q": "Which operation in a doubly linked list is generally more efficient than in a singly linked list?",
    "c": null,
    "o": [
      "Deleting a node given its reference (not its value).",
      "Traversing from the head to a specific node.",
      "Inserting a node at the beginning.",
      "Searching for a specific value."
    ]
  },
  {
    "q": "What is a potential disadvantage of using a Linked List compared to an Array for data storage?",
    "c": null,
    "o": [
      "Random access to elements is slower.",
      "Insertion and deletion are always slower.",
      "Requires more memory per element.",
      "Cannot store heterogeneous data types."
    ]
  },
  {
    "q": "Which type of tree is optimized for quick searching, insertion, and deletion of elements while maintaining a sorted order?",
    "c": null,
    "o": [
      "Binary Search Tree (BST)",
      "Complete Binary Tree",
      "Full Binary Tree",
      "Skewed Tree"
    ]
  },
  {
    "q": "What is the order of nodes visited during a Preorder traversal of a binary tree?",
    "c": null,
    "o": [
      "Root, Left, Right",
      "Left, Root, Right",
      "Left, Right, Root",
      "Right, Left, Root"
    ]
  },
  {
    "q": "When representing a graph using an Adjacency Matrix, what does a value of '1' (or a non-zero value) at `matrix[i][j]` typically signify?",
    "c": null,
    "o": [
      "There is an edge from vertex `i` to vertex `j`.",
      "Vertex `i` and vertex `j` are the same.",
      "Vertex `i` is isolated.",
      "The graph is disconnected."
    ]
  },
  {
    "q": "Which algorithm is suitable for finding the shortest path in a weighted graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Floyd-Warshall Algorithm (for all-pairs shortest paths)"
    ]
  },
  {
    "q": "After inserting elements into a Min-Heap, where would the smallest element be located?",
    "c": null,
    "o": [
      "At the root of the heap.",
      "At the last leaf node.",
      "Randomly anywhere in the heap.",
      "Only after a sorting operation."
    ]
  },
  {
    "q": "Which `heapq` function is used to add an element to a heap?",
    "c": null,
    "o": [
      "heapq.heappush()",
      "heapq.heappop()",
      "heapq.heapify()",
      "heapq.nlargest()"
    ]
  },
  {
    "q": "What is the ideal average-case time complexity for searching, insertion, and deletion in a well-designed hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "If a hash table uses Open Addressing with Linear Probing and experiences many collisions, what is a common problem that can arise?",
    "c": null,
    "o": [
      "Clustering (primary clustering)",
      "Memory leaks",
      "Infinite loops",
      "Incorrect hash values"
    ]
  },
  {
    "q": "Which of the following scenarios would most benefit from using `array.array` over a standard Python list?",
    "c": null,
    "o": [
      "Storing a large collection of integers for mathematical computations.",
      "Storing a mix of strings, integers, and custom objects.",
      "Creating a flexible data structure for frequent insertions and deletions at arbitrary positions.",
      "Representing a graph with complex node relationships."
    ]
  },
  {
    "q": "What is the primary purpose of broadcasting in NumPy?",
    "c": null,
    "o": [
      "To perform operations on arrays of different shapes without explicit looping.",
      "To convert arrays to different data types.",
      "To save arrays to disk in a compressed format.",
      "To randomly shuffle the elements within an array."
    ]
  },
  {
    "q": "A common application of a Queue is:",
    "c": null,
    "o": [
      "Managing tasks in a printer spooler.",
      "Implementing an 'undo' functionality in a text editor.",
      "Checking for balanced parentheses in an expression.",
      "Representing hierarchical data."
    ]
  },
  {
    "q": "If you are using a Python `list` to implement a Stack, which method is typically used to add an element?",
    "c": null,
    "o": [
      "append()",
      "insert(0, element)",
      "pop()",
      "remove()"
    ]
  },
  {
    "q": "When would a Circular Queue be particularly useful?",
    "c": null,
    "o": [
      "When you have a fixed-size buffer where elements are continuously added and removed.",
      "When the order of elements doesn't matter.",
      "When you need to access elements by an index.",
      "When dealing with an unknown number of elements."
    ]
  },
  {
    "q": "Consider a system where requests arrive and need to be processed based on their urgency. Which type of queue would be most suitable?",
    "c": null,
    "o": [
      "Priority Queue",
      "FIFO Queue",
      "LIFO Queue",
      "Deque"
    ]
  },
  {
    "q": "What is a major drawback of a singly linked list for certain operations compared to an array?",
    "c": null,
    "o": [
      "Accessing an element by its index takes O(n) time.",
      "Inserting an element at the beginning takes O(n) time.",
      "Deleting the head node takes O(n) time.",
      "Requires more memory due to contiguous storage."
    ]
  },
  {
    "q": "If you need to implement a Least Recently Used (LRU) cache, which data structure combination is often used for efficient operations?",
    "c": null,
    "o": [
      "Doubly Linked List and Hash Table",
      "Singly Linked List and Stack",
      "Array and Queue",
      "Binary Search Tree and Heap"
    ]
  },
  {
    "q": "What is the maximum number of nodes at level 'k' in a perfect binary tree?",
    "c": null,
    "o": [
      "$2^k$",
      "$k$",
      "$k^2$",
      "$2k$"
    ]
  },
  {
    "q": "Which traversal algorithm for a Binary Search Tree (BST) will output the elements in sorted order?",
    "c": null,
    "o": [
      "Inorder traversal",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What does a 'weighted' graph imply?",
    "c": null,
    "o": [
      "Edges have associated numerical values (weights).",
      "Vertices have associated numerical values.",
      "It contains cycles.",
      "It is always a directed graph."
    ]
  },
  {
    "q": "If you want to find all reachable nodes from a starting node in an unweighted graph, which algorithm is generally preferred?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "In Python's `heapq` module, how is a min-heap typically represented?",
    "c": null,
    "o": [
      "As a standard Python list where heap properties are maintained.",
      "As a custom heap object.",
      "As a linked list of nodes.",
      "As a dictionary mapping keys to priorities."
    ]
  },
  {
    "q": "What is the time complexity to insert an element into a heap with 'n' elements?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary drawback of a poorly chosen hash function?",
    "c": null,
    "o": [
      "Increased collisions, leading to degraded performance.",
      "Higher memory consumption for the hash table.",
      "Inability to store certain data types.",
      "Requires more complex collision resolution techniques."
    ]
  },
  {
    "q": "Which collision resolution technique in hash tables involves storing colliding elements in a linked list at the same array index?",
    "c": null,
    "o": [
      "Separate Chaining",
      "Linear Probing",
      "Quadratic Probing",
      "Double Hashing"
    ]
  },
  {
    "q": "Which NumPy function is commonly used to create an array filled with zeros?",
    "c": null,
    "o": [
      "np.zeros()",
      "np.empty()",
      "np.ones()",
      "np.array([])"
    ]
  },
  {
    "q": "What is the result of multiplying two NumPy arrays element-wise?",
    "c": "\nimport numpy as np\na = np.array([1, 2])\nb = np.array([3, 4])\nprint(a * b)\n",
    "o": [
      "[3 8]",
      "[4 6]",
      "[3 4]",
      "Error"
    ]
  },
  {
    "q": "Which operation typically has a time complexity of O(1) for a Stack implemented with a dynamic array (like Python's list)?",
    "c": null,
    "o": [
      "Push (amortized average)",
      "Searching for an element",
      "Inserting in the middle",
      "Deleting from the bottom"
    ]
  },
  {
    "q": "If you use a list in Python to implement a Queue, which method combination would be most efficient for `enqueue` and `dequeue` operations?",
    "c": null,
    "o": [
      "append() and pop(0)",
      "insert(0, element) and pop()",
      "append() and pop()",
      "extend() and remove()"
    ]
  },
  {
    "q": "What is the primary advantage of a Doubly Linked List over a Singly Linked List?",
    "c": null,
    "o": [
      "Ability to traverse backward.",
      "Less memory consumption per node.",
      "Faster search operations.",
      "Easier implementation."
    ]
  },
  {
    "q": "In a Linked List, what is a 'node' composed of?",
    "c": null,
    "o": [
      "Data and a pointer/reference to the next node (and possibly previous).",
      "Only the data.",
      "An index and the data.",
      "Only a pointer to the next node."
    ]
  },
  {
    "q": "What is a 'leaf node' in a tree?",
    "c": null,
    "o": [
      "A node with no children.",
      "The root node.",
      "A node with exactly one child.",
      "Any node that is not the root."
    ]
  },
  {
    "q": "When would a Complete Binary Tree be particularly useful?",
    "c": null,
    "o": [
      "For efficient array-based implementations of data structures like heaps.",
      "When strict sorting is required for all elements.",
      "For representing hierarchical file systems.",
      "When frequent rebalancing is necessary."
    ]
  },
  {
    "q": "What is the time complexity of adding an edge to an Adjacency Matrix representation of a graph with V vertices?",
    "c": null,
    "o": [
      "O(1)",
      "O(V)",
      "O(V^2)",
      "O(E)"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue to explore vertices layer by layer?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "Which `heapq` function can be used to efficiently get the 'k' largest elements from a list?",
    "c": null,
    "o": [
      "heapq.nlargest()",
      "heapq.nsmallest()",
      "heapq.heapify()",
      "list.sort()"
    ]
  },
  {
    "q": "What is the time complexity to extract the minimum element from a Min-Heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "If a hash function consistently maps different keys to the same few indices, what is the consequence?",
    "c": null,
    "o": [
      "Increased collisions and performance degradation.",
      "Improved memory usage efficiency.",
      "Guaranteed constant-time operations.",
      "Automatic data compression."
    ]
  },
  {
    "q": "Why is it generally not recommended to use `dict.keys()` or `dict.values()` directly for a very large number of lookups if you need to perform calculations on them?",
    "c": null,
    "o": [
      "They return view objects, not copies, which means they can change if the dictionary changes during iteration. For repeated access, conversion to a list or similar structure might be better if the dictionary is mutable.",
      "They create new copies of the keys/values every time they are called.",
      "They are always sorted, which adds overhead.",
      "They are not iterable."
    ]
  },
  {
    "q": "Which NumPy function is used to concatenate arrays along a specified axis?",
    "c": null,
    "o": [
      "np.concatenate()",
      "np.stack()",
      "np.append()",
      "np.join()"
    ]
  },
  {
    "q": "What is the key difference between `np.array([1, 2, 3])` and `np.array([[1], [2], [3]])` in terms of dimensions?",
    "c": null,
    "o": [
      "The first is 1D, the second is 2D.",
      "The first is 2D, the second is 1D.",
      "Both are 1D but with different data types.",
      "Both are 2D but with different shapes."
    ]
  },
  {
    "q": "Which of the following is a common application of a stack in compilers?",
    "c": null,
    "o": [
      "Syntax parsing (e.g., evaluating expressions, checking balanced parentheses).",
      "Managing function call arguments.",
      "Optimizing memory allocation.",
      "Handling I/O operations."
    ]
  },
  {
    "q": "If you have a limited-size buffer for incoming data where the oldest data is removed when new data arrives, which type of queue is most suitable?",
    "c": null,
    "o": [
      "Circular Queue",
      "Priority Queue",
      "Deque",
      "Regular FIFO Queue (if not handling overflow)"
    ]
  },
  {
    "q": "What is a major advantage of Linked Lists over Arrays when dealing with frequent insertions and deletions in the middle of the data structure?",
    "c": null,
    "o": [
      "No shifting of elements is required.",
      "Elements are stored contiguously in memory.",
      "Random access to elements is faster.",
      "Less memory overhead per element."
    ]
  },
  {
    "q": "What is a 'sentinel node' sometimes used for in Linked Lists?",
    "c": null,
    "o": [
      "To simplify boundary conditions (e.g., empty list, adding to head/tail).",
      "To mark the end of the list.",
      "To store special metadata about the list.",
      "To improve search performance."
    ]
  },
  {
    "q": "In a Binary Search Tree, what is the time complexity for searching for a specific element in the worst-case scenario (e.g., a skewed tree)?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What distinguishes a 'full binary tree' from a 'complete binary tree'?",
    "c": null,
    "o": [
      "A full binary tree has every node with 0 or 2 children, while a complete binary tree fills levels from left to right.",
      "A full binary tree is always balanced, while a complete binary tree is not.",
      "A full binary tree has all leaf nodes at the same level.",
      "There is no distinction; they are the same."
    ]
  },
  {
    "q": "When would using an Adjacency List be more memory-efficient than an Adjacency Matrix for graph representation?",
    "c": null,
    "o": [
      "For sparse graphs (graphs with few edges).",
      "For dense graphs (graphs with many edges).",
      "When the graph is always complete.",
      "When vertex labels are numerical."
    ]
  },
  {
    "q": "Which algorithm can be used to detect a cycle in a directed graph?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "If you need to retrieve the smallest item multiple times efficiently from a collection of changing data, which data structure is ideal?",
    "c": null,
    "o": [
      "Min-Heap",
      "Sorted List",
      "Hash Table",
      "Stack"
    ]
  },
  {
    "q": "Consider a list `data = [5, 2, 8, 1, 9]`. If you call `heapq.nsmallest(2, data)`, what will be the output?",
    "c": "\nimport heapq\ndata = [5, 2, 8, 1, 9]\nprint(heapq.nsmallest(2, data))\n",
    "o": [
      "[1, 2]",
      "[9, 8]",
      "[2, 5]",
      "[1, 5]"
    ]
  },
  {
    "q": "What is the worst-case time complexity for searching in a hash table if all keys hash to the same index (due to a bad hash function or extreme collisions)?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is 'load factor' in the context of hash tables?",
    "c": null,
    "o": [
      "The ratio of the number of items stored to the size of the hash table's underlying array.",
      "The average number of collisions per insertion.",
      "The maximum number of items a hash table can store.",
      "The time taken to rehash the table."
    ]
  },
  {
    "q": "Which NumPy attribute gives the dimensions of an array as a tuple?",
    "c": null,
    "o": [
      "shape",
      "size",
      "ndim",
      "dtype"
    ]
  },
  {
    "q": "What is the primary advantage of using Python's `collections.deque` over a `list` for implementing queues and deques?",
    "c": null,
    "o": [
      "O(1) time complexity for appends and pops from both ends.",
      "Lower memory usage for large collections.",
      "Built-in sorting capabilities.",
      "Supports direct mathematical operations like NumPy arrays."
    ]
  },
  {
    "q": "In a scenario requiring frequent additions and removals from both ends, like a work stealing deque in parallel programming, which data structure is most appropriate?",
    "c": null,
    "o": [
      "collections.deque",
      "list (as a stack)",
      "list (as a queue)",
      "priority queue"
    ]
  },
  {
    "q": "What is the time complexity for deleting a node from the middle of a singly linked list if you are given a pointer to the *previous* node?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is a 'head node' in a linked list?",
    "c": null,
    "o": [
      "The first node in the list.",
      "The node with the smallest value.",
      "The node that points to nothing.",
      "A node that stores metadata about the list."
    ]
  },
  {
    "q": "Which property defines a Binary Search Tree?",
    "c": null,
    "o": [
      "For every node, all values in its left subtree are less than its value, and all values in its right subtree are greater.",
      "Every node has exactly two children.",
      "All leaf nodes are at the same level.",
      "The tree is always perfectly balanced."
    ]
  },
  {
    "q": "What is the primary characteristic of a 'balanced' binary tree?",
    "c": null,
    "o": [
      "The heights of the left and right subtrees of any node differ by at most a small constant (e.g., 1).",
      "All nodes have the same number of children.",
      "All elements are perfectly sorted.",
      "It has a fixed depth."
    ]
  },
  {
    "q": "When would an Adjacency Matrix be preferred over an Adjacency List for graph representation?",
    "c": null,
    "o": [
      "For dense graphs, where the number of edges is close to the maximum possible.",
      "For sparse graphs, to save memory.",
      "When the graph has many disconnected components.",
      "When frequent additions and deletions of vertices are expected."
    ]
  },
  {
    "q": "What is the purpose of 'topological sort' in graph theory?",
    "c": null,
    "o": [
      "To produce a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge (u, v), vertex u comes before v in the ordering.",
      "To find the shortest path between two vertices.",
      "To detect cycles in a graph.",
      "To find the minimum spanning tree."
    ]
  },
  {
    "q": "Which `heapq` function allows you to push an item onto the heap and then pop the smallest item efficiently in a single operation?",
    "c": null,
    "o": [
      "heapq.heappushpop()",
      "heapq.heapreplace()",
      "heapq.merge()",
      "heapq.nsmallest()"
    ]
  },
  {
    "q": "What is the main property maintained in a Max-Heap?",
    "c": null,
    "o": [
      "The value of each node is greater than or equal to the values of its children.",
      "The value of each node is less than or equal to the values of its children.",
      "All elements are sorted in ascending order.",
      "The heap always remains perfectly balanced."
    ]
  },
  {
    "q": "In Python's dictionary implementation (which uses hash tables), what mechanism is used to handle collisions?",
    "c": null,
    "o": [
      "Open Addressing (specifically, a form of probing)",
      "Separate Chaining",
      "Linear search through the entire dictionary",
      "Binary search on hash values"
    ]
  },
  {
    "q": "What is a 'good' hash function characterized by?",
    "c": null,
    "o": [
      "Minimizing collisions and distributing keys uniformly.",
      "Being computationally expensive.",
      "Always returning unique indices.",
      "Sorting the input keys before hashing."
    ]
  },
  {
    "q": "Which method is used to reshape a NumPy array without changing its data?",
    "c": null,
    "o": [
      ".reshape()",
      ".resize()",
      ".transpose()",
      ".flatten()"
    ]
  },
  {
    "q": "What is the result of applying `np.sum()` to a 2D NumPy array without specifying an axis?",
    "c": "\nimport numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(np.sum(arr))\n",
    "o": [
      "10",
      "[4 6]",
      "[[1 2]\n [3 4]]",
      "Error"
    ]
  },
  {
    "q": "In a web browser, which data structure is commonly used to implement the 'back' and 'forward' navigation functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "When using a Python list as a Stack, what is the time complexity of the `pop()` operation?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "If you need to process tasks in the exact order they were received, with no priority involved, which data structure should you use?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Deque"
    ]
  },
  {
    "q": "What is the time complexity for inserting an element at the end of a singly linked list if you only have a pointer to the head?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary advantage of a Circular Linked List over a traditional singly or doubly linked list in certain applications?",
    "c": null,
    "o": [
      "It can be traversed indefinitely without a `None` pointer, useful for cyclic data.",
      "It requires less memory per node.",
      "It provides faster random access.",
      "It inherently supports priority-based operations."
    ]
  },
  {
    "q": "Which tree traversal strategy would typically be used to make a copy of a tree, or to evaluate an expression tree?",
    "c": null,
    "o": [
      "Preorder traversal",
      "Inorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is the definition of a 'root' node in a tree data structure?",
    "c": null,
    "o": [
      "The topmost node, which has no parent.",
      "A node with no children.",
      "Any node that is not a leaf.",
      "A node that acts as a sentinel."
    ]
  },
  {
    "q": "In an Adjacency List representation of a graph, how are edges typically stored?",
    "c": null,
    "o": [
      "Each vertex has a list of its adjacent vertices.",
      "As a 2D array of 0s and 1s.",
      "As a set of tuples (vertex1, vertex2).",
      "In a separate hash table."
    ]
  },
  {
    "q": "What type of graph always has edges with a specific direction?",
    "c": null,
    "o": [
      "Directed Graph",
      "Undirected Graph",
      "Weighted Graph",
      "Cyclic Graph"
    ]
  },
  {
    "q": "If you want to merge multiple sorted streams of data into a single sorted stream, which data structure or module is particularly helpful?",
    "c": null,
    "o": [
      "heapq.merge()",
      "list.sort()",
      "collections.deque",
      "dict.items()"
    ]
  },
  {
    "q": "What is the purpose of 'heapifying' a list in Python using `heapq.heapify()`?",
    "c": null,
    "o": [
      "To transform a regular list into a heap in-place.",
      "To sort the list in ascending order.",
      "To remove duplicate elements from the list.",
      "To convert the list into a dictionary."
    ]
  },
  {
    "q": "What is the term for the process of recalculating hash values and reorganizing the hash table when the load factor becomes too high?",
    "c": null,
    "o": [
      "Rehashing",
      "Collision Resolution",
      "Hashing",
      "Probing"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a symbol table in a compiler, where efficient key-value lookups are crucial?",
    "c": null,
    "o": [
      "Hash Table",
      "Linked List",
      "Array",
      "Binary Tree"
    ]
  },
  {
    "q": "Which NumPy function is used to create an array with a specified range of numbers?",
    "c": null,
    "o": [
      "np.arange()",
      "np.linspace()",
      "np.range()",
      "np.sequence()"
    ]
  },
  {
    "q": "What is the primary difference between `arr.flatten()` and `arr.ravel()` for NumPy arrays?",
    "c": null,
    "o": [
      "flatten() always returns a copy, ravel() returns a view if possible.",
      "ravel() always returns a copy, flatten() returns a view if possible.",
      "flatten() is only for 1D arrays, ravel() is for any dimension.",
      "There is no functional difference."
    ]
  },
  {
    "q": "Which of the following is NOT a common application of a Stack?",
    "c": null,
    "o": [
      "CPU job scheduling",
      "Undo/Redo functionality in applications",
      "Recursion management",
      "Expression evaluation (infix to postfix/prefix)"
    ]
  },
  {
    "q": "If you implement a Queue using a Python list and primarily use `append()` for enqueue and `pop(0)` for dequeue, what is the major performance drawback?",
    "c": null,
    "o": [
      "`pop(0)` is O(n) as it requires shifting all subsequent elements.",
      "`append()` is O(n) due to potential reallocations.",
      "Both operations are O(log n).",
      "Memory fragmentation becomes a significant issue."
    ]
  },
  {
    "q": "What is a 'tail node' in a linked list?",
    "c": null,
    "o": [
      "The last node in the list.",
      "The node that precedes the head.",
      "A node with no data.",
      "A node used for internal management only."
    ]
  },
  {
    "q": "What is a 'self-referential structure' in the context of linked lists?",
    "c": null,
    "o": [
      "Each node contains a pointer/reference to another node of the same type.",
      "The list always points back to itself.",
      "Nodes store copies of themselves.",
      "The list can only contain one type of data."
    ]
  },
  {
    "q": "In a Binary Search Tree (BST), where would a newly inserted node typically be placed?",
    "c": null,
    "o": [
      "As a leaf node, maintaining the BST property.",
      "At the root of the tree.",
      "Randomly anywhere in the tree.",
      "In the middle of the tree to balance it."
    ]
  },
  {
    "q": "What does a 'perfect binary tree' imply about its structure?",
    "c": null,
    "o": [
      "All internal nodes have two children and all leaf nodes are at the same level.",
      "All nodes have only one child.",
      "It is always skewed to one side.",
      "It has no specific structure requirements."
    ]
  },
  {
    "q": "What is the primary advantage of using an Adjacency List for representing sparse graphs?",
    "c": null,
    "o": [
      "Less memory consumption compared to an Adjacency Matrix.",
      "Faster checking for existence of an edge between two specific vertices.",
      "Simpler implementation for unweighted graphs.",
      "Direct representation of all possible edges."
    ]
  },
  {
    "q": "What is an 'undirected graph'?",
    "c": null,
    "o": [
      "A graph where edges have no specific direction (connections are bidirectional).",
      "A graph where all edges point away from the source.",
      "A graph with no cycles.",
      "A graph that cannot be traversed."
    ]
  },
  {
    "q": "If you need to retrieve the 'k' largest items from a very large dataset without sorting the entire dataset, which approach involving heaps is most efficient?",
    "c": null,
    "o": [
      "Maintain a min-heap of size 'k'.",
      "Maintain a max-heap of size 'k'.",
      "Sort the entire dataset and pick the top 'k'.",
      "Use a priority queue of unlimited size."
    ]
  },
  {
    "q": "When would `heapq.heapreplace(heap, item)` be preferred over `heapq.heappop(heap)` followed by `heapq.heappush(heap, item)`?",
    "c": null,
    "o": [
      "When you want to replace the smallest item with a new item while maintaining heap property, often more efficient.",
      "When you need to perform two distinct operations.",
      "When the heap is empty.",
      "When the item being replaced is guaranteed to be the largest."
    ]
  },
  {
    "q": "What is the concept of 'uniform distribution' in the context of hash functions?",
    "c": null,
    "o": [
      "The hash function should distribute keys evenly across the hash table's indices to minimize collisions.",
      "All keys must have the same length.",
      "The hash table should always be full.",
      "The hash function should be easy to compute."
    ]
  },
  {
    "q": "In a hash table using 'linear probing' for collision resolution, what happens if a collision occurs at an index?",
    "c": null,
    "o": [
      "The algorithm checks the next available slot sequentially until an empty one is found.",
      "A linked list is started at that index to store colliding elements.",
      "The element is discarded.",
      "The hash table is immediately rehashed."
    ]
  },
  {
    "q": "Which NumPy function is used to add a new axis to an array?",
    "c": null,
    "o": [
      "np.newaxis",
      "np.expand_dims()",
      "np.add_axis()",
      "np.insert_axis()"
    ]
  },
  {
    "q": "What is the result of the following NumPy operation?",
    "c": "\nimport numpy as np\narr = np.array([1, 2, 3])\nprint(arr + 5)\n",
    "o": [
      "[ 6  7  8]",
      "[1 2 3 5]",
      "Error",
      "[5 5 5]"
    ]
  },
  {
    "q": "Which data structure is typically used to perform a 'depth-first' traversal of a tree or graph?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Table"
    ]
  },
  {
    "q": "What is the time complexity of pushing an element onto a Stack implemented with a Python list if the list needs to reallocate memory?",
    "c": null,
    "o": [
      "Amortized O(1), but worst-case O(n)",
      "Always O(1)",
      "Always O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "When is a `collections.deque` generally preferred over a standard Python list?",
    "c": null,
    "o": [
      "When frequent insertions or deletions are needed at both ends.",
      "When random access by index is the primary operation.",
      "When the data needs to be sorted frequently.",
      "When minimizing memory usage for numerical data."
    ]
  },
  {
    "q": "In a singly linked list, how do you typically access the last element?",
    "c": null,
    "o": [
      "By traversing from the head until the `next` pointer is `None`.",
      "By direct index access (e.g., `list[length - 1]`).",
      "By using a `tail` pointer (if maintained).",
      "By a binary search approach."
    ]
  },
  {
    "q": "What is the primary characteristic of a 'root' node in a tree?",
    "c": null,
    "o": [
      "It has no parent.",
      "It has no children.",
      "It is always the smallest value in the tree.",
      "It is always the largest value in the tree."
    ]
  },
  {
    "q": "Which tree traversal strategy visits all nodes at one level before moving to the next, often used for shortest path in unweighted graphs?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Preorder traversal",
      "Inorder traversal"
    ]
  },
  {
    "q": "What is the typical time complexity for checking if an edge exists between two vertices in an Adjacency Matrix representation?",
    "c": null,
    "o": [
      "O(1)",
      "O(V)",
      "O(E)",
      "O(V + E)"
    ]
  },
  {
    "q": "Which type of graph can have multiple edges between the same pair of vertices or self-loops?",
    "c": null,
    "o": [
      "Multigraph",
      "Simple Graph",
      "Complete Graph",
      "Directed Acyclic Graph"
    ]
  },
  {
    "q": "Which data structure is fundamentally used to implement a Priority Queue efficiently?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Standard Queue",
      "Linked List"
    ]
  },
  {
    "q": "When using `heapq.nlargest(k, iterable)`, what kind of heap is internally built or simulated to find the largest elements?",
    "c": null,
    "o": [
      "A min-heap of size k.",
      "A max-heap of size k.",
      "A binary search tree.",
      "A regular sorted list."
    ]
  },
  {
    "q": "What is the potential issue if a hash table's load factor becomes too high?",
    "c": null,
    "o": [
      "Increased average time complexity for operations due to more collisions.",
      "Decreased memory usage.",
      "Improved search performance.",
      "The hash table automatically sorts itself."
    ]
  },
  {
    "q": "Which collision resolution technique involves re-hashing with a second hash function?",
    "c": null,
    "o": [
      "Double Hashing",
      "Linear Probing",
      "Quadratic Probing",
      "Separate Chaining"
    ]
  },
  {
    "q": "Which NumPy function is used to concatenate arrays along a new axis, often increasing the dimension of the resulting array?",
    "c": null,
    "o": [
      "np.stack()",
      "np.concatenate()",
      "np.vstack()",
      "np.hstack()"
    ]
  },
  {
    "q": "What does the `ndim` attribute of a NumPy array represent?",
    "c": null,
    "o": [
      "The number of dimensions (axes) of the array.",
      "The total number of elements in the array.",
      "The data type of the elements.",
      "The shape of the array as a tuple."
    ]
  },
  {
    "q": "In a recursion, what data structure is implicitly used by the system to manage function calls and their local variables?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Table"
    ]
  },
  {
    "q": "What is the primary reason that `collections.deque` is generally more efficient than a `list` for queue-like operations (i.e., `append` and `pop(0)`)?",
    "c": null,
    "o": [
      "It doesn't require shifting elements when removing from the beginning.",
      "It pre-allocates a much larger contiguous block of memory.",
      "It uses a hash table internally for faster lookups.",
      "It is implemented in pure Python, making it more flexible."
    ]
  },
  {
    "q": "What is a 'dummy node' (or sentinel node) sometimes used for in linked list implementations?",
    "c": null,
    "o": [
      "To simplify edge cases like an empty list or operations at the beginning/end.",
      "To store extra data not related to the main list elements.",
      "To mark the list as read-only.",
      "To improve search efficiency by creating shortcuts."
    ]
  },
  {
    "q": "If you have a pointer to a node in a singly linked list and want to delete that node, but you *don't* have a pointer to its previous node, what is typically required?",
    "c": null,
    "o": [
      "You must traverse from the head to find the previous node.",
      "The operation cannot be performed.",
      "You can directly delete it in O(1) time.",
      "You need to convert it to a doubly linked list first."
    ]
  },
  {
    "q": "What type of binary tree has the property that for every node, the height of its left and right subtrees differ by at most 1?",
    "c": null,
    "o": [
      "Balanced Binary Tree (e.g., AVL tree, Red-Black tree)",
      "Complete Binary Tree",
      "Full Binary Tree",
      "Degenerate Binary Tree"
    ]
  },
  {
    "q": "Which tree traversal strategy ensures that all children of a node are visited before the node itself, often used for deleting a tree?",
    "c": null,
    "o": [
      "Postorder traversal",
      "Preorder traversal",
      "Inorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "In graph theory, what does 'degree' of a vertex refer to in an undirected graph?",
    "c": null,
    "o": [
      "The number of edges incident to the vertex.",
      "The number of paths from that vertex to others.",
      "The weight of the vertex.",
      "Its position in the graph."
    ]
  },
  {
    "q": "Which graph algorithm is used to find a Minimum Spanning Tree (MST) in a weighted, undirected graph?",
    "c": null,
    "o": [
      "Prim's Algorithm or Kruskal's Algorithm",
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "q": "What is the primary characteristic of a Min-Heap data structure?",
    "c": null,
    "o": [
      "The smallest element is always at the root.",
      "The largest element is always at the root.",
      "Elements are stored in sorted order.",
      "It only contains distinct elements."
    ]
  },
  {
    "q": "If you use `heapq.heappop(my_heap)`, which element is guaranteed to be returned?",
    "c": "\nimport heapq\nmy_heap = [1, 5, 2, 8]\nheapq.heapify(my_heap)\n# After heapify: my_heap could be [1, 5, 2, 8] or [1, 8, 2, 5], depends on implementation details.\n# The important thing is that the smallest element is at index 0.\n# Let's assume it's [1, 5, 2, 8] for clarity before pop\nprint(heapq.heappop(my_heap))\n",
    "o": [
      "The smallest element in the heap.",
      "The largest element in the heap.",
      "The last element added to the heap.",
      "A randomly chosen element."
    ]
  },
  {
    "q": "What is the main purpose of collision resolution techniques in hash tables?",
    "c": null,
    "o": [
      "To handle situations where two different keys hash to the same index.",
      "To improve the performance of the hash function itself.",
      "To prevent the hash table from overflowing.",
      "To ensure that all keys are unique."
    ]
  },
  {
    "q": "Which type of probing for collision resolution in open addressing can help mitigate 'primary clustering'?",
    "c": null,
    "o": [
      "Quadratic Probing",
      "Linear Probing",
      "Separate Chaining",
      "Direct Addressing"
    ]
  },
  {
    "q": "Which NumPy function is used to compute the element-wise square root of an array?",
    "c": null,
    "o": [
      "np.sqrt()",
      "np.power(arr, 0.5)",
      "np.square_root()",
      "np.root()"
    ]
  },
  {
    "q": "What is the primary characteristic of an 'in-place' operation on a NumPy array?",
    "c": null,
    "o": [
      "It modifies the array directly without creating a new copy.",
      "It always creates a new array with the results.",
      "It changes the data type of the array.",
      "It requires less memory than non-in-place operations."
    ]
  },
  {
    "q": "Which data structure is best suited for evaluating postfix expressions?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Binary Tree",
      "Hash Table"
    ]
  },
  {
    "q": "If you are implementing a system that manages a fixed number of recent history entries, and old entries are automatically discarded when new ones arrive, which data structure is most efficient?",
    "c": null,
    "o": [
      "collections.deque with `maxlen`",
      "list (as a stack)",
      "list (as a queue)",
      "priority queue"
    ]
  },
  {
    "q": "What is a 'doubly linked list'?",
    "c": null,
    "o": [
      "A linked list where each node has pointers to both the next and previous nodes.",
      "A linked list where each node has two data fields.",
      "A linked list that can only be traversed in one direction.",
      "A linked list that connects back to itself forming a circle."
    ]
  },
  {
    "q": "What is the time complexity for inserting a node after a given node in a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the 'height' of a tree?",
    "c": null,
    "o": [
      "The length of the longest path from the root to a leaf node.",
      "The number of nodes in the tree.",
      "The number of levels in the tree.",
      "The sum of all node values."
    ]
  },
  {
    "q": "What is the primary advantage of a Binary Search Tree (BST) over a sorted array for search operations?",
    "c": null,
    "o": [
      "More efficient insertions and deletions while maintaining sorted order (on average).",
      "Guaranteed O(1) search time.",
      "Less memory consumption.",
      "Simpler implementation."
    ]
  },
  {
    "q": "What does a 'directed acyclic graph' (DAG) guarantee?",
    "c": null,
    "o": [
      "It has no cycles.",
      "All vertices have an even degree.",
      "All edges are undirected.",
      "It is always a complete graph."
    ]
  },
  {
    "q": "Which graph representation is more suitable when you need to quickly find all neighbors of a specific vertex?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Incidence Matrix",
      "Edge List"
    ]
  },
  {
    "q": "Which `heapq` function can be used to efficiently get the 'k' smallest elements from an iterable?",
    "c": null,
    "o": [
      "heapq.nsmallest()",
      "heapq.nlargest()",
      "heapq.heapify()",
      "list.sort()"
    ]
  },
  {
    "q": "What is the primary purpose of a 'heap sort' algorithm?",
    "c": null,
    "o": [
      "To sort an array efficiently by building a heap.",
      "To search for an element in a heap.",
      "To merge two heaps.",
      "To balance a heap."
    ]
  },
  {
    "q": "When does 'secondary clustering' occur in hash tables?",
    "c": null,
    "o": [
      "When different keys that hash to the same initial slot follow the same probe sequence.",
      "When all keys hash to the same slot.",
      "When the hash table is too small.",
      "When separate chaining is used."
    ]
  },
  {
    "q": "What is the approximate time complexity for searching for a key in a Python dictionary (hash table) in the average case?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which NumPy function is used to concatenate arrays horizontally (column-wise)?",
    "c": null,
    "o": [
      "np.hstack()",
      "np.vstack()",
      "np.concatenate()",
      "np.stack()"
    ]
  },
  {
    "q": "What is the key advantage of NumPy's `ndarray` over Python's built-in `list` for numerical data processing?",
    "c": null,
    "o": [
      "Memory efficiency and faster execution for large arrays due to C implementation and contiguous storage.",
      "Support for heterogeneous data types within a single array.",
      "Dynamic resizing capabilities without performance penalties.",
      "Automatic parallel processing without explicit configuration."
    ]
  },
  {
    "q": "Which data structure is essential for implementing a compiler's runtime stack to manage local variables and function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "What is the purpose of the `peek` (or `top`) operation in a Stack?",
    "c": null,
    "o": [
      "To view the top element without removing it.",
      "To remove the top element.",
      "To add an element to the top.",
      "To check if the stack is empty."
    ]
  },
  {
    "q": "In a producer-consumer problem with a fixed-size buffer, what typically happens when the buffer is full and a producer tries to add an item?",
    "c": null,
    "o": [
      "The producer waits until space becomes available (blocking operation).",
      "The oldest item is automatically removed to make space.",
      "An error is immediately raised.",
      "The new item is discarded."
    ]
  },
  {
    "q": "What is a major advantage of a Doubly Linked List for implementing certain operations, such as deletion of a specific node given only its reference (not its value)?",
    "c": null,
    "o": [
      "It can directly access the previous node in O(1) time.",
      "It uses less memory than a singly linked list.",
      "It provides faster random access to elements.",
      "It simplifies the search operation."
    ]
  },
  {
    "q": "When is a 'circular linked list' particularly useful?",
    "c": null,
    "o": [
      "For managing shared resources in a round-robin fashion or continuous looping through data.",
      "For implementing a LIFO data structure.",
      "For efficient random access to elements.",
      "For storing data that needs to be sorted frequently."
    ]
  },
  {
    "q": "In a Binary Search Tree, what is the expected average-case time complexity for search, insertion, and deletion operations?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is an 'ancestor' of a node in a tree?",
    "c": null,
    "o": [
      "Any node on the path from the root to that node, excluding the node itself.",
      "Any node below that node in the tree.",
      "Only the parent node.",
      "Any node in the same subtree."
    ]
  },
  {
    "q": "Which graph traversal algorithm is best suited for finding the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra's Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "What does 'connected components' refer to in an undirected graph?",
    "c": null,
    "o": [
      "Subgraphs in which any two vertices are connected to each other by paths, and which are connected to no additional vertices in the supergraph.",
      "Vertices that have a high degree.",
      "The edges that form a cycle.",
      "The set of all possible paths in the graph."
    ]
  },
  {
    "q": "What is the time complexity to build a heap from an unsorted array of 'n' elements using `heapq.heapify()`?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which `heapq` function is typically used in an algorithm like Dijkstra's to efficiently get the next shortest path candidate?",
    "c": null,
    "o": [
      "heapq.heappop()",
      "heapq.heappush()",
      "heapq.nlargest()",
      "heapq.heapify()"
    ]
  },
  {
    "q": "What is a 'hash collision'?",
    "c": null,
    "o": [
      "When a hash function produces the same output (hash value) for two different input keys.",
      "When a hash table runs out of memory.",
      "When a key is not found in the hash table.",
      "When the hash table is being resized."
    ]
  },
  {
    "q": "What is the main idea behind 'separate chaining' as a collision resolution technique in hash tables?",
    "c": null,
    "o": [
      "Each slot in the hash table array points to a linked list (or other data structure) of elements that hash to that slot.",
      "If a collision occurs, the algorithm probes for the next available empty slot in the table.",
      "A second hash function is used to find an alternative slot.",
      "The colliding elements overwrite existing elements."
    ]
  },
  {
    "q": "Which NumPy function is used to compute the dot product of two arrays?",
    "c": null,
    "o": [
      "np.dot()",
      "np.multiply()",
      "np.product()",
      "np.matmul()"
    ]
  },
  {
    "q": "What is the result of using boolean indexing on a NumPy array?",
    "c": "\nimport numpy as np\narr = np.array([10, 20, 30, 40])\nmask = arr > 25\nprint(arr[mask])\n",
    "o": [
      "[30 40]",
      "[False False True True]",
      "[10 20]",
      "Error"
    ]
  },
  {
    "q": "Which property of a Stack makes it suitable for managing function calls in a program?",
    "c": null,
    "o": [
      "LIFO (Last-In, First-Out) ensures the most recently called function is executed first.",
      "FIFO (First-In, First-Out) ensures functions are processed in call order.",
      "Its ability to store heterogeneous data types.",
      "Its efficient random access capabilities."
    ]
  },
  {
    "q": "What is the typical time complexity for dequeuing an element from a `collections.deque`?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary way to determine if a singly linked list is empty?",
    "c": null,
    "o": [
      "Check if the head pointer is `None`.",
      "Check if the size counter is zero (if maintained).",
      "Check if the tail pointer is `None`.",
      "Attempt to traverse and catch an error."
    ]
  },
  {
    "q": "If you need to iterate through a linked list from the end to the beginning efficiently, which type of linked list is required?",
    "c": null,
    "o": [
      "Doubly Linked List",
      "Singly Linked List",
      "Circular Linked List",
      "Skip List"
    ]
  },
  {
    "q": "In a Binary Search Tree (BST), what is the time complexity for finding the minimum element?",
    "c": null,
    "o": [
      "O(h) where h is the height of the tree (worst-case O(n)).",
      "O(1)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "What is a 'child node' in a tree?",
    "c": null,
    "o": [
      "A node directly connected to and below another node (its parent).",
      "Any node that is not the root.",
      "A leaf node.",
      "A node with multiple parents."
    ]
  },
  {
    "q": "What is an 'edge' in a graph?",
    "c": null,
    "o": [
      "A connection between two vertices.",
      "A vertex with no connections.",
      "A path that forms a loop.",
      "A property of the graph itself."
    ]
  },
  {
    "q": "Which graph algorithm is used to find the shortest paths from a single source vertex to all other vertices in a weighted graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "What is the primary operation of a Priority Queue?",
    "c": null,
    "o": [
      "Retrieving and removing the element with the highest (or lowest) priority.",
      "Retrieving elements in FIFO order.",
      "Retrieving elements in LIFO order.",
      "Sorting all elements in the queue."
    ]
  },
  {
    "q": "Which `heapq` function is used to push a new item onto the heap while maintaining the heap property?",
    "c": null,
    "o": [
      "heapq.heappush()",
      "heapq.heappop()",
      "heapq.heapify()",
      "heapq.nlargest()"
    ]
  },
  {
    "q": "What happens in a hash table if the load factor gets too high and rehashing occurs?",
    "c": null,
    "o": [
      "A new, larger underlying array is allocated, and all existing items are re-inserted using the hash function.",
      "The old array is simply extended in place.",
      "The hash function is changed.",
      "All duplicate keys are removed."
    ]
  },
  {
    "q": "In a hash table, what is the role of the 'modulo operator' (%) in a simple hash function?",
    "c": null,
    "o": [
      "To map the hash value to a valid index within the bounds of the array size.",
      "To ensure the hash value is always positive.",
      "To prevent collisions.",
      "To make the hash function more complex."
    ]
  },
  {
    "q": "Which NumPy function is used to vertically stack arrays (row-wise)?",
    "c": null,
    "o": [
      "np.vstack()",
      "np.hstack()",
      "np.concatenate()",
      "np.column_stack()"
    ]
  },
  {
    "q": "What is the primary function of `numpy.linspace(start, stop, num)`?",
    "c": null,
    "o": [
      "To generate evenly spaced numbers over a specified interval.",
      "To generate random numbers within a range.",
      "To create an array filled with zeros.",
      "To compute the linear regression of data points."
    ]
  },
  {
    "q": "What is a 'stack overflow' error?",
    "c": null,
    "o": [
      "An error that occurs when a program tries to use more space on the call stack than is available.",
      "An error in a web server stack.",
      "An error when too many items are pushed onto a data stack.",
      "An error related to memory allocation on the heap."
    ]
  },
  {
    "q": "Which method on Python's `collections.deque` is used to remove an element from the right (tail) end?",
    "c": null,
    "o": [
      "pop()",
      "popleft()",
      "remove()",
      "dequeue()"
    ]
  },
  {
    "q": "In a Doubly Linked List, if you have a pointer to a node, what is the time complexity to insert a new node *before* it?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the main characteristic that differentiates a 'circular linked list' from a 'linear linked list'?",
    "c": null,
    "o": [
      "The last node points back to the first node, forming a circle.",
      "It can only store numerical data.",
      "It is always sorted.",
      "It has a fixed size."
    ]
  },
  {
    "q": "Which property indicates that a binary tree is a 'complete binary tree'?",
    "c": null,
    "o": [
      "All levels are completely filled except possibly the last level, which is filled from left to right.",
      "Every node has either zero or two children.",
      "All leaf nodes are at the same depth.",
      "The tree is perfectly balanced."
    ]
  },
  {
    "q": "Which traversal method is most appropriate for processing hierarchical data where the parent needs to be processed before its children?",
    "c": null,
    "o": [
      "Preorder traversal",
      "Inorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is the purpose of 'depth-first search' (DFS) in graphs?",
    "c": null,
    "o": [
      "To explore as far as possible along each branch before backtracking.",
      "To find the shortest path in an unweighted graph.",
      "To find all shortest paths from a single source.",
      "To find a minimum spanning tree."
    ]
  },
  {
    "q": "In a directed graph, what is the 'in-degree' of a vertex?",
    "c": null,
    "o": [
      "The number of edges pointing *to* the vertex.",
      "The number of edges pointing *from* the vertex.",
      "The total number of edges connected to the vertex.",
      "The number of paths that pass through the vertex."
    ]
  },
  {
    "q": "Which data structure is typically used to implement a 'min-priority queue' in Python using the standard library?",
    "c": null,
    "o": [
      "heapq module (using a list as the underlying heap)",
      "collections.deque",
      "list.sort()",
      "dict"
    ]
  },
  {
    "q": "What is the time complexity for removing the largest element from a Max-Heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which factor directly impacts the performance of a hash table in terms of average-case time complexity?",
    "c": null,
    "o": [
      "The quality of the hash function and the load factor.",
      "The number of times elements are inserted.",
      "The physical memory available.",
      "The data type of the keys."
    ]
  },
  {
    "q": "If you need to store key-value pairs where keys must be unique and lookups need to be very fast, which data structure is most appropriate?",
    "c": null,
    "o": [
      "Hash Table (e.g., Python's `dict`)",
      "Sorted List",
      "Linked List",
      "Binary Search Tree (if ordering and range queries are also critical)"
    ]
  },
  {
    "q": "Which NumPy function is used to get the unique elements of an array?",
    "c": null,
    "o": [
      "np.unique()",
      "np.distinct()",
      "np.unique_elements()",
      "np.filter_duplicates()"
    ]
  },
  {
    "q": "What is 'broadcasting' in NumPy?",
    "c": null,
    "o": [
      "A mechanism that allows NumPy to perform operations on arrays of different shapes.",
      "A way to send NumPy arrays over a network.",
      "A method for parallelizing array computations.",
      "A technique for converting arrays to different data types."
    ]
  },
  {
    "q": "What is the primary operation of a 'pop' operation on a Stack?",
    "c": null,
    "o": [
      "Removes and returns the topmost element.",
      "Adds an element to the top.",
      "Returns the topmost element without removing it.",
      "Removes an element from the bottom."
    ]
  },
  {
    "q": "What is the primary characteristic of a FIFO (First-In, First-Out) data structure?",
    "c": null,
    "o": [
      "The first element added is the first one to be removed.",
      "The last element added is the first one to be removed.",
      "Elements are removed based on priority.",
      "Elements can be accessed randomly."
    ]
  },
  {
    "q": "What is the typical time complexity for searching for a specific value in an unsorted singly linked list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the main benefit of maintaining a 'tail pointer' in a singly linked list?",
    "c": null,
    "o": [
      "Allows O(1) time complexity for appending elements to the end of the list.",
      "Enables backward traversal.",
      "Improves search efficiency.",
      "Reduces memory consumption."
    ]
  },
  {
    "q": "In a Binary Search Tree (BST), if you traverse the tree using an inorder traversal, what property will the output have?",
    "c": null,
    "o": [
      "The elements will be in sorted order.",
      "The elements will be in reverse sorted order.",
      "The elements will be in the order of insertion.",
      "The elements will be randomly ordered."
    ]
  },
  {
    "q": "What is the 'depth' of a node in a tree?",
    "c": null,
    "o": [
      "The length of the path from the root to that node.",
      "The number of children the node has.",
      "The total number of nodes in its subtree.",
      "The height of the subtree rooted at that node."
    ]
  },
  {
    "q": "What is a 'vertex' in graph theory?",
    "c": null,
    "o": [
      "A fundamental unit (or node) in a graph.",
      "A connection between two nodes.",
      "A path that forms a loop.",
      "The weight of an edge."
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a stack (explicitly or implicitly via recursion) to explore as far as possible along each branch?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "What is the `heapq` module primarily designed for in Python?",
    "c": null,
    "o": [
      "Implementing min-heaps (priority queues).",
      "Implementing max-heaps directly.",
      "Sorting large lists efficiently.",
      "Searching for elements in a list."
    ]
  },
  {
    "q": "In a Min-Heap, if you insert a new element, what operation is performed to restore the heap property?",
    "c": null,
    "o": [
      "Heapify-up (or sift-up) operation.",
      "Heapify-down (or sift-down) operation.",
      "Rebuilding the entire heap.",
      "Sorting the heap."
    ]
  },
  {
    "q": "What is the worst-case time complexity for inserting an element into a Python dictionary (hash table)?",
    "c": null,
    "o": [
      "O(n) (due to potential rehashing and poor collision handling)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of using separate chaining for collision resolution in hash tables?",
    "c": null,
    "o": [
      "Requires extra memory for pointers/linked list nodes.",
      "Can suffer from primary clustering.",
      "Requires open addressing, which is more complex.",
      "Not suitable for dynamic resizing."
    ]
  },
  {
    "q": "Which NumPy function is used to compute the element-wise exponential of an array?",
    "c": null,
    "o": [
      "np.exp()",
      "np.power()",
      "np.log()",
      "np.e_power()"
    ]
  },
  {
    "q": "What is the result of adding two NumPy arrays of the same shape?",
    "c": "\nimport numpy as np\narr1 = np.array([1, 2])\narr2 = np.array([3, 4])\nprint(arr1 + arr2)\n",
    "o": [
      "[4 6]",
      "[1 2 3 4]",
      "7",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a common application of a Queue data structure?",
    "c": null,
    "o": [
      "Operating system process scheduling.",
      "Parsing expressions in a compiler.",
      "Managing undo/redo operations.",
      "Implementing recursive algorithms."
    ]
  },
  {
    "q": "What does the `popleft()` method do on a `collections.deque`?",
    "c": null,
    "o": [
      "Removes and returns an element from the left (front) end.",
      "Removes and returns an element from the right (back) end.",
      "Adds an element to the left end.",
      "Returns the leftmost element without removing it."
    ]
  },
  {
    "q": "What is a 'circular linked list'?",
    "c": null,
    "o": [
      "A linked list where the last node points back to the first node.",
      "A linked list with a fixed number of nodes.",
      "A linked list that can only be traversed in a circular fashion.",
      "A linked list that stores only numerical data."
    ]
  },
  {
    "q": "If you need to represent a sequence of elements where insertions and deletions at both ends are very frequent, which Python data structure is most appropriate?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "tuple",
      "array.array"
    ]
  },
  {
    "q": "What is a 'balanced binary search tree' (e.g., AVL tree, Red-Black tree) designed to prevent?",
    "c": null,
    "o": [
      "Degenerating into a linked list in the worst-case, preserving O(log n) performance.",
      "Overflowing memory.",
      "Collisions during insertion.",
      "Being unable to store duplicate values."
    ]
  },
  {
    "q": "Which tree traversal strategy is often used to find the minimum or maximum element in a Binary Search Tree efficiently?",
    "c": null,
    "o": [
      "Inorder traversal (for sorted order, then pick first/last)",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is a 'path' in a graph?",
    "c": null,
    "o": [
      "A sequence of distinct vertices such that consecutive vertices in the sequence are connected by an edge.",
      "A connection between two vertices.",
      "A vertex with no outgoing edges.",
      "A set of all edges in the graph."
    ]
  },
  {
    "q": "Which graph algorithm can be used to determine if a graph contains a cycle?",
    "c": null,
    "o": [
      "DFS (by detecting back edges) or BFS (for undirected graphs)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "What is the primary characteristic of a 'Max-Heap'?",
    "c": null,
    "o": [
      "The largest element is always at the root.",
      "The smallest element is always at the root.",
      "Elements are stored in sorted order.",
      "It only contains distinct elements."
    ]
  },
  {
    "q": "If you are using `heapq` and want to efficiently replace the smallest element with a new one while maintaining heap property, which function should you use?",
    "c": null,
    "o": [
      "heapq.heapreplace()",
      "heapq.heappop() then heapq.heappush()",
      "heapq.heapify()",
      "heapq.merge()"
    ]
  },
  {
    "q": "What is the main drawback of using 'linear probing' for collision resolution in hash tables if the table becomes very full?",
    "c": null,
    "o": [
      "Primary clustering, leading to long probe sequences.",
      "Increased memory usage due to linked lists.",
      "Difficulty in implementing deletions.",
      "Reduced hash function effectiveness."
    ]
  },
  {
    "q": "What is the purpose of 'rehashing' in a hash table?",
    "c": null,
    "o": [
      "To increase the size of the underlying array and redistribute existing elements to maintain efficiency when the load factor becomes too high.",
      "To resolve individual collisions as they occur.",
      "To sort the elements stored in the hash table.",
      "To convert the hash table to a different data structure."
    ]
  },
  {
    "q": "Which NumPy function is used to concatenate arrays vertically (row-wise)?",
    "c": null,
    "o": [
      "np.vstack()",
      "np.hstack()",
      "np.concatenate()",
      "np.stack()"
    ]
  },
  {
    "q": "What is the key characteristic of NumPy arrays that enables element-wise operations without explicit loops?",
    "c": null,
    "o": [
      "Vectorization",
      "Broadcasting",
      "Indexing",
      "Slicing"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing an 'undo' mechanism in a software application?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "What is the time complexity of pushing an element onto a `collections.deque`?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the main benefit of using a Doubly Linked List over a Singly Linked List?",
    "c": null,
    "o": [
      "Ability to traverse in both forward and backward directions.",
      "Lower memory usage per node.",
      "Faster search for specific elements.",
      "Simplified implementation of basic operations."
    ]
  },
  {
    "q": "What is a 'node' in a linked list?",
    "c": null,
    "o": [
      "A fundamental building block containing data and a reference to the next (and possibly previous) node.",
      "A numerical index pointing to an element.",
      "The entire collection of data.",
      "A function that operates on the list."
    ]
  },
  {
    "q": "Which tree traversal strategy is often used to get all nodes in a Binary Search Tree in sorted order?",
    "c": null,
    "o": [
      "Inorder traversal",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "In a tree data structure, what defines the 'root' node?",
    "c": null,
    "o": [
      "It is the only node with no parent.",
      "It is the node with the highest value.",
      "It is the node with the most children.",
      "It is a leaf node."
    ]
  },
  {
    "q": "What is a 'weighted graph'?",
    "c": null,
    "o": [
      "A graph where each edge has a numerical value (weight) associated with it.",
      "A graph where vertices have numerical values.",
      "A graph that contains cycles.",
      "A graph with only a few edges."
    ]
  },
  {
    "q": "Which graph representation is more efficient in terms of space for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Incidence Matrix",
      "Edge Matrix"
    ]
  },
  {
    "q": "What does the `heapq.heappush(heap, item)` function do?",
    "c": null,
    "o": [
      "Inserts an item into the heap, maintaining the heap property.",
      "Removes the smallest item from the heap.",
      "Sorts the entire heap in place.",
      "Returns the largest item in the heap."
    ]
  },
  {
    "q": "What is the key advantage of a heap over a sorted array for priority queue implementations?",
    "c": null,
    "o": [
      "Logarithmic time complexity for insertion and extraction of the min/max element.",
      "Constant time complexity for all operations.",
      "Lower memory consumption for large datasets.",
      "Simpler implementation."
    ]
  },
  {
    "q": "What is the main goal of a hash function in a hash table?",
    "c": null,
    "o": [
      "To quickly map keys to indices in the underlying array, minimizing collisions.",
      "To store keys in sorted order.",
      "To compress data before storage.",
      "To encrypt data for security."
    ]
  },
  {
    "q": "In 'open addressing' collision resolution, what happens if the initial hash index is occupied?",
    "c": null,
    "o": [
      "The algorithm probes for an alternative empty slot within the same array.",
      "A linked list is created at that index to store the colliding elements.",
      "The element is discarded.",
      "The entire hash table is rehashed."
    ]
  },
  {
    "q": "Which NumPy function is used to transpose an array (swap axes)?",
    "c": null,
    "o": [
      "np.transpose() or .T",
      "np.swapaxes()",
      "np.reshape()",
      "np.flip()"
    ]
  },
  {
    "q": "What is the primary advantage of NumPy's contiguous memory allocation for arrays?",
    "c": null,
    "o": [
      "Enables faster element access and vectorized operations.",
      "Allows for storing heterogeneous data types.",
      "Reduces the overall memory footprint.",
      "Simplifies the debugging process."
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a program's execution call stack?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "When is `collections.deque` particularly efficient?",
    "c": null,
    "o": [
      "When elements are frequently added or removed from both the beginning and the end.",
      "When random access to elements by index is a common operation.",
      "When the data needs to be sorted repeatedly.",
      "When memory footprint is a critical concern for large datasets."
    ]
  },
  {
    "q": "What is the primary difference in memory allocation between an Array and a Linked List?",
    "c": null,
    "o": [
      "Arrays typically use contiguous memory blocks, while linked lists use scattered memory blocks linked by pointers.",
      "Arrays allocate memory dynamically, while linked lists use static allocation.",
      "Arrays require more memory than linked lists for the same number of elements.",
      "Linked lists allocate memory only at compile time."
    ]
  },
  {
    "q": "If a singly linked list has a `head` and `tail` pointer, what is the time complexity to insert a new node at the end of the list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is a 'skewed binary tree'?",
    "c": null,
    "o": [
      "A binary tree where all nodes have only one child, forming a linear structure.",
      "A binary tree that is perfectly balanced.",
      "A binary tree where all leaf nodes are at the same level.",
      "A binary tree with no root node."
    ]
  },
  {
    "q": "Which property of a Binary Search Tree (BST) allows for efficient range queries (finding all elements between two values)?",
    "c": null,
    "o": [
      "The sorted order property during inorder traversal.",
      "Its constant height.",
      "Its fixed number of children per node.",
      "Its ability to store duplicate values."
    ]
  },
  {
    "q": "What is a 'subgraph' in graph theory?",
    "c": null,
    "o": [
      "A graph formed from a subset of the vertices and edges of a larger graph.",
      "A graph that contains a cycle.",
      "A graph with no edges.",
      "A graph that is always connected."
    ]
  },
  {
    "q": "What is the typical time complexity for traversing all vertices and edges in a graph using Breadth-First Search (BFS) or Depth-First Search (DFS) on an Adjacency List?",
    "c": null,
    "o": [
      "O(V + E), where V is vertices and E is edges.",
      "O(V^2)",
      "O(log V)",
      "O(E log V)"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a system where the highest-priority task is always processed next, even if it arrived later?",
    "c": null,
    "o": [
      "Priority Queue (typically implemented with a heap)",
      "FIFO Queue",
      "LIFO Stack",
      "Circular Queue"
    ]
  },
  {
    "q": "In Python's `heapq` module, when you `heappop()` an element, what happens to the element that replaces it at the root?",
    "c": null,
    "o": [
      "The last element in the heap array is moved to the root, then sifted down to maintain the heap property.",
      "The next smallest element automatically becomes the root.",
      "The heap is completely rebuilt.",
      "A random element is chosen to be the new root."
    ]
  },
  {
    "q": "What is a 'perfect hash function'?",
    "c": null,
    "o": [
      "A hash function that maps every distinct key to a unique index, ensuring no collisions.",
      "A hash function that is extremely fast to compute.",
      "A hash function that produces only prime numbers.",
      "A hash function that always returns a value of zero."
    ]
  },
  {
    "q": "Which collision resolution technique involves calculating a new index by adding some step (e.g., 1, 2, 3...) to the original hash index until an empty slot is found?",
    "c": null,
    "o": [
      "Linear Probing (a form of Open Addressing)",
      "Separate Chaining",
      "Quadratic Hashing",
      "Double Hashing"
    ]
  },
  {
    "q": "Which NumPy function is used to concatenate arrays, automatically determining the axis based on the array dimensions?",
    "c": null,
    "o": [
      "np.concatenate()",
      "np.stack()",
      "np.append()",
      "np.join()"
    ]
  },
  {
    "q": "What does the `dtype` attribute of a NumPy array indicate?",
    "c": null,
    "o": [
      "The data type of the elements stored in the array.",
      "The shape of the array.",
      "The number of dimensions.",
      "The total number of bytes the array occupies."
    ]
  },
  {
    "q": "Which data structure would be most appropriate for managing a list of tasks where the most recently added task is the first to be executed?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Linked List"
    ]
  },
  {
    "q": "What is the time complexity of the `appendleft()` operation on a `collections.deque`?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the time complexity for inserting a new node at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary disadvantage of using a Singly Linked List for random access (e.g., getting the element at index `i`)?",
    "c": null,
    "o": [
      "It requires traversing from the beginning, leading to O(n) time complexity.",
      "It consumes more memory per element due to pointers.",
      "It is inefficient for insertions and deletions.",
      "It cannot store heterogeneous data."
    ]
  },
  {
    "q": "In a Binary Search Tree, if a node has two children, how is its inorder successor typically found?",
    "c": null,
    "o": [
      "The leftmost node in its right subtree.",
      "The rightmost node in its left subtree.",
      "Its parent node.",
      "Its right child directly."
    ]
  },
  {
    "q": "What does a 'balanced binary tree' aim to achieve?",
    "c": null,
    "o": [
      "To keep the tree's height as small as possible (logarithmic) to ensure efficient operations.",
      "To ensure all leaf nodes are at the same depth.",
      "To have an equal number of nodes in the left and right subtrees.",
      "To always store elements in a perfectly sorted array."
    ]
  },
  {
    "q": "What is an 'undirected graph'?",
    "c": null,
    "o": [
      "A graph where edges have no specific direction (connections are bidirectional).",
      "A graph where all edges point from a source to a destination.",
      "A graph that contains no cycles.",
      "A graph that is fully connected."
    ]
  },
  {
    "q": "When is an Adjacency Matrix particularly useful for graph representation?",
    "c": null,
    "o": [
      "When the graph is dense (many edges) and quick checks for edge existence are needed.",
      "When the graph is sparse (few edges) to save memory.",
      "When frequent vertex additions and deletions are expected.",
      "When the graph is guaranteed to be acyclic."
    ]
  },
  {
    "q": "Which data structure provides constant-time complexity for finding the minimum element, and logarithmic time for insertion and deletion?",
    "c": null,
    "o": [
      "Min-Heap",
      "Sorted Array",
      "Hash Table",
      "Singly Linked List"
    ]
  },
  {
    "q": "What is the primary use case for the `heapq.merge()` function?",
    "c": null,
    "o": [
      "Merging multiple sorted iterables into a single sorted iterable.",
      "Combining two heaps into one larger heap.",
      "Sorting an unsorted list in-place.",
      "Finding the intersection of two sets."
    ]
  },
  {
    "q": "What is 'clustering' in a hash table?",
    "c": null,
    "o": [
      "A phenomenon where collisions cause items to group together in the hash table, leading to longer probe sequences.",
      "The process of separating colliding elements into different memory locations.",
      "The act of combining multiple hash tables into one.",
      "A measure of how evenly keys are distributed."
    ]
  },
  {
    "q": "Which collision resolution technique is generally more memory-efficient when the hash table is sparse?",
    "c": null,
    "o": [
      "Open Addressing (e.g., linear probing, quadratic probing)",
      "Separate Chaining",
      "Direct Addressing",
      "Cuckoo Hashing"
    ]
  },
  {
    "q": "Which NumPy function is used to apply a custom function element-wise to an array?",
    "c": null,
    "o": [
      "np.vectorize() or looping with a Python function",
      "np.apply()",
      "np.map()",
      "np.custom_func()"
    ]
  },
  {
    "q": "What is the result of multiplying a NumPy array by a scalar?",
    "c": "\nimport numpy as np\narr = np.array([1, 2, 3])\nprint(arr * 2)\n",
    "o": [
      "[2 4 6]",
      "[1 2 3 2]",
      "Error",
      "[1 2 3]"
    ]
  },
  {
    "q": "What is the primary characteristic of a LIFO (Last-In, First-Out) data structure?",
    "c": null,
    "o": [
      "The last element added is the first one to be removed.",
      "The first element added is the first one to be removed.",
      "Elements are removed based on priority.",
      "Elements can be accessed randomly."
    ]
  },
  {
    "q": "Which method on Python's `collections.deque` is used to add an element to the left (front) end?",
    "c": null,
    "o": [
      "appendleft()",
      "append()",
      "insert(0, element)",
      "pushleft()"
    ]
  },
  {
    "q": "What is the main drawback of a singly linked list for deletion of a specific node if you only have a reference to the node itself (not its previous node)?",
    "c": null,
    "o": [
      "It requires traversing the list from the beginning to find the preceding node.",
      "The node cannot be deleted.",
      "It causes memory leaks.",
      "It is always an O(1) operation."
    ]
  },
  {
    "q": "What is a 'tail node' in a linked list and its common purpose?",
    "c": null,
    "o": [
      "The last node in the list, often used to make appends to the end O(1).",
      "The node that acts as a sentinel.",
      "A node that stores metadata about the list.",
      "The node that is always null."
    ]
  },
  {
    "q": "What is the worst-case time complexity for searching in an unbalanced Binary Search Tree?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which tree property states that for every node, the number of nodes in its left subtree and right subtree are roughly equal?",
    "c": null,
    "o": [
      "Balance (e.g., in AVL or Red-Black trees)",
      "Completeness",
      "Fullness",
      "Skewness"
    ]
  },
  {
    "q": "What does a 'directed graph' imply about its edges?",
    "c": null,
    "o": [
      "Edges have a specific direction, from a source vertex to a destination vertex.",
      "Edges have no direction.",
      "Edges have associated weights.",
      "Edges can only connect two distinct vertices."
    ]
  },
  {
    "q": "Which graph algorithm can be used to find the connected components of an undirected graph?",
    "c": null,
    "o": [
      "BFS or DFS",
      "Dijkstra's Algorithm",
      "Prim's Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "What is the time complexity to remove the minimum element from a Min-Heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the output after `heapq.heappush(heap, 0)` on the given heap?",
    "c": "\nimport heapq\nheap = [1, 5, 2, 8]\nheapq.heapify(heap)\n# heap might be [1, 5, 2, 8] or [1, 8, 2, 5] after heapify, but 1 is at index 0\nheapq.heappush(heap, 0)\nprint(heap[0])\n",
    "o": [
      "0",
      "1",
      "2",
      "5"
    ]
  },
  {
    "q": "What is the concept of 'primary clustering' in open addressing hash tables?",
    "c": null,
    "o": [
      "When collisions cause sequences of occupied slots to grow longer, increasing search times.",
      "When different keys hash to the same initial slot.",
      "When separate chaining is used to resolve collisions.",
      "When the hash table is too small to begin with."
    ]
  },
  {
    "q": "In a hash table, what is a 'probe sequence' in the context of open addressing?",
    "c": null,
    "o": [
      "The sequence of slots examined when trying to find an empty slot for insertion or locate an existing key.",
      "The order in which elements are stored in separate chains.",
      "The list of keys that produce collisions.",
      "The steps involved in rehashing the table."
    ]
  },
  {
    "q": "Which NumPy function is used to concatenate arrays, automatically determining the axis based on the array dimensions?",
    "c": null,
    "o": [
      "np.concatenate()",
      "np.stack()",
      "np.append()",
      "np.join()"
    ]
  },
  {
    "q": "What does the `dtype` attribute of a NumPy array indicate?",
    "c": null,
    "o": [
      "The data type of the elements stored in the array.",
      "The shape of the array.",
      "The number of dimensions.",
      "The total number of bytes the array occupies."
    ]
  },
  {
    "q": "Which data structure would be most appropriate for managing a list of tasks where the most recently added task is the first to be executed?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Linked List"
    ]
  },
  {
    "q": "What is the time complexity of the `appendleft()` operation on a `collections.deque`?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the time complexity for inserting a new node at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary disadvantage of using a Singly Linked List for random access (e.g., getting the element at index `i`)?",
    "c": null,
    "o": [
      "It requires traversing from the beginning, leading to O(n) time complexity.",
      "It consumes more memory per element due to pointers.",
      "It is inefficient for insertions and deletions.",
      "It cannot store heterogeneous data."
    ]
  },
  {
    "q": "In a Binary Search Tree, if a node has two children, how is its inorder successor typically found?",
    "c": null,
    "o": [
      "The leftmost node in its right subtree.",
      "The rightmost node in its left subtree.",
      "Its parent node.",
      "Its right child directly."
    ]
  },
  {
    "q": "What does a 'balanced binary tree' aim to achieve?",
    "c": null,
    "o": [
      "To keep the tree's height as small as possible (logarithmic) to ensure efficient operations.",
      "To ensure all leaf nodes are at the same depth.",
      "To have an equal number of nodes in the left and right subtrees.",
      "To always store elements in a perfectly sorted array."
    ]
  },
  {
    "q": "What is an 'undirected graph'?",
    "c": null,
    "o": [
      "A graph where edges have no specific direction (connections are bidirectional).",
      "A graph where all edges point from a source to a destination.",
      "A graph that contains no cycles.",
      "A graph that is fully connected."
    ]
  },
  {
    "q": "When is an Adjacency Matrix particularly useful for graph representation?",
    "c": null,
    "o": [
      "When the graph is dense (many edges) and quick checks for edge existence are needed.",
      "When the graph is sparse (few edges) to save memory.",
      "When frequent vertex additions and deletions are expected.",
      "When the graph is guaranteed to be acyclic."
    ]
  },
  {
    "q": "Which data structure provides constant-time complexity for finding the minimum element, and logarithmic time for insertion and deletion?",
    "c": null,
    "o": [
      "Min-Heap",
      "Sorted Array",
      "Hash Table",
      "Singly Linked List"
    ]
  },
  {
    "q": "What is the primary use case for the `heapq.merge()` function?",
    "c": null,
    "o": [
      "Merging multiple sorted iterables into a single sorted iterable.",
      "Combining two heaps into one larger heap.",
      "Sorting an unsorted list in-place.",
      "Finding the intersection of two sets."
    ]
  },
  {
    "q": "What is 'clustering' in a hash table?",
    "c": null,
    "o": [
      "A phenomenon where collisions cause items to group together in the hash table, leading to longer probe sequences.",
      "The process of separating colliding elements into different memory locations.",
      "The act of combining multiple hash tables into one.",
      "A measure of how evenly keys are distributed."
    ]
  },
  {
    "q": "Which collision resolution technique is generally more memory-efficient when the hash table is sparse?",
    "c": null,
    "o": [
      "Open Addressing (e.g., linear probing, quadratic probing)",
      "Separate Chaining",
      "Direct Addressing",
      "Cuckoo Hashing"
    ]
  },
  {
    "q": "Which NumPy function is used to compute the element-wise absolute value of an array?",
    "c": null,
    "o": [
      "np.abs()",
      "np.absolute()",
      "np.positive()",
      "np.magnitude()"
    ]
  },
  {
    "q": "What is the primary way to create an identity matrix (a square matrix with ones on the main diagonal and zeros elsewhere) using NumPy?",
    "c": null,
    "o": [
      "np.eye(n)",
      "np.identity(n)",
      "np.zeros((n,n)) with diagonal ones",
      "np.ones((n,n)) - 1"
    ]
  },
  {
    "q": "Which of the following is a key characteristic of an Abstract Data Type (ADT) like a Stack or Queue?",
    "c": null,
    "o": [
      "It defines the logical behavior and operations, independent of implementation details.",
      "It specifies the exact memory layout of the data.",
      "It dictates the programming language used for implementation.",
      "It only allows for fixed-size storage."
    ]
  },
  {
    "q": "If you need to implement a 'round-robin' CPU scheduling algorithm, which data structure is most appropriate?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Hash Table"
    ]
  },
  {
    "q": "What is the main benefit of using a `collections.deque` over a `list` when implementing a queue for real-time data streaming?",
    "c": null,
    "o": [
      "Efficient appends and pops from both ends, which are constant time.",
      "Reduced memory footprint for large streams.",
      "Automatic data compression.",
      "Built-in support for concurrent access."
    ]
  },
  {
    "q": "What is a 'pointer' or 'reference' in the context of linked lists?",
    "c": null,
    "o": [
      "A variable that stores the memory address of another node.",
      "The actual data stored within a node.",
      "A unique identifier for each node.",
      "A function that modifies the list."
    ]
  },
  {
    "q": "What is the space complexity of a singly linked list with 'n' nodes?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which traversal method for a binary tree is often used to get all nodes in a perfectly sorted order if it's a Binary Search Tree?",
    "c": null,
    "o": [
      "Inorder traversal",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is a 'parent node' in a tree?",
    "c": null,
    "o": [
      "A node that has one or more children nodes directly below it.",
      "The root node of the tree.",
      "A node with no children.",
      "Any node that is not a leaf."
    ]
  },
  {
    "q": "What does a 'cycle' in a graph indicate?",
    "c": null,
    "o": [
      "A path that starts and ends at the same vertex, visiting other vertices in between.",
      "A graph that has no edges.",
      "A graph where all vertices are connected.",
      "A graph with weighted edges."
    ]
  },
  {
    "q": "Which graph algorithm is typically used for finding the shortest path in a graph where edge weights can be negative (but no negative cycles)?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra's Algorithm",
      "BFS",
      "DFS"
    ]
  },
  {
    "q": "What is the primary benefit of using a heap for implementing a priority queue?",
    "c": null,
    "o": [
      "Efficient (logarithmic time) insertion and extraction of the highest/lowest priority element.",
      "Constant time access to any element.",
      "Automatic sorting of all elements.",
      "Guaranteed low memory footprint."
    ]
  },
  {
    "q": "Which `heapq` function is used to convert an existing list into a heap in-place?",
    "c": null,
    "o": [
      "heapq.heapify()",
      "heapq.build_heap()",
      "heapq.make_heap()",
      "heapq.sort_heap()"
    ]
  },
  {
    "q": "What is the goal of a good hash function?",
    "c": null,
    "o": [
      "To minimize collisions and distribute keys uniformly across the hash table.",
      "To produce unique hash values for all possible inputs.",
      "To sort the input keys before hashing.",
      "To be computationally complex for security."
    ]
  },
  {
    "q": "Which collision resolution technique is generally more memory-efficient when the hash table is nearly full?",
    "c": null,
    "o": [
      "Open Addressing (e.g., linear probing)",
      "Separate Chaining",
      "Direct Addressing",
      "Cuckoo Hashing"
    ]
  },
  {
    "q": "Which NumPy function is used to find the maximum value along a specified axis of an array?",
    "c": null,
    "o": [
      "np.max() or .max()",
      "np.maximum()",
      "np.amax()",
      "np.largest()"
    ]
  },
  {
    "q": "What is the result of using `np.zeros_like(arr)` where `arr` is an existing NumPy array?",
    "c": "\nimport numpy as np\narr = np.array([[1, 2], [3, 4]])\nprint(np.zeros_like(arr))\n",
    "o": [
      "A new array of zeros with the same shape and dtype as `arr`.",
      "An array of zeros with the same number of elements as `arr` but 1D.",
      "An array filled with ones.",
      "Error, as `zeros_like` is not a valid function."
    ]
  },
  {
    "q": "Which of the following scenarios would most appropriately use a Stack?",
    "c": null,
    "o": [
      "Converting an infix expression to a postfix expression.",
      "Managing downloads in a web browser (FIFO).",
      "Storing elements that need to be accessed by priority.",
      "Representing a social network graph."
    ]
  },
  {
    "q": "If you are designing a system to manage print jobs, where jobs are processed in the order they are submitted, which data structure should you use?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Hash Table"
    ]
  },
  {
    "q": "What is a major disadvantage of using an array-based implementation for a Linked List?",
    "c": null,
    "o": [
      "Inserting or deleting elements can be inefficient due to element shifting.",
      "Memory is always contiguous, which is a disadvantage.",
      "Pointers consume more memory.",
      "It makes random access faster."
    ]
  },
  {
    "q": "What is the typical time complexity for deleting a node from the end of a singly linked list if you only have a pointer to the head?",
    "c": null,
    "o": [
      "O(n) (requires traversal to the second to last node).",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which type of binary tree has every level completely filled, except possibly the last level, and all nodes in the last level are as far left as possible?",
    "c": null,
    "o": [
      "Complete Binary Tree",
      "Full Binary Tree",
      "Perfect Binary Tree",
      "Skewed Binary Tree"
    ]
  },
  {
    "q": "Which traversal method for a binary tree is often used to delete nodes, as it processes children before the parent?",
    "c": null,
    "o": [
      "Postorder traversal",
      "Preorder traversal",
      "Inorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is an 'adjacent vertex' in a graph?",
    "c": null,
    "o": [
      "A vertex that is directly connected to another vertex by an edge.",
      "Any vertex in the same connected component.",
      "A vertex that has the same degree.",
      "A vertex that is far away in the graph."
    ]
  },
  {
    "q": "What is 'topological sorting' applied to?",
    "c": null,
    "o": [
      "Directed Acyclic Graphs (DAGs).",
      "Undirected Graphs with cycles.",
      "Weighted Graphs with negative edges.",
      "Complete Graphs."
    ]
  },
  {
    "q": "What is the main property maintained in a Min-Heap data structure?",
    "c": null,
    "o": [
      "The value of each node is less than or equal to the values of its children.",
      "The value of each node is greater than or equal to the values of its children.",
      "All elements are sorted in ascending order.",
      "The heap always remains perfectly balanced."
    ]
  },
  {
    "q": "If you call `heapq.nlargest(1, data)` on a list, what will it return?",
    "c": "\nimport heapq\ndata = [5, 2, 8, 1, 9]\nprint(heapq.nlargest(1, data))\n",
    "o": [
      "[9]",
      "[1]",
      "[8]",
      "[5]"
    ]
  },
  {
    "q": "What is the main idea behind 'open addressing' collision resolution in hash tables?",
    "c": null,
    "o": [
      "If a collision occurs, the algorithm probes for an alternative empty slot within the same hash table array.",
      "Each slot in the hash table array points to a linked list of colliding elements.",
      "A separate, smaller hash table is used to store collisions.",
      "Colliding elements are discarded."
    ]
  },
  {
    "q": "What is the average-case time complexity for inserting a key-value pair into a well-designed hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which NumPy function is used to compute the element-wise sine of an array?",
    "c": null,
    "o": [
      "np.sin()",
      "np.sine()",
      "np.math.sin()",
      "np.trig.sin()"
    ]
  },
  {
    "q": "What is the primary difference between `arr.copy()` and assigning one array to another (e.g., `b = a`) in NumPy?",
    "c": null,
    "o": [
      "Copy creates an independent copy, while assignment creates a view/reference.",
      "Assignment creates an independent copy, while copy creates a view/reference.",
      "Both create independent copies but use different syntax.",
      "Neither creates an independent copy."
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a program's undo/redo functionality?",
    "c": null,
    "o": [
      "Two Stacks (one for undo, one for redo)",
      "Two Queues",
      "A single Linked List",
      "A single Hash Table"
    ]
  },
  {
    "q": "What is the typical time complexity for adding an element to the right (back) end of a `collections.deque`?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary use case for a 'dummy head node' in a singly linked list?",
    "c": null,
    "o": [
      "To simplify operations like insertion and deletion at the beginning of the list, avoiding special case handling for an empty list.",
      "To store extra metadata about the list.",
      "To mark the end of the list.",
      "To speed up searches for elements."
    ]
  },
  {
    "q": "What is the main advantage of using a Linked List over a fixed-size array when the number of elements is highly dynamic?",
    "c": null,
    "o": [
      "Dynamic size and efficient insertions/deletions without needing to resize or shift elements.",
      "Faster random access to elements.",
      "Less memory overhead per element.",
      "Contiguous memory allocation."
    ]
  },
  {
    "q": "In a Binary Search Tree (BST), what is the time complexity for inserting a new node in the average case?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is a 'leaf node' in any tree data structure?",
    "c": null,
    "o": [
      "A node that has no children.",
      "The root node of the tree.",
      "A node with exactly one child.",
      "Any node that is not the root."
    ]
  },
  {
    "q": "What is a 'simple graph' in graph theory?",
    "c": null,
    "o": [
      "A graph that has no loops (edges from a vertex to itself) and no multiple edges between the same two vertices.",
      "A graph with no cycles.",
      "A graph with only a few vertices.",
      "A graph that is fully connected."
    ]
  },
  {
    "q": "Which graph algorithm is used to find a Minimum Spanning Tree (MST) using a greedy approach that adds edges with the smallest weights first, as long as they don't form a cycle?",
    "c": null,
    "o": [
      "Kruskal's Algorithm",
      "Prim's Algorithm",
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which of the following is a common application of a Min-Heap?",
    "c": null,
    "o": [
      "Implementing a priority queue where the smallest element has the highest priority.",
      "Implementing an undo/redo stack.",
      "Storing elements for fast average-case lookup by key.",
      "Managing function call frames in a program."
    ]
  },
  {
    "q": "What is the time complexity to find the smallest element in a Min-Heap?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "When does 'secondary clustering' occur in open addressing hash tables?",
    "c": null,
    "o": [
      "When different keys that hash to the same initial slot follow the same sequence of probes.",
      "When all keys hash to different initial slots.",
      "When separate chaining is used to resolve collisions.",
      "When the hash table is too small."
    ]
  },
  {
    "q": "What is the average-case time complexity for deleting a key-value pair from a well-designed hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which NumPy function is used to round elements of an array to the nearest integer?",
    "c": null,
    "o": [
      "np.round()",
      "np.ceil()",
      "np.floor()",
      "np.int()"
    ]
  },
  {
    "q": "What is the primary purpose of the `axis` parameter in many NumPy functions (e.g., `sum`, `mean`, `max`)?",
    "c": null,
    "o": [
      "To specify along which dimension (row, column, etc.) the operation should be performed.",
      "To set the data type of the result.",
      "To define the starting point for the operation.",
      "To indicate whether the operation should be in-place."
    ]
  },
  {
    "q": "In a compiler, which data structure is fundamental for managing symbol tables (mapping variable names to their properties)?",
    "c": null,
    "o": [
      "Hash Table",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "What is the primary benefit of using `collections.deque` over a `list` for implementing a fixed-size buffer (e.g., an LRU cache where old items are evicted)?",
    "c": null,
    "o": [
      "Efficient O(1) removals from both ends using `popleft()` and `pop()`, especially with `maxlen`.",
      "Automatically sorts elements upon insertion.",
      "Consumes less memory than a regular list.",
      "Supports faster random access by index."
    ]
  },
  {
    "q": "What is a 'node' in the context of a doubly linked list?",
    "c": null,
    "o": [
      "An element containing data and pointers to both the next and the previous node.",
      "An element containing only data.",
      "A numeric index representing the element's position.",
      "A special marker for the end of the list."
    ]
  },
  {
    "q": "What is the time complexity for searching for a specific value in a sorted singly linked list?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the 'root' node in a tree data structure?",
    "c": null,
    "o": [
      "The topmost node with no parent.",
      "A node with no children.",
      "Any node that is not a leaf.",
      "The node with the largest value."
    ]
  },
  {
    "q": "Which binary tree property states that all internal nodes (non-leaf nodes) have exactly two children?",
    "c": null,
    "o": [
      "Full Binary Tree",
      "Complete Binary Tree",
      "Perfect Binary Tree",
      "Balanced Binary Tree"
    ]
  },
  {
    "q": "What is a 'loop' or 'self-loop' in a graph?",
    "c": null,
    "o": [
      "An edge that connects a vertex to itself.",
      "A path that visits every vertex exactly once.",
      "A cycle that includes all vertices.",
      "A disconnected component in the graph."
    ]
  },
  {
    "q": "Which graph algorithm is used to find all-pairs shortest paths in a weighted graph, even with negative edge weights (but no negative cycles)?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "What is the purpose of 'sift-down' (or 'heapify-down') operation in a heap?",
    "c": null,
    "o": [
      "To restore the heap property after an element has been removed from the root or an element's value has decreased.",
      "To insert a new element into the heap.",
      "To sort the entire heap.",
      "To find the smallest element in the heap."
    ]
  },
  {
    "q": "Which `heapq` function is used to extract the smallest element from a min-heap?",
    "c": null,
    "o": [
      "heapq.heappop()",
      "heapq.heappush()",
      "heapq.nsmallest()",
      "heapq.peek()"
    ]
  },
  {
    "q": "What is the 'load factor' in a hash table a measure of?",
    "c": null,
    "o": [
      "The fullness of the hash table, calculated as (number of items) / (table size).",
      "The efficiency of the hash function.",
      "The average number of collisions.",
      "The maximum capacity of the hash table."
    ]
  },
  {
    "q": "Which collision resolution technique is often implemented using a linked list at each array index?",
    "c": null,
    "o": [
      "Separate Chaining",
      "Linear Probing",
      "Quadratic Probing",
      "Double Hashing"
    ]
  },
  {
    "q": "Which NumPy function is used to compute the standard deviation of an array?",
    "c": null,
    "o": [
      "np.std()",
      "np.average()",
      "np.variance()",
      "np.deviation()"
    ]
  },
  {
    "q": "What is the result of element-wise comparison (e.g., `arr > 5`) on a NumPy array?",
    "c": "\nimport numpy as np\narr = np.array([3, 7, 2, 9])\nprint(arr > 5)\n",
    "o": [
      "[False  True False  True]",
      "[7 9]",
      "True",
      "Error"
    ]
  },
  {
    "q": "Which data structure is suitable for managing a browser's history of visited URLs, allowing easy navigation backward and forward?",
    "c": null,
    "o": [
      "Two Stacks (one for 'back', one for 'forward')",
      "A single Queue",
      "A circular linked list",
      "A hash table"
    ]
  },
  {
    "q": "What is the primary characteristic of a Deque (Double-Ended Queue)?",
    "c": null,
    "o": [
      "Elements can be added or removed from both ends efficiently.",
      "Elements can only be added at one end and removed from the other.",
      "Elements are removed based on their priority.",
      "It provides efficient random access to elements."
    ]
  },
  {
    "q": "What is a major disadvantage of using an Array to implement a Queue, especially when `dequeue` involves removing from the front?",
    "c": null,
    "o": [
      "Removing from the front (index 0) requires shifting all subsequent elements, leading to O(n) time complexity.",
      "It uses more memory than a linked list.",
      "It cannot handle a dynamic number of elements.",
      "It is not thread-safe."
    ]
  },
  {
    "q": "What is the time complexity for deleting a node with a specific value from an unsorted singly linked list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is a 'full binary tree'?",
    "c": null,
    "o": [
      "A binary tree in which every node has either zero or two children.",
      "A binary tree where all levels are completely filled.",
      "A binary tree where all leaf nodes are at the same depth.",
      "A binary tree that is always balanced."
    ]
  },
  {
    "q": "Which binary tree traversal method produces a sorted list of elements when applied to a Binary Search Tree?",
    "c": null,
    "o": [
      "Inorder traversal",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is a 'dense graph'?",
    "c": null,
    "o": [
      "A graph where the number of edges is close to the maximum possible number of edges for its number of vertices.",
      "A graph with very few edges.",
      "A graph where all vertices have a high degree.",
      "A graph that contains many cycles."
    ]
  },
  {
    "q": "Which graph algorithm is used to find the shortest path from a single source to all other vertices in a weighted graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "What is the purpose of the 'sift-up' (or 'heapify-up') operation in a heap?",
    "c": null,
    "o": [
      "To restore the heap property after a new element has been inserted, moving it upwards until its correct position is found.",
      "To remove the smallest element from the heap.",
      "To find the largest element in the heap.",
      "To sort the entire heap."
    ]
  },
  {
    "q": "What is the time complexity for inserting an element into a Min-Heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is 'collision resolution' in hash tables?",
    "c": null,
    "o": [
      "The method used to handle situations where two or more keys hash to the same index in the hash table.",
      "The process of calculating the hash value for a key.",
      "The technique for resizing the hash table.",
      "The way to prevent any keys from hashing to the same index."
    ]
  },
  {
    "q": "Which collision resolution technique can suffer from 'primary clustering' where long sequences of occupied slots form?",
    "c": null,
    "o": [
      "Linear Probing",
      "Quadratic Probing",
      "Separate Chaining",
      "Double Hashing"
    ]
  },
  {
    "q": "Which NumPy function is used to concatenate arrays, automatically determining the axis based on the array dimensions?",
    "c": null,
    "o": [
      "np.concatenate()",
      "np.stack()",
      "np.append()",
      "np.join()"
    ]
  },
  {
    "q": "What does the `dtype` attribute of a NumPy array indicate?",
    "c": null,
    "o": [
      "The data type of the elements stored in the array.",
      "The shape of the array.",
      "The number of dimensions.",
      "The total number of bytes the array occupies."
    ]
  },
  {
    "q": "Which data structure would be most appropriate for managing a list of tasks where the most recently added task is the first to be executed?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Linked List"
    ]
  },
  {
    "q": "What is the time complexity of the `appendleft()` operation on a `collections.deque`?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the time complexity for inserting a new node at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary disadvantage of using a Singly Linked List for random access (e.g., getting the element at index `i`)?",
    "c": null,
    "o": [
      "It requires traversing from the beginning, leading to O(n) time complexity.",
      "It consumes more memory per element due to pointers.",
      "It is inefficient for insertions and deletions.",
      "It cannot store heterogeneous data."
    ]
  },
  {
    "q": "In a Binary Search Tree, if a node has two children, how is its inorder successor typically found?",
    "c": null,
    "o": [
      "The leftmost node in its right subtree.",
      "The rightmost node in its left subtree.",
      "Its parent node.",
      "Its right child directly."
    ]
  },
  {
    "q": "What does a 'balanced binary tree' aim to achieve?",
    "c": null,
    "o": [
      "To keep the tree's height as small as possible (logarithmic) to ensure efficient operations.",
      "To ensure all leaf nodes are at the same depth.",
      "To have an equal number of nodes in the left and right subtrees.",
      "To always store elements in a perfectly sorted array."
    ]
  },
  {
    "q": "What is an 'undirected graph'?",
    "c": null,
    "o": [
      "A graph where edges have no specific direction (connections are bidirectional).",
      "A graph where all edges point from a source to a destination.",
      "A graph that contains no cycles.",
      "A graph that is fully connected."
    ]
  },
  {
    "q": "When is an Adjacency Matrix particularly useful for graph representation?",
    "c": null,
    "o": [
      "When the graph is dense (many edges) and quick checks for edge existence are needed.",
      "When the graph is sparse (few edges) to save memory.",
      "When frequent vertex additions and deletions are expected.",
      "When the graph is guaranteed to be acyclic."
    ]
  },
  {
    "q": "Which data structure provides constant-time complexity for finding the minimum element, and logarithmic time for insertion and deletion?",
    "c": null,
    "o": [
      "Min-Heap",
      "Sorted Array",
      "Hash Table",
      "Singly Linked List"
    ]
  },
  {
    "q": "What is the primary use case for the `heapq.merge()` function?",
    "c": null,
    "o": [
      "Merging multiple sorted iterables into a single sorted iterable.",
      "Combining two heaps into one larger heap.",
      "Sorting an unsorted list in-place.",
      "Finding the intersection of two sets."
    ]
  },
  {
    "q": "What is 'clustering' in a hash table?",
    "c": null,
    "o": [
      "A phenomenon where collisions cause items to group together in the hash table, leading to longer probe sequences.",
      "The process of separating colliding elements into different memory locations.",
      "The act of combining multiple hash tables into one.",
      "A measure of how evenly keys are distributed."
    ]
  },
  {
    "q": "Which collision resolution technique is generally more memory-efficient when the hash table is sparse?",
    "c": null,
    "o": [
      "Open Addressing (e.g., linear probing, quadratic probing)",
      "Separate Chaining",
      "Direct Addressing",
      "Cuckoo Hashing"
    ]
  },
  {
    "q": "Which NumPy function is used to compute the element-wise exponential of an array?",
    "c": null,
    "o": [
      "np.exp()",
      "np.power()",
      "np.log()",
      "np.e_power()"
    ]
  },
  {
    "q": "What is the result of adding two NumPy arrays of the same shape?",
    "c": "\nimport numpy as np\narr1 = np.array([1, 2])\narr2 = np.array([3, 4])\nprint(arr1 + arr2)\n",
    "o": [
      "[4 6]",
      "[1 2 3 4]",
      "7",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a common application of a Queue data structure?",
    "c": null,
    "o": [
      "Operating system process scheduling.",
      "Parsing expressions in a compiler.",
      "Managing undo/redo operations.",
      "Implementing recursive algorithms."
    ]
  },
  {
    "q": "What does the `popleft()` method do on a `collections.deque`?",
    "c": null,
    "o": [
      "Removes and returns an element from the left (front) end.",
      "Removes and returns an element from the right (back) end.",
      "Adds an element to the left end.",
      "Returns the leftmost element without removing it."
    ]
  },
  {
    "q": "What is a 'circular linked list'?",
    "c": null,
    "o": [
      "A linked list where the last node points back to the first node.",
      "A linked list with a fixed number of nodes.",
      "A linked list that can only be traversed in a circular fashion.",
      "A linked list that stores only numerical data."
    ]
  },
  {
    "q": "If you need to represent a sequence of elements where insertions and deletions at both ends are very frequent, which Python data structure is most appropriate?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "tuple",
      "array.array"
    ]
  },
  {
    "q": "What is a 'balanced binary search tree' (e.g., AVL tree, Red-Black tree) designed to prevent?",
    "c": null,
    "o": [
      "Degenerating into a linked list in the worst-case, preserving O(log n) performance.",
      "Overflowing memory.",
      "Collisions during insertion.",
      "Being unable to store duplicate values."
    ]
  },
  {
    "q": "Which tree traversal strategy is often used to find the minimum or maximum element in a Binary Search Tree efficiently?",
    "c": null,
    "o": [
      "Inorder traversal (for sorted order, then pick first/last)",
      "Preorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is a 'path' in a graph?",
    "c": null,
    "o": [
      "A sequence of distinct vertices such that consecutive vertices in the sequence are connected by an edge.",
      "A connection between two vertices.",
      "A vertex with no outgoing edges.",
      "A set of all edges in the graph."
    ]
  },
  {
    "q": "Which graph algorithm can be used to determine if a graph contains a cycle?",
    "c": null,
    "o": [
      "DFS (by detecting back edges) or BFS (for undirected graphs)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "What is the primary characteristic of a 'Max-Heap'?",
    "c": null,
    "o": [
      "The largest element is always at the root.",
      "The smallest element is always at the root.",
      "Elements are stored in sorted order.",
      "It only contains distinct elements."
    ]
  },
  {
    "q": "If you are using `heapq` and want to efficiently replace the smallest element with a new one while maintaining heap property, which function should you use?",
    "c": null,
    "o": [
      "heapq.heapreplace()",
      "heapq.heappop() then heapq.heappush()",
      "heapq.heapify()",
      "heapq.merge()"
    ]
  },
  {
    "q": "What is the main drawback of using 'linear probing' for collision resolution in hash tables if the table becomes very full?",
    "c": null,
    "o": [
      "Primary clustering, leading to long probe sequences.",
      "Increased memory usage due to linked lists.",
      "Difficulty in implementing deletions.",
      "Reduced hash function effectiveness."
    ]
  },
  {
    "q": "What is the purpose of 'rehashing' in a hash table?",
    "c": null,
    "o": [
      "To increase the size of the underlying array and redistribute existing elements to maintain efficiency when the load factor becomes too high.",
      "To resolve individual collisions as they occur.",
      "To sort the elements stored in the hash table.",
      "To convert the hash table to a different data structure."
    ]
  },
  {
    "q": "Which NumPy function is used to create an array filled with a specified value?",
    "c": null,
    "o": [
      "np.full()",
      "np.fill()",
      "np.value_fill()",
      "np.create_filled()"
    ]
  },
  {
    "q": "What is the primary benefit of using `np.array_equal(arr1, arr2)` over `arr1 == arr2` for comparing two NumPy arrays?",
    "c": null,
    "o": [
      "`np.array_equal()` returns a single boolean `True` or `False`, whereas `arr1 == arr2` performs element-wise comparison and returns a boolean array.",
      "`arr1 == arr2` is faster for large arrays.",
      "`np.array_equal()` ignores the data types of the arrays.",
      "`np.array_equal()` can compare arrays of different shapes."
    ]
  },
  {
    "q": "What is the typical time complexity for performing the `push` operation on a Stack implemented using a Python list?",
    "c": null,
    "o": [
      "O(1) (when appending to the end of the list)",
      "O(n) (when inserting at the beginning of the list)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which method on Python's `collections.deque` is used to add an element to the right (back) end?",
    "c": null,
    "o": [
      "append()",
      "appendright()",
      "insert(-1, element)",
      "pushright()"
    ]
  },
  {
    "q": "When is a 'doubly linked list' generally preferred over a 'singly linked list'?",
    "c": null,
    "o": [
      "When frequent traversals in both forward and backward directions are required, or when deletions need to be efficient given only a node's reference.",
      "When memory efficiency is the top priority.",
      "When elements need to be accessed randomly by index.",
      "When the list is guaranteed to be very small."
    ]
  },
  {
    "q": "What is a 'head node' in a linked list?",
    "c": null,
    "o": [
      "The first node in the list, providing the entry point for traversal.",
      "The last node in the list.",
      "A node that stores the size of the list.",
      "A dummy node used for simplification."
    ]
  },
  {
    "q": "What is the primary characteristic of a 'perfect binary tree'?",
    "c": null,
    "o": [
      "All internal nodes have two children, and all leaf nodes are at the same depth.",
      "Every level is completely filled except possibly the last.",
      "All nodes are sorted.",
      "It has a fixed number of nodes."
    ]
  },
  {
    "q": "Which binary tree traversal is useful for creating a prefix expression (Polish notation) from an expression tree?",
    "c": null,
    "o": [
      "Preorder traversal",
      "Inorder traversal",
      "Postorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is a 'sparse graph'?",
    "c": null,
    "o": [
      "A graph where the number of edges is much less than the maximum possible number of edges for its number of vertices.",
      "A graph where all vertices have a low degree.",
      "A graph that contains no cycles.",
      "A graph with many edges."
    ]
  },
  {
    "q": "What does a 'strongly connected component' refer to in a directed graph?",
    "c": null,
    "o": [
      "A subgraph where for every pair of vertices (u, v) within the component, there is a path from u to v and a path from v to u.",
      "A subgraph where every vertex has an even degree.",
      "A set of vertices that all have edges pointing to the same external vertex.",
      "A group of vertices with no incoming edges."
    ]
  },
  {
    "q": "Which data structure is typically used to implement a 'Max-Priority Queue' where the largest element is always extracted first?",
    "c": null,
    "o": [
      "Max-Heap",
      "Min-Heap (with negation of values)",
      "Sorted Array",
      "Queue"
    ]
  },
  {
    "q": "What is the time complexity to build a Max-Heap from an unsorted array of 'n' elements?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "What is the typical time complexity for searching for a key in a well-designed hash table in the average case?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which collision resolution technique involves using a second hash function to determine the step size for probing?",
    "c": null,
    "o": [
      "Double Hashing",
      "Linear Probing",
      "Quadratic Probing",
      "Separate Chaining"
    ]
  },
  {
    "q": "Which NumPy function is used to create an array with a range of evenly spaced values?",
    "c": null,
    "o": [
      "np.arange()",
      "np.linspace()",
      "np.range()",
      "np.sequence()"
    ]
  },
  {
    "q": "What is 'broadcasting' in NumPy?",
    "c": null,
    "o": [
      "A mechanism that allows NumPy to perform operations on arrays of different shapes.",
      "A method for distributing array computations across multiple CPU cores.",
      "A way to convert a 1D array into a multi-dimensional array.",
      "The process of saving a NumPy array to a file."
    ]
  },
  {
    "q": "In a web server, which data structure is commonly used to manage incoming requests (processing them in the order they arrive)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Hash Table",
      "Binary Tree"
    ]
  },
  {
    "q": "What is the primary advantage of `collections.deque` over a standard Python `list` when implementing a queue?",
    "c": null,
    "o": [
      "O(1) time complexity for adding/removing elements from both ends, while `list` has O(n) for front operations.",
      "It consumes less memory for large numbers of elements.",
      "It offers faster random access to elements by index.",
      "It automatically sorts elements upon insertion."
    ]
  },
  {
    "q": "What is the primary characteristic of a 'singly linked list'?",
    "c": null,
    "o": [
      "Each node contains data and a pointer to the next node in the sequence.",
      "Each node contains data and pointers to both the next and previous nodes.",
      "Elements are stored in contiguous memory locations.",
      "Elements can be accessed randomly by index in O(1) time."
    ]
  },
  {
    "q": "What is the time complexity for inserting a new node into the middle of a singly linked list?",
    "c": null,
    "o": [
      "O(n) (requires traversal to the insertion point)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which binary tree traversal is useful for creating a postfix expression (Reverse Polish Notation) from an expression tree?",
    "c": null,
    "o": [
      "Postorder traversal",
      "Preorder traversal",
      "Inorder traversal",
      "Level-order traversal"
    ]
  },
  {
    "q": "What is the 'height' of a binary tree?",
    "c": null,
    "o": [
      "The length of the longest path from the root to a leaf node.",
      "The total number of nodes in the tree.",
      "The number of levels in the tree.",
      "The maximum degree of any node."
    ]
  },
  {
    "q": "What is an 'edge' in a graph?",
    "c": null,
    "o": [
      "A connection between two vertices.",
      "A data element stored in a vertex.",
      "A specific type of vertex.",
      "The path between two vertices."
    ]
  },
  {
    "q": "Which graph algorithm is used to find a Minimum Spanning Tree (MST) by starting from an arbitrary vertex and iteratively adding the cheapest edge that connects a vertex in the tree to a vertex outside the tree?",
    "c": null,
    "o": [
      "Prim's Algorithm",
      "Kruskal's Algorithm",
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What is the purpose of 'heapify' operation when building a heap from an array?",
    "c": null,
    "o": [
      "To transform an arbitrary array into a heap, typically in O(n) time.",
      "To sort the elements in the array in-place.",
      "To find the smallest element in the array.",
      "To merge multiple arrays into one heap."
    ]
  },
  {
    "q": "If you need to quickly retrieve the k largest elements from a very large dataset, which `heapq` function is most suitable?",
    "c": null,
    "o": [
      "heapq.nlargest(k, iterable)",
      "heapq.heappop() repeatedly",
      "heapq.heapify() then sort",
      "heapq.merge()"
    ]
  },
  {
    "q": "What is the concept of 'separate chaining' for collision resolution in hash tables?",
    "c": null,
    "o": [
      "Each slot in the hash table array points to a linked list (or other data structure) that stores all elements that hash to that slot.",
      "If a collision occurs, the algorithm probes for an alternative empty slot within the same array.",
      "A separate hash table is used for storing overflow items.",
      "Colliding elements are rehashed using a different function."
    ]
  },
  {
    "q": "What is the worst-case time complexity for searching for a key in a hash table that uses separate chaining, if all keys hash to the same bucket?",
    "c": null,
    "o": [
      "O(n) (equivalent to searching a linked list of n elements)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which NumPy function is used to concatenate arrays, automatically determining the axis based on the array dimensions?",
    "c": null,
    "o": [
      "np.concatenate()",
      "np.stack()",
      "np.append()",
      "np.join()"
    ]
  },
  {
    "q": "What does the `dtype` attribute of a NumPy array indicate?",
    "c": null,
    "o": [
      "The data type of the elements stored in the array.",
      "The shape of the array.",
      "The number of dimensions.",
      "The total number of bytes the array occupies."
    ]
  },
  {
    "q": "Which data structure would be most appropriate for managing a list of tasks where the most recently added task is the first to be executed?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Linked List"
    ]
  },
  {
    "q": "What is the time complexity of the `appendleft()` operation on a `collections.deque`?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the time complexity for inserting a new node at the beginning of a singly linked list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary disadvantage of using a Singly Linked List for random access (e.g., getting the element at index `i`)?",
    "c": null,
    "o": [
      "It requires traversing from the beginning, leading to O(n) time complexity.",
      "It consumes more memory per element due to pointers.",
      "It is inefficient for insertions and deletions.",
      "It cannot store heterogeneous data."
    ]
  },
  {
    "q": "In a Binary Search Tree, if a node has two children, how is its inorder successor typically found?",
    "c": null,
    "o": [
      "The leftmost node in its right subtree.",
      "The rightmost node in its left subtree.",
      "Its parent node.",
      "Its right child directly."
    ]
  },
  {
    "q": "What does a 'balanced binary tree' aim to achieve?",
    "c": null,
    "o": [
      "To keep the tree's height as small as possible (logarithmic) to ensure efficient operations.",
      "To ensure all leaf nodes are at the same depth.",
      "To have an equal number of nodes in the left and right subtrees.",
      "To always store elements in a perfectly sorted array."
    ]
  },
  {
    "q": "What is an 'undirected graph'?",
    "c": null,
    "o": [
      "A graph where edges have no specific direction (connections are bidirectional).",
      "A graph where all edges point from a source to a destination.",
      "A graph that contains no cycles.",
      "A graph that is fully connected."
    ]
  },
  {
    "q": "When is an Adjacency Matrix particularly useful for graph representation?",
    "c": null,
    "o": [
      "When the graph is dense (many edges) and quick checks for edge existence are needed.",
      "When the graph is sparse (few edges) to save memory.",
      "When frequent vertex additions and deletions are expected.",
      "When the graph is guaranteed to be acyclic."
    ]
  },
  {
    "q": "Which data structure provides constant-time complexity for finding the minimum element, and logarithmic time for insertion and deletion?",
    "c": null,
    "o": [
      "Min-Heap",
      "Sorted Array",
      "Hash Table",
      "Singly Linked List"
    ]
  },
  {
    "q": "What is the primary use case for the `heapq.merge()` function?",
    "c": null,
    "o": [
      "Merging multiple sorted iterables into a single sorted iterable.",
      "Combining two heaps into one larger heap.",
      "Sorting an unsorted list in-place.",
      "Finding the intersection of two sets."
    ]
  },
  {
    "q": "What is 'clustering' in a hash table?",
    "c": null,
    "o": [
      "A phenomenon where collisions cause items to group together in the hash table, leading to longer probe sequences.",
      "The process of separating colliding elements into different memory locations.",
      "The act of combining multiple hash tables into one.",
      "A measure of how evenly keys are distributed."
    ]
  },
  {
    "q": "Which collision resolution technique is generally more memory-efficient when the hash table is sparse?",
    "c": null,
    "o": [
      "Open Addressing (e.g., linear probing, quadratic probing)",
      "Separate Chaining",
      "Direct Addressing",
      "Cuckoo Hashing"
    ]
  }
]
