[
  {
    "q": "Which data structure is best suited for implementing an LRU (Least Recently Used) cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Queue",
      "List",
      "Stack"
    ]
  },
  {
    "q": "What data structure is typically used to represent a network of roads between cities?",
    "c": null,
    "o": [
      "Graph",
      "Stack",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which Python data structure is most suitable to maintain a dynamic set of elements with quick min value access?",
    "c": null,
    "o": [
      "Heap",
      "Set",
      "Deque",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm pattern is most commonly used in competitive programming to reduce time complexity of recursive problems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Brute Force",
      "Backtracking",
      "Recursion"
    ]
  },
  {
    "q": "In scheduling problems like job sequencing, which data structure is often used to sort tasks based on deadlines or profits?",
    "c": null,
    "o": [
      "Priority Queue",
      "Set",
      "Graph",
      "Dictionary"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing undo functionality in applications?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is a common use of Tries in real-world applications?",
    "c": null,
    "o": [
      "Autocomplete systems",
      "Sorting large numbers",
      "Matrix operations",
      "Graph traversal"
    ]
  },
  {
    "q": "Which data structure allows O(1) average time complexity for insert, delete, and lookup operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Binary Search Tree",
      "Linked List"
    ]
  },
  {
    "q": "What data structure would be most suitable to manage a to-do list where tasks are processed in the order they are added?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Graph"
    ]
  },
  {
    "q": "Which competitive programming pattern is used in problems like 'Two Sum' or 'Pair with a given sum'?",
    "c": null,
    "o": [
      "Two-pointer technique",
      "Recursion",
      "Backtracking",
      "Bit Manipulation"
    ]
  },
  {
    "q": "What kind of algorithm is best suited to find the shortest path in a weighted graph?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Kruskal's Algorithm",
      "Floyd-Warshall"
    ]
  },
  {
    "q": "Which data structure is typically used to manage memory allocation in operating systems?",
    "c": null,
    "o": [
      "Linked List",
      "Tree",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "In which situation is a circular queue preferred over a simple queue?",
    "c": null,
    "o": [
      "When memory needs to be reused efficiently",
      "When FIFO is not needed",
      "When stack operations are needed",
      "When recursion is used"
    ]
  },
  {
    "q": "Which of the following is an advantage of using adjacency list over adjacency matrix in graph representation?",
    "c": null,
    "o": [
      "Space efficiency for sparse graphs",
      "Faster edge lookup",
      "Better sorting of vertices",
      "Simpler implementation"
    ]
  },
  {
    "q": "What is the most efficient data structure to implement a leaderboard with frequent updates and top-k retrieval?",
    "c": null,
    "o": [
      "Balanced Binary Search Tree",
      "Queue",
      "Hash Table",
      "Graph"
    ]
  },
  {
    "q": "Which data structure is commonly used for syntax parsing in compilers?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which data structure would best help simulate a call center line where calls are handled in the order they arrive?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Tree"
    ]
  },
  {
    "q": "In which type of real-world system is a graph data structure most likely used?",
    "c": null,
    "o": [
      "Social Networks",
      "Inventory Management",
      "Compiler Design",
      "Authentication Systems"
    ]
  },
  {
    "q": "Which of the following structures is optimal for efficiently storing a large dictionary of words for lookup and prefix-matching?",
    "c": null,
    "o": [
      "Trie",
      "List",
      "Set",
      "Queue"
    ]
  },
  {
    "q": "Which data structure is commonly used in Dijkstra's algorithm for selecting the next closest node?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "Which Python data structure is best suited for frequency counting of elements?",
    "c": null,
    "o": [
      "Dictionary",
      "Tuple",
      "List",
      "Set"
    ]
  },
  {
    "q": "Which technique is commonly used in problems like 'Find the duplicate number in an array' with limited extra space?",
    "c": null,
    "o": [
      "Floyd’s Cycle Detection",
      "Backtracking",
      "Greedy Algorithm",
      "Memoization"
    ]
  },
  {
    "q": "Which data structure would be the most efficient to implement a cache with constant-time insertions and lookups, and eviction of least recently used items?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "List + Queue",
      "Set + Stack",
      "Dictionary only"
    ]
  },
  {
    "q": "Which algorithmic pattern helps avoid redundant calculations in overlapping subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "Brute Force",
      "Greedy",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is most suitable for maintaining a running median in a stream of numbers?",
    "c": null,
    "o": [
      "Two Heaps (Min-Heap and Max-Heap)",
      "Single Stack",
      "Graph",
      "Deque"
    ]
  },
  {
    "q": "Which real-world use case can be efficiently solved with a Union-Find (Disjoint Set) data structure?",
    "c": null,
    "o": [
      "Network connectivity",
      "Task scheduling",
      "Autocomplete search",
      "Palindrome detection"
    ]
  },
  {
    "q": "Which data structure is commonly used in task scheduling with priorities?",
    "c": null,
    "o": [
      "Heap",
      "Queue",
      "Linked List",
      "Deque"
    ]
  },
  {
    "q": "What is the best data structure for implementing browser history navigation (Back/Forward)?",
    "c": null,
    "o": [
      "Two Stacks",
      "Single Queue",
      "List",
      "Set"
    ]
  },
  {
    "q": "Which pattern is useful when solving problems like coin change or ways to climb stairs?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Backtracking",
      "Sliding Window",
      "Bitmasking"
    ]
  },
  {
    "q": "What is the ideal data structure to store log messages in chronological order with efficient append and read operations?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Set",
      "Graph"
    ]
  },
  {
    "q": "Which data structure is best suited for checking if a sequence of brackets is balanced?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is most suitable for detecting cycles in a directed graph?",
    "c": null,
    "o": [
      "Depth-First Search with recursion stack",
      "Breadth-First Search",
      "Kruskal's Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is typically used in implementing recursion internally?",
    "c": null,
    "o": [
      "Stack",
      "Heap",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which Python standard library class provides a thread-safe, memory-efficient queue?",
    "c": null,
    "o": [
      "queue.Queue",
      "collections.deque",
      "threading.Queue",
      "asyncio.Queue"
    ]
  },
  {
    "q": "Which is the most appropriate data structure to track the order of insertion and allow O(1) lookup?",
    "c": null,
    "o": [
      "OrderedDict",
      "List",
      "Set",
      "Queue"
    ]
  },
  {
    "q": "Which of the following is commonly used to solve sliding window problems efficiently?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Trie",
      "Tree"
    ]
  },
  {
    "q": "Which algorithm or pattern is widely used in interval scheduling problems?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is most suitable for a spell checker application?",
    "c": null,
    "o": [
      "Trie",
      "Graph",
      "Hash Table",
      "Stack"
    ]
  },
  {
    "q": "Which of the following problems is commonly solved using backtracking?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Finding Minimum in Array",
      "Binary Search",
      "Graph Traversal"
    ]
  },
  {
    "q": "Which data structure is used to store hierarchical data like a file system?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "List",
      "HashMap"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding connected components in a graph?",
    "c": null,
    "o": [
      "Depth-First Search",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which competitive programming technique involves pre-processing an array to answer range queries efficiently?",
    "c": null,
    "o": [
      "Prefix Sum",
      "Two Pointers",
      "Binary Search",
      "Heap"
    ]
  },
  {
    "q": "Which of these is best for implementing autocomplete and prefix-based searching?",
    "c": null,
    "o": [
      "Trie",
      "Hash Table",
      "Array",
      "Heap"
    ]
  },
  {
    "q": "Which Python module provides a heap-based priority queue?",
    "c": null,
    "o": [
      "heapq",
      "bisect",
      "queue",
      "collections"
    ]
  },
  {
    "q": "Which approach is used in dynamic programming to solve problems in bottom-up fashion?",
    "c": null,
    "o": [
      "Tabulation",
      "Memoization",
      "Recursion",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is most suitable for managing a dynamic leaderboard that allows frequent score updates and sorted retrieval?",
    "c": null,
    "o": [
      "Balanced Binary Search Tree",
      "HashMap",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm is typically used for detecting shortest paths in a graph with negative edge weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra",
      "Kruskal",
      "DFS"
    ]
  },
  {
    "q": "Which of the following is an application of the Union-Find data structure?",
    "c": null,
    "o": [
      "Kruskal’s Minimum Spanning Tree",
      "Job Scheduling",
      "Breadth-First Search",
      "Topological Sorting"
    ]
  },
  {
    "q": "Which of these data structures is ideal for implementing a browser's forward and backward navigation?",
    "c": null,
    "o": [
      "Two Stacks",
      "Queue",
      "Set",
      "Heap"
    ]
  },
  {
    "q": "What is the best-suited algorithm for solving the Knapsack problem in competitive programming?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing a scheduler that executes jobs in order of priority?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Set",
      "Trie"
    ]
  },
  {
    "q": "Which competitive programming pattern solves problems like 'Longest Increasing Subsequence' efficiently?",
    "c": null,
    "o": [
      "Binary Search with Dynamic Programming",
      "Two Pointer Technique",
      "BFS",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which structure is used internally by Python's `set` and `dict` types?",
    "c": null,
    "o": [
      "Hash Table",
      "Binary Tree",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which data structure would be most useful in a web crawler to avoid visiting the same URL twice?",
    "c": null,
    "o": [
      "Set",
      "Queue",
      "Heap",
      "List"
    ]
  },
  {
    "q": "Which algorithm pattern is used to generate all permutations of a string?",
    "c": null,
    "o": [
      "Backtracking",
      "Memoization",
      "Greedy",
      "Sliding Window"
    ]
  },
  {
    "q": "What is the ideal use-case of the deque data structure in real-world problems?",
    "c": null,
    "o": [
      "Sliding Window Maximum",
      "Binary Search Tree Traversal",
      "Graph Coloring",
      "Finding Palindromes"
    ]
  },
  {
    "q": "Which Python module is typically used for fixed-size heap implementations?",
    "c": null,
    "o": [
      "heapq",
      "collections",
      "array",
      "struct"
    ]
  },
  {
    "q": "Which algorithm helps in topological sorting of tasks with dependencies?",
    "c": null,
    "o": [
      "Kahn’s Algorithm",
      "Prim’s Algorithm",
      "A* Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which algorithmic technique solves problems like 'Maximum Subarray Sum' efficiently?",
    "c": null,
    "o": [
      "Kadane’s Algorithm",
      "Divide and Conquer",
      "Backtracking",
      "Dynamic Programming with Memoization"
    ]
  },
  {
    "q": "Which competitive programming pattern is helpful for solving problems like 'Find all anagrams in a string'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Two Pointers",
      "Binary Search",
      "DFS"
    ]
  },
  {
    "q": "Which algorithm is suitable for solving maze problems and finding paths from source to destination?",
    "c": null,
    "o": [
      "Breadth-First Search",
      "Depth-First Search",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms is typically used for efficient substring search within a large string?",
    "c": null,
    "o": [
      "KMP (Knuth-Morris-Pratt)",
      "Bubble Sort",
      "Depth-First Search",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure would be most efficient for a real-time messaging system’s message queue?",
    "c": null,
    "o": [
      "Deque",
      "List",
      "Set",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm is used to construct a Minimum Spanning Tree (MST)?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm",
      "Topological Sort",
      "KMP Algorithm"
    ]
  },
  {
    "q": "Which pattern is useful for solving problems like ‘Maximum sum subarray of size k’?",
    "c": null,
    "o": [
      "Sliding Window",
      "Two Pointer Technique",
      "Greedy",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure can efficiently support insertion, deletion, and retrieval in sorted order?",
    "c": null,
    "o": [
      "Balanced Binary Search Tree",
      "Hash Table",
      "Queue",
      "List"
    ]
  },
  {
    "q": "Which of these algorithms is most suitable for solving the Traveling Salesman Problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Breadth-First Search",
      "Greedy Algorithm",
      "Union-Find"
    ]
  },
  {
    "q": "What data structure is ideal for handling autocomplete features with quick lookup and prefix matching?",
    "c": null,
    "o": [
      "Trie",
      "Queue",
      "Stack",
      "Graph"
    ]
  },
  {
    "q": "Which Python data structure maintains the order of insertion and allows O(1) access by key?",
    "c": null,
    "o": [
      "OrderedDict",
      "List",
      "Set",
      "Tuple"
    ]
  },
  {
    "q": "Which of the following structures is best suited for implementing undo-redo functionality?",
    "c": null,
    "o": [
      "Two Stacks",
      "Queue",
      "Deque",
      "Set"
    ]
  },
  {
    "q": "Which algorithmic technique is used to solve the Subset Sum problem efficiently?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Binary Search",
      "Greedy Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which of the following is the best algorithm for real-time shortest path finding in maps?",
    "c": null,
    "o": [
      "A* Algorithm",
      "DFS",
      "Bellman-Ford",
      "Kruskal"
    ]
  },
  {
    "q": "What is the purpose of a min-heap in streaming median problems?",
    "c": null,
    "o": [
      "To store the larger half of the numbers",
      "To store the smaller half of the numbers",
      "To store duplicates",
      "To sort in descending order"
    ]
  },
  {
    "q": "Which real-world system is best modeled using a graph data structure?",
    "c": null,
    "o": [
      "Flight connections between cities",
      "List of books in a library",
      "Price list of products",
      "User login logs"
    ]
  },
  {
    "q": "Which data structure is useful for checking for palindromes in a string?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which data structure is commonly used in real-time traffic navigation systems to represent roads and intersections?",
    "c": null,
    "o": [
      "Graph",
      "Queue",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm is most suitable for solving 'Job Scheduling to maximize profit' problems?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Backtracking",
      "Dynamic Programming",
      "Floyd-Warshall"
    ]
  },
  {
    "q": "Which pattern is effective when solving 'Longest Substring Without Repeating Characters'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Binary Search",
      "Two Pointers",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is ideal to store and manage version control history in software development?",
    "c": null,
    "o": [
      "Graph (DAG)",
      "Stack",
      "Queue",
      "List"
    ]
  },
  {
    "q": "Which structure is most efficient for implementing a max-frequency stack?",
    "c": null,
    "o": [
      "HashMap + Stack",
      "Heap + Queue",
      "Stack + List",
      "Trie + Deque"
    ]
  },
  {
    "q": "Which algorithm is optimal for reconstructing a string from overlapping parts (like in DNA assembly)?",
    "c": null,
    "o": [
      "Eulerian Path in a Graph",
      "Dijkstra’s Algorithm",
      "KMP Algorithm",
      "Bellman-Ford"
    ]
  },
  {
    "q": "Which real-world problem can be modeled using a topological sort of a graph?",
    "c": null,
    "o": [
      "Task scheduling with dependencies",
      "Real-time messaging order",
      "Search autocomplete ranking",
      "Palindrome checking"
    ]
  },
  {
    "q": "Which data structure is preferred for solving the 'Next Greater Element' problem efficiently?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Set"
    ]
  },
  {
    "q": "Which data structure is best suited for storing hierarchical menus or categories in an application?",
    "c": null,
    "o": [
      "Tree",
      "Set",
      "List",
      "Stack"
    ]
  },
  {
    "q": "What type of algorithm is used in applications like Google Maps to find the fastest route?",
    "c": null,
    "o": [
      "A* Algorithm",
      "DFS",
      "Topological Sort",
      "Union-Find"
    ]
  },
  {
    "q": "What is a key reason to use a deque over a list in queue-based problems?",
    "c": null,
    "o": [
      "Faster O(1) pops from both ends",
      "Automatic sorting",
      "Less memory usage",
      "Supports hashing"
    ]
  },
  {
    "q": "Which type of data structure is often used for parsing and evaluating expressions like '3 + (2 * 4)'?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm is effective for scheduling tasks to minimize CPU idle time?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "DFS",
      "Union-Find",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is ideal for storing a list of unique items and supports fast lookup?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Queue",
      "Deque"
    ]
  },
  {
    "q": "Which pattern is commonly used for solving problems that require checking subarrays or substrings of fixed size?",
    "c": null,
    "o": [
      "Sliding Window",
      "DFS",
      "Backtracking",
      "Heap"
    ]
  },
  {
    "q": "Which real-world problem is best solved using a greedy algorithm?",
    "c": null,
    "o": [
      "Activity selection problem",
      "Graph traversal",
      "Expression evaluation",
      "Finding duplicates"
    ]
  },
  {
    "q": "Which Python module provides tools for working with efficient queues and stacks?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "bisect"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a fixed-capacity buffer in producer-consumer scenarios?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Set",
      "List"
    ]
  },
  {
    "q": "Which algorithm is best for detecting strongly connected components in a directed graph?",
    "c": null,
    "o": [
      "Kosaraju's Algorithm",
      "Prim's Algorithm",
      "Floyd-Warshall",
      "Kahn’s Algorithm"
    ]
  },
  {
    "q": "Which type of tree is most suitable for maintaining a dynamic set of numbers and answering range queries?",
    "c": null,
    "o": [
      "Segment Tree",
      "Binary Search Tree",
      "Trie",
      "Heap"
    ]
  },
  {
    "q": "Which algorithmic approach is effective in solving the Matrix Chain Multiplication problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Sliding Window"
    ]
  },
  {
    "q": "Which data structure is best for implementing a spell checker with suggestions?",
    "c": null,
    "o": [
      "Trie",
      "Set",
      "List",
      "Hash Table"
    ]
  },
  {
    "q": "Which application is a common use case of the stack data structure?",
    "c": null,
    "o": [
      "Undo operation in text editors",
      "Task scheduling",
      "Autocomplete suggestions",
      "Shortest path in a graph"
    ]
  },
  {
    "q": "What is the time complexity of inserting into a binary heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which technique is used to optimize recursive solutions that recompute results for the same inputs?",
    "c": null,
    "o": [
      "Memoization",
      "Tabulation",
      "Backtracking",
      "Two Pointer Technique"
    ]
  },
  {
    "q": "Which of the following is a practical use case for breadth-first search?",
    "c": null,
    "o": [
      "Finding shortest path in an unweighted graph",
      "Cycle detection in directed graphs",
      "Minimum spanning tree",
      "Expression evaluation"
    ]
  },
  {
    "q": "Which problem can be solved using the two-pointer technique?",
    "c": null,
    "o": [
      "Pair with target sum in sorted array",
      "Balanced parentheses",
      "Prefix sum array",
      "Tree traversal"
    ]
  },
  {
    "q": "Which of these patterns is most suitable for string compression or decoding problems?",
    "c": null,
    "o": [
      "Stack-based parsing",
      "Two Pointers",
      "Heap",
      "Graph Traversal"
    ]
  },
  {
    "q": "Which data structure can be used to efficiently check for duplicates in a stream of data?",
    "c": null,
    "o": [
      "Set",
      "Queue",
      "Heap",
      "List"
    ]
  },
  {
    "q": "Which sorting algorithm is best suited for large datasets with mostly sorted input?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Heap Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which type of graph is most suitable for representing one-way relationships, like following on social media?",
    "c": null,
    "o": [
      "Directed Graph",
      "Undirected Graph",
      "Cyclic Graph",
      "Weighted Graph"
    ]
  },
  {
    "q": "Which algorithm is most appropriate for detecting negative weight cycles in a graph?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra's",
      "Kruskal's",
      "Prim's"
    ]
  },
  {
    "q": "Which data structure is best used for prefix-based search suggestions in a search engine?",
    "c": null,
    "o": [
      "Trie",
      "HashMap",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm is typically used in AI pathfinding for games?",
    "c": null,
    "o": [
      "A* Algorithm",
      "DFS",
      "Topological Sort",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "Which data structure would help track the minimum element in a stack in O(1) time?",
    "c": null,
    "o": [
      "Stack of pairs (value, min)",
      "Queue",
      "Trie",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm technique is useful for solving problems like 'Word Break' and 'Palindrome Partitioning'?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Two Pointer",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is best suited for a sliding window median problem?",
    "c": null,
    "o": [
      "Two Heaps (Max-Heap and Min-Heap)",
      "Deque",
      "List",
      "Set"
    ]
  },
  {
    "q": "Which is the best data structure to use for task dependency resolution?",
    "c": null,
    "o": [
      "Directed Acyclic Graph (DAG)",
      "Binary Search Tree",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which of these structures is ideal for constant-time access to recent items, like a cache?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Heap + Queue",
      "Trie + List",
      "Stack + Deque"
    ]
  },
  {
    "q": "Which data structure is optimal for real-time leaderboard updates and rank retrievals?",
    "c": null,
    "o": [
      "Balanced BST",
      "Heap",
      "Stack",
      "Trie"
    ]
  },
  {
    "q": "Which problem-solving pattern works well for 'Partition Equal Subset Sum'?",
    "c": null,
    "o": [
      "Subset Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Two Pointers"
    ]
  },
  {
    "q": "Which algorithm is typically used to find bridges and articulation points in a network?",
    "c": null,
    "o": [
      "Tarjan’s Algorithm",
      "Floyd-Warshall",
      "Kruskal’s Algorithm",
      "DFS with Memoization"
    ]
  },
  {
    "q": "Which of the following is a real-world application of a disjoint-set data structure?",
    "c": null,
    "o": [
      "Network connectivity",
      "Shortest path finding",
      "Job scheduling",
      "Autocomplete feature"
    ]
  },
  {
    "q": "Which Python library helps to implement immutable lists, sets, and maps efficiently?",
    "c": null,
    "o": [
      "immutables",
      "heapq",
      "collections",
      "bisect"
    ]
  },
  {
    "q": "Which competitive programming technique is used to compute range minimum queries efficiently?",
    "c": null,
    "o": [
      "Segment Tree",
      "Trie",
      "Stack",
      "Topological Sort"
    ]
  },
  {
    "q": "Which data structure is most suitable to implement a real-time message queue system?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Graph"
    ]
  },
  {
    "q": "Which algorithmic technique is best used to solve the 'Activity Selection Problem'?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "Which of the following structures is commonly used for representing sparse graphs efficiently?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Linked List",
      "Queue"
    ]
  },
  {
    "q": "Which type of algorithm is used in compilers for syntax checking?",
    "c": null,
    "o": [
      "Stack-based Parsing",
      "Graph Traversal",
      "Dynamic Programming",
      "Greedy Algorithm"
    ]
  },
  {
    "q": "Which of the following applications uses binary search as its core logic?",
    "c": null,
    "o": [
      "Finding square root of a number",
      "Evaluating postfix expression",
      "LRU cache eviction",
      "Cycle detection in a graph"
    ]
  },
  {
    "q": "Which of these is a real-world use case of union-find (disjoint set)?",
    "c": null,
    "o": [
      "Detecting cycles in an undirected graph",
      "Pathfinding in maps",
      "Database indexing",
      "Balancing binary trees"
    ]
  },
  {
    "q": "Which scheduling algorithm ensures shortest average waiting time in CPU scheduling?",
    "c": null,
    "o": [
      "Shortest Job First (SJF)",
      "Round Robin",
      "First Come First Serve (FCFS)",
      "Priority Scheduling"
    ]
  },
  {
    "q": "Which Python module provides efficient implementations of heap queue algorithms?",
    "c": null,
    "o": [
      "heapq",
      "bisect",
      "queue",
      "collections"
    ]
  },
  {
    "q": "Which application requires the use of a circular queue?",
    "c": null,
    "o": [
      "CPU scheduling",
      "Path traversal in graphs",
      "Depth-first search",
      "Undo-redo operations"
    ]
  },
  {
    "q": "Which algorithm is commonly used in spelling correction and search suggestions?",
    "c": null,
    "o": [
      "Levenshtein Distance",
      "KMP Algorithm",
      "Radix Sort",
      "Quickselect"
    ]
  },
  {
    "q": "Which data structure supports fast insert, delete, and search, and is commonly used in caching?",
    "c": null,
    "o": [
      "Hash Table",
      "Queue",
      "Stack",
      "Binary Tree"
    ]
  },
  {
    "q": "Which competitive programming pattern is useful for problems like 'Subarray with Sum K'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Greedy",
      "Binary Search",
      "Graph Traversal"
    ]
  },
  {
    "q": "Which is an efficient data structure for real-time event processing, like logging systems?",
    "c": null,
    "o": [
      "Deque",
      "Trie",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which real-world system uses priority queues extensively?",
    "c": null,
    "o": [
      "Operating System CPU scheduling",
      "Network topology storage",
      "File directory listing",
      "Auto-completion system"
    ]
  },
  {
    "q": "Which of these is a typical application of topological sort?",
    "c": null,
    "o": [
      "Task scheduling with dependencies",
      "Finding shortest paths",
      "Cycle detection",
      "Heap sort"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing browser history functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Graph",
      "Tree"
    ]
  },
  {
    "q": "Which algorithm is commonly used in route-finding apps like Google Maps?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which of the following is the most suitable data structure to implement a dictionary?",
    "c": null,
    "o": [
      "Hash Table",
      "List",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which of the following is a real-world use case of a Trie data structure?",
    "c": null,
    "o": [
      "Auto-completion in search engines",
      "Evaluating mathematical expressions",
      "Simulating CPU scheduling",
      "Managing heap memory"
    ]
  },
  {
    "q": "Which design pattern often appears in competitive programming problems involving nested structures?",
    "c": null,
    "o": [
      "Stack-based recursion",
      "Binary search",
      "Greedy pattern",
      "Sliding window"
    ]
  },
  {
    "q": "Which data structure would you use for an efficient LRU cache?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Array + Stack",
      "Queue + Set",
      "List + Dictionary"
    ]
  },
  {
    "q": "Which algorithm is ideal for solving shortest path problems in unweighted graphs?",
    "c": null,
    "o": [
      "Breadth First Search",
      "Depth First Search",
      "Prim's Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is used in operating systems to manage memory using paging?",
    "c": null,
    "o": [
      "Linked List",
      "Heap",
      "Queue",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm is commonly used to compress files (like ZIP)?",
    "c": null,
    "o": [
      "Huffman Coding",
      "Radix Sort",
      "Kruskal’s Algorithm",
      "Depth First Search"
    ]
  },
  {
    "q": "Which data structure is most commonly used to evaluate postfix expressions?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "List"
    ]
  },
  {
    "q": "Which of the following best describes the use of dynamic programming in competitive programming?",
    "c": null,
    "o": [
      "To solve overlapping subproblems optimally",
      "To explore all possibilities using brute-force",
      "To find shortest paths in cyclic graphs",
      "To detect loops in linked lists"
    ]
  },
  {
    "q": "Which real-world scenario is best modeled by a graph?",
    "c": null,
    "o": [
      "Social networks",
      "Customer purchase history",
      "Array sorting",
      "Stack overflow error"
    ]
  },
  {
    "q": "Which of the following algorithms is ideal for scheduling jobs with deadlines?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which competitive programming pattern helps solve 'Find the minimum window substring' problems?",
    "c": null,
    "o": [
      "Sliding Window",
      "Greedy",
      "Binary Search",
      "Two Pointers"
    ]
  },
  {
    "q": "Which data structure can help implement undo-redo operations in an editor?",
    "c": null,
    "o": [
      "Two Stacks",
      "Queue",
      "Tree",
      "Hash Table"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing task scheduling with priorities?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Set",
      "Deque"
    ]
  },
  {
    "q": "In databases, which data structure is most often used to implement indexing?",
    "c": null,
    "o": [
      "B-Tree",
      "Hash Table",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which of the following problems is best solved using a greedy algorithm?",
    "c": null,
    "o": [
      "Activity selection problem",
      "Longest common subsequence",
      "Tower of Hanoi",
      "Merge sort"
    ]
  },
  {
    "q": "Which data structure is best suited for simulating a printer queue?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "List",
      "Tree"
    ]
  },
  {
    "q": "Which algorithm helps in detecting cycles in a network of nodes?",
    "c": null,
    "o": [
      "Depth First Search",
      "Breadth First Search",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is a key reason to use a set over a list in Python?",
    "c": null,
    "o": [
      "Fast membership testing",
      "Maintains insertion order",
      "Supports indexing",
      "Consumes less memory"
    ]
  },
  {
    "q": "Which of the following data structures is useful for handling collision resolution in hash tables?",
    "c": null,
    "o": [
      "Linked List",
      "Stack",
      "Tree",
      "Queue"
    ]
  },
  {
    "q": "Which data structure is used in undo mechanisms of editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Graph",
      "Trie"
    ]
  },
  {
    "q": "Which Python library is commonly used in competitive programming for input/output optimization?",
    "c": "\nimport sys\ninput = sys.stdin.readline\n",
    "o": [
      "sys",
      "os",
      "time",
      "io"
    ]
  },
  {
    "q": "Which problem-solving pattern is commonly used in problems like 'find the first repeating character'?",
    "c": null,
    "o": [
      "Hashing",
      "Greedy",
      "Two Pointers",
      "Recursion"
    ]
  },
  {
    "q": "Which of these problems is an ideal candidate for divide and conquer?",
    "c": null,
    "o": [
      "Merge Sort",
      "0/1 Knapsack",
      "Palindrome Partitioning",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is commonly used for shortest job first (SJF) CPU scheduling?",
    "c": null,
    "o": [
      "Min Heap",
      "Queue",
      "Stack",
      "Hash Map"
    ]
  },
  {
    "q": "Which data structure can represent a file system efficiently?",
    "c": null,
    "o": [
      "Tree",
      "List",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm is best for finding strongly connected components in a network graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is an application of the Union-Find data structure?",
    "c": null,
    "o": [
      "Network connectivity checking",
      "Balanced BST operations",
      "Sorting elements",
      "Memory paging"
    ]
  },
  {
    "q": "Which data structure is most appropriate to model the social network friend connections?",
    "c": null,
    "o": [
      "Graph",
      "Tree",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is commonly used in route finding applications like Google Maps?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Binary Search",
      "Merge Sort",
      "DFS"
    ]
  },
  {
    "q": "What is the advantage of using a Trie over a hash map for word lookup?",
    "c": null,
    "o": [
      "Prefix matching is faster",
      "Uses less memory",
      "Supports sorting by default",
      "Faster insertion"
    ]
  },
  {
    "q": "Which of the following is a classic use case of dynamic programming?",
    "c": null,
    "o": [
      "Fibonacci sequence",
      "Depth First Search",
      "Sorting a list",
      "Binary search"
    ]
  },
  {
    "q": "Which data structure is preferred for parsing arithmetic expressions?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Set",
      "Graph"
    ]
  },
  {
    "q": "What is the typical application of a circular queue?",
    "c": null,
    "o": [
      "Buffer management",
      "Binary search",
      "Storing graph edges",
      "Maintaining unique elements"
    ]
  },
  {
    "q": "Which competitive programming pattern uses two indexes to traverse an array efficiently?",
    "c": null,
    "o": [
      "Two pointers",
      "Greedy",
      "Backtracking",
      "Divide and conquer"
    ]
  },
  {
    "q": "Which data structure is ideal for storing a fixed-length sliding window over a stream of data?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Set",
      "Tree"
    ]
  },
  {
    "q": "Which of the following is a practical use of hashing?",
    "c": null,
    "o": [
      "Database indexing",
      "Balanced BST creation",
      "Graph traversal",
      "Recursion tracking"
    ]
  },
  {
    "q": "Which algorithm is suitable for building a network with minimal total connection cost?",
    "c": null,
    "o": [
      "Prim's Algorithm",
      "Floyd-Warshall Algorithm",
      "DFS",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which of the following data structures is suitable for autocomplete suggestions?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which is the best data structure to implement LRU (Least Recently Used) cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "List",
      "Set",
      "Queue"
    ]
  },
  {
    "q": "Which technique is useful in solving problems like trapping rain water and histogram area?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Graph",
      "Hash Map"
    ]
  },
  {
    "q": "Which scheduling algorithm uses Round Robin logic?",
    "c": null,
    "o": [
      "Circular Queue",
      "Min Heap",
      "Stack",
      "Linked List"
    ]
  },
  {
    "q": "Which data structure can help in managing dynamic memory allocation efficiently?",
    "c": null,
    "o": [
      "Binary Heap",
      "Graph",
      "Set",
      "Deque"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing undo functionality in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Graph",
      "Heap"
    ]
  },
  {
    "q": "In competitive programming, which technique is commonly used to solve problems involving subarrays with fixed-size windows?",
    "c": null,
    "o": [
      "Sliding window",
      "Recursion",
      "Backtracking",
      "Union-Find"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing a job scheduler?",
    "c": null,
    "o": [
      "Priority Queue",
      "Hash Map",
      "Stack",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm is suitable for detecting cycles in an undirected graph?",
    "c": null,
    "o": [
      "Union-Find",
      "Topological Sort",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is often used to detect duplicates within a set of elements efficiently?",
    "c": null,
    "o": [
      "Hash Set",
      "Stack",
      "Queue",
      "Binary Tree"
    ]
  },
  {
    "q": "Which technique is useful in problems involving multiple overlapping subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "DFS",
      "Greedy",
      "Sliding Window"
    ]
  },
  {
    "q": "Which data structure is used for simulating recursion without actual function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Graph"
    ]
  },
  {
    "q": "Which pattern is commonly used to solve problems like ‘maximum sum subarray of size k’?",
    "c": null,
    "o": [
      "Sliding window",
      "Greedy",
      "DFS",
      "Recursion"
    ]
  },
  {
    "q": "Which algorithm is most efficient for finding the shortest path in a graph with negative weights?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra",
      "Prim",
      "Kruskal"
    ]
  },
  {
    "q": "Which is the most suitable data structure to implement browser history?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Graph"
    ]
  },
  {
    "q": "Which data structure is suitable for efficiently storing and retrieving hierarchical data like folder structures?",
    "c": null,
    "o": [
      "Tree",
      "Hash Table",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "In a compiler, which data structure is often used to match parentheses or tags?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Set",
      "Graph"
    ]
  },
  {
    "q": "Which of the following is a real-world application of BFS?",
    "c": null,
    "o": [
      "Finding shortest path in unweighted graphs",
      "Expression evaluation",
      "Parsing nested expressions",
      "Cycle detection in directed graphs"
    ]
  },
  {
    "q": "Which algorithm can be used to solve the problem of finding connected components in a graph?",
    "c": null,
    "o": [
      "DFS",
      "Heap Sort",
      "Hashing",
      "Trie traversal"
    ]
  },
  {
    "q": "Which of these structures is most efficient for constant time insertion, deletion, and lookup?",
    "c": null,
    "o": [
      "Hash Table",
      "List",
      "Stack",
      "Tree"
    ]
  },
  {
    "q": "Which data structure is used in Dijkstra’s algorithm to select the next node with the smallest tentative distance?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Hash Map",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithmic pattern is used in problems like finding all subsets of a set?",
    "c": null,
    "o": [
      "Backtracking",
      "Sliding Window",
      "Greedy",
      "Union-Find"
    ]
  },
  {
    "q": "What data structure is commonly used to implement a cache with fast access and eviction policy?",
    "c": null,
    "o": [
      "HashMap with Doubly Linked List",
      "Array",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is best suited for building a network routing table with shortest paths?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "Which pattern is used in problems like 'Find the longest substring with k distinct characters'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Recursion",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which real-world application uses a Trie data structure?",
    "c": null,
    "o": [
      "Auto-complete search suggestions",
      "Page replacement algorithms",
      "Sorting large files",
      "Image compression"
    ]
  },
  {
    "q": "Which data structure is most efficient for maintaining the median of a dynamic data stream?",
    "c": null,
    "o": [
      "Two Heaps (Min-Heap and Max-Heap)",
      "Queue",
      "Stack",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which pattern is generally used in problems that involve checking multiple paths or permutations?",
    "c": null,
    "o": [
      "Backtracking",
      "Sliding Window",
      "Greedy",
      "Memoization"
    ]
  },
  {
    "q": "Which data structure is ideal for applications like LRU (Least Recently Used) Cache?",
    "c": null,
    "o": [
      "Doubly Linked List with Hash Map",
      "Queue with Stack",
      "Priority Queue with TreeMap",
      "Simple Array"
    ]
  },
  {
    "q": "Which application is most likely to use a circular queue?",
    "c": null,
    "o": [
      "CPU Task Scheduling",
      "Autocomplete Suggestions",
      "Tree Traversal",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure would you use to build a search engine’s index of web pages?",
    "c": null,
    "o": [
      "Hash Table",
      "Queue",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which pattern is used in problems that involve finding the k-th smallest or largest elements?",
    "c": null,
    "o": [
      "Heap-based Selection",
      "Dynamic Programming",
      "DFS",
      "Hashing"
    ]
  },
  {
    "q": "What type of data structure is most suitable for implementing a compiler’s syntax tree?",
    "c": null,
    "o": [
      "Tree",
      "Queue",
      "HashMap",
      "Heap"
    ]
  },
  {
    "q": "Which data structure is used by network routers to determine the shortest path to the destination?",
    "c": null,
    "o": [
      "Graph",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which pattern is most effective for reducing redundant calculations in recursive algorithms?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy",
      "Backtracking",
      "Sliding Window"
    ]
  },
  {
    "q": "Which data structure is most suitable for evaluating expressions using infix to postfix conversion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which real-world system would benefit most from using a graph data structure?",
    "c": null,
    "o": [
      "Social Network Friend Recommendations",
      "Online Shopping Cart",
      "Restaurant Billing System",
      "Text Editor"
    ]
  },
  {
    "q": "Which algorithmic technique is most suitable for solving the '0/1 Knapsack Problem'?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Backtracking",
      "Greedy",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is useful for representing hierarchical data like file systems?",
    "c": null,
    "o": [
      "Tree",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which competitive programming pattern is best suited for 'search in a rotated sorted array'?",
    "c": null,
    "o": [
      "Binary Search",
      "DFS",
      "BFS",
      "Sliding Window"
    ]
  },
  {
    "q": "Which of the following is commonly used for job scheduling systems like cron?",
    "c": null,
    "o": [
      "Priority Queue",
      "Hash Table",
      "Linked List",
      "Graph"
    ]
  },
  {
    "q": "Which data structure is best for handling undo operations in software applications?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Heap"
    ]
  },
  {
    "q": "Which technique is used to solve problems involving overlapping subproblems and optimal substructure?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Depth First Search",
      "Brute Force"
    ]
  },
  {
    "q": "What is the best data structure for implementing a real-time event queue?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Trie"
    ]
  },
  {
    "q": "Which pattern is used in problems like ‘maximum subarray sum’?",
    "c": null,
    "o": [
      "Kadane’s Algorithm",
      "Sliding Window",
      "Backtracking",
      "Binary Search"
    ]
  },
  {
    "q": "Which of these structures is most appropriate for implementing adjacency lists in graphs?",
    "c": null,
    "o": [
      "HashMap of Lists",
      "2D Array",
      "Stack of Queues",
      "Simple List"
    ]
  },
  {
    "q": "Which problem would benefit most from a union-find (disjoint set) data structure?",
    "c": null,
    "o": [
      "Cycle Detection in Undirected Graphs",
      "Finding All Permutations",
      "String Reversal",
      "Matrix Multiplication"
    ]
  },
  {
    "q": "Which of the following best describes how a hash table is used in database indexing?",
    "c": null,
    "o": [
      "To provide fast key-based access to records",
      "To maintain sorted order of records",
      "To link one table to another",
      "To store historical backups"
    ]
  },
  {
    "q": "Which algorithmic pattern is useful for solving maze and pathfinding problems?",
    "c": null,
    "o": [
      "Breadth-First Search",
      "Sliding Window",
      "Backtracking",
      "Kadane’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is typically used to implement a spell checker or dictionary lookup?",
    "c": null,
    "o": [
      "Trie",
      "Queue",
      "Graph",
      "Stack"
    ]
  },
  {
    "q": "Which data structure is most efficient for checking the existence of an item in constant time?",
    "c": null,
    "o": [
      "Hash Set",
      "List",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the shortest path in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "DFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is typically used to implement recursive function calls internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Tree"
    ]
  },
  {
    "q": "Which scheduling algorithm is used by many operating systems to decide which process to run next?",
    "c": null,
    "o": [
      "Priority Queue",
      "Hash Map",
      "Stack",
      "Linked List"
    ]
  },
  {
    "q": "Which of the following competitive programming problems would benefit from the two-pointer technique?",
    "c": null,
    "o": [
      "Finding a pair with a given sum in a sorted array",
      "Cycle detection in a graph",
      "Balanced parentheses check",
      "Shortest path in weighted graph"
    ]
  },
  {
    "q": "Which structure is commonly used to store a routing table in networking systems?",
    "c": null,
    "o": [
      "Trie",
      "Array",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm is commonly used for compressing data in real-world applications?",
    "c": null,
    "o": [
      "Huffman Coding",
      "Kruskal’s Algorithm",
      "Binary Search",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is best used in a browser’s forward and backward navigation?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Set",
      "Graph"
    ]
  },
  {
    "q": "Which type of tree is used in databases to maintain sorted data and allow for efficient insertion, deletion, and search?",
    "c": null,
    "o": [
      "B-Tree",
      "Binary Search Tree",
      "AVL Tree",
      "Heap"
    ]
  },
  {
    "q": "Which real-world application uses heaps or priority queues heavily?",
    "c": null,
    "o": [
      "Task Scheduling",
      "Auto-complete Suggestion",
      "Text Editor",
      "Image Processing"
    ]
  },
  {
    "q": "Which algorithm is used to detect negative cycles in a graph?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is an efficient strategy for solving problems involving substrings and patterns?",
    "c": null,
    "o": [
      "Sliding Window",
      "Recursion",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "Which application would benefit most from using a circular queue?",
    "c": null,
    "o": [
      "CPU Scheduling",
      "Expression Parsing",
      "Undo Operations",
      "HTML Tag Validation"
    ]
  },
  {
    "q": "Which algorithmic technique is commonly used in ‘coin change’ and ‘edit distance’ problems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Backtracking",
      "Greedy"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing autocomplete in search engines?",
    "c": null,
    "o": [
      "Trie",
      "Hash Map",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing undo functionality in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Graph",
      "Set"
    ]
  },
  {
    "q": "Which algorithmic strategy is often used in solving problems like ‘0/1 Knapsack’ and ‘Longest Common Subsequence’?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following would be best for implementing a cache with O(1) lookup and insertion time?",
    "c": null,
    "o": [
      "Hash Map",
      "Queue",
      "Stack",
      "Tree"
    ]
  },
  {
    "q": "Which data structure is most suitable for solving the 'Job Scheduling with Deadlines' problem?",
    "c": null,
    "o": [
      "Disjoint Set",
      "Queue",
      "Hash Table",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which pattern is commonly used in competitive programming for problems involving finding peaks or minimum in rotated sorted arrays?",
    "c": null,
    "o": [
      "Binary Search",
      "Greedy",
      "Backtracking",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which algorithm is commonly used in GPS navigation systems to calculate the shortest path?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "DFS",
      "Bellman-Ford",
      "A* with DFS"
    ]
  },
  {
    "q": "Which data structure is typically used to implement LRU cache efficiently?",
    "c": null,
    "o": [
      "Doubly Linked List + Hash Map",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is best suited for scenarios where frequent insertions and deletions occur at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Priority Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is most suitable for detecting cycles in an undirected graph?",
    "c": null,
    "o": [
      "Union-Find",
      "DFS",
      "BFS",
      "Dijkstra"
    ]
  },
  {
    "q": "Which of the following techniques is commonly used to optimize recursive problems with overlapping subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy",
      "Binary Search",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is used by operating systems to manage memory and file systems efficiently?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which data structure is typically used in a browser to track the order of visited websites?",
    "c": null,
    "o": [
      "Stack",
      "Deque",
      "Priority Queue",
      "Set"
    ]
  },
  {
    "q": "Which competitive programming pattern is best for solving problems where you need to process elements in sorted order efficiently?",
    "c": null,
    "o": [
      "Two Heaps",
      "Union Find",
      "Sliding Window",
      "DFS Traversal"
    ]
  },
  {
    "q": "Which of these problems is best solved using backtracking?",
    "c": null,
    "o": [
      "N-Queens",
      "Shortest Path",
      "Search in Rotated Array",
      "Array Rotation"
    ]
  },
  {
    "q": "Which of these algorithms is generally best for real-time shortest path computation with frequent updates?",
    "c": null,
    "o": [
      "A* Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a task scheduler with priority levels?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Deque",
      "Hash Map"
    ]
  },
  {
    "q": "Which data structure would be most efficient for checking the existence of an item in constant time?",
    "c": null,
    "o": [
      "Hash Set",
      "Array",
      "Linked List",
      "Queue"
    ]
  },
  {
    "q": "In which scenario would you typically use a Trie data structure?",
    "c": null,
    "o": [
      "Auto-completion and dictionary search",
      "Sorting numbers",
      "Balancing an expression",
      "Evaluating arithmetic expressions"
    ]
  },
  {
    "q": "Which of the following algorithms is commonly used in real-time systems to schedule jobs based on deadlines?",
    "c": null,
    "o": [
      "Earliest Deadline First",
      "Round Robin",
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "Which competitive programming technique is useful for solving 'Largest Subarray with Sum K' type problems?",
    "c": null,
    "o": [
      "Prefix Sum",
      "DFS",
      "Binary Search",
      "Union-Find"
    ]
  },
  {
    "q": "Which data structure is used to represent social networks where each user is connected to others?",
    "c": null,
    "o": [
      "Graph",
      "Tree",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is most suitable for finding connected components in an undirected graph?",
    "c": null,
    "o": [
      "Depth First Search",
      "Binary Search",
      "Kruskal’s Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "Which data structure is commonly used in compilers to evaluate expressions?",
    "c": null,
    "o": [
      "Stack",
      "Heap",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which of the following is the best approach to handle frequent range sum queries efficiently?",
    "c": null,
    "o": [
      "Segment Tree",
      "Array",
      "Hash Map",
      "Stack"
    ]
  },
  {
    "q": "Which competitive programming pattern helps in problems like 'Next Greater Element'?",
    "c": null,
    "o": [
      "Monotonic Stack",
      "Sliding Window",
      "DFS",
      "Heap"
    ]
  },
  {
    "q": "Which data structure is used in GPS navigation to represent the map of cities and roads?",
    "c": null,
    "o": [
      "Graph",
      "Heap",
      "Tree",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm is most efficient for cycle detection in a directed graph?",
    "c": null,
    "o": [
      "Tarjan’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is ideal for real-time collaborative editing (like Google Docs)?",
    "c": null,
    "o": [
      "Operational Transformation (OT) with Double-Linked Lists",
      "Queue",
      "Array",
      "Stack"
    ]
  },
  {
    "q": "Which technique is often used in solving problems like 'Find all anagrams in a string'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Binary Search",
      "Union Find",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which of these algorithms is best suited for minimizing the cost to connect all nodes in a network?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "DFS",
      "Binary Search",
      "A* Algorithm"
    ]
  },
  {
    "q": "Which of the following data structures is most appropriate for implementing a browser's back and forward button functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Map",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is commonly used by GPS systems to find the shortest route between two locations?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Binary Search",
      "Prim's Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which data structure would best model an undo feature in a text editor?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Hash Table"
    ]
  },
  {
    "q": "Which algorithmic pattern is typically used in solving problems like 'Maximum sum of subarray of size K'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Dynamic Programming",
      "Greedy",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is commonly used for implementing LRU (Least Recently Used) cache?",
    "c": null,
    "o": [
      "Hash Map + Doubly Linked List",
      "Stack",
      "Queue",
      "Min Heap"
    ]
  },
  {
    "q": "Which of the following algorithms is useful in networking to determine the best path for data packets?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Quick Sort",
      "DFS",
      "Topological Sort"
    ]
  },
  {
    "q": "Which competitive programming technique helps solve the 'Coin Change' problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Sliding Window",
      "Greedy",
      "Prefix Sum"
    ]
  },
  {
    "q": "Which of the following data structures provides the fastest average-case time complexity for lookup operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Binary Search Tree",
      "Array",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is best for detecting cycles in an undirected graph?",
    "c": null,
    "o": [
      "Union-Find",
      "BFS",
      "Binary Search",
      "Floyd-Warshall"
    ]
  },
  {
    "q": "Which pattern is used in problems that involve making a sequence of decisions and choosing the best one?",
    "c": null,
    "o": [
      "Greedy",
      "Divide and Conquer",
      "Two Pointers",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following problems is best solved using a Hash Map?",
    "c": null,
    "o": [
      "Counting word frequency",
      "Finding shortest path",
      "Balancing parentheses",
      "Sorting numbers"
    ]
  },
  {
    "q": "Which data structure is most efficient for storing a list of items and frequently adding/removing items from both ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Array",
      "Queue"
    ]
  },
  {
    "q": "Which of the following is used for pattern matching in strings?",
    "c": null,
    "o": [
      "KMP Algorithm",
      "Dijkstra’s Algorithm",
      "Union-Find",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is best suited for checking if a string has balanced parentheses?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which algorithmic strategy is typically used in scheduling problems like 'Job Scheduling with Deadlines'?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "DFS",
      "Breadth-First Search"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a task scheduler where tasks must be executed in order of their deadlines?",
    "c": null,
    "o": [
      "Min Heap",
      "Stack",
      "Hash Map",
      "Graph"
    ]
  },
  {
    "q": "Which of the following real-world problems is best modeled using a graph data structure?",
    "c": null,
    "o": [
      "Social network relationships",
      "Sorting a list",
      "Finding a palindrome",
      "Binary search"
    ]
  },
  {
    "q": "Which competitive programming technique is commonly used in problems involving overlapping subproblems and optimal substructure?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Two Pointers",
      "Recursion"
    ]
  },
  {
    "q": "In which scenario would you use a priority queue?",
    "c": null,
    "o": [
      "Task execution based on priority",
      "Storing unique elements only",
      "Backtracking a maze",
      "Fixed-size sliding window"
    ]
  },
  {
    "q": "Which algorithm is suitable for finding the shortest path in a graph with negative weights?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra's Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "What is the typical use case of a Trie data structure?",
    "c": null,
    "o": [
      "Auto-completion of words",
      "Finding shortest path",
      "Sorting numbers",
      "Managing memory"
    ]
  },
  {
    "q": "Which pattern is used when you try to find a specific pair in a sorted array that adds to a given value?",
    "c": null,
    "o": [
      "Two Pointers",
      "Backtracking",
      "Sliding Window",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which of the following scenarios would require the use of a Disjoint Set (Union-Find) structure?",
    "c": null,
    "o": [
      "Detecting cycles in a graph",
      "Finding prime numbers",
      "Sorting linked lists",
      "Balancing a binary tree"
    ]
  },
  {
    "q": "Which type of graph traversal is used in topological sorting?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s Algorithm",
      "A* Search"
    ]
  },
  {
    "q": "Which of the following best describes the use of hash tables in databases?",
    "c": null,
    "o": [
      "Indexing for fast lookups",
      "Managing disk storage",
      "Memory compaction",
      "Data encryption"
    ]
  },
  {
    "q": "Which of these patterns is most often used in competitive programming for solving problems like 'Longest Substring Without Repeating Characters'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Backtracking",
      "Dynamic Programming",
      "Graph Traversal"
    ]
  },
  {
    "q": "Which data structure allows fast lookup, insertion, and deletion of key-value pairs?",
    "c": null,
    "o": [
      "Hash Map",
      "Stack",
      "Array",
      "Heap"
    ]
  },
  {
    "q": "Which scheduling algorithm prioritizes the shortest job first?",
    "c": null,
    "o": [
      "SJF (Shortest Job First)",
      "FCFS (First Come First Serve)",
      "Round Robin",
      "Priority Scheduling"
    ]
  },
  {
    "q": "What is the best data structure for autocomplete search where a user types the first few letters?",
    "c": null,
    "o": [
      "Trie",
      "Hash Map",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which real-world system most likely uses a queue data structure?",
    "c": null,
    "o": [
      "Print job scheduling",
      "Undo operation in text editor",
      "Symbol matching in compiler",
      "Phone contacts search"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing a LRU (Least Recently Used) cache?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Array",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "In a web browser, which data structure is best used to implement the 'Back' and 'Forward' navigation?",
    "c": null,
    "o": [
      "Two Stacks",
      "Queue",
      "Graph",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm is commonly used by GPS systems to find the shortest route between two locations?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "Which of the following applications is best suited for the sliding window technique?",
    "c": null,
    "o": [
      "Finding the maximum sum of a subarray of size k",
      "Balancing a binary tree",
      "Detecting graph cycles",
      "Building a trie"
    ]
  },
  {
    "q": "Which real-world application commonly uses heaps?",
    "c": null,
    "o": [
      "Priority queue implementation",
      "Web page rendering",
      "Autocomplete feature",
      "URL shortening"
    ]
  },
  {
    "q": "Which pattern is useful for solving problems like 'maximum profit from stock prices with at most k transactions'?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which of the following real-world systems most likely uses a circular queue?",
    "c": null,
    "o": [
      "CPU Scheduling",
      "Airline Ticket Booking",
      "Bank Transaction History",
      "Online Chat Log"
    ]
  },
  {
    "q": "In which situation would a graph with weighted edges be used in practice?",
    "c": null,
    "o": [
      "Modeling road networks for navigation systems",
      "Storing user credentials",
      "Queueing customer support tickets",
      "Sorting product prices"
    ]
  },
  {
    "q": "Which approach is best suited for solving maze and puzzle-related problems in competitive programming?",
    "c": null,
    "o": [
      "Backtracking",
      "Two Pointers",
      "Hashing",
      "Bit Manipulation"
    ]
  },
  {
    "q": "Which of the following data structures is most appropriate for implementing a word dictionary with fast prefix search?",
    "c": null,
    "o": [
      "Trie",
      "Hash Map",
      "Heap",
      "Stack"
    ]
  },
  {
    "q": "Which problem-solving pattern is most effective for 'Partition Equal Subset Sum' and similar subset problems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Binary Search",
      "Greedy",
      "Sliding Window"
    ]
  },
  {
    "q": "Which of these real-world systems is most likely to use a graph with nodes and weighted edges?",
    "c": null,
    "o": [
      "Transportation networks",
      "Cloud storage",
      "Authentication systems",
      "Version control"
    ]
  },
  {
    "q": "Which of the following is most suitable for real-time shortest job execution in an operating system?",
    "c": null,
    "o": [
      "Min Heap",
      "Max Heap",
      "Linked List",
      "Array"
    ]
  },
  {
    "q": "Which pattern is commonly used in string matching algorithms like KMP and Rabin-Karp?",
    "c": null,
    "o": [
      "Pattern Matching with Preprocessing",
      "Sliding Window",
      "Two Pointers",
      "Recursion"
    ]
  },
  {
    "q": "Which application is most likely to benefit from Disjoint Set Union (DSU)?",
    "c": null,
    "o": [
      "Network connectivity checks",
      "Task scheduling",
      "Memory allocation",
      "Message encryption"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing an autocomplete feature in search engines?",
    "c": null,
    "o": [
      "Trie",
      "Hash Table",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is typically used in map applications for finding optimal routes?",
    "c": null,
    "o": [
      "A* Search Algorithm",
      "Binary Search",
      "Depth First Search",
      "Merge Sort"
    ]
  },
  {
    "q": "Which data structure is used in a social network to represent friend suggestions?",
    "c": null,
    "o": [
      "Graph",
      "Array",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which technique is best suited for solving 'Find the First Missing Positive' problem in O(n) time?",
    "c": null,
    "o": [
      "Index Mapping with In-Place Rearrangement",
      "Dynamic Programming",
      "Greedy",
      "DFS Traversal"
    ]
  },
  {
    "q": "Which real-world application commonly uses the union-find algorithm?",
    "c": null,
    "o": [
      "Detecting cycles in a network",
      "Database transactions",
      "Stock price prediction",
      "Compiling code"
    ]
  },
  {
    "q": "Which competitive programming pattern solves problems like 'Subarray with Sum K' efficiently?",
    "c": null,
    "o": [
      "Prefix Sum with HashMap",
      "Two Pointers",
      "Backtracking",
      "Sorting and Binary Search"
    ]
  },
  {
    "q": "What kind of data structure is ideal for implementing undo functionality in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm is most suitable for job scheduling problems with deadlines and profits?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Backtracking",
      "Dynamic Programming",
      "Recursion"
    ]
  },
  {
    "q": "Which data structure is suitable for representing relationships in a recommendation engine?",
    "c": null,
    "o": [
      "Graph",
      "Set",
      "Array",
      "Stack"
    ]
  },
  {
    "q": "Which real-world problem would benefit most from the segment tree data structure?",
    "c": null,
    "o": [
      "Range queries and updates in large datasets",
      "Undo/Redo operations",
      "Maintaining browser history",
      "Storing user profiles"
    ]
  },
  {
    "q": "Which pattern helps in solving 'Longest Substring Without Repeating Characters' efficiently?",
    "c": null,
    "o": [
      "Sliding Window",
      "Divide and Conquer",
      "Backtracking",
      "DFS"
    ]
  },
  {
    "q": "Which of the following applications is likely to use a min heap internally?",
    "c": null,
    "o": [
      "Event-driven simulation systems",
      "LRU cache",
      "Undo history manager",
      "Text search system"
    ]
  },
  {
    "q": "Which competitive programming pattern is best used for solving 'Combination Sum' problems?",
    "c": null,
    "o": [
      "Backtracking",
      "Binary Search",
      "Sliding Window",
      "Greedy"
    ]
  },
  {
    "q": "Which pattern helps to avoid recalculating overlapping subproblems in recursive solutions?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy",
      "Bitmasking",
      "Two Pointers"
    ]
  },
  {
    "q": "Which application commonly uses a deque (double-ended queue)?",
    "c": null,
    "o": [
      "Sliding window maximum",
      "Autocomplete",
      "Undo functionality",
      "Network routing"
    ]
  },
  {
    "q": "Which data structure is optimal for storing a dynamic leaderboard with frequent insertions and range queries?",
    "c": null,
    "o": [
      "Binary Indexed Tree (Fenwick Tree)",
      "Array",
      "Stack",
      "Hash Map"
    ]
  },
  {
    "q": "In a messaging app, which data structure is ideal for storing messages in the order they arrive?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Hash Table",
      "Heap"
    ]
  },
  {
    "q": "Which data structure is typically used to implement browser forward and backward navigation?",
    "c": null,
    "o": [
      "Two Stacks",
      "Linked List",
      "Priority Queue",
      "Hash Set"
    ]
  },
  {
    "q": "What is the best data structure to efficiently implement a cache with a fixed size and fast lookups?",
    "c": null,
    "o": [
      "Hash Map with Doubly Linked List",
      "Stack",
      "Queue",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm is frequently used for task scheduling with dependency constraints?",
    "c": null,
    "o": [
      "Topological Sort",
      "Binary Search",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "Which competitive programming pattern is useful for optimizing nested loops in 2D prefix sum problems?",
    "c": null,
    "o": [
      "Prefix Sum and Inclusion-Exclusion",
      "Two Pointers",
      "Backtracking",
      "Binary Search"
    ]
  },
  {
    "q": "Which real-world problem is best modeled using the Disjoint Set Union (DSU) structure?",
    "c": null,
    "o": [
      "Network connectivity detection",
      "Browser navigation",
      "Scheduling tasks",
      "Database indexing"
    ]
  },
  {
    "q": "What data structure is typically used to implement a priority queue in real-time task schedulers?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Linked List",
      "Set"
    ]
  },
  {
    "q": "What is the primary use of a trie in search engines?",
    "c": null,
    "o": [
      "Efficient prefix matching",
      "Sorting results",
      "Detecting loops",
      "Balancing search trees"
    ]
  },
  {
    "q": "Which algorithm is best for finding all possible schedules given time conflicts between tasks?",
    "c": null,
    "o": [
      "Backtracking",
      "Dijkstra’s Algorithm",
      "Flood Fill",
      "Divide and Conquer"
    ]
  },
  {
    "q": "What technique helps in solving knapsack-related problems efficiently?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Depth First Search",
      "Topological Sort"
    ]
  },
  {
    "q": "Which competitive programming pattern is used in problems like 'Maximum in Sliding Window'?",
    "c": null,
    "o": [
      "Monotonic Queue",
      "Binary Search Tree",
      "Prefix Sum",
      "DFS with Memoization"
    ]
  },
  {
    "q": "Which of the following is a use case for a hash table in a compiler?",
    "c": null,
    "o": [
      "Symbol table for variable lookups",
      "Call stack tracing",
      "Memory paging",
      "Register allocation"
    ]
  },
  {
    "q": "Which algorithm helps determine if all courses can be finished given prerequisites?",
    "c": null,
    "o": [
      "Topological Sorting",
      "Binary Search",
      "Quick Sort",
      "DFS with Memoization"
    ]
  },
  {
    "q": "Which competitive programming pattern can be used to solve 'Container with Most Water' problem?",
    "c": null,
    "o": [
      "Two Pointers",
      "Backtracking",
      "Sliding Window",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing autocomplete features?",
    "c": null,
    "o": [
      "Trie",
      "Stack",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which of the following algorithms is commonly used in GPS navigation systems?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Binary Search",
      "Floyd-Warshall Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "Which data structure is used in a load balancer to manage servers in round-robin fashion?",
    "c": null,
    "o": [
      "Circular Queue",
      "Priority Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "Which algorithm is best suited for detecting cycles in a directed graph?",
    "c": null,
    "o": [
      "Depth First Search (DFS)",
      "Breadth First Search (BFS)",
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which pattern is useful in solving problems like 'Longest Substring Without Repeating Characters'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Divide and Conquer",
      "Binary Search",
      "Greedy Algorithm"
    ]
  },
  {
    "q": "Which real-world application would benefit most from a priority queue?",
    "c": null,
    "o": [
      "Operating system task scheduling",
      "Storing website cookies",
      "Implementing undo-redo functionality",
      "Storing student records"
    ]
  },
  {
    "q": "Which data structure is often used in spam detection systems to check for the presence of specific words?",
    "c": null,
    "o": [
      "Hash Set",
      "Stack",
      "Priority Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which of the following is a practical use of backtracking?",
    "c": null,
    "o": [
      "Solving Sudoku puzzles",
      "Database normalization",
      "HTML rendering",
      "Memory management"
    ]
  },
  {
    "q": "Which competitive programming pattern is most suitable for solving problems involving pathfinding with constraints?",
    "c": null,
    "o": [
      "Breadth First Search (BFS)",
      "Two Pointers",
      "Sliding Window",
      "Recursion with Memoization"
    ]
  },
  {
    "q": "Which data structure provides the best performance for finding the median in a dynamic set of integers?",
    "c": null,
    "o": [
      "Two Heaps (Min-Heap and Max-Heap)",
      "Hash Table",
      "Linked List",
      "Array"
    ]
  },
  {
    "q": "Which of the following data structures is most useful in directory navigation systems (like file systems)?",
    "c": null,
    "o": [
      "Tree",
      "Stack",
      "Queue",
      "Array"
    ]
  },
  {
    "q": "Which algorithm is commonly used in social networks to find the shortest path between people?",
    "c": null,
    "o": [
      "Breadth First Search (BFS)",
      "Depth First Search (DFS)",
      "Kruskal’s Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is suitable for implementing an LRU (Least Recently Used) Cache?",
    "c": null,
    "o": [
      "Doubly Linked List with Hash Map",
      "Stack with Array",
      "Circular Queue",
      "Min Heap"
    ]
  },
  {
    "q": "Which competitive programming pattern is most applicable for solving 'Subset Sum' or '0/1 Knapsack' problems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Two Pointers",
      "Binary Search"
    ]
  },
  {
    "q": "Which algorithm helps in resolving deadlock detection in operating systems using resource allocation graphs?",
    "c": null,
    "o": [
      "Cycle Detection using DFS",
      "Topological Sort",
      "Dijkstra’s Algorithm",
      "Flood Fill"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing browser history navigation?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which of the following is the most appropriate data structure for implementing an undo feature?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Hash Map"
    ]
  },
  {
    "q": "Which algorithm is commonly used for network routing protocols like OSPF?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "A* Algorithm"
    ]
  },
  {
    "q": "What data structure is typically used in BFS traversal?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Heap"
    ]
  },
  {
    "q": "Which data structure allows fast access to frequently searched items using frequency counts?",
    "c": null,
    "o": [
      "Self-Organizing List",
      "Queue",
      "Stack",
      "Array"
    ]
  },
  {
    "q": "Which real-world system heavily uses graph data structures?",
    "c": null,
    "o": [
      "Navigation Systems",
      "Banking Systems",
      "E-commerce Recommendation Engine",
      "Hospital Management"
    ]
  },
  {
    "q": "Which algorithm pattern would you use to solve the problem of detecting if two words are anagrams?",
    "c": null,
    "o": [
      "Hashing",
      "Sliding Window",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is used to implement recursive function calls internally in programming languages?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Linked List"
    ]
  },
  {
    "q": "In a task scheduling system where tasks have priorities, which data structure is ideal?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Deque",
      "Hash Table"
    ]
  },
  {
    "q": "Which algorithm is preferred for solving mazes and puzzle problems like the rat in a maze?",
    "c": null,
    "o": [
      "Backtracking",
      "BFS",
      "Kruskal’s Algorithm",
      "Greedy Algorithm"
    ]
  },
  {
    "q": "Which data structure is best suited for detecting duplicate elements in a list efficiently?",
    "c": null,
    "o": [
      "Hash Set",
      "Array",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which approach is useful for solving 'Find the first missing positive integer'?",
    "c": null,
    "o": [
      "Index Mapping / Cyclic Sort",
      "Binary Search",
      "Two Pointers",
      "Greedy Algorithm"
    ]
  },
  {
    "q": "What is the best data structure for a contact list with quick insertions and prefix searches?",
    "c": null,
    "o": [
      "Trie",
      "Linked List",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which competitive programming pattern is used in problems like 'Trapping Rain Water'?",
    "c": null,
    "o": [
      "Two Pointers",
      "Greedy",
      "Recursion",
      "DFS"
    ]
  },
  {
    "q": "Which algorithm is most effective for finding the minimal cost path with heuristics?",
    "c": null,
    "o": [
      "A* Search Algorithm",
      "DFS",
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a task scheduler where tasks are executed based on their arrival time?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Set"
    ]
  },
  {
    "q": "Which data structure would you use for efficiently implementing an autocomplete system?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Hash Table",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm is suitable for job scheduling problems with deadlines and profits?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "What is the best data structure to store hierarchical data like file systems?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which data structure is used to store adjacency information in a sparse graph?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Heap",
      "Stack"
    ]
  },
  {
    "q": "Which algorithmic technique is best for solving problems like the 0/1 Knapsack Problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "What is the best data structure to find the median from a stream of numbers?",
    "c": null,
    "o": [
      "Heaps (Max-Heap + Min-Heap)",
      "Queue",
      "Deque",
      "Linked List"
    ]
  },
  {
    "q": "Which competitive programming pattern is applied in problems like 'Maximum Subarray Sum'?",
    "c": null,
    "o": [
      "Kadane’s Algorithm",
      "Prefix Sum",
      "Sliding Window",
      "Two Pointers"
    ]
  },
  {
    "q": "Which of these is a real-world use case of a hash table?",
    "c": null,
    "o": [
      "Implementing caches and lookups",
      "Rendering 3D objects",
      "Sorting arrays",
      "Storing call stack"
    ]
  },
  {
    "q": "Which pattern helps solve problems like 'Find All Anagrams in a String'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Dynamic Programming",
      "Binary Search",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is ideal for storing IP routing tables where prefixes need to be matched?",
    "c": null,
    "o": [
      "Trie",
      "Graph",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which technique is commonly used in detecting cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with visited and recursion stack",
      "BFS with parent tracking",
      "Dijkstra’s algorithm",
      "Prim’s algorithm"
    ]
  },
  {
    "q": "Which data structure is useful in modeling flight routes between cities?",
    "c": null,
    "o": [
      "Graph",
      "Tree",
      "Stack",
      "Hash Table"
    ]
  },
  {
    "q": "In which type of problems is the Disjoint Set Union (DSU) data structure typically used?",
    "c": null,
    "o": [
      "Network connectivity and Kruskal’s algorithm",
      "Shortest path problems",
      "Stack-based recursion",
      "Expression evaluation"
    ]
  },
  {
    "q": "Which data structure provides amortized constant time for insertion, deletion, and search?",
    "c": null,
    "o": [
      "Hash Table",
      "Linked List",
      "Queue",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing a web browser's back and forward functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which of the following is the best data structure to detect duplicate entries in a list of names?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Stack",
      "Tuple"
    ]
  },
  {
    "q": "Which data structure is typically used in operating systems for process scheduling?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm would be most appropriate for finding the shortest path in a road map network?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "DFS",
      "Kruskal's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "Which competitive programming pattern is best used when a problem involves choosing or skipping elements?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Binary Search",
      "Sliding Window",
      "Graph Traversal"
    ]
  },
  {
    "q": "Which structure is used to maintain a dynamic ranking system where scores change frequently?",
    "c": null,
    "o": [
      "Heap",
      "Queue",
      "Set",
      "Linked List"
    ]
  },
  {
    "q": "Which of these real-world applications would most likely use a graph data structure?",
    "c": null,
    "o": [
      "Social network relationships",
      "Text editor history",
      "Compiler token list",
      "Restaurant menu"
    ]
  },
  {
    "q": "Which algorithm is ideal for solving the 'Activity Selection Problem' where maximum non-overlapping activities are selected?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "Which data structure would be best to implement an LRU (Least Recently Used) Cache?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Queue + Stack",
      "Trie + Set",
      "Priority Queue"
    ]
  },
  {
    "q": "Which data structure is commonly used to convert infix expressions to postfix in compilers?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Heap"
    ]
  },
  {
    "q": "What competitive programming technique is used in problems like 'Container With Most Water'?",
    "c": null,
    "o": [
      "Two Pointers",
      "Binary Search",
      "Greedy",
      "DFS"
    ]
  },
  {
    "q": "Which of the following structures would be best for storing undo/redo history in applications?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Set",
      "Tree"
    ]
  },
  {
    "q": "What type of algorithm would be best for real-time pathfinding in a game?",
    "c": null,
    "o": [
      "A* Search Algorithm",
      "DFS",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following is a suitable pattern for problems like 'Word Break' or 'Coin Change'?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Graph Traversal",
      "Sliding Window"
    ]
  },
  {
    "q": "Which data structure is useful for building syntax trees during compilation?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing an autocomplete feature?",
    "c": null,
    "o": [
      "Trie",
      "HashMap",
      "Heap",
      "Queue"
    ]
  },
  {
    "q": "In job scheduling systems, which data structure is commonly used to prioritize jobs?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Deque",
      "Graph"
    ]
  },
  {
    "q": "Which of the following real-world problems can be solved using the Union-Find data structure?",
    "c": null,
    "o": [
      "Detecting cycles in a network",
      "Sorting large datasets",
      "Finding shortest paths",
      "Balancing load in a web server"
    ]
  },
  {
    "q": "Which competitive programming pattern is commonly used in problems involving a fixed-size subset of a list?",
    "c": null,
    "o": [
      "Sliding Window",
      "Greedy",
      "Binary Search",
      "DFS"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing a spell checker?",
    "c": null,
    "o": [
      "Trie",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the minimum spanning tree in a network of computers?",
    "c": null,
    "o": [
      "Kruskal's Algorithm",
      "Dijkstra's Algorithm",
      "DFS",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure allows you to maintain the order of insertion and support quick lookups?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "List",
      "Queue"
    ]
  },
  {
    "q": "Which technique is used in competitive programming for problems like 'Subarray Sum Equals K'?",
    "c": null,
    "o": [
      "Prefix Sum",
      "Graph Traversal",
      "Recursion",
      "KMP Algorithm"
    ]
  },
  {
    "q": "Which of these is a real-world use case of a circular queue?",
    "c": null,
    "o": [
      "CPU scheduling",
      "Undo functionality",
      "Autocomplete feature",
      "Shortest path computation"
    ]
  },
  {
    "q": "Which algorithm is best for solving maze problems or shortest path in unweighted graphs?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Kruskal’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which of these real-world applications would benefit from a hash table?",
    "c": null,
    "o": [
      "Caching in web browsers",
      "Implementing undo functionality",
      "Traversing a file system",
      "Building a parse tree"
    ]
  },
  {
    "q": "Which problem-solving pattern is commonly used for problems like 'Maximum Sum Subarray'?",
    "c": null,
    "o": [
      "Kadane’s Algorithm",
      "Backtracking",
      "Union-Find",
      "Topological Sort"
    ]
  },
  {
    "q": "Which of the following problems is best solved using backtracking?",
    "c": null,
    "o": [
      "Sudoku Solver",
      "Finding shortest path",
      "PageRank algorithm",
      "String reversal"
    ]
  },
  {
    "q": "Which type of data structure is typically used in DNS resolution?",
    "c": null,
    "o": [
      "Trie",
      "Queue",
      "Heap",
      "Deque"
    ]
  },
  {
    "q": "Which algorithm is suitable for determining if a graph contains a cycle?",
    "c": null,
    "o": [
      "DFS with visited tracking",
      "BFS",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a Least Recently Used (LRU) cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Stack",
      "Set",
      "Queue"
    ]
  },
  {
    "q": "In routing algorithms for computer networks, which algorithm is commonly used to find the shortest path?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Floyd-Warshall Algorithm",
      "DFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is most suitable for checking balanced parentheses in a string?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which technique is useful in competitive programming for problems like 'Next Greater Element'?",
    "c": null,
    "o": [
      "Monotonic Stack",
      "Binary Search",
      "Greedy",
      "Backtracking"
    ]
  },
  {
    "q": "Which real-world scenario benefits from using a graph data structure?",
    "c": null,
    "o": [
      "Modeling social networks",
      "Text editor undo feature",
      "Job scheduling",
      "Command history"
    ]
  },
  {
    "q": "Which data structure is commonly used in implementing browser back and forward navigation?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding all strongly connected components in a graph?",
    "c": null,
    "o": [
      "Kosaraju's Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm",
      "BFS"
    ]
  },
  {
    "q": "In competitive programming, what approach is used in problems requiring partitioning of an array into K equal-sum subsets?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Union-Find",
      "Prefix Sum"
    ]
  },
  {
    "q": "Which data structure helps to efficiently solve the 'median in a data stream' problem?",
    "c": null,
    "o": [
      "Two Heaps",
      "Queue",
      "Linked List",
      "Stack"
    ]
  },
  {
    "q": "Which data structure is used in implementing operating system process scheduling?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Hash Table",
      "Trie"
    ]
  },
  {
    "q": "Which is the best approach to solve a maze problem with weighted paths?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "DFS",
      "Union-Find",
      "Topological Sort"
    ]
  },
  {
    "q": "Which programming technique is used in 'Word Break' type problems in competitive programming?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Depth-First Search",
      "Hashing"
    ]
  },
  {
    "q": "Which real-world application uses heaps internally to function efficiently?",
    "c": null,
    "o": [
      "Priority job scheduling in OS",
      "HTML parsing",
      "HTTP routing",
      "File compression"
    ]
  },
  {
    "q": "Which algorithm is best for topological sorting of a Directed Acyclic Graph (DAG)?",
    "c": null,
    "o": [
      "Kahn’s Algorithm",
      "DFS",
      "Dijkstra's Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which competitive programming problem type benefits from prefix sums?",
    "c": null,
    "o": [
      "Range Sum Query",
      "String Reversal",
      "Graph Coloring",
      "Shortest Path Finding"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing an autocomplete feature in a search bar?",
    "c": null,
    "o": [
      "Trie",
      "HashMap",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which real-world application commonly uses a circular queue data structure?",
    "c": null,
    "o": [
      "CPU scheduling",
      "Spell checker",
      "Undo functionality",
      "Text compression"
    ]
  },
  {
    "q": "Which data structure is best suited to model a network of airline routes between cities?",
    "c": null,
    "o": [
      "Graph",
      "Tree",
      "Array",
      "Linked List"
    ]
  },
  {
    "q": "What technique is commonly used in competitive programming to precompute answers for range queries?",
    "c": null,
    "o": [
      "Prefix Sum",
      "Recursion",
      "Brute Force",
      "Memoization"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a job priority queue in a task scheduler?",
    "c": null,
    "o": [
      "Heap",
      "Deque",
      "Array",
      "Stack"
    ]
  },
  {
    "q": "Which pattern is often used in competitive programming to solve problems like 'Sliding Window Maximum'?",
    "c": null,
    "o": [
      "Deque-based sliding window",
      "Recursive DFS",
      "Floyd-Warshall",
      "Greedy search"
    ]
  },
  {
    "q": "Which real-world application benefits most from using disjoint set (union-find) data structure?",
    "c": null,
    "o": [
      "Network connectivity",
      "Memory allocation",
      "LRU cache",
      "Queue simulation"
    ]
  },
  {
    "q": "Which data structure allows insertion, deletion, and search operations in O(1) on average?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Tree"
    ]
  },
  {
    "q": "In a social media application, which structure is best to represent user connections?",
    "c": null,
    "o": [
      "Graph",
      "Queue",
      "Trie",
      "Stack"
    ]
  },
  {
    "q": "Which approach is used in solving the 'N-Queens' problem in competitive programming?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Divide and Conquer",
      "Memoization"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a spell checker?",
    "c": null,
    "o": [
      "Trie",
      "Graph",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is commonly used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "Prim’s algorithm",
      "Dijkstra’s algorithm",
      "Kruskal’s algorithm"
    ]
  },
  {
    "q": "Which data structure is preferred for storing large amounts of key-value pairs with fast lookups?",
    "c": null,
    "o": [
      "HashMap",
      "Array",
      "Deque",
      "Stack"
    ]
  },
  {
    "q": "Which competitive programming pattern is used for string matching problems like 'Anagrams in a String'?",
    "c": null,
    "o": [
      "Sliding Window + Hashing",
      "Prefix Tree",
      "Binary Search",
      "DFS"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding Minimum Spanning Tree in network design?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "DFS",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which data structure is commonly used in web browsers to implement the 'Back' and 'Forward' navigation?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "Which data structure is ideal for managing a print queue where the first job added is the first to be printed?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Heap"
    ]
  },
  {
    "q": "What is the most efficient data structure for checking the presence of a word in a large dictionary?",
    "c": null,
    "o": [
      "HashSet",
      "List",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which of the following data structures is best suited for implementing undo operations in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Graph"
    ]
  },
  {
    "q": "In a GPS navigation system, which algorithm is commonly used to find the shortest path between two locations?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Depth First Search",
      "Prim's Algorithm",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following is a good use case for a deque (double-ended queue)?",
    "c": null,
    "o": [
      "Implementing a sliding window",
      "Binary tree traversal",
      "Symbol matching in compiler",
      "Sorting numbers"
    ]
  },
  {
    "q": "Which competitive programming pattern is best used when trying to optimize recursive solutions?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Backtracking",
      "Greedy Algorithm",
      "Brute Force"
    ]
  },
  {
    "q": "Which data structure would be best for simulating real-world traffic signal cycles?",
    "c": null,
    "o": [
      "Circular Queue",
      "Binary Heap",
      "Stack",
      "Trie"
    ]
  },
  {
    "q": "Which real-world system can best utilize a priority queue?",
    "c": null,
    "o": [
      "Hospital emergency room triage",
      "Video streaming playlist",
      "Text editor",
      "Web browser tabs"
    ]
  },
  {
    "q": "Which algorithm is used in competitive programming to find strongly connected components in a graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure would be most efficient for implementing a Least Recently Used (LRU) Cache?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Stack + Queue",
      "Array + Stack",
      "Trie + Queue"
    ]
  },
  {
    "q": "Which real-world application commonly uses the Binary Search Tree (BST)?",
    "c": null,
    "o": [
      "Database indexing",
      "Web server routing",
      "Audio buffering",
      "IP address resolution"
    ]
  },
  {
    "q": "What is the ideal data structure for efficiently storing and querying hierarchical data like file systems?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is effective in solving the 'Subset Sum Problem' in competitive programming?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Depth First Search",
      "Greedy Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "Which pattern is commonly used in competitive programming for solving problems with overlapping subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Backtracking",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is most efficient for autocomplete feature in search engines?",
    "c": null,
    "o": [
      "Trie",
      "HashMap",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm would be most suitable for task scheduling in an operating system?",
    "c": null,
    "o": [
      "Round Robin",
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm",
      "DFS"
    ]
  },
  {
    "q": "In network routing, which data structure is commonly used to model connections between routers?",
    "c": null,
    "o": [
      "Graph",
      "Tree",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which programming technique is used to avoid redundant computations in recursive problems?",
    "c": null,
    "o": [
      "Memoization",
      "Backtracking",
      "Greedy",
      "Branch and Bound"
    ]
  },
  {
    "q": "Which competitive programming pattern involves breaking a problem into smaller overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Two Pointers",
      "Sliding Window"
    ]
  },
  {
    "q": "Which data structure would you use for evaluating expressions like '(2+3)*(5-2)'?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "HashMap",
      "Graph"
    ]
  },
  {
    "q": "What is the best choice for representing social networks like Facebook?",
    "c": null,
    "o": [
      "Graph",
      "Tree",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is commonly used in airline reservation systems to find optimal routes?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is a suitable structure for fast access to non-sequential records in a database?",
    "c": null,
    "o": [
      "Hash Table",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is often used in spelling correction systems?",
    "c": null,
    "o": [
      "Levenshtein Distance",
      "Huffman Coding",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is used in cache implementation for fast lookup and eviction policy?",
    "c": null,
    "o": [
      "HashMap with Doubly Linked List",
      "Binary Search Tree",
      "Stack",
      "Graph"
    ]
  },
  {
    "q": "Which type of algorithm is best for solving the fractional knapsack problem?",
    "c": null,
    "o": [
      "Greedy",
      "Dynamic Programming",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which real-world system could use a min-heap for its core logic?",
    "c": null,
    "o": [
      "Priority scheduling in CPU",
      "Autocomplete suggestions",
      "Spell checker",
      "Undo functionality in a text editor"
    ]
  },
  {
    "q": "What data structure is commonly used in language parsers and compilers?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which real-world application typically uses a sliding window algorithm?",
    "c": null,
    "o": [
      "Streaming data analytics",
      "File compression",
      "Memory management",
      "Path finding in maps"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing browser history navigation (back and forward)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Graph",
      "HashMap"
    ]
  },
  {
    "q": "Which algorithm pattern is best suited for solving maze or puzzle traversal problems?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Divide and Conquer",
      "Memoization"
    ]
  },
  {
    "q": "Which data structure allows efficient access to the k largest elements in a stream of numbers?",
    "c": null,
    "o": [
      "Min-Heap",
      "Max-Heap",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which of the following algorithms is ideal for finding the shortest path in a weighted graph?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Breadth First Search",
      "Depth First Search",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is used in BFS for maintaining the order of nodes to be visited?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which of these problems is best solved using the sliding window technique?",
    "c": null,
    "o": [
      "Finding the maximum sum subarray of size k",
      "Shortest path between two nodes",
      "Detecting cycles in graphs",
      "Finding LCS between two strings"
    ]
  },
  {
    "q": "Which type of data structure is generally used to model hierarchical data like file systems?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "What is a typical use of the Union-Find (Disjoint Set) data structure in real-world applications?",
    "c": null,
    "o": [
      "Detecting cycles in undirected graphs",
      "Evaluating arithmetic expressions",
      "Caching recently used items",
      "String pattern matching"
    ]
  },
  {
    "q": "Which competitive programming pattern involves checking all possibilities and pruning invalid paths?",
    "c": null,
    "o": [
      "Backtracking",
      "Sliding Window",
      "Greedy",
      "Two Pointers"
    ]
  },
  {
    "q": "Which data structure would best support an undo operation in a text editor?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Array"
    ]
  },
  {
    "q": "In database indexing, which data structure is most commonly used?",
    "c": null,
    "o": [
      "B+ Tree",
      "Graph",
      "Queue",
      "HashMap"
    ]
  },
  {
    "q": "Which data structure can be used to detect and resolve collisions in hash tables?",
    "c": null,
    "o": [
      "Linked List",
      "Queue",
      "Heap",
      "Stack"
    ]
  },
  {
    "q": "Which real-world application typically uses graphs for problem modeling?",
    "c": null,
    "o": [
      "Navigation systems",
      "Inventory management",
      "String reversal",
      "Matrix multiplication"
    ]
  },
  {
    "q": "What technique is often combined with binary search to solve problems efficiently?",
    "c": null,
    "o": [
      "Two Pointers",
      "Greedy",
      "DFS",
      "Backtracking"
    ]
  },
  {
    "q": "Which algorithmic approach is best suited for solving problems like 'Maximum Product Subarray'?",
    "c": null,
    "o": [
      "Kadane’s Algorithm",
      "Greedy",
      "DFS",
      "Heap Sort"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing a priority-based job scheduler?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "What data structure is typically used for efficiently implementing autocomplete features?",
    "c": null,
    "o": [
      "Trie",
      "Array",
      "Heap",
      "Stack"
    ]
  },
  {
    "q": "Which pattern is commonly used in dynamic programming problems like the Knapsack problem?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy",
      "Binary Search",
      "Two Pointers"
    ]
  },
  {
    "q": "In competitive programming, which pattern is best suited to find a peak element in a 2D array?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Backtracking",
      "Dynamic Programming",
      "Greedy"
    ]
  },
  {
    "q": "Which of the following is a practical use case of a circular queue?",
    "c": null,
    "o": [
      "CPU task scheduling",
      "Infix to postfix conversion",
      "Undo operations",
      "Web crawling"
    ]
  },
  {
    "q": "Which of the following real-world problems can be efficiently solved using graphs?",
    "c": null,
    "o": [
      "Finding shortest routes in GPS navigation",
      "Sorting numbers",
      "Evaluating arithmetic expressions",
      "Implementing undo feature"
    ]
  },
  {
    "q": "Which data structure is best for matching opening and closing symbols like (), {}, and []?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm pattern is typically used for solving interval scheduling problems?",
    "c": null,
    "o": [
      "Greedy",
      "Divide and Conquer",
      "Backtracking",
      "Sliding Window"
    ]
  },
  {
    "q": "Which of these data structures would be the most appropriate for implementing an LRU Cache?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Array",
      "Stack + Queue",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which algorithm is ideal for finding connected components in an undirected graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which of the following data structures is best for storing a collection of unique elements?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which data structure is often used to implement a memory-efficient dictionary for word lookups?",
    "c": null,
    "o": [
      "Trie",
      "TreeMap",
      "Array",
      "Graph"
    ]
  },
  {
    "q": "Which of the following is the most suitable for solving the N-Queens problem?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "BFS",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure would you use to evaluate postfix expressions?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding all pairs shortest path in a graph?",
    "c": null,
    "o": [
      "Floyd-Warshall",
      "Dijkstra’s",
      "DFS",
      "Prim’s"
    ]
  },
  {
    "q": "Which data structure is most suitable for maintaining a dynamic leaderboard (e.g., in games)?",
    "c": null,
    "o": [
      "Balanced Binary Search Tree",
      "Queue",
      "Hash Table",
      "Stack"
    ]
  },
  {
    "q": "In database indexing, which data structure is typically used to store indexes?",
    "c": null,
    "o": [
      "B-Tree",
      "Graph",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithmic approach is most suitable for solving a maze using all possible paths?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Sliding Window",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is commonly used for IP routing (longest prefix match)?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Graph"
    ]
  },
  {
    "q": "Which pattern is best suited for solving problems like 'Longest Substring Without Repeating Characters'?",
    "c": null,
    "o": [
      "Sliding Window",
      "Divide and Conquer",
      "Greedy",
      "Binary Search"
    ]
  },
  {
    "q": "What is the most suitable data structure for a web browser's back and forward navigation?",
    "c": null,
    "o": [
      "Two Stacks",
      "Queue",
      "Heap",
      "Deque"
    ]
  },
  {
    "q": "Which algorithm is ideal for network broadcast (like finding reachable nodes)?",
    "c": null,
    "o": [
      "Breadth-First Search",
      "Depth-First Search",
      "Dijkstra’s Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "What type of data structure is best suited for a spell checker application?",
    "c": null,
    "o": [
      "Trie",
      "HashMap",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which competitive programming pattern is suitable for solving 'Two Sum' type problems efficiently?",
    "c": null,
    "o": [
      "Hashing",
      "Recursion",
      "Greedy",
      "DFS"
    ]
  },
  {
    "q": "Which data structure can be used to efficiently simulate a call center queue where high-priority calls are served first?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Deque",
      "Array"
    ]
  },
  {
    "q": "Which real-world application uses graph traversal to determine friend recommendations?",
    "c": null,
    "o": [
      "Social networks",
      "Sorting algorithms",
      "Compiler design",
      "Operating systems"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the shortest path in a weighted graph with positive weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "BFS",
      "DFS",
      "Bellman-Ford"
    ]
  },
  {
    "q": "Which data structure helps in maintaining recently used files in an operating system?",
    "c": null,
    "o": [
      "Doubly Linked List",
      "Queue",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which pattern is used to solve problems like 'Find K Closest Elements'?",
    "c": null,
    "o": [
      "Two Pointers",
      "Backtracking",
      "Dynamic Programming",
      "DFS"
    ]
  },
  {
    "q": "Which data structure is most efficient for frequency counting of characters in a string?",
    "c": null,
    "o": [
      "HashMap",
      "Stack",
      "Tree",
      "Deque"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a task scheduler that supports periodic execution?",
    "c": null,
    "o": [
      "Min Heap",
      "Queue",
      "Stack",
      "Hash Table"
    ]
  },
  {
    "q": "In a GPS navigation system, which algorithm is most commonly used to find the shortest path?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Depth-First Search",
      "Kruskal’s Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "What data structure is used to detect cycles in a network routing graph?",
    "c": null,
    "o": [
      "Disjoint Set (Union-Find)",
      "Stack",
      "Priority Queue",
      "Hash Table"
    ]
  },
  {
    "q": "Which design pattern is commonly used in dynamic programming problems to avoid recomputation?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Backtracking",
      "Sliding Window"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing an autocomplete feature?",
    "c": null,
    "o": [
      "Trie",
      "Graph",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is best for detecting cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Dijkstra’s",
      "Union-Find"
    ]
  },
  {
    "q": "Which of the following problems is best solved using the Greedy method?",
    "c": null,
    "o": [
      "Activity Selection Problem",
      "Maze Solver",
      "Subset Sum",
      "Graph Traversal"
    ]
  },
  {
    "q": "Which structure is used to keep track of call stack in recursive function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm is typically used to detect strongly connected components in a graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What is the primary use case of a Bloom Filter in real-world systems?",
    "c": null,
    "o": [
      "Probabilistic membership testing",
      "Sorting data",
      "Finding shortest path",
      "Balancing binary trees"
    ]
  },
  {
    "q": "Which data structure is best suited for LRU (Least Recently Used) cache implementation?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Stack + Heap",
      "Queue + Stack",
      "Trie + Graph"
    ]
  },
  {
    "q": "Which of the following competitive programming patterns helps with problems involving choosing elements under constraints?",
    "c": null,
    "o": [
      "Backtracking",
      "Sliding Window",
      "Greedy",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is used in compilers for syntax checking of parentheses?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which is the best-suited algorithm for solving job scheduling problems to minimize completion time?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "DFS",
      "Union-Find",
      "Binary Search"
    ]
  },
  {
    "q": "What type of data structure is ideal for a messaging app that supports undo operations?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing undo/redo functionality in a text editor?",
    "c": null,
    "o": [
      "Two Stacks",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is most suitable for dynamic route calculation in ride-sharing apps like Uber?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Breadth-First Search",
      "Floyd-Warshall Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "Which data structure is commonly used in memory management to keep track of free and used memory blocks?",
    "c": null,
    "o": [
      "Linked List",
      "Hash Table",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is best suited for solving interval scheduling problems?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Divide and Conquer",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which algorithm is most commonly used in AI for decision-making processes such as game theory?",
    "c": null,
    "o": [
      "Minimax Algorithm",
      "Bellman-Ford Algorithm",
      "DFS",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a priority-based task manager?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Hash Map"
    ]
  },
  {
    "q": "Which approach is suitable for solving 'Maximum Subarray Sum' problems in competitive programming?",
    "c": null,
    "o": [
      "Kadane’s Algorithm",
      "Binary Search",
      "Merge Sort",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following would be used to represent a network of computers?",
    "c": null,
    "o": [
      "Graph",
      "Queue",
      "Stack",
      "Array"
    ]
  },
  {
    "q": "Which pattern is commonly used for problems that require checking all combinations of elements?",
    "c": null,
    "o": [
      "Backtracking",
      "Sliding Window",
      "Greedy",
      "Two Pointers"
    ]
  },
  {
    "q": "Which data structure is used in the implementation of hash tables to resolve collisions?",
    "c": null,
    "o": [
      "Linked List",
      "Stack",
      "Queue",
      "Array"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing browser history navigation?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Trie",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is useful for finding connected components in an undirected graph?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "In databases, which data structure is commonly used for indexing?",
    "c": null,
    "o": [
      "B-Tree",
      "Hash Table",
      "Heap",
      "Queue"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing an event-driven simulator where events are processed in order of occurrence?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Array",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm helps solve the '0/1 Knapsack Problem' optimally?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Union-Find",
      "DFS"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing autocomplete functionality in a search engine?",
    "c": null,
    "o": [
      "Trie",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is commonly used in spam filtering and document classification?",
    "c": null,
    "o": [
      "Naive Bayes",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "A* Search"
    ]
  },
  {
    "q": "Which data structure is commonly used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "Disjoint Set (Union-Find)",
      "Queue",
      "Trie",
      "Stack"
    ]
  },
  {
    "q": "In competitive programming, which technique helps optimize nested loops when searching in sorted arrays?",
    "c": null,
    "o": [
      "Two Pointers",
      "Brute Force",
      "DFS",
      "Recursion"
    ]
  },
  {
    "q": "Which data structure is used in the LRU (Least Recently Used) cache mechanism?",
    "c": null,
    "o": [
      "Hash Map + Doubly Linked List",
      "Stack + Queue",
      "Heap + Array",
      "Hash Map + Queue"
    ]
  },
  {
    "q": "Which of the following is a real-world application of graphs?",
    "c": null,
    "o": [
      "Social Networks",
      "Binary Search Trees",
      "Sorting Algorithms",
      "Recursion Trees"
    ]
  },
  {
    "q": "Which algorithm is ideal for shortest path finding with negative weights?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra’s",
      "A* Search",
      "DFS"
    ]
  },
  {
    "q": "Which data structure is typically used to implement recursion internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which pattern is best suited for finding a subarray with a given sum in an array of positive numbers?",
    "c": null,
    "o": [
      "Sliding Window",
      "Backtracking",
      "Merge Sort",
      "DFS"
    ]
  },
  {
    "q": "Which scheduling algorithm is ideal for minimizing average waiting time?",
    "c": null,
    "o": [
      "Shortest Job First (SJF)",
      "First Come First Serve (FCFS)",
      "Round Robin",
      "Priority Scheduling"
    ]
  },
  {
    "q": "What data structure is most suitable for implementing task dependency ordering?",
    "c": null,
    "o": [
      "Directed Acyclic Graph (DAG)",
      "Heap",
      "Queue",
      "Trie"
    ]
  },
  {
    "q": "Which type of heap is most suitable for implementing a median finder?",
    "c": null,
    "o": [
      "Two Heaps (Min and Max)",
      "Binary Heap",
      "Fibonacci Heap",
      "Binomial Heap"
    ]
  },
  {
    "q": "Which algorithm is used in navigation systems like GPS to find the shortest path?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure allows efficient range minimum queries?",
    "c": null,
    "o": [
      "Segment Tree",
      "Binary Tree",
      "Heap",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm technique is used in problems like Matrix Chain Multiplication?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a browser’s back and forward button?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which of the following best represents a real-world use of a priority queue?",
    "c": null,
    "o": [
      "Task scheduling in operating systems",
      "Autocomplete feature",
      "Image compression",
      "Game leaderboard sorting"
    ]
  },
  {
    "q": "What is the best data structure for implementing undo functionality in a text editor?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Map",
      "Graph"
    ]
  },
  {
    "q": "Which technique is often used in competitive programming to reduce time complexity of repeated subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "Binary Search",
      "Greedy Approach",
      "Bit Manipulation"
    ]
  },
  {
    "q": "Which real-world application benefits from using a hash table?",
    "c": null,
    "o": [
      "Database indexing",
      "CPU scheduling",
      "Shortest path navigation",
      "Image rendering"
    ]
  },
  {
    "q": "Which algorithm is used in network routing protocols like OSPF?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "DFS",
      "A* Algorithm"
    ]
  },
  {
    "q": "Which design pattern is commonly applied in problems involving recursion and overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Divide and Conquer",
      "Simulation"
    ]
  },
  {
    "q": "Which data structure is most effective in checking for balanced parentheses in expressions?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "In competitive programming, which technique helps solve problems like finding missing elements in a sorted array?",
    "c": null,
    "o": [
      "Binary Search",
      "DFS",
      "Union-Find",
      "Sliding Window"
    ]
  },
  {
    "q": "Which of the following is the best use case for a circular queue?",
    "c": null,
    "o": [
      "CPU scheduling in Round Robin",
      "Backtracking in games",
      "Priority management in heaps",
      "String pattern matching"
    ]
  },
  {
    "q": "Which algorithm is ideal for topological sorting of tasks with dependencies?",
    "c": null,
    "o": [
      "Kahn’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which approach is widely used to solve maze problems or puzzles like the Knight’s Tour?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Divide and Conquer",
      "Sliding Window"
    ]
  },
  {
    "q": "What is the primary advantage of using adjacency lists over matrices in sparse graphs?",
    "c": null,
    "o": [
      "Efficient space usage",
      "Faster traversal",
      "More readable format",
      "Constant-time edge lookup"
    ]
  },
  {
    "q": "Which real-world application requires finding connected components in a graph?",
    "c": null,
    "o": [
      "Community detection in social networks",
      "Sorting algorithms",
      "Memory management in OS",
      "Document scanning"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element in a heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithm is used in minimum spanning tree problems in networks?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "A* Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure helps in implementing a LRU (Least Recently Used) cache efficiently?",
    "c": null,
    "o": [
      "Hash Map with Doubly Linked List",
      "Priority Queue",
      "Binary Tree",
      "Stack"
    ]
  },
  {
    "q": "Which real-world scenario can be modeled using a bipartite graph?",
    "c": null,
    "o": [
      "Job assignment problems",
      "Web page ranking",
      "Shortest path finding",
      "Stock price prediction"
    ]
  },
  {
    "q": "What is a common application of the Union-Find (Disjoint Set) data structure?",
    "c": null,
    "o": [
      "Detecting cycles in an undirected graph",
      "Sorting elements",
      "Counting frequencies",
      "Implementing recursion"
    ]
  },
  {
    "q": "Which algorithm is most suitable for traversing all the nodes of a tree level by level?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Greedy Algorithm"
    ]
  },
  {
    "q": "What technique is commonly used to slide a window over data in problems involving subarrays or substrings?",
    "c": null,
    "o": [
      "Sliding Window Technique",
      "Two Pointer Technique",
      "Divide and Conquer",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which real-life system can be modeled as a graph with weighted edges?",
    "c": null,
    "o": [
      "Road networks for GPS navigation",
      "Email spam filter",
      "Online quiz scoring",
      "Typing speed measurement"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element by key in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is a limitation of the binary search algorithm?",
    "c": null,
    "o": [
      "Requires sorted input",
      "Slow on small arrays",
      "Works only on strings",
      "Consumes too much space"
    ]
  },
  {
    "q": "Which technique is used to avoid recomputation in recursive problems?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy Method",
      "Bitmasking",
      "Sliding Window"
    ]
  },
  {
    "q": "Which algorithm is commonly used in AI pathfinding applications such as games?",
    "c": null,
    "o": [
      "A* Search",
      "DFS",
      "Prim’s Algorithm",
      "Merge Sort"
    ]
  },
  {
    "q": "Which operation is the fastest in a Trie data structure?",
    "c": null,
    "o": [
      "Prefix lookup",
      "Finding min value",
      "Sorting",
      "Backtracking"
    ]
  },
  {
    "q": "What problem is the Floyd-Warshall algorithm used to solve?",
    "c": null,
    "o": [
      "All pairs shortest path",
      "Minimum spanning tree",
      "Sorting numbers",
      "Finding duplicates"
    ]
  },
  {
    "q": "Which real-world scenario requires finding articulation points in a graph?",
    "c": null,
    "o": [
      "Analyzing network vulnerability",
      "Sorting huge datasets",
      "Detecting plagiarism",
      "Optimizing matrix multiplication"
    ]
  },
  {
    "q": "Which technique helps solve problems like 'maximum sum subarray' efficiently?",
    "c": null,
    "o": [
      "Kadane’s Algorithm",
      "Quick Sort",
      "Union-Find",
      "KMP Algorithm"
    ]
  },
  {
    "q": "Which of the following problems is best solved using Dynamic Programming?",
    "c": null,
    "o": [
      "Knapsack Problem",
      "Binary Search",
      "Depth First Search",
      "Topological Sorting"
    ]
  },
  {
    "q": "Which graph traversal method uses a queue?",
    "c": null,
    "o": [
      "Breadth-First Search",
      "Depth-First Search",
      "Prim's Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "In which scenario would a priority queue be most useful?",
    "c": null,
    "o": [
      "Task scheduling in operating systems",
      "Storing social media posts",
      "Managing a shopping cart",
      "Storing a playlist"
    ]
  },
  {
    "q": "Which algorithm is typically used for detecting cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Prim's Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "What is a key feature of greedy algorithms?",
    "c": null,
    "o": [
      "Make locally optimal choices",
      "Always backtrack",
      "Use recursion heavily",
      "Explore all possible paths"
    ]
  },
  {
    "q": "Which data structure is used in the implementation of recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Map",
      "Heap"
    ]
  },
  {
    "q": "Which shortest path algorithm allows for negative edge weights (but no negative cycles)?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra",
      "Kruskal",
      "Floyd-Warshall"
    ]
  },
  {
    "q": "What is the time complexity of merging two sorted arrays of size m and n?",
    "c": null,
    "o": [
      "O(m + n)",
      "O(mn)",
      "O(log m + log n)",
      "O(m log n)"
    ]
  },
  {
    "q": "Which algorithm is based on the divide and conquer paradigm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Linear Search",
      "BFS",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What is the primary advantage of using a heap data structure?",
    "c": null,
    "o": [
      "Efficient access to the smallest or largest element",
      "Maintains sorted order at all times",
      "Fast insertions and deletions at both ends",
      "Supports constant-time access by index"
    ]
  },
  {
    "q": "Which type of graph is used to represent one-way streets in navigation systems?",
    "c": null,
    "o": [
      "Directed Graph",
      "Undirected Graph",
      "Weighted Tree",
      "Bipartite Graph"
    ]
  },
  {
    "q": "Which algorithm is used to generate a Huffman Tree for data compression?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Depth First Search",
      "Divide and Conquer"
    ]
  },
  {
    "q": "In which situation would you use a Topological Sort?",
    "c": null,
    "o": [
      "Course scheduling with prerequisites",
      "Shortest path in an undirected graph",
      "Social network connections",
      "Finding articulation points"
    ]
  },
  {
    "q": "Which of the following problems can be solved using Backtracking?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Finding GCD",
      "Binary Search",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "What is the key idea behind the Divide and Conquer technique?",
    "c": null,
    "o": [
      "Break problem into sub-problems, solve them independently, and combine solutions",
      "Explore all possible options and choose the best one",
      "Use recursion with memoization",
      "Iteratively improve solution based on local best"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is not comparison-based?",
    "c": null,
    "o": [
      "Counting Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which algorithm is best suited to find strongly connected components in a directed graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "What is memoization in dynamic programming?",
    "c": null,
    "o": [
      "Caching results of expensive function calls to avoid redundant work",
      "Breaking problems into smaller sub-problems",
      "Backtracking to find solutions",
      "Dividing data into clusters"
    ]
  },
  {
    "q": "Which of the following algorithms is used to detect negative cycles in a graph?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra",
      "Prim's Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which property does a greedy algorithm always maintain?",
    "c": null,
    "o": [
      "Greedy choice property",
      "Global optimality",
      "Multiple solution paths",
      "Backtracking property"
    ]
  },
  {
    "q": "What is the time complexity of finding the Minimum Spanning Tree using Kruskal’s Algorithm (with Union-Find)?",
    "c": null,
    "o": [
      "O(E log E)",
      "O(V^2)",
      "O(V + E)",
      "O(log V)"
    ]
  },
  {
    "q": "Which of the following algorithms uses a priority queue to work efficiently?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which technique is used in solving the Longest Common Subsequence (LCS) problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Branch and Bound"
    ]
  },
  {
    "q": "Which of the following problems is not NP-complete?",
    "c": null,
    "o": [
      "Binary Search",
      "Traveling Salesman Problem",
      "Subset Sum",
      "3-SAT"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement undo operations in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which real-world application typically uses graphs for its internal structure?",
    "c": null,
    "o": [
      "Social Networks",
      "Online Shopping Cart",
      "Banking Interest Calculator",
      "Weather App"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a scheduler or task manager with varying priorities?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Deque",
      "Hash Table"
    ]
  },
  {
    "q": "In competitive programming, what is a 'sliding window' used for?",
    "c": null,
    "o": [
      "Optimizing subarray or substring computations",
      "Sorting elements in linear time",
      "Avoiding recursion stack overflow",
      "Simulating graph traversals"
    ]
  },
  {
    "q": "Which data structure is most efficient for checking balanced parentheses in expressions?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Graph",
      "Set"
    ]
  },
  {
    "q": "Which algorithm is used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Prim's algorithm",
      "Dijkstra's algorithm"
    ]
  },
  {
    "q": "Which type of search is ideal for large, sorted datasets?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Depth First Search",
      "Breadth First Search"
    ]
  },
  {
    "q": "Which data structure is used for cache implementation with fast access and order preservation?",
    "c": null,
    "o": [
      "Ordered Dictionary (LRU Cache)",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which of the following is a common pattern in competitive programming problems involving intervals?",
    "c": null,
    "o": [
      "Sweep Line Algorithm",
      "Bellman-Ford Algorithm",
      "Backtracking",
      "Bitmasking"
    ]
  },
  {
    "q": "What is the main use of the Union-Find (Disjoint Set Union) data structure in applications?",
    "c": null,
    "o": [
      "Tracking connected components in a network",
      "Sorting arrays efficiently",
      "Simulating stack behavior",
      "Maintaining data order in a queue"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a browser's back and forward navigation?",
    "c": null,
    "o": [
      "Two Stacks",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which real-world problem can be solved using Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Finding the shortest path in GPS navigation",
      "Sorting user ratings",
      "Scheduling recurring meetings",
      "Encrypting messages"
    ]
  },
  {
    "q": "Which data structure is preferred for implementing a job queue in operating systems?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Set"
    ]
  },
  {
    "q": "What is the typical use case of a Trie data structure?",
    "c": null,
    "o": [
      "Autocomplete and spell-check",
      "Database indexing",
      "Image processing",
      "Circular queue operations"
    ]
  },
  {
    "q": "Which algorithmic pattern is most suitable for solving the Knapsack problem in competitive programming?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Depth First Search",
      "Binary Search"
    ]
  },
  {
    "q": "Which of the following structures is commonly used for network routing protocols like OSPF?",
    "c": null,
    "o": [
      "Graph",
      "Heap",
      "Stack",
      "Hash Map"
    ]
  },
  {
    "q": "Which application typically requires a circular queue data structure?",
    "c": null,
    "o": [
      "Printer spooler",
      "Image editor",
      "Search engine index",
      "Library catalog"
    ]
  },
  {
    "q": "Which of the following is the most suitable pattern for solving 'Two Sum' or similar problems efficiently?",
    "c": null,
    "o": [
      "Hashing",
      "Binary Search",
      "Sorting",
      "Greedy"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing undo-redo functionality?",
    "c": null,
    "o": [
      "Two Stacks",
      "Queue",
      "Graph",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is commonly used for scheduling problems where tasks must be done in a specific order?",
    "c": null,
    "o": [
      "Topological Sorting",
      "Kruskal’s Algorithm",
      "DFS",
      "A* Search"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a cache using the Least Recently Used (LRU) strategy?",
    "c": null,
    "o": [
      "HashMap with Doubly Linked List",
      "Stack",
      "Queue",
      "Binary Tree"
    ]
  },
  {
    "q": "Which algorithmic approach is most efficient for solving problems like coin change and edit distance?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is commonly used in a firewall to match incoming IP packets to rules?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which competitive programming technique is used to optimize nested loops using precomputed data?",
    "c": null,
    "o": [
      "Prefix Sum",
      "Binary Search",
      "DFS",
      "Recursion"
    ]
  },
  {
    "q": "Which of the following best represents the use of a min-heap in real-world scenarios?",
    "c": null,
    "o": [
      "Task scheduling where tasks with lowest execution time are given priority",
      "Database indexing",
      "URL shortening",
      "Implementing autocomplete"
    ]
  },
  {
    "q": "Which data structure is typically used in AI pathfinding algorithms like A*?",
    "c": null,
    "o": [
      "Priority Queue (Min-Heap)",
      "Stack",
      "Hash Table",
      "Deque"
    ]
  },
  {
    "q": "Which pattern is commonly used in solving sliding window maximum or minimum problems?",
    "c": null,
    "o": [
      "Deque-based Sliding Window",
      "Two Pointers",
      "DFS",
      "Stack Simulation"
    ]
  },
  {
    "q": "Which of these is a real-world use case of hash maps?",
    "c": null,
    "o": [
      "Counting word frequencies in a document",
      "Finding the shortest route in maps",
      "Simulating browser tabs",
      "Encrypting user passwords"
    ]
  },
  {
    "q": "Which data structure is efficient for finding the median of a dynamic data stream?",
    "c": null,
    "o": [
      "Two Heaps (Min and Max Heap)",
      "Queue",
      "Binary Search Tree",
      "Array"
    ]
  },
  {
    "q": "Which of the following problems is best solved using the Union-Find (Disjoint Set) data structure?",
    "c": null,
    "o": [
      "Detecting cycles in an undirected graph",
      "Finding top K frequent elements",
      "Implementing undo-redo operations",
      "Evaluating postfix expressions"
    ]
  },
  {
    "q": "Which data structure is used to implement undo and redo functionality in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which data structure would you use to efficiently manage seat booking in a theater (where you need to find and reserve k consecutive free seats)?",
    "c": null,
    "o": [
      "Segment Tree",
      "Linked List",
      "Hash Table",
      "Stack"
    ]
  },
  {
    "q": "Which type of tree is used in databases to allow logarithmic time range queries and insertion?",
    "c": null,
    "o": [
      "B-Tree",
      "Binary Search Tree",
      "Trie",
      "AVL Tree"
    ]
  },
  {
    "q": "In routing tables and IP lookup, which data structure is often used for matching prefixes efficiently?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Stack",
      "Array"
    ]
  },
  {
    "q": "Which data structure is used for level-order traversal of a binary tree?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Hash Map"
    ]
  },
  {
    "q": "Which technique is commonly used in competitive programming to optimize multiple queries on a static array?",
    "c": null,
    "o": [
      "Segment Tree",
      "Heap",
      "Stack",
      "DFS"
    ]
  },
  {
    "q": "Which of the following is a common real-world use of graph algorithms?",
    "c": null,
    "o": [
      "Social network friend suggestions",
      "Sorting emails",
      "Encrypting data",
      "Calculating factorial"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing an autocomplete system?",
    "c": null,
    "o": [
      "Trie",
      "Stack",
      "Heap",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is commonly used in GPS systems for finding shortest paths?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Merge Sort",
      "Depth-First Search"
    ]
  },
  {
    "q": "Which competitive programming concept helps reduce time complexity when working with multiple subarray queries?",
    "c": null,
    "o": [
      "Prefix Sum Array",
      "Stack Overflow Prevention",
      "Fibonacci Memoization",
      "Binary Tree Traversal"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a job scheduling system where tasks are prioritized?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Hash Table",
      "Graph"
    ]
  },
  {
    "q": "Which data structure is typically used to detect cycles in a network routing system?",
    "c": null,
    "o": [
      "Graph",
      "Heap",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithmic technique is used in competitive programming to solve problems like coin change and knapsack efficiently?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Greedy Algorithm",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following is an example of a real-world application that uses a stack?",
    "c": null,
    "o": [
      "Web browser back button",
      "Finding shortest path",
      "Auto-suggestion while typing",
      "Network routing"
    ]
  },
  {
    "q": "Which algorithm is often used to detect communities or clusters in social networks?",
    "c": null,
    "o": [
      "Depth-First Search",
      "Kruskal’s Algorithm",
      "Breadth-First Search",
      "K-Means Clustering"
    ]
  },
  {
    "q": "What data structure is best suited for implementing LRU (Least Recently Used) cache?",
    "c": null,
    "o": [
      "Hash Map + Doubly Linked List",
      "Stack",
      "Binary Tree",
      "Array"
    ]
  },
  {
    "q": "Which of these is a common use of hashing in real-world applications?",
    "c": null,
    "o": [
      "Password storage",
      "CPU scheduling",
      "Tree traversal",
      "Image rendering"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the minimum spanning tree in a network of computers?",
    "c": null,
    "o": [
      "Kruskal's Algorithm",
      "Depth-First Search",
      "Dijkstra's Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "Which competitive programming strategy involves breaking a problem into overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Method",
      "Binary Search",
      "Recursion"
    ]
  },
  {
    "q": "In a multiplayer online game, which data structure helps in managing players' rankings efficiently?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Trie"
    ]
  },
  {
    "q": "Which data structure is best for implementing an autocomplete feature?",
    "c": null,
    "o": [
      "Trie",
      "Stack",
      "Queue",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which algorithm is commonly used in navigation systems like Google Maps for shortest path finding?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Floyd-Warshall Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which of the following data structures is most suitable for simulating a call center queue system?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Heap"
    ]
  },
  {
    "q": "Which competitive programming pattern involves using two pointers that move at different speeds to solve problems efficiently?",
    "c": null,
    "o": [
      "Fast and Slow Pointer",
      "Sliding Window",
      "Divide and Conquer",
      "Greedy"
    ]
  },
  {
    "q": "Which data structure is used in databases to store indexes for fast lookup?",
    "c": null,
    "o": [
      "B-Tree",
      "Stack",
      "Queue",
      "Trie"
    ]
  },
  {
    "q": "Which of the following is a real-world application of a graph?",
    "c": null,
    "o": [
      "Social media friend connections",
      "Array sorting",
      "Recursion stack trace",
      "Function overloading"
    ]
  },
  {
    "q": "Which algorithmic pattern is suitable for solving interval problems like meeting room scheduling?",
    "c": null,
    "o": [
      "Greedy",
      "Divide and Conquer",
      "Binary Search",
      "Depth-First Search"
    ]
  },
  {
    "q": "What data structure would be most suitable for storing a leaderboard that updates frequently?",
    "c": null,
    "o": [
      "Heap",
      "Array",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which structure is ideal for detecting balanced parentheses in a programming language compiler?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which of these real-world systems heavily uses hash tables for efficient performance?",
    "c": null,
    "o": [
      "DNS resolution",
      "Air traffic control",
      "Railway reservation",
      "Audio processing"
    ]
  },
  {
    "q": "Which data structure is typically used to implement breadth-first search (BFS) in graphs?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "Which real-world problem is commonly modeled as a graph for efficient solutions?",
    "c": null,
    "o": [
      "Transportation networks",
      "String matching",
      "Memory allocation",
      "Sorting numbers"
    ]
  },
  {
    "q": "Which algorithm is best suited to find the shortest path in a weighted graph without negative edges?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "DFS",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "In competitive programming, which technique helps optimize problems involving subsets and combinations?",
    "c": null,
    "o": [
      "Bitmasking",
      "Greedy",
      "Divide and Conquer",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which data structure is efficient for LRU cache implementation?",
    "c": null,
    "o": [
      "Hash Map combined with Doubly Linked List",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which data structure allows efficient insertion, deletion, and retrieval of the median value from a dynamic data stream?",
    "c": null,
    "o": [
      "Two Heaps (Min-Heap and Max-Heap)",
      "Array",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is commonly used to detect cycles in undirected graphs?",
    "c": null,
    "o": [
      "Union-Find (Disjoint Set)",
      "DFS with recursion stack",
      "BFS",
      "Topological Sort"
    ]
  },
  {
    "q": "Which scheduling algorithm minimizes average waiting time for non-preemptive tasks?",
    "c": null,
    "o": [
      "Shortest Job First (SJF)",
      "Round Robin",
      "First Come First Serve (FCFS)",
      "Priority Scheduling"
    ]
  },
  {
    "q": "Which data structure is used internally in many database indexes for efficient range queries?",
    "c": null,
    "o": [
      "B-Tree",
      "Hash Table",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which of the following is a common use case of the sliding window technique?",
    "c": null,
    "o": [
      "Finding the maximum sum subarray of size k",
      "Sorting a linked list",
      "Graph traversal",
      "Dynamic programming"
    ]
  },
  {
    "q": "Which data structure is best for implementing a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Queue",
      "Stack",
      "Hash Map"
    ]
  },
  {
    "q": "Which algorithmic technique is often used in problems that can be divided into independent subproblems?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is ideal for detecting whether a graph contains cycles?",
    "c": null,
    "o": [
      "Disjoint Set Union (Union-Find)",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which competitive programming pattern involves trying all possible combinations to solve a problem?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Dynamic Programming",
      "Sliding Window"
    ]
  },
  {
    "q": "Which algorithm is used for topological sorting in directed acyclic graphs?",
    "c": null,
    "o": [
      "Kahn’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing a FIFO buffer?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which real-world application typically uses a Trie data structure?",
    "c": null,
    "o": [
      "Dictionary word search and autocomplete",
      "Memory allocation",
      "File compression",
      "Graph shortest path"
    ]
  },
  {
    "q": "Which data structure can be used to implement undo functionality efficiently?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Map",
      "Graph"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a stack data structure?",
    "c": null,
    "o": [
      "Depth-First Search",
      "Breadth-First Search",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which scheduling algorithm gives each process a fixed time slot in a cyclic order?",
    "c": null,
    "o": [
      "Round Robin",
      "Shortest Job First",
      "Priority Scheduling",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement a graph’s adjacency list?",
    "c": null,
    "o": [
      "Hash Map of Lists",
      "Array",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is used to find the articulation points in a network graph?",
    "c": null,
    "o": [
      "Tarjan’s Algorithm",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which pattern in competitive programming involves maintaining a window over a sequence and updating results as the window moves?",
    "c": null,
    "o": [
      "Sliding Window",
      "Backtracking",
      "Divide and Conquer",
      "Greedy"
    ]
  },
  {
    "q": "What is the primary advantage of using a balanced binary search tree like an AVL or Red-Black tree?",
    "c": null,
    "o": [
      "Maintains sorted order with O(log n) insertion and search",
      "Uses less memory than a linked list",
      "Faster deletion than arrays",
      "Always faster than hash tables"
    ]
  },
  {
    "q": "Which data structure supports quick insertion, deletion, and access in O(1) average time?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which scheduling algorithm is preemptive and based on process priority?",
    "c": null,
    "o": [
      "Priority Scheduling",
      "Round Robin",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which of the following is a typical use case of dynamic programming in real-world applications?",
    "c": null,
    "o": [
      "Optimizing resource allocation",
      "Sorting data",
      "Data encryption",
      "Web crawling"
    ]
  },
  {
    "q": "Which of the following data structures is most suitable for implementing a breadth-first search on a tree?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "Which competitive programming technique is used to reduce the complexity of subset problems using bit operations?",
    "c": null,
    "o": [
      "Bitmasking",
      "Greedy",
      "Backtracking",
      "Sliding Window"
    ]
  },
  {
    "q": "Which of the following algorithms helps to find the minimum spanning tree of a connected weighted graph?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing a fixed-size circular buffer?",
    "c": null,
    "o": [
      "Circular Queue",
      "Stack",
      "Linked List",
      "Hash Map"
    ]
  },
  {
    "q": "Which real-world problem is typically modeled as a minimum spanning tree problem?",
    "c": null,
    "o": [
      "Designing efficient electrical grids",
      "Sorting a list of numbers",
      "Parsing HTML documents",
      "Implementing undo operations"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a priority-based task scheduler?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Hash Table"
    ]
  },
  {
    "q": "Which algorithm is commonly used to find strongly connected components in a directed graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What is the main advantage of the sliding window technique in competitive programming?",
    "c": null,
    "o": [
      "Reduces time complexity for subarray/subsequence problems",
      "Simplifies recursion",
      "Reduces memory usage",
      "Ensures global optimality"
    ]
  },
  {
    "q": "Which data structure allows constant-time insertion and deletion at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is best for shortest path calculation on graphs with negative edge weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is typically used to implement breadth-first traversal of a graph?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "Which data structure is often used in text processing to quickly find patterns or prefixes?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which scheduling algorithm assigns CPU time slices to each process in equal portions and in circular order?",
    "c": null,
    "o": [
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a LIFO (Last In First Out) system?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "In which scenario is a hash table preferred over a binary search tree?",
    "c": null,
    "o": [
      "When average-case constant time for insertion, deletion, and lookup is needed",
      "When maintaining sorted order is important",
      "When memory usage needs to be minimal",
      "When frequent range queries are performed"
    ]
  },
  {
    "q": "Which algorithmic technique is most appropriate for solving the Traveling Salesman Problem approximately?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is used internally by Dijkstra's algorithm to efficiently select the next node to process?",
    "c": null,
    "o": [
      "Min-Heap (Priority Queue)",
      "Stack",
      "Queue",
      "Hash Map"
    ]
  },
  {
    "q": "Which data structure is typically used to keep track of visited nodes during Depth-First Search (DFS)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Set",
      "Heap"
    ]
  },
  {
    "q": "Which algorithmic pattern involves solving a problem by breaking it into subproblems, solving each subproblem once, and storing their results?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure allows efficient insertion and deletion at both ends, commonly used in deque operations?",
    "c": null,
    "o": [
      "Doubly Linked List",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is used to sort elements by repeatedly selecting the smallest (or largest) element and moving it to the sorted portion?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which real-world system commonly uses the concept of graphs to represent relationships or connections?",
    "c": null,
    "o": [
      "Social Networks",
      "File Compression",
      "Image Processing",
      "Operating System Scheduling"
    ]
  },
  {
    "q": "Which data structure can efficiently support prefix queries and is often used in search engines?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing undo functionality in applications?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Map",
      "Graph"
    ]
  },
  {
    "q": "What is the primary advantage of using a balanced binary search tree like AVL or Red-Black tree?",
    "c": null,
    "o": [
      "Ensures O(log n) time for insertions, deletions, and lookups",
      "Uses less memory than linked lists",
      "Faster than hash tables in all cases",
      "Automatically sorts data in O(1) time"
    ]
  },
  {
    "q": "Which algorithmic technique is best suited for solving optimization problems with overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is used internally by BFS traversal in a graph?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "In competitive programming, which technique involves iterating over all subsets of a set using bit manipulation?",
    "c": null,
    "o": [
      "Bitmasking",
      "Sliding Window",
      "Dynamic Programming",
      "Greedy"
    ]
  },
  {
    "q": "Which algorithm is used to find the minimum spanning tree of a weighted connected graph?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure provides efficient lookup, insertion, and deletion with average O(1) time complexity?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which scheduling algorithm gives each process a fixed time slot in a cyclic order?",
    "c": null,
    "o": [
      "Round Robin",
      "Shortest Job First",
      "Priority Scheduling",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure is often used to represent hierarchical data such as file systems?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "Queue",
      "Hash Map"
    ]
  },
  {
    "q": "Which algorithmic pattern helps in solving problems by moving two pointers over the input to maintain a window of interest?",
    "c": null,
    "o": [
      "Sliding Window",
      "Divide and Conquer",
      "Backtracking",
      "Greedy"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement a LIFO system?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Table"
    ]
  },
  {
    "q": "Which real-world application heavily relies on graph data structures?",
    "c": null,
    "o": [
      "Social network friend suggestions",
      "Word processing",
      "Image editing",
      "File compression"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which competitive programming technique involves solving overlapping subproblems by storing results?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure allows constant-time average lookup, insertion, and deletion?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which data structure is typically used to implement a breadth-first search?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "Which algorithm helps to detect cycles in undirected graphs?",
    "c": null,
    "o": [
      "Union-Find (Disjoint Set)",
      "DFS with recursion stack",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which scheduling algorithm assigns CPU time based on process priority and allows preemption?",
    "c": null,
    "o": [
      "Priority Scheduling",
      "Round Robin",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure is used internally in an LRU cache to track the order of usage?",
    "c": null,
    "o": [
      "Doubly Linked List",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithmic pattern is useful for problems involving intervals and events ordered by time?",
    "c": null,
    "o": [
      "Sweep Line Algorithm",
      "Divide and Conquer",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is typically used to efficiently implement a FIFO system?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which algorithmic technique is best suited for solving optimization problems with overlapping subproblems and optimal substructure?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is best for implementing a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue to explore nodes level by level?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is commonly used to solve the balanced parentheses problem?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "Which real-world application uses graphs to represent and analyze relationships among entities?",
    "c": null,
    "o": [
      "Social networks",
      "Image compression",
      "Sorting algorithms",
      "Memory management"
    ]
  },
  {
    "q": "Which scheduling algorithm processes the shortest available job next to reduce waiting time?",
    "c": null,
    "o": [
      "Shortest Job First (SJF)",
      "Round Robin",
      "Priority Scheduling",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which competitive programming pattern involves precomputing answers for overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Sliding Window"
    ]
  },
  {
    "q": "Which data structure is often used to implement an autocomplete system efficiently?",
    "c": null,
    "o": [
      "Trie",
      "Stack",
      "Queue",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path from a single source to all vertices in a graph with negative weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing recursive function calls and backtracking?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which real-world system uses graphs to model connections and routes between nodes?",
    "c": null,
    "o": [
      "Transportation networks",
      "File systems",
      "Text editors",
      "Memory allocation"
    ]
  },
  {
    "q": "Which algorithm is used to detect cycles in directed graphs?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "Union-Find",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure provides O(1) average time complexity for search, insertion, and deletion operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which scheduling algorithm assigns CPU to processes in the order they arrive without preemption?",
    "c": null,
    "o": [
      "First Come First Serve (FCFS)",
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First"
    ]
  },
  {
    "q": "Which competitive programming technique helps reduce complexity by avoiding recomputation of subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement a breadth-first search on a tree or graph?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Deque"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest paths between all pairs of vertices in a weighted graph?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is used to efficiently manage and update disjoint sets in union-find operations?",
    "c": null,
    "o": [
      "Disjoint Set Union (DSU)",
      "Stack",
      "Queue",
      "Trie"
    ]
  },
  {
    "q": "Which competitive programming pattern uses two indices to traverse or partition an array or string?",
    "c": null,
    "o": [
      "Two Pointers",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a breadth-first search on large sparse graphs?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Hash Table",
      "Stack"
    ]
  },
  {
    "q": "Which real-world problem can be solved efficiently using a minimum spanning tree algorithm?",
    "c": null,
    "o": [
      "Designing network cabling to minimize cost",
      "Sorting a list of integers",
      "Searching for a word in a dictionary",
      "Compressing files"
    ]
  },
  {
    "q": "Which data structure can be used to implement both FIFO and LIFO behavior depending on the operations used?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is commonly used to detect strongly connected components in a directed graph?",
    "c": null,
    "o": [
      "Tarjan’s Algorithm",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is often used in implementing caches to maintain the order of usage?",
    "c": null,
    "o": [
      "Doubly Linked List",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which competitive programming technique involves precomputing results to answer multiple queries efficiently?",
    "c": null,
    "o": [
      "Prefix Sum",
      "Backtracking",
      "Greedy",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is best for implementing a scheduler that always picks the next task with the highest priority?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Hash Map"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path in a graph with negative weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure efficiently supports insertion, deletion, and median retrieval in a dynamic dataset?",
    "c": null,
    "o": [
      "Two Heaps (Min-Heap and Max-Heap)",
      "Array",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which scheduling algorithm assigns fixed time slots to each process in a cyclic order?",
    "c": null,
    "o": [
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure is typically used for implementing depth-first search (DFS)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "In real-world applications, which data structure is commonly used to represent hierarchical data such as file systems?",
    "c": null,
    "o": [
      "Tree",
      "Graph",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithmic technique breaks problems into smaller independent subproblems, solves them recursively, and combines their results?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is efficient for handling priority-based task scheduling in operating systems?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Hash Table"
    ]
  },
  {
    "q": "Which graph algorithm is used to find the shortest path from a single source to all other vertices in graphs without negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure supports fast lookup, insertion, and deletion operations, typically in O(1) average time?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which scheduling algorithm improves CPU utilization by allowing preemption based on process priority?",
    "c": null,
    "o": [
      "Preemptive Priority Scheduling",
      "First Come First Serve",
      "Round Robin",
      "Shortest Job First"
    ]
  },
  {
    "q": "Which competitive programming pattern is useful when dealing with problems that involve processing all subarrays or substrings efficiently?",
    "c": null,
    "o": [
      "Sliding Window",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement an autocomplete feature for fast prefix-based search?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm can be used to detect negative weight cycles in a graph?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is ideal for managing memory allocation and deallocation in operating systems?",
    "c": null,
    "o": [
      "Linked List",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue to explore nodes in increasing order of their distance from the source?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement undo-redo functionality in text editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Map",
      "Graph"
    ]
  },
  {
    "q": "Which scheduling algorithm is non-preemptive and selects the process with the shortest burst time next?",
    "c": null,
    "o": [
      "Shortest Job First (SJF)",
      "Round Robin",
      "Priority Scheduling",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which algorithmic technique is typically used in solving problems like the knapsack problem and Fibonacci sequence?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure efficiently supports insertion, deletion, and retrieval of the maximum element?",
    "c": null,
    "o": [
      "Max-Heap",
      "Stack",
      "Queue",
      "Hash Table"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a scheduler that prioritizes tasks with the earliest deadline first?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is used to find the strongly connected components of a directed graph in linear time?",
    "c": null,
    "o": [
      "Tarjan’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which competitive programming pattern involves two pointers moving at different speeds to detect cycles or duplicates?",
    "c": null,
    "o": [
      "Floyd’s Cycle Detection (Tortoise and Hare)",
      "Sliding Window",
      "Backtracking",
      "Greedy"
    ]
  },
  {
    "q": "Which data structure is best for representing sparse graphs efficiently?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Hash Table",
      "Array"
    ]
  },
  {
    "q": "Which data structure allows efficient insertion and deletion at both the front and rear ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithmic technique is useful for solving problems by exploring all possible configurations and pruning invalid ones?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is typically used to implement a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Queue",
      "Stack",
      "Hash Map"
    ]
  },
  {
    "q": "Which scheduling algorithm cycles through processes, assigning each a fixed time quantum?",
    "c": null,
    "o": [
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing undo operations in software?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which graph algorithm finds the shortest path from one node to all others in graphs without negative edges?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is best suited for storing and searching strings with common prefixes efficiently?",
    "c": null,
    "o": [
      "Trie",
      "Hash Table",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which technique is commonly used in competitive programming to handle range query problems efficiently?",
    "c": null,
    "o": [
      "Segment Tree",
      "Greedy",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which algorithm is used to detect cycles in an undirected graph efficiently?",
    "c": null,
    "o": [
      "Union-Find (Disjoint Set)",
      "DFS with recursion stack",
      "BFS",
      "Topological Sort"
    ]
  },
  {
    "q": "Which data structure is used to store frequency counts and provide fast lookup in counting sort?",
    "c": null,
    "o": [
      "Array",
      "Linked List",
      "Heap",
      "Stack"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a LIFO cache system?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Table"
    ]
  },
  {
    "q": "Which real-world application frequently uses graphs to represent interconnected entities?",
    "c": null,
    "o": [
      "Social networks",
      "Text editors",
      "Image processing",
      "Database indexing"
    ]
  },
  {
    "q": "Which algorithm is commonly used for finding shortest paths in graphs with weighted edges and no negative cycles?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which competitive programming technique involves storing results of subproblems to avoid recomputation?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure provides average O(1) time complexity for insertion, deletion, and search operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which data structure is used internally by BFS traversal of graphs?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "Which scheduling algorithm preempts processes based on priority levels?",
    "c": null,
    "o": [
      "Priority Scheduling",
      "Round Robin",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure supports efficient prefix-based search for strings?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm can detect negative weight cycles in a weighted graph?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure can be used to maintain the median of a data stream efficiently?",
    "c": null,
    "o": [
      "Two Heaps (Min-Heap and Max-Heap)",
      "Array",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing recursive algorithms and backtracking?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which graph algorithm is used to find the strongly connected components in a directed graph?",
    "c": null,
    "o": [
      "Tarjan’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which scheduling algorithm assigns the CPU to the process that arrives first and runs it to completion without preemption?",
    "c": null,
    "o": [
      "First Come First Serve (FCFS)",
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First"
    ]
  },
  {
    "q": "Which data structure is used internally by Dijkstra’s algorithm to select the next vertex with the smallest tentative distance?",
    "c": null,
    "o": [
      "Min-Heap (Priority Queue)",
      "Stack",
      "Queue",
      "Hash Map"
    ]
  },
  {
    "q": "Which competitive programming pattern involves two indices traversing a data structure to solve problems like subarrays or substrings efficiently?",
    "c": null,
    "o": [
      "Two Pointers",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement a deque (double-ended queue)?",
    "c": null,
    "o": [
      "Doubly Linked List",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm helps find the minimum spanning tree of a connected weighted graph by sorting edges and using union-find?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure efficiently supports range queries and updates in competitive programming?",
    "c": null,
    "o": [
      "Segment Tree",
      "Trie",
      "Heap",
      "Stack"
    ]
  },
  {
    "q": "Which algorithmic technique involves choosing the locally optimal solution at each step in the hope of finding a global optimum?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is best for implementing a cache that removes the least recently used items first?",
    "c": null,
    "o": [
      "Doubly Linked List combined with Hash Map",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a FIFO system?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which algorithmic technique solves problems by combining solutions to overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is used internally by a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue to explore nodes level-by-level?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure helps in solving balanced parentheses or expression parsing problems?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Hash Map"
    ]
  },
  {
    "q": "Which real-world application heavily relies on graphs to model relationships and interactions?",
    "c": null,
    "o": [
      "Social Networks",
      "Image Compression",
      "Sorting Algorithms",
      "Operating Systems"
    ]
  },
  {
    "q": "Which scheduling algorithm always selects the process with the shortest execution time next?",
    "c": null,
    "o": [
      "Shortest Job First (SJF)",
      "Round Robin",
      "Priority Scheduling",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which competitive programming pattern is used to efficiently process all subarrays or substrings in linear time?",
    "c": null,
    "o": [
      "Sliding Window",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is optimized for prefix searching and autocomplete features?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm detects negative weight cycles in graphs?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing an undo operation?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which real-world system can be modeled as a graph where nodes represent locations and edges represent roads?",
    "c": null,
    "o": [
      "Transportation Networks",
      "File Systems",
      "Social Networks",
      "Text Editors"
    ]
  },
  {
    "q": "Which algorithm is most suitable for finding the shortest path in graphs with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which programming pattern stores computed values to avoid redundant calculations in recursive problems?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "Which data structure provides average O(1) time complexity for search, insert, and delete operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which data structure is typically used in BFS graph traversal?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which scheduling algorithm allows processes to run in equal time slices in a cyclic order?",
    "c": null,
    "o": [
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure supports efficient prefix search and is commonly used in autocomplete systems?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm is capable of detecting negative weight cycles in a graph?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure combination is used to implement an LRU cache efficiently?",
    "c": null,
    "o": [
      "Doubly Linked List and Hash Map",
      "Stack and Queue",
      "Heap and Stack",
      "Queue and Trie"
    ]
  },
  {
    "q": "Which data structure allows insertion, deletion, and access of elements in constant average time and maintains no order?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which real-world application uses a graph to represent and optimize flight routes between cities?",
    "c": null,
    "o": [
      "Airline Route Planning",
      "Social Media Friend Suggestions",
      "Web Page Ranking",
      "Inventory Management"
    ]
  },
  {
    "q": "Which algorithm uses a greedy approach to find the minimum spanning tree by selecting edges in order of increasing weight?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which competitive programming technique is used to break a problem into smaller overlapping subproblems and solve each once?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Backtracking",
      "Greedy",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is best suited for efficiently implementing a FIFO queue with O(1) insertion and deletion?",
    "c": null,
    "o": [
      "Linked List",
      "Array",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which scheduling algorithm prioritizes the process with the earliest deadline first to minimize deadline misses?",
    "c": null,
    "o": [
      "Earliest Deadline First (EDF)",
      "Round Robin",
      "Priority Scheduling",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure supports efficient prefix-based searches and is used in IP routing and autocomplete systems?",
    "c": null,
    "o": [
      "Trie",
      "Hash Table",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is designed to find all pairs shortest paths in a graph using dynamic programming?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure allows fast access to the maximum or minimum element and is used in priority queues?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which competitive programming pattern involves moving two pointers to solve problems like subarray sums or longest substring without repeats?",
    "c": null,
    "o": [
      "Two Pointers",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure efficiently supports insertion, deletion, and searching of elements in sorted order?",
    "c": null,
    "o": [
      "Binary Search Tree",
      "Hash Table",
      "Array",
      "Linked List"
    ]
  },
  {
    "q": "Which real-world application benefits from using graphs to model dependencies between tasks?",
    "c": null,
    "o": [
      "Project Scheduling",
      "Image Compression",
      "Text Editing",
      "Database Indexing"
    ]
  },
  {
    "q": "Which algorithm finds the minimum spanning tree starting from an arbitrary node and expanding edges with minimal weights?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which competitive programming technique tries all possible solutions and backtracks when constraints are violated?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is best suited to implement a FIFO queue that also supports fast access to the front and rear elements?",
    "c": null,
    "o": [
      "Deque (Double Ended Queue)",
      "Stack",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which scheduling algorithm assigns the CPU to the process with the highest priority, allowing preemption?",
    "c": null,
    "o": [
      "Preemptive Priority Scheduling",
      "Round Robin",
      "First Come First Serve",
      "Shortest Job First"
    ]
  },
  {
    "q": "Which data structure is used to efficiently find words with a common prefix in dictionaries and autocomplete systems?",
    "c": null,
    "o": [
      "Trie",
      "Hash Table",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which algorithm is used to detect negative weight cycles in a graph by relaxing edges repeatedly?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is used in priority scheduling to efficiently pick the next process to run?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which competitive programming pattern uses precomputed values to answer queries in logarithmic time on arrays?",
    "c": null,
    "o": [
      "Segment Tree",
      "Backtracking",
      "Sliding Window",
      "Two Pointers"
    ]
  },
  {
    "q": "Which data structure uses nodes with pointers to efficiently represent hierarchical relationships?",
    "c": null,
    "o": [
      "Tree",
      "Array",
      "Stack",
      "Hash Table"
    ]
  },
  {
    "q": "Which real-world application uses graphs to model the flow of information between devices?",
    "c": null,
    "o": [
      "Computer Networks",
      "Image Processing",
      "Text Editing",
      "Inventory Management"
    ]
  },
  {
    "q": "Which algorithm finds shortest paths from a single source even when edges have negative weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which competitive programming technique involves recursively exploring all possible choices and undoing them if they lead to invalid solutions?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is best for implementing undo-redo operations where last action is reversed first?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Trie"
    ]
  },
  {
    "q": "Which scheduling algorithm divides CPU time into small slices and cycles through processes to provide fairness?",
    "c": null,
    "o": [
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure allows efficient prefix searching and is implemented as a tree of characters?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm computes shortest paths between all pairs of vertices in a weighted graph using dynamic programming?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is used to implement a priority queue by maintaining a heap property?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which competitive programming pattern uses two pointers moving through a data structure to solve substring or subarray problems efficiently?",
    "c": null,
    "o": [
      "Two Pointers",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is optimal for implementing a last-in, first-out (LIFO) system?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which real-world use case frequently models entities and their relationships using graphs?",
    "c": null,
    "o": [
      "Social Networks",
      "Text Editors",
      "Operating Systems",
      "File Compression"
    ]
  },
  {
    "q": "Which algorithm is best for finding shortest paths in graphs without negative edges?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which technique avoids recomputing solutions to subproblems by storing their results?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy Algorithm",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "Which data structure provides constant average time complexity for insertion, deletion, and search operations using key-value pairs?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Binary Search Tree",
      "Linked List"
    ]
  },
  {
    "q": "Which traversal method uses a queue to explore nodes in a graph level by level?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which CPU scheduling algorithm assigns time slices equally and cycles through processes in a fixed order?",
    "c": null,
    "o": [
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure is highly efficient for prefix-based queries and autocomplete systems?",
    "c": null,
    "o": [
      "Trie",
      "Heap",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm can detect the presence of negative weight cycles in a weighted graph?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure combination is commonly used to implement an efficient Least Recently Used (LRU) cache?",
    "c": null,
    "o": [
      "Doubly Linked List and Hash Map",
      "Stack and Queue",
      "Heap and Queue",
      "Trie and Hash Table"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a priority scheduling system where tasks with the highest priority run first?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Hash Table"
    ]
  },
  {
    "q": "In network routing, which data structure is commonly used to represent the network topology?",
    "c": null,
    "o": [
      "Graph",
      "Array",
      "Stack",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in graphs with possible negative edges but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which technique in competitive programming involves breaking a problem into smaller overlapping subproblems and storing their solutions?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing a FIFO queue with O(1) time complexity for insertions and deletions?",
    "c": null,
    "o": [
      "Linked List",
      "Array",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which scheduling algorithm assigns CPU time based on process priority and allows preemption?",
    "c": null,
    "o": [
      "Preemptive Priority Scheduling",
      "Round Robin",
      "First Come First Serve",
      "Shortest Job First"
    ]
  },
  {
    "q": "Which data structure allows for fast prefix searches and is commonly used in autocomplete features?",
    "c": null,
    "o": [
      "Trie",
      "Hash Table",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm computes shortest paths between all pairs of nodes using dynamic programming?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure maintains the heap property, enabling efficient access to the minimum or maximum element?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which competitive programming technique involves using two indices moving through an array to solve problems like finding subarrays or substrings?",
    "c": null,
    "o": [
      "Two Pointers",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement recursive function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which real-world application commonly uses graphs to model and analyze social relationships?",
    "c": null,
    "o": [
      "Social Networks",
      "Database Indexing",
      "Operating Systems",
      "Image Processing"
    ]
  },
  {
    "q": "Which algorithm is best for finding shortest paths in weighted graphs without negative edges?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which technique in algorithm design involves solving a problem by combining solutions to smaller subproblems?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure allows insertion and deletion at both ends efficiently?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which scheduling algorithm assigns CPU time slices to processes in a cyclic order?",
    "c": null,
    "o": [
      "Round Robin",
      "Priority Scheduling",
      "Shortest Job First",
      "First Come First Serve"
    ]
  },
  {
    "q": "Which data structure is optimized for prefix matching and autocomplete in text processing?",
    "c": null,
    "o": [
      "Trie",
      "Hash Table",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which algorithm detects negative cycles and finds shortest paths in graphs with negative edges?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is used to efficiently implement priority queues?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which competitive programming technique uses two pointers moving at different speeds to detect cycles in a linked list?",
    "c": null,
    "o": [
      "Floyd’s Cycle Detection Algorithm",
      "Sliding Window",
      "Backtracking",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which of the following sorting algorithms has the best average-case performance?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which traversal method uses a stack to process nodes in depth-first order?",
    "c": null,
    "o": [
      "DFS (Depth-First Search)",
      "BFS (Breadth-First Search)",
      "Level Order Traversal",
      "Inorder Traversal"
    ]
  },
  {
    "q": "Which graph representation is better for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Incidence Matrix",
      "Edge List"
    ]
  },
  {
    "q": "Which algorithm technique is used in the 0/1 Knapsack Problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure uses LIFO (Last In, First Out) order?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Tree"
    ]
  },
  {
    "q": "Which of these problems can be solved using the Union-Find data structure?",
    "c": null,
    "o": [
      "Cycle Detection in Undirected Graph",
      "Shortest Path",
      "Minimum Spanning Tree",
      "Topological Sort"
    ]
  },
  {
    "q": "Which of the following is a characteristic of greedy algorithms?",
    "c": null,
    "o": [
      "Make locally optimal choices",
      "Try all possible solutions",
      "Divide problem into subproblems",
      "Explore multiple paths"
    ]
  },
  {
    "q": "Which tree traversal method prints the left subtree, the root, and then the right subtree?",
    "c": null,
    "o": [
      "Inorder Traversal",
      "Preorder Traversal",
      "Postorder Traversal",
      "Level Order Traversal"
    ]
  },
  {
    "q": "Which hashing technique handles collisions by placing items in a list at each index?",
    "c": null,
    "o": [
      "Chaining",
      "Linear Probing",
      "Quadratic Probing",
      "Double Hashing"
    ]
  },
  {
    "q": "Which of the following problems is best suited for backtracking?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Sorting a list",
      "Finding shortest path",
      "Evaluating arithmetic expressions"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is not based on comparison?",
    "c": null,
    "o": [
      "Counting Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which data structure is used in the implementation of recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which traversal method is used in BFS of a graph?",
    "c": null,
    "o": [
      "Level Order Traversal",
      "Inorder Traversal",
      "Preorder Traversal",
      "Postorder Traversal"
    ]
  },
  {
    "q": "Which of the following is a self-balancing binary search tree?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Heap",
      "Trie",
      "Segment Tree"
    ]
  },
  {
    "q": "Which algorithm design technique is used in Merge Sort?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Dynamic Programming",
      "Greedy",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure gives the best performance for implementing priority queues?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue to explore nodes?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Inorder Traversal",
      "Postorder Traversal"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following algorithms is used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element in a binary heap?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is true for a stable sorting algorithm?",
    "c": null,
    "o": [
      "It preserves the relative order of equal elements",
      "It sorts faster than unstable sorts",
      "It requires less memory",
      "It always uses recursion"
    ]
  },
  {
    "q": "Which of the following data structures is best suited for implementing LRU cache?",
    "c": null,
    "o": [
      "HashMap and Doubly Linked List",
      "Stack and Queue",
      "Binary Heap",
      "Priority Queue"
    ]
  },
  {
    "q": "Which of the following is not a greedy algorithm?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm",
      "Activity Selection Problem"
    ]
  },
  {
    "q": "Which sorting algorithm is the best for nearly sorted data?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "In a min-heap, the smallest element is always located at:",
    "c": null,
    "o": [
      "The root node",
      "The leftmost leaf",
      "The rightmost node",
      "Any leaf node"
    ]
  },
  {
    "q": "Which graph algorithm works by relaxing the edges repeatedly?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following data structures supports FIFO (First-In First-Out) order?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Heap"
    ]
  },
  {
    "q": "Which technique is used by the Floyd-Warshall algorithm?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path from a source to all other vertices in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Depth-First Search"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which algorithm is used to find strongly connected components in a graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of a binary search tree?",
    "c": null,
    "o": [
      "All left descendants are less than the node",
      "All right descendants are greater than the node",
      "Duplicates are always placed on the right",
      "It is a complete binary tree"
    ]
  },
  {
    "q": "Which algorithm uses divide and conquer approach?",
    "c": null,
    "o": [
      "Merge Sort",
      "Prim's Algorithm",
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What is the best case time complexity of Insertion Sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which traversal method is used in Depth-First Search?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Hash Table"
    ]
  },
  {
    "q": "Which of the following algorithms is used for Topological Sorting?",
    "c": null,
    "o": [
      "Kahn’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which of these sorting algorithms has the worst-case time complexity of O(n log n)?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which of the following problems can be solved using dynamic programming?",
    "c": null,
    "o": [
      "0/1 Knapsack Problem",
      "Minimum Spanning Tree",
      "Binary Search",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following is true for a greedy algorithm?",
    "c": null,
    "o": [
      "It builds up a solution piece by piece always choosing the next piece that offers the most immediate benefit.",
      "It always finds the global optimum.",
      "It works only for graphs with cycles.",
      "It backtracks to correct mistakes."
    ]
  },
  {
    "q": "Which algorithm is used for solving the All-Pairs Shortest Path problem?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "In which scenario does the Bellman-Ford algorithm work better than Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "When the graph contains negative weight edges",
      "When the graph is undirected",
      "When the graph contains only positive edges",
      "When the graph is a tree"
    ]
  },
  {
    "q": "Which of the following is not used in Dynamic Programming?",
    "c": null,
    "o": [
      "Backtracking",
      "Overlapping subproblems",
      "Optimal substructure",
      "Memoization"
    ]
  },
  {
    "q": "Which of the following is a Divide and Conquer algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Prim's Algorithm",
      "Bellman-Ford",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which sorting algorithm is considered stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Heap Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the time complexity of Binary Search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following is an example of a backtracking algorithm?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Kruskal’s Algorithm",
      "Heap Sort",
      "Binary Search"
    ]
  },
  {
    "q": "Which graph traversal algorithm can detect cycles in a directed graph?",
    "c": null,
    "o": [
      "Depth-First Search",
      "Breadth-First Search",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm is used for finding the minimum spanning tree of a graph?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which of the following problems can be solved using the Dynamic Programming technique?",
    "c": null,
    "o": [
      "Longest Common Subsequence",
      "Binary Search",
      "Depth-First Search",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the main idea behind Divide and Conquer algorithms?",
    "c": null,
    "o": [
      "Break the problem into sub-problems, solve them independently, and combine their solutions",
      "Repeat the steps in a loop until the answer is found",
      "Use a greedy approach to find optimal solution",
      "Traverse the graph until all nodes are visited"
    ]
  },
  {
    "q": "Which of the following is NOT a property of a greedy algorithm?",
    "c": null,
    "o": [
      "Backtracking to explore all paths",
      "Making locally optimal choices",
      "No re-computation of subproblems",
      "Solving problems in top-down manner"
    ]
  },
  {
    "q": "Which algorithm is best suited for solving the 0/1 Knapsack problem exactly?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Depth-First Search"
    ]
  },
  {
    "q": "What is the best-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which of the following algorithms is used to find articulation points in a graph?",
    "c": null,
    "o": [
      "Depth-First Search",
      "Breadth-First Search",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm uses a priority queue to efficiently determine the shortest path from a source?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "What is the typical space complexity of Dynamic Programming solutions using bottom-up tabulation?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which sorting algorithm divides the array into two halves, recursively sorts them, and merges them?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which approach does the backtracking algorithm use?",
    "c": null,
    "o": [
      "Depth-first search with pruning",
      "Breadth-first traversal",
      "Divide and conquer",
      "Greedy choices with memoization"
    ]
  },
  {
    "q": "Which of the following algorithm paradigms does the Floyd-Warshall algorithm belong to?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "In a greedy algorithm, which of the following is most essential for correctness?",
    "c": null,
    "o": [
      "Greedy Choice Property and Optimal Substructure",
      "Memoization of all subproblems",
      "Backtracking through all decisions",
      "Dividing the problem into equal halves"
    ]
  },
  {
    "q": "Which of the following is a limitation of greedy algorithms?",
    "c": null,
    "o": [
      "They don’t always produce the globally optimal solution",
      "They are not time efficient",
      "They use recursion extensively",
      "They work only on undirected graphs"
    ]
  },
  {
    "q": "Which algorithm technique is primarily used in the Tower of Hanoi problem?",
    "c": null,
    "o": [
      "Recursion",
      "Greedy",
      "Backtracking",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which of the following algorithms solves the Single Source Shortest Path problem in graphs with negative weights?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm is used for finding Minimum Spanning Tree using greedy method?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Tarjan’s Algorithm"
    ]
  },
  {
    "q": "Which of the following problems is best solved using backtracking?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Sorting an Array",
      "Finding Maximum Subarray",
      "Binary Search"
    ]
  },
  {
    "q": "What is memoization in dynamic programming?",
    "c": null,
    "o": [
      "Storing results of subproblems to avoid recomputation",
      "Dividing the problem into half at every step",
      "Making greedy decisions at each step",
      "Backtracking to undo previous steps"
    ]
  },
  {
    "q": "Which of the following is true about the time complexity of Merge Sort?",
    "c": null,
    "o": [
      "It is always O(n log n)",
      "Best case is O(n)",
      "Worst case is O(n^2)",
      "Average case is O(n)"
    ]
  },
  {
    "q": "Which of the following is an application of the BFS algorithm?",
    "c": null,
    "o": [
      "Shortest path in an unweighted graph",
      "Topological sorting of a DAG",
      "Finding bridges in a graph",
      "Minimum Spanning Tree"
    ]
  },
  {
    "q": "Which of the following problems can be efficiently solved using Dynamic Programming?",
    "c": null,
    "o": [
      "Longest Common Subsequence",
      "Sorting a List",
      "Finding a Prime Number",
      "Binary Search Tree Traversal"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of Divide and Conquer approach?",
    "c": null,
    "o": [
      "Overlapping subproblems",
      "Problem is divided into subproblems",
      "Solutions of subproblems are combined",
      "Recursion is typically used"
    ]
  },
  {
    "q": "What is the primary goal of a greedy algorithm?",
    "c": null,
    "o": [
      "Make locally optimal choices hoping for a global optimum",
      "Search all possibilities",
      "Divide the problem into overlapping subproblems",
      "Combine results of subproblems"
    ]
  },
  {
    "q": "Which of the following is NOT solved using backtracking?",
    "c": null,
    "o": [
      "Merge Sort",
      "Sudoku Solver",
      "N-Queens Problem",
      "Hamiltonian Cycle"
    ]
  },
  {
    "q": "Which algorithm technique is used in Strassen’s Matrix Multiplication?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "In dynamic programming, what does 'optimal substructure' mean?",
    "c": null,
    "o": [
      "An optimal solution can be built from optimal solutions of subproblems",
      "The structure of the algorithm is optimal",
      "Every subproblem has the same size",
      "Subproblems do not overlap"
    ]
  },
  {
    "q": "Which algorithm is an example of using both Dynamic Programming and Greedy techniques?",
    "c": null,
    "o": [
      "Huffman Coding",
      "Quick Sort",
      "Binary Search",
      "Depth First Search"
    ]
  },
  {
    "q": "Which sorting algorithm uses Divide and Conquer technique?",
    "c": null,
    "o": [
      "Merge Sort",
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which problem is a good example of overlapping subproblems?",
    "c": null,
    "o": [
      "Fibonacci Sequence",
      "Binary Search",
      "Depth First Search",
      "Linear Search"
    ]
  },
  {
    "q": "What is the major drawback of the brute-force approach?",
    "c": null,
    "o": [
      "It has high time complexity",
      "It is hard to implement",
      "It always gives incorrect results",
      "It uses a greedy strategy"
    ]
  },
  {
    "q": "Which algorithmic technique is used in solving the Tower of Hanoi problem?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following is true for greedy algorithms?",
    "c": null,
    "o": [
      "They make a locally optimal choice at each step",
      "They solve subproblems only once",
      "They always produce the globally optimal solution",
      "They work by exploring all possibilities"
    ]
  },
  {
    "q": "Which of the following problems is best suited for the divide and conquer approach?",
    "c": null,
    "o": [
      "Merge Sort",
      "0/1 Knapsack Problem",
      "Travelling Salesman Problem",
      "Graph Coloring"
    ]
  },
  {
    "q": "Which of these techniques is used in solving the Longest Increasing Subsequence problem efficiently?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Greedy Algorithm",
      "Brute Force"
    ]
  },
  {
    "q": "Which problem can be solved using backtracking?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Binary Search",
      "Bubble Sort",
      "Matrix Multiplication"
    ]
  },
  {
    "q": "Which is a key difference between dynamic programming and divide and conquer?",
    "c": null,
    "o": [
      "Dynamic programming solves overlapping subproblems",
      "Divide and conquer avoids recursion",
      "Divide and conquer solves overlapping subproblems",
      "Dynamic programming does not use subproblems"
    ]
  },
  {
    "q": "What makes a problem suitable for a greedy solution?",
    "c": null,
    "o": [
      "Greedy choice property and optimal substructure",
      "Only overlapping subproblems",
      "High space complexity",
      "Multiple solutions"
    ]
  },
  {
    "q": "Which of the following is NOT a feature of backtracking?",
    "c": null,
    "o": [
      "Always chooses the best option first",
      "Recursively explores possibilities",
      "Abandons solutions that do not meet criteria",
      "Tries all options if needed"
    ]
  },
  {
    "q": "Which of these is an example of a problem that can be solved using a greedy algorithm?",
    "c": null,
    "o": [
      "Fractional Knapsack Problem",
      "Longest Common Subsequence",
      "Matrix Chain Multiplication",
      "Edit Distance"
    ]
  },
  {
    "q": "Which algorithmic strategy is typically used for optimization problems like shortest path?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Backtracking",
      "Brute Force",
      "Recursion without memoization"
    ]
  },
  {
    "q": "Which algorithmic technique is used in solving the Matrix Chain Multiplication problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which of the following algorithmic strategies is most suitable for problems with optimal substructure and overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Branch and Bound"
    ]
  },
  {
    "q": "In which technique do we build up a solution using previously computed solutions to subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Backtracking",
      "Brute Force",
      "Greedy Algorithm"
    ]
  },
  {
    "q": "Which of these is a key characteristic of the Divide and Conquer technique?",
    "c": null,
    "o": [
      "Problem is divided into independent subproblems",
      "All subproblems are solved simultaneously",
      "Solution is built from smallest to largest subproblem",
      "Always gives the best solution"
    ]
  },
  {
    "q": "Which of these is an application of the backtracking algorithm?",
    "c": null,
    "o": [
      "Sudoku Solver",
      "Binary Search",
      "Heap Sort",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "q": "Which of the following problems can be solved using Dynamic Programming?",
    "c": null,
    "o": [
      "Longest Common Subsequence",
      "N-Queens",
      "Linear Search",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of these problems is commonly solved using the greedy approach?",
    "c": null,
    "o": [
      "Huffman Coding",
      "Matrix Chain Multiplication",
      "0/1 Knapsack Problem",
      "Travelling Salesman Problem"
    ]
  },
  {
    "q": "What is memoization in the context of dynamic programming?",
    "c": null,
    "o": [
      "Caching previously computed results",
      "Dividing the problem into smaller subproblems",
      "Choosing the local optimum",
      "Backtracking on invalid options"
    ]
  },
  {
    "q": "Which problem is not suitable for the greedy algorithm?",
    "c": null,
    "o": [
      "0/1 Knapsack Problem",
      "Fractional Knapsack Problem",
      "Huffman Coding",
      "Activity Selection Problem"
    ]
  },
  {
    "q": "What does backtracking mainly rely on?",
    "c": null,
    "o": [
      "Recursion and pruning",
      "Memoization",
      "Sorting",
      "Greedy choice"
    ]
  },
  {
    "q": "Which algorithmic technique does the Quick Sort algorithm use?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Dynamic Programming",
      "Greedy Method",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following is true about greedy algorithms?",
    "c": null,
    "o": [
      "They make the locally optimal choice at each step",
      "They always guarantee the globally optimal solution",
      "They solve problems by exhaustive search",
      "They are based on recursion and memoization"
    ]
  },
  {
    "q": "What is the key difference between backtracking and branch-and-bound?",
    "c": null,
    "o": [
      "Branch-and-bound uses cost function to prune nodes",
      "Backtracking guarantees the optimal solution",
      "Branch-and-bound solves only graph problems",
      "Backtracking uses greedy heuristics"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Floyd-Warshall Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "In which of the following is the optimal substructure property essential?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithms",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "Which technique is primarily used in solving the Traveling Salesman Problem (TSP) using brute force?",
    "c": null,
    "o": [
      "Backtracking with all permutations",
      "Greedy Method",
      "Divide and Conquer",
      "Dynamic Programming"
    ]
  },
  {
    "q": "What makes an algorithm follow the divide and conquer paradigm?",
    "c": null,
    "o": [
      "Divides a problem into subproblems, solves them independently, and combines solutions",
      "Finds optimal solution by comparing all possible outcomes",
      "Solves problems using recursion and memorization",
      "Builds up solution by choosing the best local option"
    ]
  },
  {
    "q": "What is a common application of dynamic programming?",
    "c": null,
    "o": [
      "Fibonacci number calculation",
      "Depth First Search",
      "Bubble Sort",
      "Binary Search"
    ]
  },
  {
    "q": "Which of these is not typically solved using backtracking?",
    "c": null,
    "o": [
      "Dijkstra’s Shortest Path",
      "Sudoku Solver",
      "N-Queens Problem",
      "Hamiltonian Circuit"
    ]
  },
  {
    "q": "Which problem is commonly solved using the divide and conquer technique?",
    "c": null,
    "o": [
      "Merge Sort",
      "Floyd-Warshall Algorithm",
      "0/1 Knapsack",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following problems is best solved using the greedy method?",
    "c": null,
    "o": [
      "Activity Selection Problem",
      "Fibonacci Number Calculation",
      "Tower of Hanoi",
      "Matrix Chain Multiplication"
    ]
  },
  {
    "q": "What is memoization in dynamic programming?",
    "c": null,
    "o": [
      "Storing previously computed results to avoid recomputation",
      "Dividing a problem into subproblems",
      "Making decisions at each step to build a solution",
      "Using stacks to store recursion states"
    ]
  },
  {
    "q": "Which data structure is commonly used in the implementation of Dijkstra’s Algorithm?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which of the following is NOT a property of dynamic programming?",
    "c": null,
    "o": [
      "Always uses recursion",
      "Optimal substructure",
      "Overlapping subproblems",
      "Bottom-up or top-down approach"
    ]
  },
  {
    "q": "In which algorithmic technique are decisions made at each step with the hope that they lead to the optimal solution?",
    "c": null,
    "o": [
      "Greedy Method",
      "Dynamic Programming",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "What is the time complexity of the naive recursive solution for the Fibonacci sequence?",
    "c": null,
    "o": [
      "O(2^n)",
      "O(n)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which technique is used in the binary search algorithm?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy Method",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "Which of the following problems does NOT typically use dynamic programming?",
    "c": null,
    "o": [
      "Finding the minimum spanning tree",
      "0/1 Knapsack Problem",
      "Longest Common Subsequence",
      "Matrix Chain Multiplication"
    ]
  },
  {
    "q": "Which of the following is true about greedy algorithms?",
    "c": null,
    "o": [
      "They may not always produce the optimal solution",
      "They always consider all subproblems",
      "They store results of subproblems",
      "They work only with recursive problems"
    ]
  },
  {
    "q": "Which algorithmic technique does Merge Sort use?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy Method",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "Which of the following problems can be solved using dynamic programming?",
    "c": null,
    "o": [
      "Longest Common Subsequence",
      "Finding Prime Numbers",
      "Binary Search",
      "Breadth First Search"
    ]
  },
  {
    "q": "Which algorithmic strategy is most suitable for solving the Fractional Knapsack problem?",
    "c": null,
    "o": [
      "Greedy Method",
      "Dynamic Programming",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which one is a key difference between divide-and-conquer and dynamic programming?",
    "c": null,
    "o": [
      "Overlapping subproblems are solved in dynamic programming but not in divide-and-conquer",
      "Divide-and-conquer is bottom-up while dynamic programming is top-down",
      "Dynamic programming requires recursion while divide-and-conquer does not",
      "Divide-and-conquer always provides optimal solutions, but dynamic programming does not"
    ]
  },
  {
    "q": "In dynamic programming, what does 'optimal substructure' mean?",
    "c": null,
    "o": [
      "The solution to the problem can be constructed from solutions to its subproblems",
      "The problem can only be solved recursively",
      "Each subproblem must be solved independently",
      "The problem has no overlapping subproblems"
    ]
  },
  {
    "q": "Which of these problems is typically solved using backtracking?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Fibonacci Number Calculation",
      "Binary Search",
      "Huffman Encoding"
    ]
  },
  {
    "q": "Which problem does NOT typically use the greedy method for an optimal solution?",
    "c": null,
    "o": [
      "0/1 Knapsack Problem",
      "Huffman Coding",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which technique avoids solving the same subproblem multiple times?",
    "c": null,
    "o": [
      "Memoization",
      "Greedy Method",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "What is the space complexity of storing a dynamic programming table for the Longest Common Subsequence (LCS) problem of two strings of length m and n?",
    "c": null,
    "o": [
      "O(m * n)",
      "O(m + n)",
      "O(log m + log n)",
      "O(m^n)"
    ]
  },
  {
    "q": "Which of the following uses a top-down approach?",
    "c": null,
    "o": [
      "Memoization",
      "Tabulation",
      "Greedy Algorithm",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following is the best example of a problem with overlapping subproblems?",
    "c": null,
    "o": [
      "Fibonacci Sequence",
      "Binary Search",
      "Linear Search",
      "Tower of Hanoi"
    ]
  },
  {
    "q": "Which algorithm is most suitable for solving the 'Activity Selection Problem'?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "In which of the following problems is memoization commonly used?",
    "c": null,
    "o": [
      "Fibonacci Number Computation",
      "Breadth First Search",
      "Bubble Sort",
      "Depth First Search"
    ]
  },
  {
    "q": "Which of the following problems does NOT have optimal substructure property?",
    "c": null,
    "o": [
      "Travelling Salesman Problem using brute force",
      "Longest Common Subsequence",
      "Shortest Path in a Graph",
      "0/1 Knapsack Problem"
    ]
  },
  {
    "q": "Which of the following is an example of a divide and conquer algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which of the following problems can be solved using dynamic programming but NOT efficiently with greedy algorithms?",
    "c": null,
    "o": [
      "0/1 Knapsack Problem",
      "Fractional Knapsack Problem",
      "Minimum Spanning Tree",
      "Activity Selection Problem"
    ]
  },
  {
    "q": "Which of the following algorithm paradigms is typically used to solve the Traveling Salesman Problem (TSP)?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Linear Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which of these is an advantage of dynamic programming over recursion?",
    "c": null,
    "o": [
      "Avoids recomputation of subproblems",
      "Always runs faster",
      "Uses more memory",
      "Is easier to understand"
    ]
  },
  {
    "q": "Which of the following algorithms is NOT a greedy algorithm?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Huffman Coding",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "In tabulation method of dynamic programming, which order are the subproblems solved?",
    "c": null,
    "o": [
      "Bottom-up",
      "Top-down",
      "Random Order",
      "Greedy Order"
    ]
  },
  {
    "q": "Which of the following properties must a problem satisfy to be solved using dynamic programming?",
    "c": null,
    "o": [
      "Overlapping subproblems and optimal substructure",
      "Only optimal substructure",
      "Only overlapping subproblems",
      "None of the above"
    ]
  },
  {
    "q": "Which technique is used in greedy algorithms to make decisions?",
    "c": null,
    "o": [
      "Locally optimal choice",
      "Backtracking",
      "Divide and merge",
      "Memoization"
    ]
  },
  {
    "q": "What is the time complexity of the merge sort algorithm?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which of the following problems can be efficiently solved using a greedy algorithm?",
    "c": null,
    "o": [
      "Fractional Knapsack",
      "0/1 Knapsack",
      "Longest Common Subsequence",
      "Matrix Chain Multiplication"
    ]
  },
  {
    "q": "Which dynamic programming approach uses recursion and memoization?",
    "c": null,
    "o": [
      "Top-down",
      "Bottom-up",
      "Greedy",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which of the following is an application of dynamic programming?",
    "c": null,
    "o": [
      "Rod Cutting Problem",
      "Depth First Search",
      "Binary Search Tree Traversal",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the main idea behind divide and conquer algorithms?",
    "c": null,
    "o": [
      "Divide problem into subproblems, solve them recursively, and combine solutions",
      "Divide input into equal halves without solving",
      "Iterate through entire input",
      "Try all possible solutions and pick the best one"
    ]
  },
  {
    "q": "Which algorithmic strategy would best solve the Longest Increasing Subsequence problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Brute Force",
      "Divide and Conquer"
    ]
  },
  {
    "q": "In greedy algorithms, the greedy choice property ensures:",
    "c": null,
    "o": [
      "A locally optimal choice leads to a globally optimal solution",
      "Every possible path is evaluated",
      "All subproblems are solved",
      "Solutions are always optimal"
    ]
  },
  {
    "q": "Which algorithm uses a greedy approach for constructing an optimal prefix code?",
    "c": null,
    "o": [
      "Huffman Coding",
      "Kruskal’s Algorithm",
      "Binary Search",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which condition is necessary for divide and conquer to work efficiently?",
    "c": null,
    "o": [
      "Subproblems must be independent",
      "Subproblems must be overlapping",
      "Only one subproblem must exist",
      "All subproblems must share the same input"
    ]
  },
  {
    "q": "Which of the following is a characteristic of dynamic programming?",
    "c": null,
    "o": [
      "Overlapping subproblems",
      "Independent subproblems",
      "Randomized decisions",
      "Unstructured recursion"
    ]
  },
  {
    "q": "Which problem is best solved using the divide and conquer technique?",
    "c": null,
    "o": [
      "Merge Sort",
      "Dijkstra’s Algorithm",
      "0/1 Knapsack",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "In dynamic programming, what does memoization help prevent?",
    "c": null,
    "o": [
      "Repeated calculations",
      "Memory overflow",
      "Incorrect results",
      "Code duplication"
    ]
  },
  {
    "q": "Which of the following is not typically solved using a greedy approach?",
    "c": null,
    "o": [
      "0/1 Knapsack Problem",
      "Prim’s Minimum Spanning Tree",
      "Activity Selection Problem",
      "Huffman Encoding"
    ]
  },
  {
    "q": "What is the time complexity of a divide and conquer algorithm that divides a problem into 2 subproblems of size n/2 and combines them in linear time?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which property allows dynamic programming to store solutions to subproblems?",
    "c": null,
    "o": [
      "Optimal substructure",
      "Greedy choice",
      "Recursion depth",
      "Independent branching"
    ]
  },
  {
    "q": "Which algorithm is an example of divide and conquer in computational geometry?",
    "c": null,
    "o": [
      "Closest Pair of Points",
      "Floyd-Warshall Algorithm",
      "Bellman-Ford Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "Which method is used to solve problems in the bottom-up dynamic programming approach?",
    "c": null,
    "o": [
      "Tabulation",
      "Memoization",
      "Backtracking",
      "Greedy expansion"
    ]
  },
  {
    "q": "Which algorithm uses dynamic programming to find shortest paths between all pairs of vertices?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms is a greedy algorithm for minimum spanning trees?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "Which of the following is a necessary condition for a greedy algorithm to work?",
    "c": null,
    "o": [
      "Greedy choice property",
      "Backtracking property",
      "Overlapping subproblems",
      "Divide and merge property"
    ]
  },
  {
    "q": "Which of the following is NOT a step in divide and conquer?",
    "c": null,
    "o": [
      "Merge all results directly",
      "Divide the problem into subproblems",
      "Conquer the subproblems recursively",
      "Combine the results of subproblems"
    ]
  },
  {
    "q": "What is the primary advantage of using dynamic programming over recursion?",
    "c": null,
    "o": [
      "Avoids recalculating overlapping subproblems",
      "Uses more memory for speed",
      "Always faster for any problem",
      "Requires no base case"
    ]
  },
  {
    "q": "Which problem can be efficiently solved using greedy strategy?",
    "c": null,
    "o": [
      "Fractional Knapsack",
      "0/1 Knapsack",
      "Longest Common Subsequence",
      "Matrix Chain Multiplication"
    ]
  },
  {
    "q": "In divide and conquer, if a problem is divided into 'a' subproblems of size n/b, and the combine step takes O(n^d) time, what is the Master Theorem case when a < b^d?",
    "c": null,
    "o": [
      "Case 1: T(n) = Θ(n^d)",
      "Case 2: T(n) = Θ(n^d log n)",
      "Case 3: T(n) = Θ(n^log_b(a))",
      "Cannot be determined"
    ]
  },
  {
    "q": "What does greedy algorithm assume at each step?",
    "c": null,
    "o": [
      "Locally optimal choice leads to global optimum",
      "All subproblems are independent",
      "Global optimum is known",
      "Solution must be brute-forced"
    ]
  },
  {
    "q": "What is the optimal substructure property?",
    "c": null,
    "o": [
      "An optimal solution can be constructed from optimal solutions of subproblems",
      "All subproblems must be of equal size",
      "Only global choices matter",
      "Greedy choices are always correct"
    ]
  },
  {
    "q": "Which algorithm is based on dynamic programming for solving the matrix chain multiplication problem?",
    "c": null,
    "o": [
      "Matrix Chain Order Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of the following problems is commonly solved using dynamic programming?",
    "c": null,
    "o": [
      "Longest Increasing Subsequence",
      "Heap Sort",
      "Depth First Search",
      "Binary Search Tree Insertion"
    ]
  },
  {
    "q": "Which characteristic is common to problems suitable for dynamic programming?",
    "c": null,
    "o": [
      "Overlapping subproblems and optimal substructure",
      "Greedy choices and randomization",
      "Independent subproblems only",
      "Problems must be non-recursive"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is based on the divide and conquer technique?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which algorithm design technique does Dijkstra's algorithm follow?",
    "c": null,
    "o": [
      "Greedy",
      "Divide and Conquer",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which algorithm design strategy does the Floyd-Warshall algorithm use?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Divide and Conquer",
      "Brute Force"
    ]
  },
  {
    "q": "Which of the following is an example of a problem that can be solved using backtracking?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Binary Search",
      "Bubble Sort",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "What is the time complexity of Merge Sort in the worst case?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "In the greedy algorithm for job scheduling with deadlines, what is the typical strategy?",
    "c": null,
    "o": [
      "Select jobs with maximum profit first",
      "Select shortest jobs first",
      "Select jobs randomly",
      "Select jobs with earliest deadlines first"
    ]
  },
  {
    "q": "Which type of problems cannot be solved using greedy algorithms?",
    "c": null,
    "o": [
      "0/1 Knapsack Problem",
      "Activity Selection Problem",
      "Fractional Knapsack Problem",
      "Huffman Encoding"
    ]
  },
  {
    "q": "Which of the following is NOT a property of dynamic programming problems?",
    "c": null,
    "o": [
      "Greedy choice property",
      "Optimal substructure",
      "Overlapping subproblems",
      "Memoization"
    ]
  },
  {
    "q": "What is the recurrence relation for Merge Sort?",
    "c": null,
    "o": [
      "T(n) = 2T(n/2) + O(n)",
      "T(n) = T(n-1) + O(1)",
      "T(n) = T(n/2) + O(1)",
      "T(n) = T(n-1) + T(n-2)"
    ]
  },
  {
    "q": "Which of the following uses backtracking?",
    "c": null,
    "o": [
      "Sudoku Solver",
      "Merge Sort",
      "Binary Search",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the main idea behind the divide and conquer technique?",
    "c": null,
    "o": [
      "Breaking a problem into smaller subproblems, solving them independently, and combining their results",
      "Trying all possible solutions",
      "Solving problems iteratively",
      "Using a greedy approach to find local optima"
    ]
  },
  {
    "q": "Which of the following problems is best solved using dynamic programming?",
    "c": null,
    "o": [
      "Longest Common Subsequence",
      "Linear Search",
      "Tower of Hanoi",
      "Binary Search"
    ]
  },
  {
    "q": "Which algorithm uses a greedy approach to build an optimal binary tree for data compression?",
    "c": null,
    "o": [
      "Huffman Encoding",
      "Merge Sort",
      "Prim's Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "What does the term 'memoization' refer to in dynamic programming?",
    "c": null,
    "o": [
      "Storing the results of expensive function calls and reusing them",
      "Dividing a problem into smaller parts",
      "Randomizing input data",
      "Sorting a list to optimize access"
    ]
  },
  {
    "q": "Which of these algorithms uses the backtracking technique?",
    "c": null,
    "o": [
      "Solving a Maze",
      "Bubble Sort",
      "Linear Search",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm is an example of the greedy strategy?",
    "c": null,
    "o": [
      "Prim's Algorithm",
      "Merge Sort",
      "Binary Search",
      "Depth First Search"
    ]
  },
  {
    "q": "Which of the following problems cannot be optimally solved using greedy algorithms?",
    "c": null,
    "o": [
      "0/1 Knapsack Problem",
      "Minimum Spanning Tree",
      "Huffman Encoding",
      "Activity Selection"
    ]
  },
  {
    "q": "Which of the following is NOT a step in the divide and conquer paradigm?",
    "c": null,
    "o": [
      "Make greedy choices",
      "Divide the problem",
      "Conquer subproblems",
      "Combine results"
    ]
  },
  {
    "q": "Which problem is a good candidate for dynamic programming due to overlapping subproblems?",
    "c": null,
    "o": [
      "Fibonacci Number Calculation",
      "Sorting a List",
      "Finding Maximum in an Array",
      "Traversing a Tree"
    ]
  },
  {
    "q": "Which algorithm is typically used to find all subsets of a set?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which of the following is a characteristic of greedy algorithms?",
    "c": null,
    "o": [
      "They make the locally optimal choice at each step",
      "They always guarantee the globally optimal solution",
      "They store all intermediate results",
      "They solve problems by recursion only"
    ]
  },
  {
    "q": "In dynamic programming, what is the optimal substructure property?",
    "c": null,
    "o": [
      "A problem’s solution can be constructed efficiently from solutions of its subproblems",
      "The solution involves choosing the best greedy option",
      "The problem is solved by brute force",
      "The problem needs to be divided in a specific ratio"
    ]
  },
  {
    "q": "Which algorithm uses divide and conquer and is efficient for sorting?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Backtracking is most suitable for which type of problems?",
    "c": null,
    "o": [
      "Constraint Satisfaction Problems like N-Queens",
      "Finding the maximum element",
      "Searching in a sorted array",
      "Calculating GCD of two numbers"
    ]
  },
  {
    "q": "What does dynamic programming avoid that recursion may not?",
    "c": null,
    "o": [
      "Repeated calculation of the same subproblems",
      "Breaking a problem into parts",
      "Stack overflow",
      "Memory allocation"
    ]
  },
  {
    "q": "Which of the following problems can be efficiently solved using a greedy algorithm?",
    "c": null,
    "o": [
      "Fractional Knapsack",
      "0/1 Knapsack",
      "Travelling Salesman Problem",
      "Matrix Chain Multiplication"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path from a single source in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of these algorithms is based on backtracking?",
    "c": null,
    "o": [
      "Sudoku Solver",
      "Dijkstra’s Algorithm",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the time complexity of Merge Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following techniques solves problems by combining solutions of subproblems recursively?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy Method",
      "Brute Force",
      "Linear Search"
    ]
  },
  {
    "q": "Which of the following is a key difference between greedy algorithms and dynamic programming?",
    "c": null,
    "o": [
      "Greedy algorithms make decisions without revisiting them; dynamic programming stores solutions to subproblems",
      "Greedy algorithms store all previous computations; dynamic programming does not",
      "Dynamic programming always gives a suboptimal solution; greedy always gives optimal",
      "Greedy algorithms require recursion; dynamic programming does not"
    ]
  },
  {
    "q": "Which algorithm solves the 0/1 Knapsack problem optimally?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Depth First Search",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What is memoization in dynamic programming?",
    "c": null,
    "o": [
      "Storing solutions to subproblems to avoid redundant computations",
      "Dividing a problem into smaller parts",
      "Making decisions based on future consequences",
      "Using a stack to track recursion"
    ]
  },
  {
    "q": "Which of the following is an example of a problem best solved using backtracking?",
    "c": null,
    "o": [
      "Solving a maze",
      "Sorting an array",
      "Calculating factorial",
      "Finding the sum of a list"
    ]
  },
  {
    "q": "In divide and conquer, what happens after dividing the problem?",
    "c": null,
    "o": [
      "Subproblems are solved recursively and their results combined",
      "Each subproblem is ignored",
      "The largest subproblem is solved only",
      "The original problem is returned as the result"
    ]
  },
  {
    "q": "Which of the following is not a typical application of dynamic programming?",
    "c": null,
    "o": [
      "Finding prime numbers",
      "Matrix Chain Multiplication",
      "Longest Common Subsequence",
      "Fibonacci Number Calculation"
    ]
  },
  {
    "q": "Which sorting algorithm uses divide and conquer?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What does the greedy choice property ensure?",
    "c": null,
    "o": [
      "A locally optimal choice leads to a globally optimal solution",
      "Only the smallest input is considered",
      "All subproblems are solved recursively",
      "Results are stored for future use"
    ]
  },
  {
    "q": "Which of the following algorithms is used for constructing minimum spanning trees?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the main disadvantage of backtracking?",
    "c": null,
    "o": [
      "It may require exponential time in worst cases",
      "It cannot be implemented with recursion",
      "It uses more memory than dynamic programming",
      "It only works on sorted data"
    ]
  },
  {
    "q": "What type of algorithm is used in the Traveling Salesman Problem to find the exact optimal solution?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Linear Search",
      "Hashing"
    ]
  },
  {
    "q": "Which of the following problems is an example of an NP-complete problem?",
    "c": null,
    "o": [
      "Subset Sum Problem",
      "Binary Search",
      "Bubble Sort",
      "Breadth First Search"
    ]
  },
  {
    "q": "What does the 'overlapping subproblems' property refer to in dynamic programming?",
    "c": null,
    "o": [
      "The same subproblem is solved multiple times",
      "Subproblems cannot be reused",
      "Each subproblem has a different size",
      "Subproblems are solved in parallel"
    ]
  },
  {
    "q": "Which technique is used in branch and bound to prune the search tree?",
    "c": null,
    "o": [
      "Bounding function",
      "Greedy choice",
      "Memoization",
      "Recursion stack"
    ]
  },
  {
    "q": "Which problem is commonly solved using the backtracking technique?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Sorting integers",
      "Linear regression",
      "Computing GCD"
    ]
  },
  {
    "q": "Which of the following is true about greedy algorithms?",
    "c": null,
    "o": [
      "They make the best choice at each step without reconsidering previous choices",
      "They always give an optimal solution",
      "They solve subproblems only once",
      "They use exhaustive search"
    ]
  },
  {
    "q": "Which algorithm is generally used to solve the Longest Increasing Subsequence problem efficiently?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Depth First Search",
      "Breadth First Search"
    ]
  },
  {
    "q": "What is the primary goal of the divide and conquer technique?",
    "c": null,
    "o": [
      "Divide a problem into smaller subproblems, solve them independently, and combine",
      "Use recursion to iterate through all solutions",
      "Solve the problem greedily from start to end",
      "Store all results in a memoization table"
    ]
  },
  {
    "q": "Which problem is best solved by using a greedy algorithm?",
    "c": null,
    "o": [
      "Activity Selection Problem",
      "0/1 Knapsack Problem",
      "TSP (exact solution)",
      "Longest Common Subsequence"
    ]
  },
  {
    "q": "In dynamic programming, which approach is typically used to fill the solution table?",
    "c": null,
    "o": [
      "Bottom-up",
      "Top-down with no recursion",
      "Greedy decision tree",
      "Random sampling"
    ]
  },
  {
    "q": "Which of the following problems is commonly used to demonstrate the greedy algorithm technique?",
    "c": null,
    "o": [
      "Fractional Knapsack Problem",
      "Matrix Chain Multiplication",
      "Longest Common Subsequence",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What does the 'optimal substructure' property mean in dynamic programming?",
    "c": null,
    "o": [
      "The solution to a problem can be built from solutions to its subproblems",
      "Each subproblem must be solved independently",
      "The problem must be solved using backtracking",
      "Solutions are non-deterministic"
    ]
  },
  {
    "q": "Which of these is NOT a component of the branch and bound technique?",
    "c": null,
    "o": [
      "Memoization table",
      "Bounding function",
      "Search tree",
      "Pruning"
    ]
  },
  {
    "q": "In backtracking, what happens when a solution cannot be completed?",
    "c": null,
    "o": [
      "It backtracks to the previous state to try another option",
      "It terminates the program",
      "It restarts from the beginning",
      "It randomly chooses another path"
    ]
  },
  {
    "q": "Which approach is used in the top-down implementation of dynamic programming?",
    "c": null,
    "o": [
      "Recursion with memoization",
      "Iterative loop with stack",
      "Divide and conquer with greedy",
      "Pure recursion without memory"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of the greedy approach?",
    "c": null,
    "o": [
      "It may not always produce an optimal solution",
      "It uses too much memory",
      "It is always slower than brute force",
      "It cannot be implemented using recursion"
    ]
  },
  {
    "q": "Which algorithm solves the All-Pairs Shortest Path problem efficiently?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which problem can be effectively solved using divide and conquer?",
    "c": null,
    "o": [
      "Merge Sort",
      "Fractional Knapsack",
      "N-Queens",
      "Subset Sum"
    ]
  },
  {
    "q": "Which of the following is true for dynamic programming and not for recursion?",
    "c": null,
    "o": [
      "It avoids solving the same subproblem multiple times",
      "It always requires a stack",
      "It increases time complexity",
      "It does not store intermediate results"
    ]
  },
  {
    "q": "Which data structure is commonly used in the implementation of backtracking algorithms?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Hash Map",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is a problem where dynamic programming is generally more efficient than divide and conquer?",
    "c": null,
    "o": [
      "Longest Common Subsequence",
      "Binary Search",
      "Quick Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which condition must a problem satisfy to apply the greedy method effectively?",
    "c": null,
    "o": [
      "Greedy choice property",
      "Multiple recursion",
      "Exponential time complexity",
      "High space complexity"
    ]
  },
  {
    "q": "In the context of dynamic programming, what is memoization?",
    "c": null,
    "o": [
      "Storing solutions of subproblems to avoid redundant computation",
      "Storing all input values in a list",
      "Remembering user input for next execution",
      "Using a memory-efficient algorithm"
    ]
  },
  {
    "q": "Which of the following problems is typically solved using backtracking?",
    "c": null,
    "o": [
      "Sudoku Solver",
      "Merge Sort",
      "Shortest Path in Graph",
      "Hash Map Search"
    ]
  },
  {
    "q": "Which of the following is true about the 0/1 Knapsack problem?",
    "c": null,
    "o": [
      "It is solved using dynamic programming or backtracking",
      "It is best solved using a greedy approach",
      "It has a polynomial-time greedy solution",
      "It cannot be solved by recursion"
    ]
  },
  {
    "q": "Which algorithm is based on the branch and bound technique?",
    "c": null,
    "o": [
      "Travelling Salesman Problem (TSP)",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following is NOT true about dynamic programming?",
    "c": null,
    "o": [
      "It always finds the global optimal solution",
      "It solves each subproblem only once",
      "It avoids recomputation by storing results",
      "It works only for sorting problems"
    ]
  },
  {
    "q": "Which of these is a key characteristic of the divide and conquer technique?",
    "c": null,
    "o": [
      "Dividing the problem into smaller subproblems and combining their solutions",
      "Trying all possibilities recursively",
      "Making greedy choices without considering future consequences",
      "Storing results of all subproblems"
    ]
  },
  {
    "q": "What is the time complexity of the merge sort algorithm?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "In backtracking algorithms, which method is used to discard a decision path?",
    "c": null,
    "o": [
      "Pruning",
      "Partitioning",
      "Memoization",
      "Reduction"
    ]
  },
  {
    "q": "Which of the following is an example of a problem that benefits from the greedy algorithm?",
    "c": null,
    "o": [
      "Activity Selection Problem",
      "Matrix Chain Multiplication",
      "0/1 Knapsack Problem",
      "Travelling Salesman Problem"
    ]
  },
  {
    "q": "Which of the following algorithm techniques uses a decision tree structure for exploring all possibilities?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Divide and Conquer",
      "Dynamic Programming"
    ]
  },
  {
    "q": "What is the worst-case time complexity of the quicksort algorithm?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which technique is most suitable for problems with optimal substructure and overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following is not typically solved using divide and conquer?",
    "c": null,
    "o": [
      "Dijkstra’s Shortest Path Algorithm",
      "Merge Sort",
      "Binary Search",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following is a feature of the greedy method?",
    "c": null,
    "o": [
      "Local optimal choice leads to global optimum",
      "All subproblems must be solved before solving the main problem",
      "It explores all paths",
      "It backtracks to find all solutions"
    ]
  },
  {
    "q": "What is the primary difference between greedy and dynamic programming techniques?",
    "c": null,
    "o": [
      "Greedy makes locally optimal choices, DP ensures global optimality",
      "DP is faster than greedy",
      "Greedy uses more memory",
      "There is no difference"
    ]
  },
  {
    "q": "Which algorithmic strategy would best suit solving a maze problem?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Divide and Conquer",
      "Hashing"
    ]
  },
  {
    "q": "In which situation would you not use a greedy algorithm?",
    "c": null,
    "o": [
      "When future consequences of choices matter",
      "When the problem has the greedy choice property",
      "When local choices lead to optimal solution",
      "When problems have uniform cost"
    ]
  },
  {
    "q": "Which of the following is a classic application of dynamic programming?",
    "c": null,
    "o": [
      "Fibonacci Number Calculation",
      "Binary Search",
      "Heap Sort",
      "Breadth First Search"
    ]
  },
  {
    "q": "Which algorithmic technique is used in the Merge Sort algorithm?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Dynamic Programming",
      "Greedy Method",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following problems is typically solved using dynamic programming?",
    "c": null,
    "o": [
      "Longest Common Subsequence",
      "Depth First Search",
      "Finding Prime Numbers",
      "Binary Tree Traversal"
    ]
  },
  {
    "q": "In which scenario does backtracking perform better than brute-force search?",
    "c": null,
    "o": [
      "When the solution space can be pruned",
      "When all paths need to be explored",
      "When the input size is very small",
      "When the solution is guaranteed to be at the end"
    ]
  },
  {
    "q": "Which of the following best describes the greedy approach?",
    "c": null,
    "o": [
      "Make the best possible choice at each step",
      "Try every possible path",
      "Divide the problem into subproblems and solve independently",
      "Use a stack to solve the problem recursively"
    ]
  },
  {
    "q": "What is the key property required for a problem to be solved by a greedy algorithm?",
    "c": null,
    "o": [
      "Greedy choice property and optimal substructure",
      "Overlapping subproblems",
      "Backtracking tree structure",
      "Recursive breakdown"
    ]
  },
  {
    "q": "Which algorithm is used for solving the 0/1 Knapsack problem efficiently?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Branch and Bound"
    ]
  },
  {
    "q": "Which sorting algorithm uses the divide and conquer approach?",
    "c": null,
    "o": [
      "Merge Sort",
      "Selection Sort",
      "Bubble Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "Which of the following problems is a classic example of backtracking?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Sorting an array",
      "Calculating factorial",
      "Inorder traversal of binary tree"
    ]
  },
  {
    "q": "Which algorithm technique is generally the fastest for problems with overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Brute Force",
      "Greedy",
      "Divide and Conquer"
    ]
  },
  {
    "q": "What type of algorithm is Prim's algorithm for finding Minimum Spanning Tree?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which algorithm technique is primarily used in the Binary Search algorithm?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Dynamic Programming",
      "Backtracking",
      "Greedy"
    ]
  },
  {
    "q": "Which of the following problems is **not** typically solved using dynamic programming?",
    "c": null,
    "o": [
      "Sorting a list",
      "Matrix Chain Multiplication",
      "Longest Increasing Subsequence",
      "Fibonacci Number Calculation"
    ]
  },
  {
    "q": "What is the main idea behind the divide and conquer technique?",
    "c": null,
    "o": [
      "Break the problem into subproblems, solve them independently, and combine results",
      "Try all possibilities and pick the best one",
      "Make locally optimal choices",
      "Use memoization to speed up recursive calls"
    ]
  },
  {
    "q": "Which of the following is an example of a problem solved using greedy algorithm?",
    "c": null,
    "o": [
      "Activity Selection Problem",
      "0/1 Knapsack Problem",
      "Longest Common Subsequence",
      "Tower of Hanoi"
    ]
  },
  {
    "q": "In which technique is memoization commonly used?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which algorithmic technique is best suited for solving Sudoku puzzles?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "q": "What is the key idea of dynamic programming?",
    "c": null,
    "o": [
      "Store solutions to subproblems to avoid redundant work",
      "Try all possibilities",
      "Always choose the shortest path",
      "Split the input into equal parts"
    ]
  },
  {
    "q": "Which of the following is **not** a property of greedy algorithms?",
    "c": null,
    "o": [
      "Overlapping subproblems",
      "Greedy choice property",
      "Local optimality",
      "Optimal substructure"
    ]
  },
  {
    "q": "What type of problem is the 'Traveling Salesman Problem'?",
    "c": null,
    "o": [
      "NP-hard combinatorial optimization",
      "Greedy solvable",
      "Divide and Conquer",
      "Dynamic Programming only"
    ]
  },
  {
    "q": "Which technique is used in the QuickSort algorithm?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Backtracking",
      "Greedy",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which technique is best suited for solving the 'Subset Sum Problem'?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following problems is generally solved using the backtracking technique?",
    "c": null,
    "o": [
      "N-Queens Problem",
      "Binary Search",
      "Bubble Sort",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "Which technique is used in the Merge Sort algorithm?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking"
    ]
  },
  {
    "q": "Which algorithm is most appropriate for solving the 'Longest Common Subsequence' problem?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Brute Force"
    ]
  },
  {
    "q": "What algorithmic technique is used in the 'Dijkstra’s Shortest Path' algorithm?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Divide and Conquer",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "What does the greedy method focus on at each step?",
    "c": null,
    "o": [
      "Making the locally optimal choice",
      "Exploring all possibilities",
      "Dividing into subproblems",
      "Storing previous solutions"
    ]
  },
  {
    "q": "Which of these is a key characteristic of dynamic programming problems?",
    "c": null,
    "o": [
      "Overlapping subproblems and optimal substructure",
      "Locally optimal choices",
      "No overlapping subproblems",
      "Recursive division only"
    ]
  },
  {
    "q": "What kind of problems is the 'Branch and Bound' technique typically used for?",
    "c": null,
    "o": [
      "Combinatorial optimization problems",
      "Sorting problems",
      "String matching",
      "Matrix multiplication"
    ]
  },
  {
    "q": "Which of these problems is typically **not** solved using backtracking?",
    "c": null,
    "o": [
      "Binary Tree Traversal",
      "N-Queens",
      "Sudoku Solver",
      "Hamiltonian Path"
    ]
  },
  {
    "q": "What is a necessary condition for applying dynamic programming?",
    "c": null,
    "o": [
      "Overlapping subproblems",
      "Greedy choice property",
      "No subproblem dependency",
      "Solution must be unique"
    ]
  },
  {
    "q": "Which algorithm technique is generally used in the 'Knapsack Problem' (0/1 Knapsack)?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which algorithmic technique is employed in the 'Quick Sort' algorithm?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking"
    ]
  },
  {
    "q": "The Greedy approach fails for which version of the Knapsack Problem?",
    "c": null,
    "o": [
      "0/1 Knapsack",
      "Fractional Knapsack",
      "Unbounded Knapsack",
      "Greedy Knapsack"
    ]
  },
  {
    "q": "Which of the following problems is typically solved using divide and conquer?",
    "c": null,
    "o": [
      "Merge Sort",
      "Traveling Salesman Problem",
      "0/1 Knapsack",
      "N-Queens Problem"
    ]
  },
  {
    "q": "Which problem is **best** solved using the greedy approach?",
    "c": null,
    "o": [
      "Activity Selection Problem",
      "Longest Common Subsequence",
      "N-Queens Problem",
      "Matrix Chain Multiplication"
    ]
  },
  {
    "q": "Which is **not** a key requirement for a greedy algorithm to work optimally?",
    "c": null,
    "o": [
      "Overlapping Subproblems",
      "Greedy Choice Property",
      "Optimal Substructure",
      "Problem can be broken into subproblems"
    ]
  },
  {
    "q": "Which method is most suitable for solving a maze problem?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Hashing"
    ]
  },
  {
    "q": "Which of the following is solved using Dynamic Programming?",
    "c": null,
    "o": [
      "Matrix Chain Multiplication",
      "Heap Sort",
      "Breadth First Search",
      "Counting Sort"
    ]
  },
  {
    "q": "Which of these algorithmic techniques is generally **not** suitable for NP-complete problems?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Backtracking",
      "Branch and Bound",
      "Dynamic Programming"
    ]
  },
  {
    "q": "In which scenario would the greedy algorithm give an incorrect result?",
    "c": null,
    "o": [
      "When local choices do not lead to a globally optimal solution",
      "When all choices are optimal",
      "When subproblems are independent",
      "When data is sorted"
    ]
  },
    {
        "q": "Which data structure is ideal for implementing a browser's back and forward button functionality?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "HashMap",
            "Linked List"
        ]
    },
    {
        "q": "Which data structure is commonly used to implement task scheduling in operating systems?",
        "c": null,
        "o": [
            "Priority Queue",
            "Hash Table",
            "Array",
            "Stack"
        ]
    },
    {
        "q": "What is the best data structure to store a mapping between domain names and IP addresses for fast lookup?",
        "c": null,
        "o": [
            "Hash Table",
            "Queue",
            "Stack",
            "Heap"
        ]
    },
    {
        "q": "In competitive programming, which technique reduces the time complexity of recursive solutions by storing intermediate results?",
        "c": null,
        "o": [
            "Memoization",
            "Greedy",
            "Backtracking",
            "Brute Force"
        ]
    },
    {
        "q": "Which of the following data structures is best suited for implementing undo functionality?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Heap",
            "Set"
        ]
    },
    {
        "q": "Which data structure would be most efficient for checking whether a word exists in a dictionary of 100,000 English words?",
        "c": null,
        "o": [
            "Trie",
            "Array",
            "Queue",
            "Graph"
        ]
    },
    {
        "q": "Which data structure is commonly used in GPS navigation algorithms like Dijkstra’s shortest path?",
        "c": null,
        "o": [
            "Graph",
            "Stack",
            "Linked List",
            "Queue"
        ]
    },
    {
        "q": "Which of the following is an efficient way to maintain a dynamic median in a data stream?",
        "c": null,
        "o": [
            "Two Heaps (Max-Heap and Min-Heap)",
            "HashMap",
            "Queue and Stack",
            "Binary Search Tree only"
        ]
    },
    {
        "q": "In competitive programming, which pattern solves problems like 'find the first subarray with a sum greater than x'?",
        "c": null,
        "o": [
            "Sliding Window",
            "Binary Search",
            "Merge Sort",
            "Backtracking"
        ]
    },
    {
        "q": "Which structure is best suited to model a social network where users are connected to many other users?",
        "c": null,
        "o": [
            "Graph",
            "Queue",
            "Array",
            "Heap"
        ]
    },
    {
        "q": "Which data structure is optimal for implementing a LRU (Least Recently Used) cache?",
        "c": null,
        "o": [
            "Doubly Linked List with HashMap",
            "Stack with HashMap",
            "Queue with Stack",
            "Binary Search Tree"
        ]
    },
    {
        "q": "Which algorithm pattern is commonly used in solving maze or puzzle problems in competitive programming?",
        "c": null,
        "o": [
            "Backtracking",
            "Greedy",
            "Divide and Conquer",
            "Memoization"
        ]
    },
    {
        "q": "Which data structure is most suitable to implement an autocomplete feature?",
        "c": null,
        "o": [
            "Trie",
            "Graph",
            "Linked List",
            "Stack"
        ]
    },
    {
        "q": "Which of the following data structures would be most suitable to implement a task manager with multiple levels of priorities?",
        "c": null,
        "o": [
            "Heap",
            "Array",
            "Deque",
            "Set"
        ]
    },
    {
        "q": "What is the main benefit of using a HashMap in real-time spell-checkers?",
        "c": null,
        "o": [
            "Constant time lookup for known words",
            "Efficient memory usage",
            "Lexicographical ordering",
            "Fast insertion at the end"
        ]
    },
    {
        "q": "Which structure is most useful for implementing a leaderboard where scores need to be sorted and updated frequently?",
        "c": null,
        "o": [
            "Balanced Binary Search Tree",
            "Queue",
            "Stack",
            "Graph"
        ]
    },
    {
        "q": "Which algorithm is best suited for finding the shortest route in a road network?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "Binary Search",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "Which technique is used in dynamic programming to avoid recomputation of subproblems?",
        "c": null,
        "o": [
            "Memoization",
            "Iteration",
            "Greedy",
            "Recursion"
        ]
    },
    {
        "q": "Which data structure is used in BFS (Breadth First Search)?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Hash Table",
            "Heap"
        ]
    },
    {
        "q": "Which of the following is best for implementing a system that handles large datasets with frequent range minimum queries?",
        "c": null,
        "o": [
            "Segment Tree",
            "Linked List",
            "Binary Heap",
            "Trie"
        ]
    },
    {
        "q": "Which data structure is most efficient for implementing a queue in real-time task scheduling?",
        "c": null,
        "o": [
            "Deque",
            "Stack",
            "Trie",
            "Set"
        ]
    },
    {
        "q": "In a web crawler, which data structure is typically used to avoid visiting the same URL more than once?",
        "c": null,
        "o": [
            "Set",
            "Stack",
            "Queue",
            "Array"
        ]
    },
    {
        "q": "Which algorithm pattern is useful in problems where you need to explore all combinations, like the N-Queens problem?",
        "c": null,
        "o": [
            "Backtracking",
            "Greedy",
            "Dynamic Programming",
            "Binary Search"
        ]
    },
    {
        "q": "Which data structure is ideal for matching open and close brackets in a compiler?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Linked List",
            "Hash Table"
        ]
    },
    {
        "q": "Which of these patterns is best suited for problems involving overlapping subproblems and optimal substructure?",
        "c": null,
        "o": [
            "Dynamic Programming",
            "Backtracking",
            "Divide and Conquer",
            "Greedy"
        ]
    },
    {
        "q": "Which data structure provides the best time complexity for insertion, deletion, and search on average?",
        "c": null,
        "o": [
            "Hash Table",
            "Binary Search Tree",
            "Array",
            "Stack"
        ]
    },
    {
        "q": "Which data structure is best suited to detect cycles in a graph?",
        "c": null,
        "o": [
            "Disjoint Set (Union-Find)",
            "Queue",
            "Stack",
            "Linked List"
        ]
    },
    {
        "q": "In a DNS resolver system, which data structure is mostly used for caching hostname to IP mappings?",
        "c": null,
        "o": [
            "Hash Map",
            "Heap",
            "Queue",
            "Trie"
        ]
    },
    {
        "q": "Which algorithm is often used in competitive programming to solve 'subset sum' or 'knapsack' problems?",
        "c": null,
        "o": [
            "Dynamic Programming",
            "Greedy",
            "DFS",
            "Sliding Window"
        ]
    },
    {
        "q": "What is a suitable data structure for storing hierarchical data such as a company org chart?",
        "c": null,
        "o": [
            "Tree",
            "Graph",
            "Array",
            "Queue"
        ]
    },
    {
        "q": "Which algorithm is typically used in routing protocols to find the shortest path in a network?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Merge Sort",
            "Backtracking",
            "Linear Search"
        ]
    },
    {
        "q": "Which data structure helps efficiently find the k largest elements in a stream of numbers?",
        "c": null,
        "o": [
            "Min-Heap",
            "Stack",
            "Queue",
            "Set"
        ]
    },
    {
        "q": "Which data structure is best for implementing a circular buffer in streaming applications?",
        "c": null,
        "o": [
            "Circular Queue",
            "Stack",
            "Binary Tree",
            "Set"
        ]
    },
    {
        "q": "Which of the following is used for efficiently storing and retrieving variable-length keys like IP addresses or URLs?",
        "c": null,
        "o": [
            "Trie",
            "Heap",
            "Array",
            "Queue"
        ]
    },
    {
        "q": "Which data structure is used to manage function calls and recursion internally?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Array",
            "Graph"
        ]
    },
    {
        "q": "In an event-driven system, which data structure is commonly used to manage pending events?",
        "c": null,
        "o": [
            "Priority Queue",
            "Hash Table",
            "Stack",
            "Binary Tree"
        ]
    },
    {
        "q": "Which approach is useful for solving problems that can be divided into overlapping sub-problems with optimal substructure?",
        "c": null,
        "o": [
            "Dynamic Programming",
            "Greedy",
            "Brute Force",
            "Recursion Only"
        ]
    },
    {
        "q": "Which data structure is suitable for checking palindromes efficiently?",
        "c": null,
        "o": [
            "Deque",
            "Queue",
            "Set",
            "Heap"
        ]
    },
    {
        "q": "Which algorithm is commonly used to generate optimal job sequences in scheduling problems?",
        "c": null,
        "o": [
            "Greedy Algorithm",
            "DFS",
            "Binary Search",
            "Dynamic Programming"
        ]
    },
    {
        "q": "Which of the following is most appropriate for efficiently maintaining a leaderboard that updates in real-time?",
        "c": null,
        "o": [
            "Balanced BST",
            "Queue",
            "Hash Map",
            "Linked List"
        ]
    },
    {
        "q": "Which data structure allows efficient implementation of a prefix-based search such as auto-suggestions?",
        "c": null,
        "o": [
            "Trie",
            "Heap",
            "Queue",
            "HashMap"
        ]
    },
    {
        "q": "Which data structure would be the most efficient for implementing a music playlist where songs can be played forwards and backwards?",
        "c": null,
        "o": [
            "Doubly Linked List",
            "Array",
            "Queue",
            "Trie"
        ]
    },
    {
        "q": "Which algorithm is ideal for network packet routing to minimize transmission delay?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "Bubble Sort",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which competitive programming technique is suitable for solving problems that require merging intervals or segments?",
        "c": null,
        "o": [
            "Two Pointers",
            "Sliding Window",
            "Backtracking",
            "DFS"
        ]
    },
    {
        "q": "Which data structure is used in web servers to handle incoming requests in order?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Set",
            "Tree"
        ]
    },
    {
        "q": "Which algorithm pattern is ideal for solving puzzles like Sudoku?",
        "c": null,
        "o": [
            "Backtracking",
            "Binary Search",
            "Greedy",
            "Sliding Window"
        ]
    },
    {
        "q": "What is the most efficient data structure to manage a dynamic set of integers and support search, insert, and delete operations in logarithmic time?",
        "c": null,
        "o": [
            "Balanced Binary Search Tree",
            "Array",
            "Queue",
            "Linked List"
        ]
    },
    {
        "q": "Which of the following algorithms is most effective in solving 'minimum spanning tree' problems in computer networks?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "DFS",
            "Prim’s Algorithm",
            "Binary Search"
        ]
    },
    {
        "q": "Which of the following is a practical use case of a heap?",
        "c": null,
        "o": [
            "Implementing a priority queue",
            "Depth-first traversal",
            "Autocompletion system",
            "Finding prime numbers"
        ]
    },
    {
        "q": "Which data structure is suitable for implementing a firewall rule matching system that checks patterns in real time?",
        "c": null,
        "o": [
            "Trie",
            "Stack",
            "Heap",
            "Circular Queue"
        ]
    },
    {
        "q": "Which data structure is best suited for implementing a spell checker that can suggest corrections?",
        "c": null,
        "o": [
            "Trie",
            "Heap",
            "Queue",
            "Stack"
        ]
    },
    {
        "q": "Which algorithm is most efficient for solving the shortest path in a weighted graph without negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "BFS",
            "DFS",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which data structure allows constant-time access to elements by index and is ideal for storing leaderboard scores?",
        "c": null,
        "o": [
            "Array",
            "Queue",
            "Set",
            "Graph"
        ]
    },
    {
        "q": "Which competitive programming strategy is ideal for string pattern matching problems?",
        "c": null,
        "o": [
            "Two Pointers",
            "DFS",
            "Union-Find",
            "Heap"
        ]
    },
    {
        "q": "Which algorithm technique is useful for solving optimization problems like finding the longest increasing subsequence?",
        "c": null,
        "o": [
            "Dynamic Programming",
            "Greedy",
            "Backtracking",
            "Divide and Conquer"
        ]
    },
    {
        "q": "Which data structure is useful for parsing arithmetic expressions like '(3 + 4) * 2'?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Set",
            "Trie"
        ]
    },
    {
        "q": "Which algorithm is typically used in database query optimizers for join operations?",
        "c": null,
        "o": [
            "Hash Join",
            "DFS",
            "Dijkstra’s Algorithm",
            "Greedy"
        ]
    },
    {
        "q": "Which data structure is optimal for implementing undo-redo functionality in editors?",
        "c": null,
        "o": [
            "Two Stacks",
            "Single Queue",
            "Deque",
            "Linked List"
        ]
    },
    {
        "q": "Which algorithm pattern is frequently used to detect fraud in transaction networks?",
        "c": null,
        "o": [
            "Graph Traversal",
            "Sliding Window",
            "Binary Search",
            "Sorting"
        ]
    },
    {
        "q": "Which data structure is most appropriate for storing IP routing tables?",
        "c": null,
        "o": [
            "Trie",
            "Hash Table",
            "Linked List",
            "Set"
        ]
    },
    {
        "q": "Which algorithm is suitable for finding the strongly connected components in a directed graph?",
        "c": null,
        "o": [
            "Kosaraju’s Algorithm",
            "Dijkstra’s Algorithm",
            "Floyd-Warshall Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which data structure is preferred for implementing an MRU (Most Recently Used) cache?",
        "c": null,
        "o": [
            "Doubly Linked List with HashMap",
            "Queue with Set",
            "Stack with HashMap",
            "Binary Search Tree"
        ]
    },
    {
        "q": "Which real-world application would most benefit from using a union-find (disjoint-set) data structure?",
        "c": null,
        "o": [
            "Network connectivity check",
            "Route optimization",
            "Balanced parentheses checker",
            "Web crawler implementation"
        ]
    },
    {
        "q": "Which algorithm pattern is suitable for solving problems like 'find the smallest subarray with sum ≥ k'?",
        "c": null,
        "o": [
            "Sliding Window",
            "Backtracking",
            "Merge Sort",
            "Memoization"
        ]
    },
    {
        "q": "Which data structure allows you to maintain insertion order while ensuring unique keys?",
        "c": null,
        "o": [
            "Ordered Dictionary",
            "HashMap",
            "Set",
            "Queue"
        ]
    },
    {
        "q": "Which data structure is used to simulate recursion manually in competitive programming?",
        "c": null,
        "o": [
            "Stack",
            "Heap",
            "Queue",
            "Array"
        ]
    },
    {
        "q": "Which real-world system benefits from a graph data structure for modeling relationships?",
        "c": null,
        "o": [
            "Social Network",
            "Music Playlist",
            "Library Catalog",
            "Video Stream Buffer"
        ]
    },
    {
        "q": "Which algorithm is used to compute transitive closure of a directed graph?",
        "c": null,
        "o": [
            "Floyd-Warshall Algorithm",
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which data structure is efficient for representing a sparse graph?",
        "c": null,
        "o": [
            "Adjacency List",
            "Adjacency Matrix",
            "2D Array",
            "Heap"
        ]
    },
    {
        "q": "Which data structure is used for implementing BFS in a graph traversal?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Set",
            "Heap"
        ]
    },
    {
        "q": "Which data structure is used in a compiler for syntax checking using matching parentheses?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "HashMap",
            "Graph"
        ]
    },
    {
        "q": "Which algorithm pattern is most effective for solving interval scheduling problems?",
        "c": null,
        "o": [
            "Greedy",
            "Backtracking",
            "Binary Search",
            "Dynamic Programming"
        ]
    },
    {
        "q": "Which of the following real-world problems can be best solved using a graph data structure?",
        "c": null,
        "o": [
            "Finding friends-of-friends in a social network",
            "Tracking recent files in an editor",
            "Sorting a list of strings",
            "Checking if a number is prime"
        ]
    },
    {
        "q": "Which data structure is best suited for a scheduler that needs to always pick the next task with highest priority?",
        "c": null,
        "o": [
            "Max-Heap",
            "Stack",
            "Linked List",
            "Deque"
        ]
    },
    {
        "q": "Which data structure would be ideal for managing a call center queue where agents serve customers in order?",
        "c": null,
        "o": [
            "Queue",
            "Set",
            "Stack",
            "Trie"
        ]
    },
    {
        "q": "Which algorithm is most suitable for detecting negative weight cycles in a graph?",
        "c": null,
        "o": [
            "Bellman-Ford Algorithm",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which algorithmic pattern is ideal for problems involving multiple overlapping ranges, like interval merging?",
        "c": null,
        "o": [
            "Two Pointers",
            "Graph Traversal",
            "Greedy",
            "Backtracking"
        ]
    },
    {
        "q": "Which data structure is used in implementing a real-time chat system where the latest message is always shown last?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Heap",
            "Trie"
        ]
    },
    {
        "q": "Which data structure provides O(1) time complexity for insert, delete, and lookup operations?",
        "c": null,
        "o": [
            "Hash Table",
            "Binary Search Tree",
            "Heap",
            "Linked List"
        ]
    },
    {
        "q": "Which of the following problems is best solved using depth-first search (DFS)?",
        "c": null,
        "o": [
            "Finding connected components in a graph",
            "Job scheduling",
            "Finding the shortest path in a weighted graph",
            "Checking string anagrams"
        ]
    },
    {
        "q": "Which data structure is commonly used to build a navigation system that finds the shortest path between two locations?",
        "c": null,
        "o": [
            "Graph",
            "Heap",
            "Stack",
            "Queue"
        ]
    },
    {
        "q": "Which algorithmic technique is ideal for solving problems involving the selection of non-overlapping intervals?",
        "c": null,
        "o": [
            "Greedy",
            "DFS",
            "Sliding Window",
            "Brute Force"
        ]
    },
    {
        "q": "Which data structure would you use in a stock span problem where previous greater elements need to be tracked?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Array",
            "Trie"
        ]
    },
    {
        "q": "Which data structure is useful for storing frequency counts in text analysis?",
        "c": null,
        "o": [
            "Hash Map",
            "Linked List",
            "Stack",
            "Heap"
        ]
    },
    {
        "q": "Which algorithm is often used in real-time applications to find the closest match to a string?",
        "c": null,
        "o": [
            "Levenshtein Distance",
            "DFS",
            "Kruskal’s Algorithm",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "Which data structure can be used to implement an efficient autocomplete engine with prefix matching?",
        "c": null,
        "o": [
            "Trie",
            "Set",
            "Linked List",
            "Binary Tree"
        ]
    },
    {
        "q": "Which algorithm is typically used to construct a Huffman encoding tree?",
        "c": null,
        "o": [
            "Greedy Algorithm",
            "Dynamic Programming",
            "DFS",
            "Union-Find"
        ]
    },
    {
        "q": "Which of the following data structures would be best for implementing undo/redo in a text editor?",
        "c": null,
        "o": [
            "Two Stacks",
            "Queue",
            "Heap",
            "Set"
        ]
    },
    {
        "q": "Which pattern is commonly used in competitive programming to count subarrays with a given sum efficiently?",
        "c": null,
        "o": [
            "Prefix Sum",
            "Two Pointers",
            "Backtracking",
            "DFS"
        ]
    },
    {
        "q": "Which algorithm is commonly used to find the minimum spanning tree in a weighted graph?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "DFS",
            "Binary Search",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which data structure is suitable for detecting cycles in an undirected graph?",
        "c": null,
        "o": [
            "Disjoint Set (Union-Find)",
            "Stack",
            "Queue",
            "Linked List"
        ]
    },
    {
        "q": "Which data structure is most efficient for storing and accessing top trending topics on social media?",
        "c": null,
        "o": [
            "Heap",
            "Hash Map",
            "Queue",
            "Graph"
        ]
    },
    {
        "q": "Which pattern is commonly used in competitive programming to handle range queries efficiently?",
        "c": null,
        "o": [
            "Segment Tree",
            "Two Pointers",
            "DFS",
            "Backtracking"
        ]
    },
    {
        "q": "Which data structure is typically used in load balancing scenarios to evenly distribute tasks?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Set",
            "Graph"
        ]
    },
    {
        "q": "Which algorithmic approach is used in problems involving a grid or matrix, such as pathfinding in a maze?",
        "c": null,
        "o": [
            "BFS (Breadth First Search)",
            "DFS (Depth First Search)",
            "Greedy Algorithm",
            "Binary Search"
        ]
    },
    {
        "q": "Which data structure is suitable for storing autocomplete suggestions in order of popularity?",
        "c": null,
        "o": [
            "Trie with Heap",
            "Linked List",
            "Queue",
            "Set"
        ]
    },
    {
        "q": "Which pattern is ideal for detecting anagrams in a large text corpus?",
        "c": null,
        "o": [
            "Sliding Window",
            "Graph Traversal",
            "Backtracking",
            "Union-Find"
        ]
    },
    {
        "q": "Which algorithm is used to detect cycles in a directed graph?",
        "c": null,
        "o": [
            "DFS with recursion stack",
            "Dijkstra’s Algorithm",
            "Union-Find",
            "Topological Sort"
        ]
    },
    {
        "q": "Which data structure is best for implementing a cache with fast access and eviction policy?",
        "c": null,
        "o": [
            "Hash Map with Doubly Linked List",
            "Heap",
            "Array",
            "Graph"
        ]
    },
    {
        "q": "Which data structure is suitable for checking whether a word is a palindrome in O(1) time per check?",
        "c": null,
        "o": [
            "Deque",
            "Stack",
            "Queue",
            "Array"
        ]
    },
    {
        "q": "Which algorithm pattern is most effective in problems requiring decisions based on optimal substructure without recomputation?",
        "c": null,
        "o": [
            "Dynamic Programming",
            "Greedy",
            "Backtracking",
            "Brute Force"
        ]
    },
    {
        "q": "Which data structure helps in implementing consistent hashing for distributed systems?",
        "c": null,
        "o": [
            "Hash Ring (using Circular Linked List or TreeMap)",
            "Min Heap",
            "Array",
            "Stack"
        ]
    },
    {
        "q": "Which data structure is used for efficient task management in multi-threaded environments where tasks need to be processed in order?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Trie",
            "Set"
        ]
    },
    {
        "q": "Which algorithm is most suited for finding articulation points and bridges in a network?",
        "c": null,
        "o": [
            "Tarjan’s Algorithm",
            "Kruskal’s Algorithm",
            "Floyd-Warshall",
            "DFS only"
        ]
    },
    {
        "q": "Which data structure is most commonly used for implementing a web crawler's URL frontier?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Heap",
            "Trie"
        ]
    },
    {
        "q": "Which pattern is most appropriate for solving problems like 'find the number of subarrays with sum K'?",
        "c": null,
        "o": [
            "Prefix Sum with HashMap",
            "Two Pointers",
            "DFS",
            "Union-Find"
        ]
    },
    {
        "q": "Which data structure is ideal for storing and matching multiple string patterns efficiently?",
        "c": null,
        "o": [
            "Trie",
            "Queue",
            "Heap",
            "Linked List"
        ]
    },
    {
        "q": "Which algorithm is typically used for deadlock detection in operating systems?",
        "c": null,
        "o": [
            "Cycle Detection using DFS",
            "Dijkstra’s Algorithm",
            "Union-Find",
            "Greedy Matching"
        ]
    },
    {
        "q": "Which data structure is used to keep track of visited nodes in depth-first search (DFS)?",
        "c": null,
        "o": [
            "Set",
            "Stack",
            "Queue",
            "Heap"
        ]
    },
    {
        "q": "Which pattern is suitable for efficiently processing a stream of elements and maintaining a rolling window average?",
        "c": null,
        "o": [
            "Sliding Window",
            "Two Pointers",
            "Greedy",
            "Backtracking"
        ]
    },
    {
        "q": "Which data structure is best suited for implementing undo functionality in applications like text editors?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Heap",
            "Tree"
        ]
    },
    {
        "q": "Which algorithm is most efficient for finding the shortest path in a map with varying terrain costs?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "Averaging"
        ]
    },
    {
        "q": "Which data structure is often used for autocomplete features in search engines?",
        "c": null,
        "o": [
            "Trie",
            "Heap",
            "Stack",
            "Deque"
        ]
    },
    {
        "q": "In a recommendation engine, which algorithm is often used to find items similar to a given item?",
        "c": null,
        "o": [
            "K-Nearest Neighbors",
            "Bellman-Ford",
            "Prim's Algorithm",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "Which data structure allows fast lookups, insertions, and deletions and is often used for caching?",
        "c": null,
        "o": [
            "Hash Table",
            "Queue",
            "Array",
            "Linked List"
        ]
    },
    {
        "q": "Which algorithm is suitable for finding the minimum spanning tree in a weighted network?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm",
            "Floyd-Warshall Algorithm"
        ]
    },
    {
        "q": "Which technique is useful when solving problems like finding the longest substring without repeating characters?",
        "c": null,
        "o": [
            "Sliding Window",
            "Dynamic Programming",
            "Recursion",
            "Backtracking"
        ]
    },
    {
        "q": "Which structure is used to evaluate expressions written in Reverse Polish Notation (RPN)?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Set",
            "Heap"
        ]
    },
    {
        "q": "Which algorithm is commonly used for job scheduling in OS with different priorities?",
        "c": null,
        "o": [
            "Heap (Priority Queue)",
            "Stack",
            "Graph Traversal",
            "Hash Table"
        ]
    },
    {
        "q": "Which structure is best for designing a Least Recently Used (LRU) cache?",
        "c": null,
        "o": [
            "Ordered Dictionary or Doubly Linked List + Hash Map",
            "Set",
            "Simple List",
            "Binary Search Tree"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient for nearly sorted data?",
        "c": null,
        "o": [
            "Insertion Sort",
            "Bubble Sort",
            "Selection Sort",
            "Heap Sort"
        ]
    },
    {
        "q": "What data structure is best suited for implementing a job queue in a print server?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Set",
            "Tree"
        ]
    },
    {
        "q": "Which algorithm is used for finding the transitive closure of a graph?",
        "c": null,
        "o": [
            "Floyd-Warshall",
            "Dijkstra's Algorithm",
            "Prim's Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which data structure provides O(1) average time for search, insert, and delete?",
        "c": null,
        "o": [
            "Hash Table",
            "Binary Tree",
            "Queue",
            "Linked List"
        ]
    },
    {
        "q": "What data structure would you use to evaluate arithmetic expressions with operator precedence?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Array",
            "Heap"
        ]
    },
    {
        "q": "Which algorithm is best suited for maze solving and shortest path finding in unweighted graphs?",
        "c": null,
        "o": [
            "Breadth-First Search (BFS)",
            "Depth-First Search (DFS)",
            "A* Search",
            "Dijkstra's Algorithm"
        ]
    },
    {
        "q": "Which data structure is typically used in recursive function calls behind the scenes?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Heap",
            "Graph"
        ]
    },
    {
        "q": "What is the main advantage of using a heap in Dijkstra's algorithm?",
        "c": null,
        "o": [
            "Efficient extraction of minimum",
            "Constant time insertion",
            "Quick searching of values",
            "Easy to implement"
        ]
    },
    {
        "q": "Which algorithm is best for detecting cycles in a directed graph?",
        "c": null,
        "o": [
            "DFS with recursion stack",
            "BFS",
            "Prim's algorithm",
            "Kruskal's algorithm"
        ]
    },
    {
        "q": "What data structure can be used to implement a browser's forward and backward navigation?",
        "c": null,
        "o": [
            "Two Stacks",
            "Queue",
            "Hash Map",
            "Binary Tree"
        ]
    },
    {
        "q": "Which data structure allows insertions and deletions at both ends but not in the middle?",
        "c": null,
        "o": [
            "Deque",
            "Stack",
            "Queue",
            "Linked List"
        ]
    },
    {
        "q": "Which sorting algorithm uses the divide-and-conquer technique?",
        "c": null,
        "o": [
            "Merge Sort",
            "Bubble Sort",
            "Selection Sort",
            "Insertion Sort"
        ]
    },
    {
        "q": "In a min-heap, the smallest element is always located at:",
        "c": null,
        "o": [
            "Root",
            "Leftmost leaf",
            "Rightmost node",
            "Middle"
        ]
    },
    {
        "q": "Which graph representation uses more memory in dense graphs?",
        "c": null,
        "o": [
            "Adjacency Matrix",
            "Adjacency List",
            "Edge List",
            "Incidence Matrix"
        ]
    },
    {
        "q": "Which of the following is not a stable sorting algorithm?",
        "c": null,
        "o": [
            "Heap Sort",
            "Bubble Sort",
            "Merge Sort",
            "Insertion Sort"
        ]
    },
    {
        "q": "Which data structure is ideal for implementing LRU cache?",
        "c": null,
        "o": [
            "Hash Map + Doubly Linked List",
            "Stack",
            "Queue",
            "Trie"
        ]
    },
    {
        "q": "What is the time complexity of searching in a balanced binary search tree?",
        "c": null,
        "o": [
            "O(log n)",
            "O(n)",
            "O(1)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of the following algorithms is used to find a Minimum Spanning Tree?",
        "c": null,
        "o": [
            "Kruskal's Algorithm",
            "Dijkstra's Algorithm",
            "Floyd-Warshall Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "What is the best-case time complexity of Quick Sort?",
        "c": null,
        "o": [
            "O(n log n)",
            "O(n^2)",
            "O(log n)",
            "O(n)"
        ]
    },
    {
        "q": "Which of the following data structures is used in BFS traversal?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Heap",
            "Tree"
        ]
    },
    {
        "q": "Which of the following data structures is non-linear?",
        "c": null,
        "o": [
            "Tree",
            "Stack",
            "Queue",
            "Array"
        ]
    },
    {
        "q": "Which of the following is true for a hash table?",
        "c": null,
        "o": [
            "Provides average-case O(1) access time",
            "Keys must be sorted",
            "Does not allow duplicate keys",
            "Always uses chaining for collision"
        ]
    },
    {
        "q": "What does the pop operation do in a stack?",
        "c": null,
        "o": [
            "Removes the top element",
            "Adds a new element",
            "Removes the bottom element",
            "Clears the entire stack"
        ]
    },
    {
        "q": "Which of these is not a characteristic of a binary heap?",
        "c": null,
        "o": [
            "It is a complete binary tree",
            "Each parent has at most two children",
            "It is always a balanced tree",
            "Each node can have more than two children"
        ]
    },
    {
        "q": "Which algorithm is typically used to find the shortest path in a weighted graph?",
        "c": null,
        "o": [
            "Dijkstra's Algorithm",
            "Prim's Algorithm",
            "DFS",
            "Kruskal's Algorithm"
        ]
    },
    {
        "q": "Which traversal technique uses a stack in its implementation?",
        "c": null,
        "o": [
            "Depth-First Search",
            "Breadth-First Search",
            "Level Order Traversal",
            "Inorder Traversal"
        ]
    },
    {
        "q": "Which data structure supports LIFO?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Heap",
            "Deque"
        ]
    },
    {
        "q": "In which tree is the difference between heights of left and right subtrees at most one for all nodes?",
        "c": null,
        "o": [
            "AVL Tree",
            "Binary Tree",
            "B-Tree",
            "Red-Black Tree"
        ]
    },
    {
        "q": "Which algorithm works by selecting a pivot and partitioning the array?",
        "c": null,
        "o": [
            "Quick Sort",
            "Merge Sort",
            "Selection Sort",
            "Heap Sort"
        ]
    },
    {
        "q": "What is the auxiliary space complexity of Merge Sort?",
        "c": null,
        "o": [
            "O(n)",
            "O(1)",
            "O(log n)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of the following data structures is ideal for implementing recursion?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Array",
            "Heap"
        ]
    },
    {
        "q": "What is the worst-case time complexity of searching in a binary search tree (BST)?",
        "c": null,
        "o": [
            "O(n)",
            "O(log n)",
            "O(1)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which sorting algorithm is best suited for small datasets and nearly sorted data?",
        "c": null,
        "o": [
            "Insertion Sort",
            "Quick Sort",
            "Merge Sort",
            "Heap Sort"
        ]
    },
    {
        "q": "Which of the following algorithms uses backtracking?",
        "c": null,
        "o": [
            "N-Queens Problem",
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "Merge Sort"
        ]
    },
    {
        "q": "What is a primary advantage of using a trie over a hash table?",
        "c": null,
        "o": [
            "Efficient prefix search",
            "Less memory usage",
            "Faster lookups for all key types",
            "Handles collisions automatically"
        ]
    },
    {
        "q": "Which data structure is used in BFS traversal of a graph?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Set",
            "Heap"
        ]
    },
    {
        "q": "What is the maximum number of children a node can have in a binary tree?",
        "c": null,
        "o": [
            "2",
            "3",
            "1",
            "4"
        ]
    },
    {
        "q": "Which sorting algorithm guarantees O(n log n) performance in all cases?",
        "c": null,
        "o": [
            "Merge Sort",
            "Quick Sort",
            "Bubble Sort",
            "Insertion Sort"
        ]
    },
    {
        "q": "Which algorithm is commonly used for cycle detection in a graph?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s Algorithm",
            "Bellman-Ford"
        ]
    },
    {
        "q": "In a circular queue, what condition indicates the queue is full?",
        "c": null,
        "o": [
            "(rear + 1) % size == front",
            "rear == size",
            "rear == front",
            "front == -1"
        ]
    },
  {
    "q": "Which data structure is used to implement function call stacks in most programming languages?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Tree"
    ]
  },
  {
    "q": "What is the time complexity to insert an element at the end of a Python list (amortized)?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure gives the best average-case time complexity for search operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Binary Search Tree",
      "Queue",
      "Array"
    ]
  },
  {
    "q": "Which of the following is true about the heap data structure?",
    "c": null,
    "o": [
      "It always maintains a complete binary tree",
      "It is a self-balancing binary search tree",
      "It is used for implementing DFS",
      "It guarantees O(1) deletion"
    ]
  },
  {
    "q": "Which traversal method is used in Depth-First Search?",
    "c": null,
    "o": [
      "Preorder",
      "Level order",
      "Breadth-first",
      "Postorder only"
    ]
  },
  {
    "q": "In which case does Quick Sort perform worst?",
    "c": null,
    "o": [
      "When the pivot always picks the greatest or smallest element",
      "When the pivot is the median",
      "When the array has duplicate values",
      "When the array is nearly sorted"
    ]
  },
  {
    "q": "Which of the following problems is best solved with dynamic programming?",
    "c": null,
    "o": [
      "0/1 Knapsack Problem",
      "Finding the GCD",
      "Traversing a binary tree",
      "Checking prime numbers"
    ]
  },
  {
    "q": "What is the maximum number of edges in an undirected graph with n vertices?",
    "c": null,
    "o": [
      "n(n-1)/2",
      "n",
      "n^2",
      "2n"
    ]
  },
  {
    "q": "Which Python module provides a built-in implementation of heaps?",
    "c": null,
    "o": [
      "heapq",
      "collections",
      "queue",
      "bisect"
    ]
  },
  {
    "q": "Which algorithm can find the shortest path in a weighted graph with negative weights?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra's",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which data structure supports LIFO order?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is not a stable sorting algorithm?",
    "c": null,
    "o": [
      "Heap Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which algorithm uses the divide and conquer approach?",
    "c": null,
    "o": [
      "Merge Sort",
      "Linear Search",
      "Bubble Sort",
      "Heapify"
    ]
  },
  {
    "q": "What is the worst-case time complexity of binary search on a sorted array?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of these is not a characteristic of a greedy algorithm?",
    "c": null,
    "o": [
      "Always finds globally optimal solution",
      "Makes locally optimal choice at each step",
      "Does not revisit past decisions",
      "Fast and memory-efficient"
    ]
  },
  {
    "q": "Which Python collection is best suited for implementing a queue?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "Which of the following algorithms is used for cycle detection in a graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra's",
      "Prim’s"
    ]
  },
  {
    "q": "Which technique is used to avoid redundant computations in recursion?",
    "c": null,
    "o": [
      "Memoization",
      "Backtracking",
      "Iteration",
      "Greedy"
    ]
  },
  {
    "q": "Which data structure is used in Breadth-First Search (BFS)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Heap"
    ]
  },
  {
    "q": "What is the purpose of the 'bisect' module in Python?",
    "c": null,
    "o": [
      "Binary search in sorted lists",
      "Balanced trees",
      "Sorting lists",
      "Priority queues"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following data structures is best suited for implementing undo operations?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which data structure uses the concept of hashing?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Array"
    ]
  },
  {
    "q": "What will be the output of len(set([1, 2, 2, 3]))?",
    "c": null,
    "o": [
      "3",
      "4",
      "2",
      "1"
    ]
  },
  {
    "q": "Which data structure is used by Python’s heapq module?",
    "c": null,
    "o": [
      "Min Heap",
      "Max Heap",
      "Binary Tree",
      "AVL Tree"
    ]
  },
  {
    "q": "Which of the following is a characteristic of dynamic programming?",
    "c": null,
    "o": [
      "Overlapping subproblems",
      "No memory usage",
      "Randomized decisions",
      "Greedy choices"
    ]
  },
  {
    "q": "Which function is used to reverse a list in place in Python?",
    "c": null,
    "o": [
      "list.reverse()",
      "reversed(list)",
      "list[::-1]",
      "sorted(list, reverse=True)"
    ]
  },
  {
    "q": "Which of these is not an in-place sorting algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the output of sorted([3, 1, 4, 2])?",
    "c": null,
    "o": [
      "[1, 2, 3, 4]",
      "[4, 3, 2, 1]",
      "[3, 1, 4, 2]",
      "[2, 4, 1, 3]"
    ]
  },
  {
    "q": "Which of these is true about Python lists?",
    "c": null,
    "o": [
      "They are mutable",
      "They are immutable",
      "They are unordered",
      "They cannot contain duplicates"
    ]
  },
  {
    "q": "Which algorithm is used for cycle detection in a directed graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which built-in function returns the largest item in an iterable?",
    "c": null,
    "o": [
      "max()",
      "largest()",
      "top()",
      "biggest()"
    ]
  },
  {
    "q": "Which of the following is not a characteristic of a binary search tree?",
    "c": null,
    "o": [
      "Left subtree has smaller values",
      "Right subtree has larger values",
      "Can have duplicate keys by default",
      "All subtrees are BSTs"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching in a balanced BST?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithm is used to find minimum spanning tree?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Depth First Search"
    ]
  },
  {
    "q": "Which of these is not supported by Python sets?",
    "c": null,
    "o": [
      "Indexing",
      "Union",
      "Intersection",
      "Difference"
    ]
  },
  {
    "q": "Which method removes all items from a list?",
    "c": null,
    "o": [
      "clear()",
      "delete()",
      "removeAll()",
      "popAll()"
    ]
  },
  {
    "q": "What is the primary use of a deque in Python?",
    "c": null,
    "o": [
      "Fast append and pop operations from both ends",
      "Sorting elements",
      "Index-based access",
      "Storing key-value pairs"
    ]
  },
  {
    "q": "Which data structure is used in recursive function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Heap Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "In Python, what does the 'heapq' module provide?",
    "c": null,
    "o": [
      "Heap queue algorithms",
      "Hash functions",
      "Balanced BSTs",
      "Graph traversal"
    ]
  },
  {
    "q": "Which algorithm is used to detect negative weight cycles?",
    "c": null,
    "o": [
      "Bellman-Ford",
      "Dijkstra",
      "Prim",
      "Kruskal"
    ]
  },
  {
    "q": "Which data structure is best for implementing LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "Tuple",
      "List"
    ]
  },
  {
    "q": "What is the default sorting order of the sort() function in Python?",
    "c": null,
    "o": [
      "Ascending",
      "Descending",
      "Random",
      "None"
    ]
  },
  {
    "q": "Which of these is used to implement DFS using iteration?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Heap"
    ]
  },
  {
    "q": "Which of these Python structures is immutable?",
    "c": null,
    "o": [
      "Tuple",
      "List",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "Which operation has the worst-case O(n) time complexity in a singly linked list?",
    "c": null,
    "o": [
      "Accessing last element",
      "Inserting at head",
      "Deleting from head",
      "Traversing"
    ]
  },
  {
    "q": "What does the bisect module help with in Python?",
    "c": null,
    "o": [
      "Binary search and insertion in sorted lists",
      "Matrix multiplication",
      "Queue management",
      "Heap operations"
    ]
  },
  {
    "q": "Which data structure provides amortized O(1) time for insertion and deletion at the end?",
    "c": null,
    "o": [
      "List",
      "Deque",
      "Set",
      "Tuple"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "Breadth First Search (BFS)",
      "Depth First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is a non-linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which of these allows duplicates and maintains insertion order in Python?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Dictionary",
      "FrozenSet"
    ]
  },
  {
    "q": "Which of the following has O(log n) time complexity for insert and delete?",
    "c": null,
    "o": [
      "Binary Search Tree (BST)",
      "Array",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "Which of these is used to find strongly connected components in a graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which sorting algorithm is NOT comparison-based?",
    "c": null,
    "o": [
      "Counting Sort",
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which Python module provides thread-safe queues?",
    "c": null,
    "o": [
      "queue",
      "collections",
      "threading",
      "heapq"
    ]
  },
  {
    "q": "Which data structure is used in the implementation of undo features in editors?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which is the best data structure to store key-value pairs with constant average-time lookup?",
    "c": null,
    "o": [
      "Dictionary",
      "List of Tuples",
      "Set",
      "Linked List"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching in a Binary Search Tree (BST)?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure allows insertion and deletion from both ends?",
    "c": null,
    "o": [
      "Deque",
      "Queue",
      "Stack",
      "Tree"
    ]
  },
  {
    "q": "Which algorithm is used for topological sorting of a Directed Acyclic Graph (DAG)?",
    "c": null,
    "o": [
      "Depth First Search (DFS)",
      "Breadth First Search (BFS)",
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "Which Python module provides a priority queue implementation?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "collections",
      "bisect"
    ]
  },
  {
    "q": "Which of the following is NOT a property of a hash table?",
    "c": null,
    "o": [
      "Maintains order of elements",
      "Provides constant-time access on average",
      "Uses a hash function",
      "Handles collisions"
    ]
  },
  {
    "q": "What is the time complexity to delete an element from a linked list given the reference to that node?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure can be used to efficiently implement a LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "List",
      "Tuple"
    ]
  },
  {
    "q": "Which algorithm is used to detect cycles in a graph?",
    "c": null,
    "o": [
      "Depth First Search",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "Which of the following is a divide-and-conquer algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which traversal of a binary tree visits nodes in the order: left, root, right?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level order"
    ]
  },
  {
    "q": "What is the primary advantage of a doubly linked list over a singly linked list?",
    "c": null,
    "o": [
      "Can be traversed in both directions",
      "Uses less memory",
      "Simpler implementation",
      "Faster access to elements"
    ]
  },
  {
    "q": "Which of the following is not a stable sorting algorithm?",
    "c": null,
    "o": [
      "Heap Sort",
      "Bubble Sort",
      "Merge Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which data structure is typically used to implement a DFS algorithm?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average-case performance?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the auxiliary space complexity of Merge Sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "In which data structure does each node have at most two children?",
    "c": null,
    "o": [
      "Binary Tree",
      "Graph",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is used to implement undo features in software?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Heap"
    ]
  },
  {
    "q": "Which function in Python is used to find the index of an element in a list?",
    "c": null,
    "o": [
      "list.index()",
      "list.find()",
      "list.locate()",
      "list.search()"
    ]
  },
  {
    "q": "Which of the following is used for implementing LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "Heap",
      "Stack"
    ]
  },
  {
    "q": "Which Python built-in type behaves like a hash table?",
    "c": null,
    "o": [
      "dict",
      "list",
      "tuple",
      "set"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure works on the principle of First-In-First-Out (FIFO)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which of these algorithms is used to detect cycles in a graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra's",
      "Kruskal's"
    ]
  },
  {
    "q": "What is the result of calling `pop()` on an empty Python list?",
    "c": null,
    "o": [
      "IndexError",
      "None",
      "0",
      "ValueError"
    ]
  },
  {
    "q": "Which of the following is not a characteristic of a heap?",
    "c": null,
    "o": [
      "It is a complete binary tree",
      "It can be implemented using arrays",
      "Each node has at most three children",
      "The root has the highest (max-heap) or lowest (min-heap) value"
    ]
  },
  {
    "q": "Which algorithm divides the array into subarrays, sorts them, and then merges them?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What does `heapq.heappop()` do in Python?",
    "c": null,
    "o": [
      "Removes and returns the smallest element",
      "Removes and returns the largest element",
      "Adds an element to a heap",
      "Sorts the heap"
    ]
  },
  {
    "q": "Which of the following data structures allows duplicates in Python?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Dict keys",
      "Tuple keys"
    ]
  },
  {
    "q": "Which Python module provides a double-ended queue implementation?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "itertools"
    ]
  },
  {
    "q": "Which traversal method visits the left subtree, the root, and then the right subtree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level order"
    ]
  },
  {
    "q": "What is the best case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is used in recursive function calls in Python?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which algorithm is used for finding the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra",
      "Bellman-Ford"
    ]
  },
  {
    "q": "Which sorting algorithm is typically the fastest in practice for large unsorted arrays?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the output of: `sorted([3, 1, 2], reverse=True)`?",
    "c": null,
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[2, 3, 1]",
      "[3, 1, 2]"
    ]
  },
  {
    "q": "Which of these is an advantage of using a linked list over an array?",
    "c": null,
    "o": [
      "Dynamic size",
      "Constant time indexing",
      "Less memory usage",
      "Faster sorting"
    ]
  },
  {
    "q": "Which traversal technique uses a queue?",
    "c": null,
    "o": [
      "Level order",
      "Inorder",
      "Preorder",
      "Postorder"
    ]
  },
  {
    "q": "Which of these structures is best for implementing a priority queue in Python?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which method is used to remove and return an element from a specific index in a list?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "del",
      "discard()"
    ]
  },
  {
    "q": "Which data structure guarantees FIFO (First-In, First-Out) order?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which of the following is a stable sorting algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which keyword is used to define a generator in Python?",
    "c": null,
    "o": [
      "yield",
      "return",
      "generate",
      "next"
    ]
  },
  {
    "q": "What is the space complexity of a binary search tree in the worst case?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "What does the `heapq` module implement in Python?",
    "c": null,
    "o": [
      "Min heap",
      "Max heap",
      "Binary search tree",
      "Fibonacci heap"
    ]
  },
  {
    "q": "Which algorithm uses the divide-and-conquer strategy?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of these data structures does NOT allow duplicate elements?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Deque"
    ]
  },
  {
    "q": "Which traversal is typically used for depth-first search in graphs?",
    "c": null,
    "o": [
      "Stack-based",
      "Queue-based",
      "Heap-based",
      "Hash-based"
    ]
  },
  {
    "q": "Which of the following has the worst time complexity in average case for searching?",
    "c": null,
    "o": [
      "Unordered list",
      "Binary Search Tree",
      "Hash Table",
      "Balanced BST"
    ]
  },
  {
    "q": "Which data structure is used in recursive function calls internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the shortest path in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the average time complexity for search operation in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm is NOT in-place?",
    "c": null,
    "o": [
      "Merge Sort",
      "Insertion Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of the following is used to implement a LIFO structure?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which tree traversal visits nodes in the order: left subtree, root, right subtree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which Python module provides tools to implement graphs and complex networks?",
    "c": null,
    "o": [
      "networkx",
      "heapq",
      "collections",
      "itertools"
    ]
  },
  {
    "q": "Which is the best case time complexity for Bubble Sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which function is used to sort a list in descending order in Python?",
    "c": null,
    "o": [
      "sorted(list, reverse=True)",
      "list.sort(descending=True)",
      "sort(list, descending=True)",
      "reverse_sort(list)"
    ]
  },
  {
    "q": "Which data structure uses two ends to insert and delete elements?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "Which of the following data structures gives the best performance for implementing a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "What is the output of `len(set([1, 2, 2, 3, 4]))` in Python?",
    "c": null,
    "o": [
      "4",
      "5",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which algorithm is based on the divide and conquer paradigm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Linear Search"
    ]
  },
  {
    "q": "Which of the following statements about Python lists is true?",
    "c": null,
    "o": [
      "They can store elements of different types",
      "They are immutable",
      "They use a linked list internally",
      "They are slower than sets for lookups"
    ]
  },
  {
    "q": "Which traversal technique uses a queue to visit nodes in a binary tree?",
    "c": null,
    "o": [
      "Level-order",
      "Inorder",
      "Preorder",
      "Postorder"
    ]
  },
  {
    "q": "What is the worst-case time complexity for quicksort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "What does `heapq.heappop()` do?",
    "c": null,
    "o": [
      "Removes and returns the smallest item",
      "Removes and returns the largest item",
      "Returns the heap size",
      "Sorts the heap"
    ]
  },
  {
    "q": "Which of the following is a stable sorting algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of these operations has constant time complexity in a set?",
    "c": null,
    "o": [
      "Membership test (`in`)",
      "Sorting",
      "Indexing",
      "Slicing"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing undo operations?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "What is the time complexity to access an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is used in depth-first search (DFS)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "In Python, what is the output of `sorted([3, 1, 2])`?",
    "c": null,
    "o": [
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[2, 1, 3]",
      "None of the above"
    ]
  },
  {
    "q": "What is the main advantage of using a linked list over an array?",
    "c": null,
    "o": [
      "Dynamic memory allocation",
      "Faster random access",
      "Less memory usage",
      "Fixed size"
    ]
  },
  {
    "q": "Which sorting algorithm works by repeatedly swapping adjacent elements if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which Python module provides a double-ended queue implementation?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "deque"
    ]
  },
  {
    "q": "Which traversal visits the left subtree, root, then right subtree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following operations is not allowed on Python sets?",
    "c": null,
    "o": [
      "Indexing",
      "Adding elements",
      "Removing elements",
      "Membership test"
    ]
  },
  {
    "q": "What is the space complexity of recursive Fibonacci without memoization?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(2^n)"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "DFS",
      "Prim's Algorithm",
      "Bellman-Ford"
    ]
  },
  {
    "q": "Which of the following Python data types is ordered and immutable?",
    "c": null,
    "o": [
      "Tuple",
      "List",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "What data structure is best suited for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Array"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the end of a Python list (amortized)?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python built-in function returns the length of a data structure?",
    "c": null,
    "o": [
      "len()",
      "size()",
      "count()",
      "length()"
    ]
  },
  {
    "q": "Which of these is a characteristic of a heap?",
    "c": null,
    "o": [
      "Parent is always greater or smaller than its children",
      "All elements are sorted",
      "It supports constant time lookups",
      "Uses binary search"
    ]
  },
  {
    "q": "Which traversal method is used by breadth-first search (BFS)?",
    "c": null,
    "o": [
      "Level-order",
      "Inorder",
      "Preorder",
      "Postorder"
    ]
  },
  {
    "q": "Which method removes and returns an element from a Python set?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "discard()",
      "del()"
    ]
  },
  {
    "q": "What is the best case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(1)"
    ]
  },
  {
    "q": "Which of these operations on a Python dictionary is the fastest?",
    "c": null,
    "o": [
      "Lookup by key",
      "Sorting by value",
      "Iterating values",
      "Getting all keys"
    ]
  },
  {
    "q": "Which graph algorithm uses a priority queue for implementation?",
    "c": null,
    "o": [
      "Dijkstra's algorithm",
      "DFS",
      "BFS",
      "Kruskal's algorithm"
    ]
  },
  {
    "q": "What is the worst-case time complexity of binary search on a sorted list?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following is not a stable sorting algorithm?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which data structure is used in a depth-first search algorithm?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Heap"
    ]
  },
  {
    "q": "Which Python data type is best suited for implementing a hash table?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Set",
      "Tuple"
    ]
  },
  {
    "q": "Which method is used to add an element to the end of a list in Python?",
    "c": null,
    "o": [
      "append()",
      "insert()",
      "extend()",
      "add()"
    ]
  },
  {
    "q": "In which case will quicksort perform its worst?",
    "c": null,
    "o": [
      "When the pivot is the smallest or largest element each time",
      "When all elements are unique",
      "When the list is already sorted",
      "When all elements are equal"
    ]
  },
  {
    "q": "Which of the following data structures guarantees O(1) average time complexity for insert, delete, and search operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which algorithm is commonly used to find the shortest path in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "Which of the following operations is the most time-consuming for a singly linked list?",
    "c": null,
    "o": [
      "Accessing the last element",
      "Inserting at the beginning",
      "Deleting from the beginning",
      "Checking if empty"
    ]
  },
  {
    "q": "Which of the following is a divide-and-conquer algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which data structure uses the LIFO (Last In First Out) principle?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which built-in function is used to sort a list in Python?",
    "c": null,
    "o": [
      "sorted()",
      "arrange()",
      "order()",
      "sortlist()"
    ]
  },
  {
    "q": "What is the time complexity to access an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "Array",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which method removes the last item from a list in Python?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "delete()",
      "discard()"
    ]
  },
  {
    "q": "What is the default sorting order used by the sorted() function in Python?",
    "c": null,
    "o": [
      "Ascending",
      "Descending",
      "Lexicographical",
      "Random"
    ]
  },
  {
    "q": "Which of these is a self-balancing binary search tree?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Heap",
      "Trie",
      "Segment Tree"
    ]
  },
  {
    "q": "What is the maximum number of children a binary tree node can have?",
    "c": null,
    "o": [
      "2",
      "1",
      "3",
      "Unlimited"
    ]
  },
  {
    "q": "Which of the following operations has the highest time complexity in a heap?",
    "c": null,
    "o": [
      "Search for a specific value",
      "Insert",
      "Delete root",
      "Get minimum/maximum"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Linked List"
    ]
  },
  {
    "q": "What is the worst-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these is a divide and conquer algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Linear Search"
    ]
  },
  {
    "q": "Which traversal method is used to get the contents of a BST in sorted order?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level order"
    ]
  },
  {
    "q": "Which Python module provides a priority queue implementation?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "collections",
      "bisect"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a scheduler?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Linked List",
      "Tree"
    ]
  },
  {
    "q": "Which algorithm is used in Python’s built-in sort() function?",
    "c": null,
    "o": [
      "Timsort",
      "Quicksort",
      "Heapsort",
      "Mergesort"
    ]
  },
  {
    "q": "Which of the following is a non-linear data structure?",
    "c": null,
    "o": [
      "Graph",
      "List",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "Which structure uses both FIFO and LIFO principles?",
    "c": null,
    "o": [
      "Deque",
      "Queue",
      "Stack",
      "Array"
    ]
  },
  {
    "q": "What is the space complexity of Merge Sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following operations is the fastest in a Python dictionary?",
    "c": null,
    "o": [
      "Lookup",
      "Deletion",
      "Insertion",
      "Traversal"
    ]
  },
  {
    "q": "Which data structure is best for implementing undo operations?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is not a characteristic of a binary search tree?",
    "c": null,
    "o": [
      "Left subtree contains only nodes with values less than the node’s key",
      "Right subtree contains only nodes with values greater than the node’s key",
      "No duplicate nodes",
      "All leaves are at the same level"
    ]
  },
  {
    "q": "What is the height of a complete binary tree with n nodes?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure uses key-value pairs?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "Which of the following is true about hash functions?",
    "c": null,
    "o": [
      "They map data to a fixed size",
      "They sort data efficiently",
      "They prevent data loss",
      "They increase data size"
    ]
  },
  {
    "q": "Which data structure supports O(1) insertion and deletion from both ends?",
    "c": null,
    "o": [
      "Deque",
      "Queue",
      "Stack",
      "List"
    ]
  },
  {
    "q": "Which sorting algorithm is considered stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following is the best case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following is an in-place sorting algorithm?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Counting Sort",
      "Radix Sort"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "Tuple",
      "Stack"
    ]
  },
  {
    "q": "Which Python module provides a heap queue algorithm?",
    "c": null,
    "o": [
      "heapq",
      "bisect",
      "collections",
      "deque"
    ]
  },
  {
    "q": "Which of the following has the worst-case time complexity of O(n^2)?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort (with random pivot)",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of these can be used to implement a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Queue",
      "Deque",
      "Stack"
    ]
  },
  {
    "q": "What is the default implementation of Python’s set?",
    "c": null,
    "o": [
      "Hash table",
      "Binary search tree",
      "List",
      "Linked list"
    ]
  },
  {
    "q": "Which of these traversals results in a sorted list for a BST?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a weighted graph?",
    "c": null,
    "o": [
      "Dijkstra's algorithm",
      "DFS",
      "Kruskal's algorithm",
      "Prim's algorithm"
    ]
  },
  {
    "q": "Which of the following operations takes O(1) time in Python’s deque?",
    "c": null,
    "o": [
      "Append to either end",
      "Insert at arbitrary position",
      "Remove from arbitrary position",
      "Sort the deque"
    ]
  },
  {
    "q": "Which is the most efficient algorithm to detect a cycle in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Dijkstra’s algorithm",
      "Prim’s algorithm"
    ]
  },
  {
    "q": "Which data structure uses LIFO (Last-In-First-Out) ordering?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Tree"
    ]
  },
  {
    "q": "Which algorithm is used to sort in O(n log n) time on average and uses a divide-and-conquer strategy?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following data structures allows insertion and deletion at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Queue",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which built-in Python function returns the length of a list?",
    "c": null,
    "o": [
      "len()",
      "length()",
      "count()",
      "size()"
    ]
  },
  {
    "q": "Which data structure is used in breadth-first search?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which method adds an element to the end of a list in Python?",
    "c": null,
    "o": [
      "append()",
      "add()",
      "insert()",
      "push()"
    ]
  },
  {
    "q": "Which algorithm is guaranteed to run in O(n log n) time?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which of the following is not a stable sorting algorithm?",
    "c": null,
    "o": [
      "Heap Sort",
      "Bubble Sort",
      "Merge Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which data structure is best for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which traversal method is used to copy a binary tree?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following data structures does not allow duplicate elements?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which searching algorithm is best suited for a sorted array?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Exponential Search"
    ]
  },
  {
    "q": "Which method is used to remove the last element from a list in Python?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "del()",
      "discard()"
    ]
  },
  {
    "q": "Which data structure is implemented as a priority queue in Python?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "List",
      "Deque"
    ]
  },
  {
    "q": "Which algorithm repeatedly swaps adjacent elements if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which of the following is the worst-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which Python structure is most suitable for mapping keys to values?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "Which of the following methods can be used to sort a list in Python?",
    "c": null,
    "o": [
      "sort()",
      "order()",
      "arrange()",
      "sequence()"
    ]
  },
  {
    "q": "Which traversal technique visits the root, then left, then right subtree?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "What is the time complexity to search an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n^2)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following data structures provides constant time complexity for insertion, deletion, and search operations?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Tree"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of these is a divide-and-conquer algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the output of len({1, 2, 3, 2}) in Python?",
    "c": null,
    "o": [
      "3",
      "4",
      "2",
      "1"
    ]
  },
  {
    "q": "Which data structure uses LIFO (Last In First Out)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the shortest path in a weighted graph?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "DFS",
      "BFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "Stack",
      "Queue",
      "Array"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average case performance?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "In Python, what will be the output of list('abc')?",
    "c": null,
    "o": [
      "['a', 'b', 'c']",
      "[abc]",
      "('a', 'b', 'c')",
      "['abc']"
    ]
  },
  {
    "q": "Which algorithm is commonly used for cycle detection in a graph?",
    "c": null,
    "o": [
      "Union-Find",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which Python built-in data structure is best for implementing a priority queue?",
    "c": null,
    "o": [
      "heapq",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python list by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithm is used in Python’s built-in sort() method?",
    "c": null,
    "o": [
      "Timsort",
      "Quicksort",
      "Mergesort",
      "Heapsort"
    ]
  },
  {
    "q": "Which of the following data structures is implemented using a circular buffer?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Hash Table",
      "Binary Tree"
    ]
  },
  {
    "q": "Which tree traversal method visits nodes in sorted order for a binary search tree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level Order"
    ]
  },
  {
    "q": "Which of the following is not a characteristic of a heap?",
    "c": null,
    "o": [
      "All levels are fully filled except possibly the last",
      "All nodes are sorted according to the heap property",
      "It is a complete binary tree",
      "It allows O(1) access to the minimum or maximum"
    ]
  },
  {
    "q": "Which method is used to remove a key from a Python dictionary?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "delete()",
      "discard()"
    ]
  },
  {
    "q": "Which Python module provides support for double-ended queues?",
    "c": null,
    "o": [
      "collections",
      "queue",
      "heapq",
      "functools"
    ]
  },
  {
    "q": "Which of the following problems can be solved using dynamic programming?",
    "c": null,
    "o": [
      "0/1 Knapsack",
      "Binary Search",
      "Depth First Search",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the auxiliary space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure uses LIFO (Last-In, First-Out) principle?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Heap"
    ]
  },
  {
    "q": "Which Python data type is most efficient for checking the existence of an element?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "deque"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following algorithms is best suited for finding the shortest path in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra's algorithm",
      "Prim's algorithm",
      "Kruskal's algorithm",
      "Depth First Search"
    ]
  },
  {
    "q": "Which data structure is typically used in Breadth-First Search (BFS)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Hash Table"
    ]
  },
  {
    "q": "In Python, what is the output of `list('abc')`?",
    "c": null,
    "o": [
      "['a', 'b', 'c']",
      "['abc']",
      "('a', 'b', 'c')",
      "{'a', 'b', 'c'}"
    ]
  },
  {
    "q": "Which sorting algorithm is not stable?",
    "c": null,
    "o": [
      "Selection sort",
      "Merge sort",
      "Bubble sort",
      "Insertion sort"
    ]
  },
  {
    "q": "Which method is used to add a key-value pair to a Python dictionary?",
    "c": null,
    "o": [
      "dict[key] = value",
      "dict.add(key, value)",
      "dict.insert(key, value)",
      "dict.push(key, value)"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithm technique divides the problem into smaller subproblems and solves them recursively?",
    "c": null,
    "o": [
      "Divide and conquer",
      "Greedy",
      "Dynamic programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which Python collection type maintains insertion order as of Python 3.7+?",
    "c": null,
    "o": [
      "dict",
      "set",
      "frozenset",
      "heapq"
    ]
  },
  {
    "q": "What is the time complexity of retrieving an element from a list by index in Python?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithm is used to detect cycles in a graph?",
    "c": null,
    "o": [
      "Depth First Search (DFS)",
      "Breadth First Search (BFS)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "Which of the following is a mutable data type in Python?",
    "c": null,
    "o": [
      "list",
      "tuple",
      "str",
      "int"
    ]
  },
  {
    "q": "Which sorting algorithm has the best worst-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What does the `heapq` module in Python provide?",
    "c": null,
    "o": [
      "Functions for implementing heaps",
      "Functions for sorting lists",
      "Functions for graphs",
      "Functions for linked lists"
    ]
  },
  {
    "q": "Which of these is not a Python sequence type?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "range"
    ]
  },
  {
    "q": "Which Python data structure allows duplicate values and is ordered?",
    "c": null,
    "o": [
      "list",
      "set",
      "dict (keys)",
      "frozenset"
    ]
  },
  {
    "q": "Which traversal visits the left subtree, then the node, and finally the right subtree?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which algorithm solves the 'knapsack problem' efficiently using overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing recursion internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which Python built-in data structure is best for implementing a priority queue?",
    "c": null,
    "o": [
      "heapq",
      "deque",
      "set",
      "list"
    ]
  },
  {
    "q": "Which of the following methods removes and returns an arbitrary element from a set?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "discard()",
      "del()"
    ]
  },
  {
    "q": "Which algorithm is used in the `sorted()` function in Python?",
    "c": null,
    "o": [
      "Timsort",
      "Quicksort",
      "Heapsort",
      "Mergesort"
    ]
  },
  {
    "q": "What is the average time complexity of search in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which traversal method is used for breadth-first search in a tree?",
    "c": null,
    "o": [
      "Level-order",
      "In-order",
      "Post-order",
      "Pre-order"
    ]
  },
  {
    "q": "Which Python module provides a double-ended queue?",
    "c": null,
    "o": [
      "collections",
      "queue",
      "deque",
      "heapq"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the shortest path in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "DFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which of the following is an application of a graph data structure?",
    "c": null,
    "o": [
      "Social Networks",
      "Binary Search",
      "Stacks",
      "Sorting Algorithms"
    ]
  },
  {
    "q": "Which of the following data structures allows LIFO access?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Linked List"
    ]
  },
  {
    "q": "What is the main advantage of a linked list over an array?",
    "c": null,
    "o": [
      "Dynamic size",
      "Fast random access",
      "Lower memory usage",
      "Sorted data"
    ]
  },
  {
    "q": "Which Python data type is best suited to implement a hash table?",
    "c": null,
    "o": [
      "dict",
      "list",
      "set",
      "tuple"
    ]
  },
  {
    "q": "Which sorting algorithm is considered stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "In a binary tree, what is the maximum number of nodes at level 'l'?",
    "c": null,
    "o": [
      "2^l",
      "2^(l+1)",
      "2^(l-1)",
      "l^2"
    ]
  },
  {
    "q": "What is the time complexity to access an element in a Python list by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these is not a self-balancing binary search tree?",
    "c": null,
    "o": [
      "Trie",
      "AVL Tree",
      "Red-Black Tree",
      "Splay Tree"
    ]
  },
  {
    "q": "What is the height of a complete binary tree with 'n' nodes?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is the most efficient in terms of time complexity for inserting an element?",
    "c": null,
    "o": [
      "Stack (using list)",
      "Queue (using list)",
      "List at beginning",
      "Tuple"
    ]
  },
  {
    "q": "What will be the result of the expression `bool([])` in Python?",
    "c": null,
    "o": [
      "False",
      "True",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which data structure is used in a recursive function call stack?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which data structure provides the best performance for implementing a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Queue",
      "Stack",
      "Array"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "What will `len(set([1, 2, 2, 3]))` return in Python?",
    "c": null,
    "o": [
      "3",
      "4",
      "2",
      "1"
    ]
  },
  {
    "q": "Which of the following is an in-place sorting algorithm?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bucket Sort",
      "Radix Sort"
    ]
  },
  {
    "q": "What is the output of `sorted([3, 1, 2])` in Python?",
    "c": null,
    "o": [
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[1, 3, 2]",
      "[2, 3, 1]"
    ]
  },
  {
    "q": "Which built-in Python module helps implement FIFO queues efficiently?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "itertools",
      "array"
    ]
  },
  {
    "q": "Which of the following is **not** a linear data structure?",
    "c": null,
    "o": [
      "Graph",
      "Stack",
      "Queue",
      "Array"
    ]
  },
  {
    "q": "Which method adds an element to the end of a Python list?",
    "c": null,
    "o": [
      "append()",
      "add()",
      "insert()",
      "extend()"
    ]
  },
  {
    "q": "What is the default time complexity of the `in` operator for checking membership in a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing undo operations?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Set"
    ]
  },
  {
    "q": "Which algorithm uses the divide and conquer strategy?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "In Python, which keyword is used to define a generator function?",
    "c": null,
    "o": [
      "yield",
      "return",
      "def",
      "lambda"
    ]
  },
  {
    "q": "Which of these has O(1) time complexity for element insertion and deletion from both ends?",
    "c": null,
    "o": [
      "deque",
      "list",
      "tuple",
      "set"
    ]
  },
  {
    "q": "Which algorithm is best for finding the shortest path in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the main advantage of a hash table over a list?",
    "c": null,
    "o": [
      "Faster lookups",
      "Less memory usage",
      "Maintains order",
      "Allows duplicates"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is NOT stable?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which built-in Python type is immutable?",
    "c": null,
    "o": [
      "Tuple",
      "List",
      "Dictionary",
      "Set"
    ]
  },
  {
    "q": "What is the best case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which algorithm is used for topological sorting in a DAG?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which Python data type does not allow duplicate values?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which of the following is NOT a linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "Stack",
      "Queue",
      "Array"
    ]
  },
  {
    "q": "Which algorithm is used for finding connected components in a graph?",
    "c": null,
    "o": [
      "DFS",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following has the worst-case time complexity of O(n^2)?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Heap Sort",
      "Quick Sort (average case)"
    ]
  },
  {
    "q": "Which Python collection is ordered, mutable, and allows duplicate elements?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Dictionary",
      "Tuple"
    ]
  },
  {
    "q": "Which of the following is used to implement priority queues?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Deque",
      "Set"
    ]
  },
  {
    "q": "What does the 'pop' operation do in a stack?",
    "c": null,
    "o": [
      "Removes the top element",
      "Removes the bottom element",
      "Adds an element to the top",
      "Adds an element to the bottom"
    ]
  },
  {
    "q": "Which traversal method is used in binary search trees to get sorted data?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following data structures is implemented as a doubly linked list in Python’s standard library?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "set",
      "tuple"
    ]
  },
  {
    "q": "What is the average time complexity for searching an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm repeatedly selects the minimum element and moves it to the beginning?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which of the following Python data types is immutable?",
    "c": null,
    "o": [
      "tuple",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "What is the time complexity of appending an element to the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which graph traversal method uses a queue to track nodes to visit?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "Which algorithm is efficient for finding the minimum spanning tree in a weighted graph?",
    "c": null,
    "o": [
      "Kruskal's Algorithm",
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which of the following sorting algorithms has an average time complexity of O(n log n)?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the primary characteristic of a max-heap?",
    "c": null,
    "o": [
      "The parent node is always greater than or equal to its children",
      "The parent node is always less than or equal to its children",
      "Nodes are sorted in ascending order",
      "Nodes are sorted in descending order"
    ]
  },
  {
    "q": "Which Python built-in data structure allows fast membership testing and does not allow duplicates?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "dict"
    ]
  },
  {
    "q": "Which of these is the best data structure for implementing an undo feature?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "Which algorithmic paradigm is typically used in solving the knapsack problem efficiently?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python built-in data type is immutable and ordered?",
    "c": null,
    "o": [
      "tuple",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "What is the best case time complexity of insertion sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a stack or recursion to explore nodes?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which Python data structure preserves the order of insertion and allows key-value pairs?",
    "c": null,
    "o": [
      "dict",
      "set",
      "list",
      "tuple"
    ]
  },
  {
    "q": "Which data structure is used internally by Python’s `set`?",
    "c": null,
    "o": [
      "Hash Table",
      "Binary Tree",
      "Linked List",
      "Array"
    ]
  },
  {
    "q": "Which sorting algorithm divides the array into subarrays and then merges them in sorted order?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following operations is O(1) in a Python list?",
    "c": null,
    "o": [
      "Accessing an element by index",
      "Inserting at the beginning",
      "Deleting an element from the middle",
      "Searching for an element"
    ]
  },
  {
    "q": "Which data structure is best for implementing a FIFO queue?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which algorithm technique stores results of subproblems to avoid redundant computations?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in an unsorted Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is an immutable Python data type?",
    "c": null,
    "o": [
      "frozenset",
      "list",
      "dict",
      "set"
    ]
  },
  {
    "q": "Which sorting algorithm works by repeatedly swapping adjacent elements?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What does the `pop()` method do in a Python list?",
    "c": null,
    "o": [
      "Removes and returns the last element",
      "Removes the first element",
      "Adds an element to the end",
      "Returns the length"
    ]
  },
  {
    "q": "Which data structure is optimal for implementing breadth-first search (BFS)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which of these is NOT a characteristic of a balanced binary search tree?",
    "c": null,
    "o": [
      "Height is O(log n)",
      "All nodes have two children",
      "Left subtree contains smaller values",
      "Right subtree contains larger values"
    ]
  },
  {
    "q": "What is the worst-case time complexity of accessing an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following algorithms is used to find strongly connected components in a graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is used to implement recursion internally?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Array"
    ]
  },
  {
    "q": "Which Python data structure provides O(1) average time complexity for search, insert, and delete operations?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "Which algorithm sorts by repeatedly dividing the list into halves?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of a queue?",
    "c": null,
    "o": [
      "LIFO (Last In First Out)",
      "FIFO (First In First Out)",
      "Enqueue operation",
      "Dequeue operation"
    ]
  },
  {
    "q": "What is the average time complexity of searching for an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these is a greedy algorithm?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which Python module provides an implementation of heaps?",
    "c": null,
    "o": [
      "heapq",
      "collections",
      "queue",
      "functools"
    ]
  },
  {
    "q": "Which of these data structures is used to implement depth-first search (DFS)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "Which traversal of a binary tree visits the root node last?",
    "c": null,
    "o": [
      "Post-order",
      "Pre-order",
      "In-order",
      "Level-order"
    ]
  },
  {
    "q": "Which data structure provides the best performance for priority scheduling?",
    "c": null,
    "o": [
      "Heap",
      "Queue",
      "Stack",
      "List"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing breadth-first search (BFS)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "What is the primary purpose of a hash function in a hash table?",
    "c": null,
    "o": [
      "To compute the index for storing keys",
      "To sort the keys",
      "To compress data",
      "To encrypt the keys"
    ]
  },
  {
    "q": "Which algorithm can be used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is NOT a stable sorting algorithm?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the output of `bool({})` in Python?",
    "c": null,
    "o": [
      "False",
      "True",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which Python data structure allows for efficient FIFO operations and is part of the collections module?",
    "c": null,
    "o": [
      "deque",
      "list",
      "set",
      "tuple"
    ]
  },
  {
    "q": "Which algorithm paradigm involves solving smaller overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Greedy Algorithm",
      "Backtracking"
    ]
  },
  {
    "q": "What is the worst-case time complexity of inserting into a Python dictionary?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which traversal technique visits nodes in the order: left child, node, right child?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "What is the primary advantage of using a linked list over an array?",
    "c": null,
    "o": [
      "Dynamic size and ease of insertion/deletion",
      "Faster random access",
      "Less memory usage",
      "Sorted data"
    ]
  },
  {
    "q": "Which data structure is best for implementing a LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "List",
      "Set",
      "Tuple"
    ]
  },
  {
    "q": "Which algorithm is used for efficient substring search in strings?",
    "c": null,
    "o": [
      "KMP (Knuth-Morris-Pratt) Algorithm",
      "Bubble Sort",
      "Merge Sort",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is a self-balancing binary search tree?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Heap",
      "Trie",
      "Red-Black Tree (also self-balancing, but AVL is a common example)"
    ]
  },
  {
    "q": "Which Python data structure is most suitable for storing unique items?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "dict"
    ]
  },
  {
    "q": "Which of the following graph algorithms finds the shortest path from a source to all vertices in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Prim's Algorithm",
      "Kruskal's Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python tuple by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is typically used to implement recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "What is the advantage of using a heap data structure?",
    "c": null,
    "o": [
      "Efficient retrieval of the minimum or maximum element",
      "Fast random access",
      "Maintaining sorted order",
      "Constant time insertions"
    ]
  },
  {
    "q": "Which algorithm technique uses a heuristic to find an approximate solution quickly?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which Python built-in type maintains insertion order starting from Python 3.7?",
    "c": null,
    "o": [
      "dict",
      "set",
      "list",
      "tuple"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a breadth-first traversal of a graph?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "What is the main purpose of a priority queue?",
    "c": null,
    "o": [
      "To process elements based on priority rather than insertion order",
      "To maintain sorted order",
      "To allow random access",
      "To store unique elements"
    ]
  },
  {
    "q": "Which of the following is true about a Python list?",
    "c": null,
    "o": [
      "It is mutable and ordered",
      "It is immutable and unordered",
      "It stores only unique elements",
      "It uses hashing for element access"
    ]
  },
  {
    "q": "Which algorithm is typically used to detect cycles in an undirected graph?",
    "c": null,
    "o": [
      "Union-Find (Disjoint Set)",
      "Dijkstra's Algorithm",
      "DFS with recursion stack",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What is the average case time complexity of accessing a value in a Python dictionary by key?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python data type is best for representing an immutable sequence of elements?",
    "c": null,
    "o": [
      "tuple",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing a LIFO collection?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which of the following algorithms uses a greedy approach for finding the minimum spanning tree?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of a binary search tree?",
    "c": null,
    "o": [
      "Nodes are stored in a sorted manner with left child < parent < right child",
      "It allows duplicate nodes",
      "Left subtree contains only nodes with values less than the parent",
      "Right subtree contains only nodes with values greater than the parent"
    ]
  },
  {
    "q": "What data structure would you typically use to implement backtracking algorithms?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing a cache with fast access and eviction?",
    "c": null,
    "o": [
      "Hash Map with Doubly Linked List (LRU Cache)",
      "Stack",
      "Queue",
      "Binary Tree"
    ]
  },
  {
    "q": "Which algorithm technique is based on breaking a problem into smaller subproblems, solving them independently, and combining the results?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "What is the worst-case time complexity of inserting an element into a Python set?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is a linear data structure?",
    "c": null,
    "o": [
      "Queue",
      "Graph",
      "Tree",
      "Heap"
    ]
  },
  {
    "q": "Which traversal method visits nodes in the order: root, left subtree, right subtree?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which Python module provides thread-safe queue implementations?",
    "c": null,
    "o": [
      "queue",
      "collections",
      "heapq",
      "itertools"
    ]
  },
  {
    "q": "What is the output of `list(range(3, 8))` in Python?",
    "c": null,
    "o": [
      "[3, 4, 5, 6, 7]",
      "[3, 4, 5, 6, 7, 8]",
      "[3, 8]",
      "[4, 5, 6, 7]"
    ]
  },
  {
    "q": "Which sorting algorithm repeatedly compares adjacent elements and swaps them if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which Python data structure is unordered, mutable, and indexed by keys?",
    "c": null,
    "o": [
      "dict",
      "list",
      "tuple",
      "set"
    ]
  },
  {
    "q": "Which algorithm is used to detect cycles in a directed graph using recursion stack?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure supports efficient insertion, deletion, and lookup with average O(1) time complexity?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Tree"
    ]
  },
  {
    "q": "What is the best use case for a trie data structure?",
    "c": null,
    "o": [
      "Efficient prefix-based searches",
      "Sorting numbers",
      "Implementing stacks",
      "Finding shortest paths"
    ]
  },
  {
    "q": "Which algorithm paradigm solves problems by exploring all possible solutions and pruning invalid ones?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which of these is NOT a property of a binary search tree (BST)?",
    "c": null,
    "o": [
      "All leaves are at the same depth",
      "Left subtree nodes are less than the root",
      "Right subtree nodes are greater than the root",
      "No duplicate nodes in standard BST"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average-case performance for large datasets?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which Python data structure is immutable and hashable?",
    "c": null,
    "o": [
      "tuple",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "Which of the following is a common use case of a graph data structure?",
    "c": null,
    "o": [
      "Modeling social networks",
      "Sorting lists",
      "Implementing queues",
      "Text searching"
    ]
  },
  {
    "q": "Which data structure allows insertion and deletion at both ends efficiently?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "What is the primary advantage of using a balanced binary search tree?",
    "c": null,
    "o": [
      "Maintains O(log n) time complexity for insert, delete, and search",
      "Faster than hash tables for all operations",
      "Uses less memory than arrays",
      "Allows duplicate keys"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in graphs with negative edge weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is most appropriate for managing tasks with priorities?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithmic approach solves problems by making locally optimal choices at each step?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a balanced AVL tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python data structure automatically resizes as elements are added or removed?",
    "c": null,
    "o": [
      "List",
      "Tuple",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "Which traversal visits nodes level by level in a tree?",
    "c": null,
    "o": [
      "Level-order Traversal",
      "In-order Traversal",
      "Pre-order Traversal",
      "Post-order Traversal"
    ]
  },
  {
    "q": "Which data structure can efficiently check for membership and prevent duplicates?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which algorithm is used to find the minimum spanning tree in a graph?",
    "c": null,
    "o": [
      "Kruskal's Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure provides constant time complexity for insertion and deletion at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "What is the main benefit of dynamic programming?",
    "c": null,
    "o": [
      "Avoids recomputation by storing intermediate results",
      "Always runs in linear time",
      "Uses a greedy approach",
      "Breaks problems into independent subproblems"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing function call management in programming languages?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which of the following Python data structures is unordered and does not allow duplicates?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "dict"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path from a single source in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which sorting algorithm divides the input into smaller parts, sorts them, and merges the results?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element by index in a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which traversal method visits the root node first, then left and right subtrees?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which Python module provides an efficient implementation of heaps?",
    "c": null,
    "o": [
      "heapq",
      "collections",
      "queue",
      "itertools"
    ]
  },
  {
    "q": "Which data structure efficiently supports insertion, deletion, and search with average O(1) time complexity?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Tree"
    ]
  },
  {
    "q": "Which of the following is a self-balancing binary search tree?",
    "c": null,
    "o": [
      "AVL Tree",
      "Heap",
      "Trie",
      "Graph"
    ]
  },
  {
    "q": "Which technique is used in dynamic programming to solve problems?",
    "c": null,
    "o": [
      "Overlapping subproblems and optimal substructure",
      "Divide and conquer",
      "Greedy choice",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is commonly used to implement a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "What is the main advantage of using a trie data structure?",
    "c": null,
    "o": [
      "Efficient retrieval of strings based on prefixes",
      "Faster sorting of numbers",
      "Better memory usage for large datasets",
      "Improved graph traversal"
    ]
  },
  {
    "q": "Which sorting algorithm is typically the fastest on average for large datasets?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which data structure allows constant-time average complexity for membership tests in Python?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "dict"
    ]
  },
  {
    "q": "Which algorithm technique is characterized by making a sequence of choices, each locally optimal?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the end of a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which traversal of a binary tree visits nodes in left-root-right order?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which algorithm is used to find the minimum spanning tree of a connected, weighted graph?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which Python data structure preserves insertion order and stores key-value pairs?",
    "c": null,
    "o": [
      "dict",
      "set",
      "list",
      "tuple"
    ]
  },
  {
    "q": "Which algorithm finds strongly connected components in a directed graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is best for implementing an undo feature in applications?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element by index in a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithmic technique involves trying out different solutions and discarding those that fail?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which data structure is used in Python’s `collections` module for efficient FIFO operations?",
    "c": null,
    "o": [
      "deque",
      "list",
      "set",
      "tuple"
    ]
  },
  {
    "q": "Which sorting algorithm is stable and has O(n log n) time complexity in the worst case?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which traversal method in binary trees visits the root node last?",
    "c": null,
    "o": [
      "Post-order",
      "Pre-order",
      "In-order",
      "Level-order"
    ]
  },
  {
    "q": "Which Python data structure automatically handles hashing for key-value storage?",
    "c": null,
    "o": [
      "dict",
      "list",
      "tuple",
      "set"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue data structure?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is most efficient for implementing priority queues?",
    "c": null,
    "o": [
      "Heap",
      "Queue",
      "Stack",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithmic paradigm solves problems by storing solutions to subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which data structure is most appropriate for implementing recursion call stacks?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which Python data structure stores elements in insertion order and allows duplicate values?",
    "c": null,
    "o": [
      "list",
      "set",
      "dict",
      "tuple"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a weighted graph without negative edges?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following sorting algorithms has a worst-case time complexity of O(n^2)?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which traversal technique in a binary tree visits nodes in left-root-right order?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which Python module provides efficient implementations of queue data structures including FIFO and LIFO?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "itertools",
      "functools"
    ]
  },
  {
    "q": "Which data structure supports fast membership testing, insertion, and deletion with average O(1) time?",
    "c": null,
    "o": [
      "Hash Set",
      "List",
      "Tuple",
      "Linked List"
    ]
  },
  {
    "q": "Which self-balancing binary search tree maintains the height difference between left and right subtrees to at most 1?",
    "c": null,
    "o": [
      "AVL Tree",
      "Red-Black Tree",
      "Binary Heap",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm is used to find strongly connected components in directed graphs?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What data structure is most efficient for managing a to-do list where tasks have different priorities?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing a breadth-first search (BFS) algorithm?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm is typically used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which Python data structure maintains the order of insertion and allows key-value pairs?",
    "c": null,
    "o": [
      "dict",
      "set",
      "list",
      "tuple"
    ]
  },
  {
    "q": "Which algorithm uses a greedy approach to find the minimum spanning tree of a graph?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which traversal method of a binary tree visits nodes in root-left-right order?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "What is the average case time complexity of searching an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm is NOT stable?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which data structure is best for implementing undo functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which Python module provides a deque data structure that supports fast appends and pops from both ends?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "itertools"
    ]
  },
  {
    "q": "Which algorithmic technique uses memoization to optimize recursive computations?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is optimal for implementing a LIFO collection?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithmic technique is based on making decisions by choosing locally optimal options?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which Python data type is immutable and hashable, often used as keys in dictionaries?",
    "c": null,
    "o": [
      "tuple",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "Which algorithm finds shortest paths from a single source in graphs with negative edge weights (without negative cycles)?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure allows for insertion and deletion at both ends in O(1) time?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "What is the average-case time complexity of inserting an element into a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm divides the list and merges sorted halves?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which Python module provides functions for creating iterators for efficient looping?",
    "c": null,
    "o": [
      "itertools",
      "collections",
      "heapq",
      "functools"
    ]
  },
  {
    "q": "Which graph traversal uses a stack or recursion?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of these is a characteristic of a balanced binary search tree?",
    "c": null,
    "o": [
      "Height is O(log n)",
      "All nodes have two children",
      "Duplicates are allowed",
      "Unordered nodes"
    ]
  },
  {
    "q": "Which data structure uses FIFO order for element processing?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "What is the primary benefit of using a hash table?",
    "c": null,
    "o": [
      "Fast average-time access, insertion, and deletion",
      "Maintains elements in sorted order",
      "Uses less memory than arrays",
      "Allows duplicate keys"
    ]
  },
  {
    "q": "Which sorting algorithm works by repeatedly swapping adjacent elements if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which traversal of a binary tree visits nodes in the order: left, root, right?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which Python data structure is unordered and does not allow duplicates?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "dict"
    ]
  },
  {
    "q": "Which algorithmic approach involves solving subproblems and combining their results?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which Python module provides thread-safe queues?",
    "c": null,
    "o": [
      "queue",
      "collections",
      "heapq",
      "itertools"
    ]
  },
  {
    "q": "Which of the following is NOT a property of a binary search tree?",
    "c": null,
    "o": [
      "Nodes must have two children",
      "Left child is less than the parent node",
      "Right child is greater than the parent node",
      "No duplicate nodes in standard BST"
    ]
  },
  {
    "q": "Which data structure is used in depth-first search (DFS)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Deque"
    ]
  },
  {
    "q": "Which algorithm finds the minimum spanning tree by sorting edges by weight?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a LIFO order collection?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithmic paradigm involves choosing the best local option at each step?",
    "c": null,
    "o": [
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which Python data structure is immutable and hashable, often used as dictionary keys?",
    "c": null,
    "o": [
      "tuple",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "Which algorithm finds shortest paths in graphs with negative edge weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure allows insertion and deletion at both ends with O(1) complexity?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "What is the average time complexity of inserting into a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm divides and merges sublists to sort an entire list?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which Python module offers efficient iterators for looping?",
    "c": null,
    "o": [
      "itertools",
      "collections",
      "heapq",
      "functools"
    ]
  },
  {
    "q": "Which graph traversal method uses recursion or a stack?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What characteristic defines a balanced binary search tree?",
    "c": null,
    "o": [
      "Height is O(log n)",
      "Every node has two children",
      "Duplicates allowed",
      "Unordered nodes"
    ]
  },
  {
    "q": "Which data structure operates on a FIFO principle?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "What advantage does a hash table provide?",
    "c": null,
    "o": [
      "Fast average-time access, insertion, and deletion",
      "Maintains sorted order",
      "Uses less memory than arrays",
      "Allows duplicate keys"
    ]
  },
  {
    "q": "Which sorting algorithm repeatedly swaps adjacent elements if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which traversal visits nodes in left-root-right order in a binary tree?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which Python data structure is unordered and disallows duplicates?",
    "c": null,
    "o": [
      "set",
      "list",
      "tuple",
      "dict"
    ]
  },
  {
    "q": "Which algorithmic approach divides a problem into smaller subproblems and combines their results?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which Python module offers thread-safe queue implementations?",
    "c": null,
    "o": [
      "queue",
      "collections",
      "heapq",
      "itertools"
    ]
  },
  {
    "q": "Which of these is NOT a property of a binary search tree?",
    "c": null,
    "o": [
      "Nodes must have two children",
      "Left child is less than parent",
      "Right child is greater than parent",
      "No duplicate nodes"
    ]
  },
  {
    "q": "Which data structure is primarily used in depth-first search (DFS)?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Deque"
    ]
  },
  {
    "q": "Which algorithm finds a minimum spanning tree by sorting edges by weight?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is used to implement recursion and function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which Python data type preserves insertion order and supports key-value pairs?",
    "c": null,
    "o": [
      "dict",
      "set",
      "list",
      "tuple"
    ]
  },
  {
    "q": "Which algorithm finds shortest paths in graphs with only non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which sorting algorithm has an average and worst-case time complexity of O(n log n) and is stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which tree traversal visits nodes in root-left-right order?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which Python module provides a deque class for double-ended queue operations?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "itertools"
    ]
  },
  {
    "q": "Which data structure offers average O(1) complexity for insertion, deletion, and membership tests?",
    "c": null,
    "o": [
      "Hash Set",
      "List",
      "Tuple",
      "Linked List"
    ]
  },
  {
    "q": "Which self-balancing binary search tree maintains node colors to ensure balance?",
    "c": null,
    "o": [
      "Red-Black Tree",
      "AVL Tree",
      "Binary Heap",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm finds strongly connected components in directed graphs?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is suitable for managing tasks with varying priorities?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which data structure allows insertion and deletion only at one end?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Deque",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm technique is best suited for optimization problems with overlapping subproblems?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Backtracking"
    ]
  },
  {
    "q": "Which Python data structure is ordered, mutable, and allows duplicate elements?",
    "c": null,
    "o": [
      "list",
      "set",
      "tuple",
      "dict"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue to explore nodes level by level?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which sorting algorithm works by selecting the smallest element and swapping it with the first unsorted element?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "What is the time complexity to access an element by index in a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python module provides an implementation of heap queue algorithms?",
    "c": null,
    "o": [
      "heapq",
      "collections",
      "queue",
      "itertools"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of a binary search tree?",
    "c": null,
    "o": [
      "All nodes have two children",
      "Left subtree has smaller values",
      "Right subtree has larger values",
      "No duplicate keys"
    ]
  },
  {
    "q": "Which algorithmic paradigm solves problems by exploring all possible solutions and backtracking when needed?",
    "c": null,
    "o": [
      "Backtracking",
      "Greedy Algorithm",
      "Divide and Conquer",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which data structure provides efficient O(log n) insertion, deletion, and access for sorted data?",
    "c": null,
    "o": [
      "Balanced Binary Search Tree",
      "Array",
      "Hash Table",
      "Stack"
    ]
  },
  {
    "q": "Which data structure is best for implementing undo functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithmic strategy solves problems by breaking them down into independent subproblems?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy Algorithm",
      "Dynamic Programming",
      "Backtracking"
    ]
  },
  {
    "q": "Which Python data type is immutable and can be used as keys in dictionaries?",
    "c": null,
    "o": [
      "tuple",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "Which algorithm finds shortest paths from a single source node in graphs with possible negative edge weights?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure supports efficient insertion and deletion at both ends?",
    "c": null,
    "o": [
      "Deque",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "What is the average time complexity of adding an element to a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm repeatedly swaps adjacent elements to sort the list?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which Python module provides tools for efficient looping and combinatorics?",
    "c": null,
    "o": [
      "itertools",
      "collections",
      "heapq",
      "functools"
    ]
  },
  {
    "q": "Which graph traversal uses a stack or recursion to explore nodes deeply before backtracking?",
    "c": null,
    "o": [
      "Depth-First Search (DFS)",
      "Breadth-First Search (BFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What defines a balanced binary search tree?",
    "c": null,
    "o": [
      "Its height is O(log n)",
      "Each node has two children",
      "Allows duplicate nodes",
      "Nodes are unordered"
    ]
  },
  {
    "q": "Which data structure is best suited for breadth-first search traversal?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which algorithm finds strongly connected components in directed graphs?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which Python data structure maintains insertion order and allows key-value pairs?",
    "c": null,
    "o": [
      "dict",
      "set",
      "list",
      "tuple"
    ]
  },
  {
    "q": "Which algorithm finds the minimum spanning tree using edge weights in sorted order?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which tree traversal visits nodes in root-left-right order?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "What is the average time complexity for searching in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm is unstable?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which data structure is best for implementing undo functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Linked List"
    ]
  },
  {
    "q": "Which Python module provides a double-ended queue with fast append and pop operations on both ends?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "itertools"
    ]
  },
  {
    "q": "Which algorithmic technique uses memoization to avoid redundant computations?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Backtracking",
      "Divide and Conquer"
    ]
  },
  {
    "q": "Which data structure is typically used to implement function call management and recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which Python data structure preserves insertion order and stores key-value pairs?",
    "c": null,
    "o": [
      "dict",
      "set",
      "list",
      "tuple"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which sorting algorithm uses the divide-and-conquer approach and merges sorted sublists?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which binary tree traversal visits nodes in root-left-right order?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which Python module provides a deque for efficient double-ended queue operations?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "itertools"
    ]
  },
  {
    "q": "Which data structure supports average O(1) time complexity for insertion, deletion, and membership checks?",
    "c": null,
    "o": [
      "Hash Set",
      "List",
      "Tuple",
      "Linked List"
    ]
  },
  {
    "q": "Which self-balancing binary search tree maintains a height balance factor of -1, 0, or 1 for each node?",
    "c": null,
    "o": [
      "AVL Tree",
      "Red-Black Tree",
      "Binary Heap",
      "Trie"
    ]
  },
  {
    "q": "Which algorithm finds strongly connected components in directed graphs using two DFS passes?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure efficiently manages tasks according to their priority?",
    "c": null,
    "o": [
      "Priority Queue",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "What is the worst-case time complexity of accessing an element in a Python list by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithm is based on repeatedly swapping adjacent elements if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which Python built-in type is best suited for implementing a Last-In-First-Out (LIFO) stack?",
    "c": null,
    "o": [
      "list",
      "set",
      "dict",
      "tuple"
    ]
  },
  {
    "q": "Which algorithm is commonly used for finding a Minimum Spanning Tree in a graph?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "A* Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "Queue",
      "Stack",
      "Array"
    ]
  },
  {
    "q": "Which algorithm is best suited for sorting nearly sorted data efficiently?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Bubble Sort",
      "Radix Sort"
    ]
  },
  {
    "q": "Which Python module provides an efficient implementation of heaps?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "collections",
      "bisect"
    ]
  },
  {
    "q": "Which data structure is used to implement BFS in a graph?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which tree traversal method can be used to print nodes in sorted order in a binary search tree?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which data structure uses the principle of FIFO (First In First Out)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "What is the average time complexity of searching in a balanced Binary Search Tree (BST)?",
    "c": null,
    "o": [
      "O(log n)",
      "O(1)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Hash Table"
    ]
  },
  {
    "q": "Which algorithm divides the array into two halves, sorts each half, and then merges them?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which Python data structure maintains the insertion order as of Python 3.7?",
    "c": null,
    "o": [
      "dict",
      "set",
      "frozenset",
      "heapq"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is NOT comparison-based?",
    "c": null,
    "o": [
      "Radix Sort",
      "Merge Sort",
      "Heap Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following operations is the most expensive in a singly linked list?",
    "c": null,
    "o": [
      "Deleting the last element",
      "Inserting at the beginning",
      "Deleting the first element",
      "Traversing the list"
    ]
  },
  {
    "q": "Which graph traversal uses a stack, either explicitly or via recursion?",
    "c": null,
    "o": [
      "Depth First Search",
      "Breadth First Search",
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "What is the purpose of a hash function in a hash table?",
    "c": null,
    "o": [
      "To compute the index for storing a key",
      "To encrypt data",
      "To balance a binary tree",
      "To perform compression"
    ]
  },
  {
    "q": "Which Python collection allows duplicate elements and supports indexing?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Dictionary",
      "Tuple"
    ]
  },
  {
    "q": "Which sorting algorithm has the best worst-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the space complexity of Breadth First Search (BFS) in terms of the number of vertices V?",
    "c": null,
    "o": [
      "O(V)",
      "O(1)",
      "O(log V)",
      "O(V^2)"
    ]
  },
  {
    "q": "In which case does Quick Sort perform worst?",
    "c": null,
    "o": [
      "Already sorted array",
      "Random elements",
      "All elements are distinct",
      "All elements are the same"
    ]
  },
  {
    "q": "Which of the following Python data types is immutable?",
    "c": null,
    "o": [
      "tuple",
      "list",
      "dict",
      "set"
    ]
  },
  {
    "q": "Which data structure is used to implement LRU (Least Recently Used) cache efficiently?",
    "c": null,
    "o": [
      "HashMap + Doubly Linked List",
      "Queue + Stack",
      "Binary Search Tree",
      "Set + Queue"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is a non-linear data structure?",
    "c": null,
    "o": [
      "Graph",
      "Queue",
      "Stack",
      "Array"
    ]
  },
  {
    "q": "What is the result of popping an item from an empty stack?",
    "c": null,
    "o": [
      "Underflow",
      "Overflow",
      "Segmentation Fault",
      "Zero"
    ]
  },
  {
    "q": "Which method is used to add an item to a Python list?",
    "c": null,
    "o": [
      "append()",
      "add()",
      "insert()",
      "push()"
    ]
  },
  {
    "q": "Which of the following is not a valid traversal method for binary trees?",
    "c": null,
    "o": [
      "Outside-in",
      "Inorder",
      "Preorder",
      "Postorder"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "Stack",
      "Queue",
      "Array"
    ]
  },
  {
    "q": "Which Python collection is best suited for implementing a FIFO queue?",
    "c": null,
    "o": [
      "collections.deque",
      "list",
      "set",
      "dict"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a tuple?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these algorithms is used to find the shortest path in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which traversal method is used for topological sorting in a Directed Acyclic Graph (DAG)?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Inorder",
      "Level Order"
    ]
  },
  {
    "q": "Which data structure uses the concept of LIFO?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Tree"
    ]
  },
  {
    "q": "Which of the following methods is used to add an element at a specific index in a Python list?",
    "c": null,
    "o": [
      "insert()",
      "append()",
      "extend()",
      "add()"
    ]
  },
  {
    "q": "What is the maximum number of edges in an undirected graph with n vertices?",
    "c": null,
    "o": [
      "n(n-1)/2",
      "n^2",
      "n(n+1)/2",
      "2n"
    ]
  },
  {
    "q": "Which of the following is a divide and conquer algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "In Python, what does the 'heapq' module implement?",
    "c": null,
    "o": [
      "Min-Heap",
      "Max-Heap",
      "Binary Search Tree",
      "Priority Queue using Stack"
    ]
  },
  {
    "q": "Which operation is performed in O(1) time on a Python set?",
    "c": null,
    "o": [
      "Checking membership",
      "Sorting elements",
      "Indexing by position",
      "Reversing order"
    ]
  },
  {
    "q": "Which sorting algorithm is stable and has O(n log n) worst-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the purpose of the 'reversed()' function in Python?",
    "c": null,
    "o": [
      "Returns an iterator that accesses the given sequence in the reverse order",
      "Reverses the list in-place",
      "Sorts the list in reverse",
      "Returns a copy of the reversed list"
    ]
  },
  {
    "q": "Which traversal of a binary search tree gives the nodes in ascending order?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level order"
    ]
  },
  {
    "q": "What is the auxiliary space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which method in Python list is used to remove and return the last item?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "del",
      "discard()"
    ]
  },
  {
    "q": "Which graph representation is more space efficient for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Edge List",
      "Incidence Matrix"
    ]
  },
  {
    "q": "Which data structure is used for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Array",
      "Heap"
    ]
  },
  {
    "q": "What does 'deque' stand for in Python?",
    "c": null,
    "o": [
      "Double-ended queue",
      "Double-queue",
      "Dynamic end queue",
      "Dual-ended collection"
    ]
  },
  {
    "q": "Which of the following data structures allows fast insertion and deletion but does not support indexing?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "String"
    ]
  },
  {
    "q": "Which Python built-in data structure maintains the insertion order as of Python 3.7+?",
    "c": null,
    "o": [
      "dict",
      "set",
      "tuple",
      "frozenset"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the shortest path in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Depth First Search"
    ]
  },
  {
    "q": "Which function is used to get the number of elements in a list in Python?",
    "c": null,
    "o": [
      "len()",
      "count()",
      "size()",
      "length()"
    ]
  },
  {
    "q": "Which method adds an element to the end of a list in Python?",
    "c": null,
    "o": [
      "append()",
      "extend()",
      "insert()",
      "push()"
    ]
  },
  {
    "q": "Which data structure uses FIFO (First In First Out) ordering?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "Which sorting algorithm has the worst-case time complexity of O(n^2)?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Heap Sort",
      "Quick Sort (random pivot)"
    ]
  },
  {
    "q": "What is the time complexity to access an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is a characteristic of a binary search tree?",
    "c": null,
    "o": [
      "Left subtree contains values less than the node",
      "All nodes have exactly two children",
      "It’s a balanced tree",
      "Values are stored only at the leaves"
    ]
  },
  {
    "q": "Which operation is not allowed directly on Python tuples?",
    "c": null,
    "o": [
      "Item assignment",
      "Indexing",
      "Iteration",
      "Slicing"
    ]
  },
  {
    "q": "Which of the following algorithms is used to detect cycles in a graph?",
    "c": null,
    "o": [
      "Depth First Search",
      "Dijkstra’s Algorithm",
      "Breadth First Search",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is best for implementing LRU (Least Recently Used) cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "List",
      "Tuple"
    ]
  },
  {
    "q": "What is the average time complexity for inserting an element in a Python list at the end?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python module provides support for heaps?",
    "c": null,
    "o": [
      "heapq",
      "collections",
      "queue",
      "bisect"
    ]
  },
  {
    "q": "Which algorithm is typically used in solving the 'knapsack problem'?",
    "c": null,
    "o": [
      "Dynamic Programming",
      "Greedy Algorithm",
      "Depth First Search",
      "Backtracking"
    ]
  },
  {
    "q": "What will be the result of: `set([1, 2, 2, 3])`?",
    "c": null,
    "o": [
      "{1, 2, 3}",
      "[1, 2, 3]",
      "(1, 2, 3)",
      "{1: 1, 2: 2, 3: 3}"
    ]
  },
  {
    "q": "Which sorting algorithm is stable and has O(n log n) worst-case time?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the purpose of `deque` in Python?",
    "c": null,
    "o": [
      "Double-ended queue",
      "A type of dictionary",
      "Sorted list",
      "Unordered collection"
    ]
  },
  {
    "q": "Which of these data structures is used in a recursive algorithm's call stack?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "List",
      "Heap"
    ]
  },
  {
    "q": "Which algorithm finds connected components in a graph?",
    "c": null,
    "o": [
      "Depth First Search",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which method removes and returns the last item from a list in Python?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "del",
      "discard()"
    ]
  },
  {
    "q": "Which of the following has O(1) time complexity for lookup operations in Python?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set (unordered)"
    ]
  },
  {
    "q": "What does the 'bisect' module help with in Python?",
    "c": null,
    "o": [
      "Binary search operations on sorted lists",
      "Heap implementation",
      "Graph traversal",
      "Matrix multiplication"
    ]
  },
  {
    "q": "Which Python built-in function is used to sort a list?",
    "c": null,
    "o": [
      "sorted()",
      "sortlist()",
      "arrange()",
      "order()"
    ]
  },
  {
    "q": "Which data structure allows elements to be added and removed from both ends efficiently?",
    "c": null,
    "o": [
      "deque",
      "stack",
      "queue",
      "dictionary"
    ]
  },
  {
    "q": "What is the space complexity of a recursive Fibonacci function without memoization?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which algorithm is optimal for finding the shortest path in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Depth First Search",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which operation is faster in a set than in a list?",
    "c": null,
    "o": [
      "Membership testing (using 'in')",
      "Indexing by position",
      "Slicing",
      "Appending elements"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Graph",
      "List",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which Python data type maintains the order of items and allows duplicate values?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Dictionary (pre-3.7)",
      "Frozenset"
    ]
  },
  {
    "q": "Which algorithm repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Insertion Sort",
      "Merge Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following Python data structures is immutable?",
    "c": null,
    "o": [
      "Tuple",
      "List",
      "Dictionary",
      "Set"
    ]
  },
  {
    "q": "Which sorting algorithm is based on divide and conquer and has average case time complexity O(n log n)?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which of the following is used to implement a stack in Python?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which data structure can be used to check for balanced parentheses in an expression?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which Python module provides a priority queue implementation?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "collections",
      "bisect"
    ]
  },
  {
    "q": "In which case does the time complexity of binary search become O(log n)?",
    "c": null,
    "o": [
      "When the input list is sorted",
      "When the input list is unsorted",
      "When duplicates are allowed",
      "In worst case only"
    ]
  },
  {
    "q": "Which algorithm always picks the smallest edge that doesn’t form a cycle to construct MST?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which method is used to add an element at the end of a list in Python?",
    "c": null,
    "o": [
      "append()",
      "add()",
      "insert()",
      "extend()"
    ]
  },
  {
    "q": "Which is the best data structure to implement a LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "List",
      "Set",
      "Tuple"
    ]
  },
  {
    "q": "Which of the following data structures allows fast lookup by key?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "Which of these data structures is best for implementing BFS in a graph?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is used in recursive function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "List",
      "Dictionary"
    ]
  },
  {
    "q": "What is the maximum number of nodes in a binary tree of height h?",
    "c": null,
    "o": [
      "2^h - 1",
      "2h",
      "h^2",
      "log h"
    ]
  },
  {
    "q": "Which of the following is a self-balancing binary search tree?",
    "c": null,
    "o": [
      "AVL Tree",
      "Binary Heap",
      "Trie",
      "BFS Tree"
    ]
  },
  {
    "q": "What is the best case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which Python standard module provides tools for working with iterators?",
    "c": null,
    "o": [
      "itertools",
      "collections",
      "functools",
      "array"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a weighted graph with no negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which Python data type is used to represent a fixed-size, immutable sequence of elements?",
    "c": null,
    "o": [
      "Tuple",
      "List",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following data structures does not allow duplicate elements?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python module provides a double-ended queue (deque)?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "array"
    ]
  },
  {
    "q": "Which traversal method visits the left subtree, root, and right subtree in a binary tree?",
    "c": null,
    "o": [
      "In-order",
      "Pre-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which algorithm divides the array into halves recursively to sort it?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which data structure uses FIFO (First-In-First-Out) principle?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Tree"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Graph",
      "Queue",
      "Stack",
      "Array"
    ]
  },
  {
    "q": "Which algorithm is commonly used for cycle detection in a graph?",
    "c": null,
    "o": [
      "Depth First Search",
      "Breadth First Search",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the worst-case time complexity of accessing an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "What is the output of `len(set([1, 2, 2, 3]))` in Python?",
    "c": null,
    "o": [
      "3",
      "4",
      "2",
      "5"
    ]
  },
  {
    "q": "Which sorting algorithm is not comparison-based?",
    "c": null,
    "o": [
      "Counting Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of the following can be used to implement a priority queue in Python?",
    "c": null,
    "o": [
      "heapq",
      "deque",
      "list",
      "set"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a queue?",
    "c": null,
    "o": [
      "Breadth First Search",
      "Depth First Search",
      "Dijkstra's Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm",
      "DFS",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "Which Python data structure maintains the order of insertion (since Python 3.7)?",
    "c": null,
    "o": [
      "dict",
      "set",
      "tuple",
      "frozenset"
    ]
  },
  {
    "q": "What is the time complexity of inserting into a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is not a valid heap type?",
    "c": null,
    "o": [
      "Side Heap",
      "Min Heap",
      "Max Heap",
      "Binary Heap"
    ]
  },
  {
    "q": "What is the time complexity of binary search on a sorted list?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following Python structures is best for implementing LRU Cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "List",
      "Tuple"
    ]
  },
  {
    "q": "What is the average case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which of these is a stable sorting algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Heap Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which data structure is used in DFS traversal of a graph?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Priority Queue"
    ]
  },
  {
    "q": "Which of these is used to find connected components in a graph?",
    "c": null,
    "o": [
      "DFS",
      "Prim's Algorithm",
      "Dijkstra's Algorithm",
      "Binary Search"
    ]
  },
  {
    "q": "Which Python built-in type is best for implementing a simple hash table?",
    "c": null,
    "o": [
      "dict",
      "list",
      "set",
      "tuple"
    ]
  },
  {
    "q": "What is the output of `sorted([3, 1, 2], reverse=True)`?",
    "c": null,
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[2, 3, 1]",
      "[1, 3, 2]"
    ]
  },
  {
    "q": "Which of these algorithms is used for topological sorting?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra",
      "Kruskal"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is ideal for checking matching parentheses in an expression?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "List",
      "Dictionary"
    ]
  },
  {
    "q": "Which sorting algorithm divides the list into sublists that are then merged?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python list by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What data structure can be used to implement a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "List"
    ]
  },
  {
    "q": "Which of the following data structures is not built-in in Python?",
    "c": null,
    "o": [
      "Tree",
      "List",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "Which of the following is true about Python sets?",
    "c": null,
    "o": [
      "They do not allow duplicate elements",
      "They maintain insertion order",
      "They are mutable and ordered",
      "They can contain key-value pairs"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a balanced binary search tree?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following uses a greedy approach?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Merge Sort",
      "Depth First Search"
    ]
  },
  {
    "q": "Which Python module provides an implementation of heaps?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "collections",
      "bisect"
    ]
  },
  {
    "q": "Which of the following can be used to implement an adjacency list in Python?",
    "c": null,
    "o": [
      "Dictionary of lists",
      "Tuple of tuples",
      "List of sets",
      "Set of tuples"
    ]
  },
  {
    "q": "Which Python collection is best for counting frequency of items?",
    "c": null,
    "o": [
      "Counter from collections",
      "List",
      "Set",
      "Tuple"
    ]
  },
  {
    "q": "What is the average time complexity of inserting an element into a Python set?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a weighted graph without negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Graph",
      "Queue",
      "Stack",
      "List"
    ]
  },
  {
    "q": "What is the result of len({1, 2, 2, 3}) in Python?",
    "c": null,
    "o": [
      "3",
      "4",
      "2",
      "Error"
    ]
  },
  {
    "q": "Which sorting algorithm is generally the fastest on average for large datasets?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the time complexity to delete the last element from a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure follows First-In-First-Out (FIFO)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "Which module in Python offers a double-ended queue?",
    "c": null,
    "o": [
      "collections",
      "queue",
      "heapq",
      "array"
    ]
  },
  {
    "q": "Which data structure is most suitable for recursive function calls?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which traversal method uses a queue internally?",
    "c": null,
    "o": [
      "Breadth First Search",
      "Depth First Search",
      "Inorder Traversal",
      "Postorder Traversal"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing undo functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Graph"
    ]
  },
  {
    "q": "Which Python built-in function returns a sorted version of any iterable?",
    "c": null,
    "o": [
      "sorted()",
      "sort()",
      "order()",
      "arrange()"
    ]
  },
  {
    "q": "What is the maximum number of edges in a simple undirected graph with n vertices?",
    "c": null,
    "o": [
      "n(n-1)/2",
      "n(n+1)/2",
      "n",
      "n-1"
    ]
  },
  {
    "q": "Which of the following is a divide-and-conquer algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which algorithm is suitable for detecting cycles in a directed graph?",
    "c": null,
    "o": [
      "Depth First Search",
      "Breadth First Search",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of the following operations is the most expensive in a singly linked list?",
    "c": null,
    "o": [
      "Deleting the last node",
      "Inserting at the beginning",
      "Traversing the list",
      "Inserting at the end"
    ]
  },
  {
    "q": "Which Python data type allows key-value pair storage?",
    "c": null,
    "o": [
      "Dictionary",
      "Tuple",
      "List",
      "Set"
    ]
  },
  {
    "q": "Which tree traversal visits nodes in the order: left subtree, root, right subtree?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level Order"
    ]
  },
  {
    "q": "Which Python module provides a heap implementation?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "collections",
      "array"
    ]
  },
  {
    "q": "Which of the following data structures does not allow duplicate elements?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which of the following algorithms is used to find the shortest path in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which of these data structures is best suited for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "What is the worst-case time complexity of quicksort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which of the following operations has the highest time complexity in a hash table?",
    "c": null,
    "o": [
      "Rehashing",
      "Searching",
      "Insertion",
      "Deletion"
    ]
  },
  {
    "q": "Which traversal is used to get the contents of a binary search tree in sorted order?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following is NOT a stable sorting algorithm?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is used in breadth-first search (BFS)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Heap"
    ]
  },
  {
    "q": "Which built-in Python function is used to get the length of a list?",
    "c": null,
    "o": [
      "len()",
      "length()",
      "count()",
      "size()"
    ]
  },
  {
    "q": "Which of the following statements about Python tuples is true?",
    "c": null,
    "o": [
      "They are immutable",
      "They are dynamic",
      "They allow duplicate keys",
      "They consume more memory than lists"
    ]
  },
  {
    "q": "Which data structure is commonly used for implementing LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "Heap",
      "Queue"
    ]
  },
  {
    "q": "What is the average-case time complexity for searching in a Binary Search Tree (BST)?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm is most efficient for nearly sorted arrays?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Bubble Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which data structure supports First-In-First-Out (FIFO) principle?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Set"
    ]
  },
  {
    "q": "Which function is used to add an element at the end of a Python list?",
    "c": null,
    "o": [
      "append()",
      "insert()",
      "add()",
      "extend()"
    ]
  },
  {
    "q": "Which of the following is true about Python sets?",
    "c": null,
    "o": [
      "They do not allow duplicate elements",
      "They maintain insertion order",
      "They are mutable and ordered",
      "They allow indexing"
    ]
  },
  {
    "q": "Which traversal is used to delete a tree safely?",
    "c": null,
    "o": [
      "Postorder",
      "Inorder",
      "Preorder",
      "Level-order"
    ]
  },
  {
    "q": "Which method can be used to sort a list in-place in Python?",
    "c": null,
    "o": [
      "list.sort()",
      "sorted(list)",
      "list.sorted()",
      "sort(list)"
    ]
  },
  {
    "q": "Which of the following is not a linear data structure?",
    "c": null,
    "o": [
      "Graph",
      "Stack",
      "Queue",
      "Array"
    ]
  },
  {
    "q": "Which algorithm technique does Merge Sort use?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy",
      "Backtracking",
      "Dynamic Programming"
    ]
  },
  {
    "q": "Which Python module provides a heap queue algorithm?",
    "c": null,
    "o": [
      "heapq",
      "queue",
      "deque",
      "bisect"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is true about tuples in Python?",
    "c": null,
    "o": [
      "They are immutable",
      "They are mutable",
      "They are unordered",
      "They support item deletion"
    ]
  },
  {
    "q": "Which Python data type is best for implementing a priority queue?",
    "c": null,
    "o": [
      "heapq",
      "set",
      "list",
      "dict"
    ]
  },
  {
    "q": "What is the maximum number of nodes in a binary tree of height h?",
    "c": null,
    "o": [
      "2^h - 1",
      "h^2",
      "2*h",
      "h!"
    ]
  },
  {
    "q": "Which of the following is used for fast membership testing?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary values"
    ]
  },
  {
    "q": "Which data structure is ideal for checking balanced parentheses in an expression?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Set",
      "Graph"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a hash table?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these can be used as keys in a Python dictionary?",
    "c": null,
    "o": [
      "Immutable types",
      "Lists",
      "Sets",
      "All types"
    ]
  },
  {
    "q": "Which of the following algorithms is not comparison-based?",
    "c": null,
    "o": [
      "Counting Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average-case time complexity among the following?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which Python standard library module supports double-ended queues?",
    "c": null,
    "o": [
      "collections",
      "heapq",
      "queue",
      "array"
    ]
  },
  {
    "q": "Which of the following data structures is most suitable for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "List",
      "Set"
    ]
  },
  {
    "q": "Which algorithm technique does Merge Sort follow?",
    "c": null,
    "o": [
      "Divide and Conquer",
      "Greedy",
      "Backtracking",
      "Dynamic Programming"
    ]
  },
  {
    "q": "In a binary search tree, what is the time complexity of finding the maximum value?",
    "c": null,
    "o": [
      "O(h)",
      "O(log n)",
      "O(n)",
      "O(1)"
    ]
  },
  {
    "q": "What does the `bisect` module in Python help with?",
    "c": null,
    "o": [
      "Maintaining a list in sorted order",
      "Splitting strings",
      "Dividing numbers",
      "Creating binary trees"
    ]
  },
  {
    "q": "Which of the following statements about Python sets is true?",
    "c": null,
    "o": [
      "They do not allow duplicates",
      "They maintain insertion order",
      "They are indexable",
      "They are sorted by default"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding the shortest path in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which of the following is a mutable data structure in Python?",
    "c": null,
    "o": [
      "List",
      "Tuple",
      "String",
      "frozenset"
    ]
  },
  {
    "q": "Which of the following is not a valid time complexity of a sorting algorithm?",
    "c": null,
    "o": [
      "O(n^3)",
      "O(log n)",
      "O(n log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element by index in a Python list?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following data structures is implemented as a dynamic array in Python?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Tuple",
      "Dict"
    ]
  },
  {
    "q": "Which method is used to insert an element at the end of a Python list?",
    "c": null,
    "o": [
      "append()",
      "insert()",
      "extend()",
      "add()"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which heap type is used to implement a priority queue in Python's `heapq` module?",
    "c": null,
    "o": [
      "Min heap",
      "Max heap",
      "Binary search tree",
      "AVL tree"
    ]
  },
  {
    "q": "Which algorithm is typically used for cycle detection in a graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s algorithm",
      "Kruskal’s algorithm",
      "Topological sort"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing LRU cache?",
    "c": null,
    "o": [
      "OrderedDict",
      "Set",
      "List",
      "Tuple"
    ]
  },
  {
    "q": "Which of the following can be used to ensure constant time complexity for lookup in Python?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Deque"
    ]
  },
  {
    "q": "Which traversal method is used in Depth First Search?",
    "c": null,
    "o": [
      "Stack-based traversal",
      "Queue-based traversal",
      "Level order traversal",
      "None of the above"
    ]
  },
  {
    "q": "Which built-in Python function returns the length of a list?",
    "c": null,
    "o": [
      "len()",
      "length()",
      "size()",
      "count()"
    ]
  },
  {
    "q": "What does the `pop()` method do in a Python list?",
    "c": null,
    "o": [
      "Removes and returns the last element",
      "Adds an element to the end",
      "Removes all elements",
      "Sorts the list"
    ]
  },
  {
    "q": "Which algorithm is guaranteed to find the shortest path in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s algorithm",
      "Depth First Search",
      "Breadth First Search",
      "Bellman-Ford algorithm"
    ]
  },
  {
    "q": "What is the output of `len({1, 2, 2, 3})` in Python?",
    "c": null,
    "o": [
      "3",
      "4",
      "2",
      "Error"
    ]
  },
  {
    "q": "Which Python collection does not allow duplicate elements?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which sorting algorithm is stable and has O(n log n) time complexity in the worst case?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which function is used to reverse a list in-place in Python?",
    "c": null,
    "o": [
      "reverse()",
      "reversed()",
      "invert()",
      "flip()"
    ]
  },
  {
    "q": "Which data structure works on the principle of FIFO?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "What is the space complexity of Depth First Search?",
    "c": null,
    "o": [
      "O(h) where h is the depth of the tree",
      "O(1)",
      "O(n^2)",
      "O(n log n)"
    ]
  },
  {
    "q": "What will be the result of `sorted([3, 1, 4, 2])`?",
    "c": null,
    "o": [
      "[1, 2, 3, 4]",
      "[4, 3, 2, 1]",
      "[3, 1, 4, 2]",
      "Error"
    ]
  },
  {
    "q": "Which data structure uses hashing for storage and lookup?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Queue"
    ]
  },
  {
    "q": "Which of the following operations is the fastest in a Python dictionary?",
    "c": null,
    "o": [
      "Lookup by key",
      "Insertion at the end",
      "Deletion by index",
      "Sorting keys"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python list by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following can be used as a key in a Python dictionary?",
    "c": null,
    "o": [
      "Tuple",
      "List",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "What is the worst-case time complexity of inserting an element into a Python set?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which algorithm is typically used for cycle detection in graphs?",
    "c": null,
    "o": [
      "Depth First Search",
      "Dijkstra's Algorithm",
      "Prim's Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "Which of the following data structures allows duplicate elements?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Dictionary keys",
      "All of the above"
    ]
  },
  {
    "q": "What will be the output of `set('hello')` in Python?",
    "c": null,
    "o": [
      "{'h', 'e', 'l', 'o'}",
      "{'hello'}",
      "{['h', 'e', 'l', 'l', 'o']}",
      "['h', 'e', 'l', 'o']"
    ]
  },
  {
    "q": "Which algorithm is based on the divide and conquer approach?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Linear Search"
    ]
  },
  {
    "q": "What does the `heapq` module in Python provide?",
    "c": null,
    "o": [
      "Heap queue algorithms",
      "Graph traversal",
      "Sorting large datasets",
      "Data encryption"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing undo functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "List",
      "Tree"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average-case performance?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which of the following is true about Python's `deque` from the `collections` module?",
    "c": null,
    "o": [
      "It supports fast appends and pops from both ends",
      "It only allows insertion at the end",
      "It is slower than a list",
      "It cannot be used as a stack"
    ]
  },
  {
    "q": "Which algorithm is typically used to find the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "Breadth First Search",
      "Depth First Search",
      "Dijkstra's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "In a binary search tree (BST), what is the time complexity of searching for an element in the average case?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following data structures uses the First-In-First-Out (FIFO) principle?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Tree"
    ]
  },
  {
    "q": "Which of the following operations is not supported by Python sets?",
    "c": null,
    "o": [
      "Indexing",
      "Union",
      "Intersection",
      "Difference"
    ]
  },
  {
    "q": "What is the maximum number of children a node can have in a binary tree?",
    "c": null,
    "o": [
      "2",
      "1",
      "3",
      "Any number"
    ]
  },
  {
    "q": "Which data structure is best for implementing a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Set"
    ]
  },
  {
    "q": "What does the `bisect` module in Python provide?",
    "c": null,
    "o": [
      "Binary search operations",
      "Sorting utilities",
      "Tree-based algorithms",
      "Hashing functions"
    ]
  },
  {
    "q": "Which traversal method processes the root node before its subtrees in a tree?",
    "c": null,
    "o": [
      "Preorder",
      "Inorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which of the following is used to implement recursion internally in Python?",
    "c": null,
    "o": [
      "Call Stack",
      "Queue",
      "Linked List",
      "Heap"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python list by index?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python module provides functions for working with heaps?",
    "c": null,
    "o": [
      "heapq",
      "priorityq",
      "bisect",
      "collections"
    ]
  },
  {
    "q": "Which traversal of a binary search tree (BST) returns the values in sorted order?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level-order"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing undo functionality?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "In Python, which data structure is ordered, mutable, and allows duplicate elements?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Dictionary",
      "Tuple"
    ]
  },
  {
    "q": "Which graph algorithm is used for cycle detection in a directed graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm is used to find a Minimum Spanning Tree?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS",
      "DFS"
    ]
  },
  {
    "q": "What is the space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following has the highest priority in a max heap?",
    "c": null,
    "o": [
      "Root node",
      "Leaf node",
      "Leftmost node",
      "Rightmost node"
    ]
  },
  {
    "q": "Which of the following data structures provides O(1) time complexity for insertion, deletion, and lookup in average case?",
    "c": null,
    "o": [
      "Hash Table",
      "Array",
      "Linked List",
      "Binary Search Tree"
    ]
  },
  {
    "q": "Which of the following algorithms is used to find the shortest path in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which built-in Python data type is best suited to implement a queue?",
    "c": null,
    "o": [
      "deque from collections",
      "list",
      "set",
      "tuple"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which sorting algorithm is stable and works in O(n^2) time complexity?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Selection Sort",
      "Heap Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following can be used to implement a graph in Python?",
    "c": null,
    "o": [
      "Dictionary of lists",
      "Set of sets",
      "List of sets",
      "Tuple of lists"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element into a binary search tree (BST) on average?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following is a non-linear data structure?",
    "c": null,
    "o": [
      "Tree",
      "List",
      "Tuple",
      "Dictionary"
    ]
  },
  {
    "q": "Which Python module provides tools for working with permutations and combinations?",
    "c": null,
    "o": [
      "itertools",
      "functools",
      "collections",
      "math"
    ]
  },
  {
    "q": "Which technique is used in dynamic programming to avoid recomputation of overlapping subproblems?",
    "c": null,
    "o": [
      "Memoization",
      "Recursion",
      "Backtracking",
      "Greedy method"
    ]
  },
  {
    "q": "Which data structure is typically used for implementing recursion?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "What is the purpose of the `heapq` module in Python?",
    "c": null,
    "o": [
      "Implement priority queues using heaps",
      "Sort strings",
      "Work with binary search trees",
      "Implement hash tables"
    ]
  },
  {
    "q": "Which of the following is a property of a min-heap?",
    "c": null,
    "o": [
      "Parent is always less than or equal to its children",
      "Parent is always greater than its children",
      "Tree is always complete and sorted",
      "Leaf nodes are always smaller than root"
    ]
  },
  {
    "q": "Which of these sorting algorithms has the best average case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What does the `bisect` module in Python provide?",
    "c": null,
    "o": [
      "Binary search utilities for sorted lists",
      "Bit manipulation functions",
      "Matrix operations",
      "Sorting algorithms"
    ]
  },
  {
    "q": "Which data structure uses LIFO (Last In First Out) principle?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Tree",
      "Graph"
    ]
  },
  {
    "q": "In which algorithm is the pivot element used to partition the array?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of the following is an application of the BFS algorithm?",
    "c": null,
    "o": [
      "Finding shortest path in an unweighted graph",
      "Evaluating arithmetic expressions",
      "Topological sorting",
      "Solving mazes with weighted paths"
    ]
  },
  {
    "q": "Which of the following Python types maintains the insertion order as of Python 3.7+?",
    "c": null,
    "o": [
      "dict",
      "set",
      "frozenset",
      "tuple"
    ]
  },
  {
    "q": "What is the worst-case time complexity of searching in a hash table?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following data structures is best suited for implementing a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "What will `collections.deque` provide that a list does not perform efficiently?",
    "c": null,
    "o": [
      "Fast append and pop from both ends",
      "Sorting",
      "In-place reversal",
      "Random access"
    ]
  },
  {
    "q": "Which traversal method is used in depth-first search (DFS)?",
    "c": null,
    "o": [
      "Preorder",
      "Breadth-order",
      "Level-order",
      "Heap-order"
    ]
  },
  {
    "q": "Which of the following algorithms uses a divide-and-conquer strategy?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Linear Search"
    ]
  },
  {
    "q": "What is the average-case time complexity of searching in a binary search tree (BST)?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following data structures allows duplicate elements?",
    "c": null,
    "o": [
      "List",
      "Set",
      "Dictionary keys",
      "None of the above"
    ]
  },
  {
    "q": "Which built-in function returns the number of elements in a list in Python?",
    "c": null,
    "o": [
      "len()",
      "count()",
      "size()",
      "length()"
    ]
  },
  {
    "q": "Which sorting algorithm is generally considered the fastest for small datasets in Python?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of the following is not a built-in data structure in Python?",
    "c": null,
    "o": [
      "Tree",
      "Set",
      "List",
      "Dictionary"
    ]
  },
  {
    "q": "Which graph algorithm is used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s algorithm",
      "Dijkstra’s algorithm"
    ]
  },
  {
    "q": "Which of the following is a mutable data type in Python?",
    "c": null,
    "o": [
      "List",
      "Tuple",
      "String",
      "Integer"
    ]
  },
  {
    "q": "Which data structure uses LIFO (Last In First Out) principle?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Tree"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path in a weighted graph?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "DFS",
      "BFS",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing a recursive algorithm?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Set",
      "Heap"
    ]
  },
  {
    "q": "Which of the following is used to remove duplicates from a list?",
    "c": null,
    "o": [
      "set()",
      "dict()",
      "list()",
      "tuple()"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which data structure is used in Breadth First Search (BFS)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "In Python, what does `dict.get(key, default)` do?",
    "c": null,
    "o": [
      "Returns the value for key if it exists, else returns default",
      "Deletes the key if it exists",
      "Adds a new key with default value",
      "Raises KeyError if key not found"
    ]
  },
  {
    "q": "Which sorting algorithm is stable and has O(n log n) time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which built-in Python module supports heap operations?",
    "c": null,
    "o": [
      "heapq",
      "collections",
      "bisect",
      "queue"
    ]
  },
  {
    "q": "Which of these is the correct way to declare a set in Python?",
    "c": null,
    "o": [
      "{1, 2, 3}",
      "[1, 2, 3]",
      "(1, 2, 3)",
      "{\"1\": 1, \"2\": 2}"
    ]
  },
  {
    "q": "Which algorithm is used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with visited and recursion stack",
      "BFS only",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the output of `sorted([3, 1, 2], reverse=True)`?",
    "c": null,
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[2, 1, 3]",
      "[3, 1, 2]"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element in a Python dictionary?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is best suited for implementing a priority queue?",
    "c": null,
    "o": [
      "Heap",
      "Stack",
      "Queue",
      "Linked List"
    ]
  },
  {
    "q": "Which function is used to insert an element at a specific index in a list?",
    "c": null,
    "o": [
      "insert()",
      "append()",
      "add()",
      "extend()"
    ]
  },
  {
    "q": "What will be the output of `list('abc')`?",
    "c": null,
    "o": [
      "['a', 'b', 'c']",
      "['abc']",
      "('a', 'b', 'c')",
      "{'a', 'b', 'c'}"
    ]
  },
  {
    "q": "Which traversal of a binary search tree gives the elements in sorted order?",
    "c": null,
    "o": [
      "Inorder",
      "Preorder",
      "Postorder",
      "Level Order"
    ]
  },
  {
    "q": "Which of the following operations is not allowed on a tuple?",
    "c": null,
    "o": [
      "append()",
      "count()",
      "index()",
      "len()"
    ]
  },
  {
    "q": "What is the default data structure used by the `deque` object from `collections`?",
    "c": null,
    "o": [
      "Double-ended queue",
      "Stack",
      "Heap",
      "Queue"
    ]
  },
  {
    "q": "Which method removes and returns the last element from a list in Python?",
    "c": null,
    "o": [
      "pop()",
      "remove()",
      "del",
      "discard()"
    ]
  },
  {
    "q": "Which of the following is the correct time complexity for binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which sorting algorithm is the fastest in average case among these?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What does the `heapq` module in Python implement?",
    "c": null,
    "o": [
      "Min-Heap",
      "Max-Heap",
      "Binary Search Tree",
      "Priority Queue using list"
    ]
  },
  {
    "q": "Which data structure follows First-In-First-Out (FIFO)?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Tree",
      "Set"
    ]
  },
  {
    "q": "What will `my_list = [1, 2, 3]; my_list[1:2] = [7, 8]` produce?",
    "c": null,
    "o": [
      "[1, 7, 8, 3]",
      "[1, 2, 3, 7, 8]",
      "[1, 7, 8, 2, 3]",
      "[7, 8]"
    ]
  },
  {
    "q": "What does `set.intersection(set1, set2)` do?",
    "c": null,
    "o": [
      "Returns common elements in both sets",
      "Returns all unique elements",
      "Returns elements in set1 but not in set2",
      "Returns True if sets are disjoint"
    ]
  },
  {
    "q": "Which of the following is not a built-in Python data structure?",
    "c": null,
    "o": [
      "Tree",
      "Set",
      "Tuple",
      "List"
    ]
  },
  {
    "q": "Which function is used to find the length of a list?",
    "c": null,
    "o": [
      "len()",
      "length()",
      "size()",
      "count()"
    ]
  },
  {
    "q": "What is the output of `len({'a':1, 'b':2, 'c':3})`?",
    "c": null,
    "o": [
      "3",
      "6",
      "2",
      "1"
    ]
  },
  {
    "q": "Which data structure uses LIFO (Last-In-First-Out) ordering?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Linked List",
      "Tree"
    ]
  },
  {
    "q": "What is the time complexity of inserting an element at the beginning of a Python list?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which method is used to add a new element to the end of a list?",
    "c": null,
    "o": [
      "append()",
      "insert()",
      "extend()",
      "add()"
    ]
  },
  {
    "q": "Which of the following operations is not supported by Python sets?",
    "c": null,
    "o": [
      "Indexing",
      "Union",
      "Intersection",
      "Difference"
    ]
  },
  {
    "q": "Which of these data structures guarantees unique elements?",
    "c": null,
    "o": [
      "Set",
      "List",
      "Tuple",
      "Stack"
    ]
  },
  {
    "q": "Which of the following is a property of a binary search tree?",
    "c": null,
    "o": [
      "Left child < parent < right child",
      "Parent < left child < right child",
      "Parent > left child > right child",
      "Left child == right child"
    ]
  },
  {
    "q": "Which of these algorithms is used for finding the shortest path in a graph?",
    "c": null,
    "o": [
      "Dijkstra's Algorithm",
      "DFS",
      "Prim's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "In which data structure are elements stored as key-value pairs?",
    "c": null,
    "o": [
      "Dictionary",
      "List",
      "Tuple",
      "Set"
    ]
  },
  {
    "q": "Which sorting algorithm is stable and has O(n log n) worst-case complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which built-in function returns the largest item in an iterable?",
    "c": null,
    "o": [
      "max()",
      "largest()",
      "top()",
      "biggest()"
    ]
  }
]