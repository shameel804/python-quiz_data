[
  {
    "q": "Which traversal uses a queue data structure in its implementation?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "What data structure is typically used to implement DFS?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Min-Heap",
      "Priority Queue"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path from a single source to all other nodes in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which of the following algorithms is a Greedy algorithm for finding the Minimum Spanning Tree using edge sorting?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms uses a priority queue (min-heap) to select the next vertex with the smallest edge weight?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which of the following best describes BFS traversal?",
    "c": null,
    "o": [
      "Level-order traversal from the starting node",
      "Depth-first exploration of paths",
      "Random exploration of nodes",
      "Shortest-path traversal in all graphs"
    ]
  },
  {
    "q": "Which of the following algorithms does NOT guarantee the shortest path in graphs with negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "None of the above"
    ]
  },
  {
    "q": "What is the time complexity of DFS in a graph with V vertices and E edges?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(VE)"
    ]
  },
  {
    "q": "In Kruskal’s Algorithm, what is the key operation to avoid cycles?",
    "c": null,
    "o": [
      "Union-Find (Disjoint Set)",
      "Priority Queue",
      "Recursion",
      "Backtracking"
    ]
  },
  {
    "q": "Which of the following code snippets correctly represents a basic DFS traversal in Python?",
    "c": "graph = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1]}\nvisited = set()\n\ndef dfs(v):\n    if v not in visited:\n        print(v)\n        visited.add(v)\n        for neighbor in graph[v]:\n            dfs(neighbor)\n\ndfs(0)",
    "o": [
      "0 1 3 2",
      "0 2 1 3",
      "3 1 0 2",
      "1 0 2 3"
    ]
  },
  {
    "q": "What is the key difference between DFS and BFS in terms of the data structure used?",
    "c": null,
    "o": [
      "DFS uses a stack, BFS uses a queue",
      "DFS uses a queue, BFS uses a stack",
      "Both use stacks",
      "Both use queues"
    ]
  },
  {
    "q": "Which algorithm is more suitable for finding the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra's Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "q": "In Prim’s algorithm, which data structure is typically used to select the next minimum-weight edge efficiently?",
    "c": null,
    "o": [
      "Min-Heap (Priority Queue)",
      "Disjoint Set",
      "Queue",
      "Stack"
    ]
  },
  {
    "q": "What happens in Kruskal’s algorithm if we don’t use a union-find data structure?",
    "c": null,
    "o": [
      "We cannot efficiently check for cycles",
      "It runs faster",
      "It will perform DFS automatically",
      "It converts to Prim’s algorithm"
    ]
  },
  {
    "q": "Which condition must a graph satisfy for Dijkstra’s algorithm to work correctly?",
    "c": null,
    "o": [
      "All edge weights must be non-negative",
      "Graph must be connected",
      "Graph must be directed",
      "Graph must be unweighted"
    ]
  },
  {
    "q": "Which of the following represents the first step in Kruskal's Algorithm?",
    "c": null,
    "o": [
      "Sort all edges by weight",
      "Pick a random starting node",
      "Build adjacency matrix",
      "Initialize all nodes as visited"
    ]
  },
  {
    "q": "In a connected undirected graph, how many edges are there in the Minimum Spanning Tree with N nodes?",
    "c": null,
    "o": [
      "N - 1",
      "N",
      "N + 1",
      "2N - 1"
    ]
  },
  {
    "q": "Which algorithm is guaranteed to work on disconnected graphs for finding a Minimum Spanning Forest?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which of the following code snippets performs BFS traversal on a graph?",
    "c": "from collections import deque\n\ngraph = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1]}\nvisited = set()\nqueue = deque([0])\n\nwhile queue:\n    node = queue.popleft()\n    if node not in visited:\n        print(node)\n        visited.add(node)\n        queue.extend(graph[node])",
    "o": [
      "0 1 2 3",
      "0 2 1 3",
      "3 1 0 2",
      "0 3 2 1"
    ]
  },
  {
    "q": "Which of the following algorithms can be used to detect cycles in an undirected graph?",
    "c": null,
    "o": [
      "DFS with parent tracking",
      "BFS with topological sorting",
      "Dijkstra's Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms can be applied to both directed and undirected graphs?",
    "c": null,
    "o": [
      "DFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Topological Sort"
    ]
  },
  {
    "q": "Which of the following is true about DFS traversal?",
    "c": null,
    "o": [
      "It may not visit all nodes in a disconnected graph",
      "It always visits the shortest path first",
      "It guarantees a minimum spanning tree",
      "It uses a queue to manage nodes"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what happens if we use a regular queue instead of a priority queue?",
    "c": null,
    "o": [
      "It may not give the correct shortest paths",
      "It will run faster",
      "It will behave like Prim’s algorithm",
      "No difference, result remains same"
    ]
  },
  {
    "q": "Which algorithm is more efficient in sparse graphs for computing MST?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm with adjacency matrix",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following operations is critical in Prim's algorithm?",
    "c": null,
    "o": [
      "Extracting the minimum weight edge connected to the MST",
      "Sorting all edges initially",
      "Union of disjoint sets",
      "Cycle detection"
    ]
  },
  {
    "q": "Which condition ensures Kruskal’s algorithm produces a valid MST?",
    "c": null,
    "o": [
      "Graph is connected and undirected",
      "Graph is directed",
      "Graph has all equal weight edges",
      "Graph is acyclic"
    ]
  },
  {
    "q": "Which algorithm can be modified to find all paths from source to target in a graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "Which of the following is NOT used in Kruskal's algorithm?",
    "c": null,
    "o": [
      "Adjacency list",
      "Edge list",
      "Sorting edges",
      "Disjoint Set"
    ]
  },
  {
    "q": "Which statement about BFS is correct?",
    "c": null,
    "o": [
      "BFS finds the shortest path in unweighted graphs",
      "BFS uses recursion",
      "BFS works only in trees",
      "BFS uses disjoint sets"
    ]
  },
  {
    "q": "Which of the following correctly initializes a visited dictionary for all nodes in a graph with 5 nodes (0 to 4)?",
    "c": "visited = {i: False for i in range(5)}",
    "o": [
      "visited = {i: False for i in range(5)}",
      "visited = [False] * 5",
      "visited = dict(0,1,2,3,4)",
      "visited = range(5)"
    ]
  },
  {
    "q": "Which algorithm is most suitable for traversing or searching tree or graph data structures recursively?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Dijkstra’s algorithm using a binary heap?",
    "c": null,
    "o": [
      "O((V + E) log V)",
      "O(V^2)",
      "O(E^2)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which technique is used in Prim’s algorithm to avoid revisiting nodes?",
    "c": null,
    "o": [
      "Visited set or array",
      "Parent pointer tracking",
      "Backtracking",
      "Recursion"
    ]
  },
  {
    "q": "Which of the following is a property of a Minimum Spanning Tree?",
    "c": null,
    "o": [
      "It connects all vertices with minimum total edge weight",
      "It always includes the heaviest edge",
      "It contains cycles",
      "It only exists for directed graphs"
    ]
  },
  {
    "q": "Which of the following is true about the edge list used in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "It is sorted by weight",
      "It contains only edges with odd weights",
      "It ignores duplicate edges",
      "It uses a queue instead of a list"
    ]
  },
  {
    "q": "Which graph algorithm is not suitable for graphs with negative weight edges?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "BFS",
      "DFS"
    ]
  },
  {
    "q": "What is the output of the following code snippet using DFS?",
    "c": "graph = {0: [1, 2], 1: [3], 2: [], 3: []}\nvisited = []\n\ndef dfs(node):\n    if node not in visited:\n        visited.append(node)\n        for n in graph[node]:\n            dfs(n)\ndfs(0)\nprint(visited)",
    "o": [
      "[0, 1, 3, 2]",
      "[0, 2, 1, 3]",
      "[0, 1, 2, 3]",
      "[0, 3, 1, 2]"
    ]
  },
  {
    "q": "Which algorithm updates distances of all adjacent vertices of a selected vertex?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "Which data structure helps efficiently manage connected components in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Disjoint Set (Union-Find)",
      "Heap",
      "Queue",
      "Adjacency Matrix"
    ]
  },
  {
    "q": "What does DFS traversal follow?",
    "c": null,
    "o": [
      "Path as deep as possible before backtracking",
      "Level-by-level traversal",
      "Shortest weighted path",
      "Cycle detection first"
    ]
  },
  {
    "q": "What is the output of the following BFS code on the given graph?",
    "c": "from collections import deque\n\ngraph = {0: [1, 2], 1: [3], 2: [4], 3: [], 4: []}\nvisited = []\nqueue = deque([0])\n\nwhile queue:\n    node = queue.popleft()\n    if node not in visited:\n        visited.append(node)\n        queue.extend(graph[node])\nprint(visited)",
    "o": [
      "[0, 1, 2, 3, 4]",
      "[0, 2, 1, 4, 3]",
      "[0, 1, 3, 2, 4]",
      "[0, 3, 1, 2, 4]"
    ]
  },
  {
    "q": "In which of the following algorithms are all edges of the graph considered and sorted by weight?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which traversal algorithm is more likely to be used for solving puzzles with only one solution path?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which algorithm is best suited for finding shortest paths from a source vertex in a graph with negative edge weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which of the following conditions may cause Dijkstra's algorithm to fail?",
    "c": null,
    "o": [
      "Presence of negative edge weights",
      "Disconnected graph",
      "Directed edges",
      "Use of adjacency list"
    ]
  },
  {
    "q": "Which algorithm builds the MST by starting from any node and adding the smallest edge to the tree at each step?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is used to implement a priority queue in Dijkstra’s and Prim’s algorithms?",
    "c": null,
    "o": [
      "Min-Heap",
      "Max-Heap",
      "Stack",
      "Deque"
    ]
  },
  {
    "q": "Which of the following statements is true about BFS traversal?",
    "c": null,
    "o": [
      "It visits nodes level by level",
      "It uses recursion",
      "It backtracks when stuck",
      "It always finds the MST"
    ]
  },
  {
    "q": "Which of the following algorithms guarantees no cycles in the result?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "In Kruskal’s algorithm, what is the first thing you do after sorting all edges?",
    "c": null,
    "o": [
      "Add edges one by one, checking for cycles",
      "Select a random starting vertex",
      "Build a heap of all edges",
      "Initialize visited array"
    ]
  },
  {
    "q": "Which of the following operations is common in both Dijkstra’s and Prim’s algorithm?",
    "c": null,
    "o": [
      "Selecting the minimum weight edge using a priority queue",
      "Sorting all edges before starting",
      "Cycle detection using union-find",
      "Pushing all nodes into a stack"
    ]
  },
  {
    "q": "What is the primary use of DFS in graph theory?",
    "c": null,
    "o": [
      "Cycle detection",
      "Finding shortest path",
      "Minimum spanning tree",
      "Graph coloring"
    ]
  },
  {
    "q": "What does BFS guarantee when used on an unweighted graph?",
    "c": null,
    "o": [
      "Shortest path in terms of number of edges",
      "Minimum cost path",
      "Longest path",
      "Random traversal"
    ]
  },
  {
    "q": "In which of the following cases will DFS visit all nodes?",
    "c": null,
    "o": [
      "When the graph is connected",
      "Only in trees",
      "When graph has no cycles",
      "When starting node has only one neighbor"
    ]
  },
  {
    "q": "Which of the following correctly describes the greedy choice in Kruskal's algorithm?",
    "c": null,
    "o": [
      "Choose the edge with the smallest weight that doesn't form a cycle",
      "Choose the first edge of each vertex",
      "Choose the shortest path from the source",
      "Choose all edges with minimum weight first"
    ]
  },
  {
    "q": "Which graph representation is better for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Edge Matrix",
      "Incidence Matrix"
    ]
  },
  {
    "q": "Which of the following is an output of Prim’s algorithm?",
    "c": null,
    "o": [
      "Minimum Spanning Tree",
      "Shortest Path Tree",
      "Eulerian Path",
      "Cycle Detection"
    ]
  },
  {
    "q": "What is the main goal of Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Find shortest paths from a source to all other vertices",
      "Detect cycles",
      "Find a spanning tree",
      "Traverse all vertices"
    ]
  },
  {
    "q": "Which of these graph algorithms always results in a tree structure?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which of the following correctly initializes the priority queue in Dijkstra’s algorithm?",
    "c": "import heapq\n\npq = []\nheapq.heappush(pq, (0, source))",
    "o": [
      "heapq.heappush(pq, (0, source))",
      "pq = [source, 0]",
      "heapq.heappush(pq, source)",
      "heapq.heappush(pq, 0)"
    ]
  },
  {
    "q": "Which graph traversal method is preferred when the solution is closer to the root?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms can work correctly even if the graph is disconnected?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which algorithm is most appropriate for finding a spanning tree with minimal total edge weight in a connected graph?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "BFS",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which structure is essential for checking whether adding an edge in Kruskal's algorithm forms a cycle?",
    "c": null,
    "o": [
      "Disjoint Set Union (Union-Find)",
      "Stack",
      "Queue",
      "Adjacency Matrix"
    ]
  },
  {
    "q": "Which algorithm maintains a set of visited vertices and grows the MST one vertex at a time?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "What is the best case time complexity of DFS traversal in a graph with V vertices and E edges?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V)",
      "O(V log V)",
      "O(E^2)"
    ]
  },
  {
    "q": "Which of the following is a valid output order for DFS on a binary tree starting at root 1?",
    "c": "        1\n       / \\\n      2   3\n     / \\\n    4   5",
    "o": [
      "1 2 4 5 3",
      "1 3 2 5 4",
      "1 2 3 4 5",
      "1 4 2 5 3"
    ]
  },
  {
    "q": "What is the key reason Prim’s algorithm is not as efficient on sparse graphs using an adjacency matrix?",
    "c": null,
    "o": [
      "Inefficient edge scanning",
      "Too many recursive calls",
      "Too much sorting overhead",
      "Stack overflow"
    ]
  },
  {
    "q": "Which step ensures that Dijkstra’s algorithm doesn't revisit the same node with a longer path?",
    "c": null,
    "o": [
      "Mark node as visited after shortest path is found",
      "Use DFS before adding to heap",
      "Sort all vertices beforehand",
      "Recalculate heap on each iteration"
    ]
  },
  {
    "q": "What will be the output of this DFS code?",
    "c": "graph = {0: [1, 2], 1: [3], 2: [4], 3: [], 4: []}\nvisited = []\ndef dfs(v):\n    if v not in visited:\n        visited.append(v)\n        for n in graph[v]:\n            dfs(n)\ndfs(0)\nprint(visited)",
    "o": [
      "[0, 1, 3, 2, 4]",
      "[0, 2, 4, 1, 3]",
      "[0, 1, 2, 3, 4]",
      "[0, 3, 1, 4, 2]"
    ]
  },
  {
    "q": "Which of the following statements is true for BFS traversal?",
    "c": null,
    "o": [
      "It explores all neighbors at the current depth before moving deeper",
      "It explores as far as possible along a branch before backtracking",
      "It always results in a minimum spanning tree",
      "It uses a stack for its implementation"
    ]
  },
  {
    "q": "Which of the following is an application of DFS?",
    "c": null,
    "o": [
      "Topological sorting",
      "Shortest path finding in unweighted graph",
      "Minimum spanning tree",
      "Page ranking"
    ]
  },
  {
    "q": "Which of these algorithms does NOT necessarily produce a tree?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "DFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what happens if a node is revisited with a larger tentative distance?",
    "c": null,
    "o": [
      "It is ignored",
      "It is processed again",
      "The smaller distance is overwritten",
      "It triggers cycle detection"
    ]
  },
  {
    "q": "Which is the most suitable algorithm for finding the shortest distance between two nodes in a weighted graph with all positive weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is a key limitation of using an adjacency matrix for graph representation?",
    "c": null,
    "o": [
      "Wastes space in sparse graphs",
      "Cannot represent directed edges",
      "Cannot store edge weights",
      "Slower for dense graphs"
    ]
  },
  {
    "q": "Which of the following statements about Kruskal’s algorithm is false?",
    "c": null,
    "o": [
      "It always starts from the smallest edge and adds it if it doesn’t form a cycle",
      "It may work on disconnected graphs to form a spanning forest",
      "It guarantees the shortest path from source to all vertices",
      "It uses a disjoint-set (union-find) structure"
    ]
  },
  {
    "q": "What is the purpose of the `heapq.heappush()` in Dijkstra’s implementation?",
    "c": null,
    "o": [
      "Insert a new node with its current shortest distance into the priority queue",
      "Delete the minimum distance node",
      "Merge two heaps",
      "Check for cycle"
    ]
  },
  {
    "q": "Which graph traversal method is best for checking connectivity in an undirected graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which step is necessary in both Prim’s and Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Selection of edge with minimum weight",
      "Selection of a starting vertex",
      "Use of recursion",
      "Use of adjacency matrix only"
    ]
  },
  {
    "q": "Which of the following will be visited last in a BFS traversal of this graph starting from node 0?",
    "c": "graph = {0: [1, 2], 1: [3, 4], 2: [], 3: [], 4: []}",
    "o": [
      "4",
      "2",
      "3",
      "1"
    ]
  },
  {
    "q": "Which of the following is true about edge selection in Prim’s algorithm?",
    "c": null,
    "o": [
      "Only edges connected to the growing MST are considered",
      "All graph edges are considered at once",
      "All edges are pre-sorted",
      "Only leaf edges are considered"
    ]
  },
  {
    "q": "Which of the following is not a valid step in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Update distance of neighbors if a shorter path is found",
      "Push neighbor to min-heap with updated cost",
      "Allow revisiting a node if it gives a longer path",
      "Mark a node as visited after finalizing its shortest path"
    ]
  },
  {
    "q": "Which structure in Python is best suited for implementing the visited set in DFS?",
    "c": null,
    "o": [
      "set()",
      "list",
      "tuple",
      "dict"
    ]
  },
  {
    "q": "Which algorithm can be applied directly to find a path from a start to goal node in a maze?",
    "c": null,
    "o": [
      "DFS",
      "Kruskal's Algorithm",
      "Prim's Algorithm",
      "Bellman-Ford"
    ]
  },
  {
    "q": "What is the time complexity of Prim’s algorithm using a min-heap and adjacency list for a graph with V vertices and E edges?",
    "c": null,
    "o": [
      "O(E log V)",
      "O(V^2)",
      "O(V log E)",
      "O(E^2)"
    ]
  },
  {
    "q": "Which of the following is true about the output of DFS on a disconnected graph?",
    "c": null,
    "o": [
      "It may not visit all vertices unless DFS is called on all components",
      "It always visits all vertices",
      "It fails on disconnected graphs",
      "It returns an MST"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "graph = {0: [1], 1: [2], 2: [0, 3], 3: []}\nvisited = []\ndef dfs(v):\n    if v not in visited:\n        visited.append(v)\n        for n in graph[v]:\n            dfs(n)\ndfs(0)\nprint(visited)",
    "o": [
      "[0, 1, 2, 3]",
      "[0, 1, 2]",
      "[0, 2, 1, 3]",
      "[0, 3, 2, 1]"
    ]
  },
  {
    "q": "Which of these problems cannot be solved using Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Single-source shortest path",
      "Finding Minimum Spanning Tree",
      "Finding Minimum Spanning Forest",
      "Cycle detection in a graph"
    ]
  },
  {
    "q": "Which of the following statements is false about BFS?",
    "c": null,
    "o": [
      "BFS uses a stack",
      "BFS finds shortest path in unweighted graphs",
      "BFS uses a queue",
      "BFS can detect connected components"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing BFS?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Disjoint Set"
    ]
  },
  {
    "q": "Which property ensures Prim’s algorithm builds a valid MST?",
    "c": null,
    "o": [
      "It always picks the smallest edge connecting the MST to an unvisited node",
      "It avoids cycles using union-find",
      "It starts from the vertex with minimum degree",
      "It considers only leaf nodes"
    ]
  },
  {
    "q": "Which one is true about the behavior of DFS traversal?",
    "c": null,
    "o": [
      "It explores one path as deep as possible before backtracking",
      "It visits all neighbors first before moving deeper",
      "It only works on undirected graphs",
      "It is guaranteed to find the shortest path"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what triggers updating the shortest known distance to a neighbor?",
    "c": null,
    "o": [
      "Finding a shorter path via the current vertex",
      "Finding a longer path",
      "Revisiting a node",
      "Detecting a cycle"
    ]
  },
  {
    "q": "Which of the following is NOT a feature of Kruskal’s algorithm?",
    "c": null,
    "o": [
      "It uses a priority queue to choose the next edge",
      "It can work on disconnected graphs",
      "It sorts edges based on weight",
      "It uses the union-find data structure"
    ]
  },
  {
    "q": "Which traversal can be used to detect a cycle in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS with priority queue",
      "Kruskal’s algorithm",
      "Prim’s algorithm"
    ]
  },
  {
    "q": "Which of the following is required to initialize Prim’s algorithm?",
    "c": null,
    "o": [
      "A starting vertex",
      "Sorted edge list",
      "Disjoint set",
      "All vertices marked visited"
    ]
  },
  {
    "q": "What does Dijkstra’s algorithm do if there are multiple paths with the same cost?",
    "c": null,
    "o": [
      "It picks the first one found",
      "It throws an error",
      "It picks the longest one",
      "It returns all possible paths"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "graph = {0: [1, 2], 1: [], 2: [3], 3: []}\nvisited = []\ndef dfs(v):\n    if v not in visited:\n        visited.append(v)\n        for n in graph[v]:\n            dfs(n)\ndfs(0)\nprint(visited)",
    "o": [
      "[0, 1, 2, 3]",
      "[0, 2, 3, 1]",
      "[0, 3, 2, 1]",
      "[0, 1, 3, 2]"
    ]
  },
  {
    "q": "Which is the correct order of steps in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Sort edges → Initialize disjoint sets → Add non-cycling edges",
      "Start from a node → Use priority queue → Select edge",
      "Build MST from vertex 0 → Visit all nodes → Update weights",
      "Create matrix → Traverse graph → Sum edge weights"
    ]
  },
  {
    "q": "Which algorithm uses edge relaxation as a core step to update shortest distances?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the key difference between Prim’s and Kruskal’s algorithms?",
    "c": null,
    "o": [
      "Prim’s grows a tree from one vertex, Kruskal’s connects components using edges",
      "Kruskal’s always starts from vertex 0",
      "Prim’s requires a sorted edge list",
      "Kruskal’s uses a priority queue"
    ]
  },
  {
    "q": "Which of the following is NOT required for DFS?",
    "c": null,
    "o": [
      "Queue",
      "Visited structure",
      "Recursion or stack",
      "Graph adjacency structure"
    ]
  },
  {
    "q": "In a graph with cycles, which traversal algorithm may fall into an infinite loop if 'visited' is not used?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following graph algorithms is not suitable for finding connected components in a graph?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS",
      "Union-Find"
    ]
  },
  {
    "q": "Which is the correct time complexity of Kruskal’s Algorithm with union-find?",
    "c": null,
    "o": [
      "O(E log E)",
      "O(V^2)",
      "O(V + E)",
      "O(E^2)"
    ]
  },
  {
    "q": "Which condition will lead Prim’s algorithm to create incorrect MST results?",
    "c": null,
    "o": [
      "Negative edge weights",
      "Graph with cycles",
      "Undirected graph",
      "Disconnected graph"
    ]
  },
  {
    "q": "Which of these algorithms can work on both connected and disconnected graphs by default?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which algorithm will visit nodes in the following order for this graph: 0 → 1 → 2 → 3?",
    "c": "graph = {0: [1], 1: [2], 2: [3], 3: []}\ndef dfs(v):\n    print(v)\n    for n in graph[v]:\n        dfs(n)\ndfs(0)",
    "o": [
      "DFS",
      "BFS",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which of these algorithms uses edge sorting as a first step?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which algorithm ensures a globally minimum path cost from a source to all vertices, given non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Depth First Search"
    ]
  },
  {
    "q": "What is the major drawback of using DFS for finding the shortest path?",
    "c": null,
    "o": [
      "It does not guarantee the shortest path",
      "It requires an adjacency matrix",
      "It requires sorting the graph",
      "It cannot detect cycles"
    ]
  },
  {
    "q": "Which condition ensures a unique Minimum Spanning Tree (MST)?",
    "c": null,
    "o": [
      "All edge weights are distinct",
      "Graph is fully connected",
      "Graph is a tree",
      "There are no cycles"
    ]
  },
  {
    "q": "Which algorithm is best for dense graphs when using an adjacency matrix representation?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which of the following will always give the same traversal output on a tree?",
    "c": null,
    "o": [
      "DFS and BFS may give different results",
      "DFS and BFS always produce the same output",
      "Only DFS works on trees",
      "Only BFS works on trees"
    ]
  },
  {
    "q": "What happens if we do not mark visited nodes in BFS?",
    "c": null,
    "o": [
      "It may enter an infinite loop",
      "It will stop immediately",
      "It will ignore all neighbors",
      "It will skip the source node"
    ]
  },
  {
    "q": "What data structure is ideal for cycle detection in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Disjoint Set (Union-Find)",
      "Stack",
      "Queue",
      "Heap"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, which nodes are always selected first?",
    "c": null,
    "o": [
      "Nodes with minimum tentative distance",
      "Nodes with maximum degree",
      "Leaf nodes",
      "Unreachable nodes"
    ]
  },
  {
    "q": "Which of the following correctly describes a step in BFS?",
    "c": null,
    "o": [
      "Dequeue the front node and enqueue its unvisited neighbors",
      "Pop the last node and push its neighbors",
      "Recursively explore the first neighbor",
      "Sort neighbors before traversal"
    ]
  },
  {
    "q": "What is the output of this DFS code?",
    "c": "graph = {0: [1, 2], 1: [3], 2: [4], 3: [], 4: []}\nvisited = []\ndef dfs(v):\n    if v not in visited:\n        visited.append(v)\n        for n in graph[v]:\n            dfs(n)\ndfs(0)\nprint(visited)",
    "o": [
      "[0, 1, 3, 2, 4]",
      "[0, 2, 4, 1, 3]",
      "[0, 3, 1, 4, 2]",
      "[0, 1, 2, 3, 4]"
    ]
  },
  {
    "q": "Which of the following is true about DFS traversal in a tree?",
    "c": null,
    "o": [
      "It visits all nodes exactly once in a depth-wise manner",
      "It always finds the shortest path between two nodes",
      "It requires an adjacency matrix",
      "It revisits nodes multiple times"
    ]
  },
  {
    "q": "Which traversal strategy is used in the Breadth First Search algorithm?",
    "c": null,
    "o": [
      "Level order traversal",
      "Depth-wise traversal",
      "Greedy traversal",
      "Post-order traversal"
    ]
  },
  {
    "q": "Which of the following does NOT affect the result of Kruskal’s algorithm?",
    "c": null,
    "o": [
      "The order of edges with equal weight",
      "The choice of disjoint set implementation",
      "The graph being connected",
      "The starting vertex"
    ]
  },
  {
    "q": "What is the output of this BFS traversal starting from node 0?",
    "c": "from collections import deque\ngraph = {0: [1, 2], 1: [3], 2: [4], 3: [], 4: []}\nvisited = []\nq = deque([0])\nwhile q:\n    node = q.popleft()\n    if node not in visited:\n        visited.append(node)\n        q.extend(graph[node])\nprint(visited)",
    "o": [
      "[0, 1, 2, 3, 4]",
      "[0, 2, 1, 4, 3]",
      "[0, 1, 3, 2, 4]",
      "[0, 3, 4, 1, 2]"
    ]
  },
  {
    "q": "Which of the following is NOT a step in Prim’s algorithm?",
    "c": null,
    "o": [
      "Sorting all edges before processing",
      "Starting from any node",
      "Using a priority queue or min-heap",
      "Keeping track of visited vertices"
    ]
  },
  {
    "q": "What is the total number of edges in a Minimum Spanning Tree with V vertices?",
    "c": null,
    "o": [
      "V - 1",
      "V",
      "V + 1",
      "2 * V"
    ]
  },
  {
    "q": "Which algorithm is more suitable for dense graphs with many edges?",
    "c": null,
    "o": [
      "Prim’s Algorithm with adjacency matrix",
      "Kruskal’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "Which operation is performed when union-by-rank is used in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Union of two disjoint sets based on tree height",
      "Sorting vertices by degree",
      "Updating the minimum weight",
      "Breadth-wise traversal"
    ]
  },
  {
    "q": "What is the worst-case time complexity of BFS in terms of vertices (V) and edges (E)?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which of the following correctly describes how a cycle is detected in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Using union-find to check if two vertices are in the same set",
      "Using a visited set and stack",
      "Using a queue during traversal",
      "Sorting the graph before DFS"
    ]
  },
  {
    "q": "Which traversal method can be used to topologically sort a DAG (Directed Acyclic Graph)?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is a necessary condition for Prim’s algorithm to work correctly?",
    "c": null,
    "o": [
      "The graph must be connected",
      "The graph must be a tree",
      "The graph must be a DAG",
      "The graph must be complete"
    ]
  },
  {
    "q": "Which step in Dijkstra’s algorithm ensures that the shortest path to a node is found?",
    "c": null,
    "o": [
      "Selecting the node with the minimum distance from the priority queue",
      "Sorting all edges before processing",
      "Using DFS for path expansion",
      "Checking for cycles before relaxing edges"
    ]
  },
  {
    "q": "Which graph algorithm is more efficient on sparse graphs?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm with adjacency matrix",
      "Dijkstra’s Algorithm with matrix",
      "BFS with queue"
    ]
  },
  {
    "q": "What would be the output of DFS for the following graph starting from 0?",
    "c": "graph = {0: [1, 2], 1: [3], 2: [], 3: [4], 4: []}\nvisited = []\ndef dfs(v):\n    if v not in visited:\n        visited.append(v)\n        for n in graph[v]:\n            dfs(n)\ndfs(0)\nprint(visited)",
    "o": [
      "[0, 1, 3, 4, 2]",
      "[0, 2, 1, 3, 4]",
      "[0, 1, 2, 3, 4]",
      "[0, 3, 1, 2, 4]"
    ]
  },
  {
    "q": "Which component of Kruskal’s algorithm is responsible for avoiding cycles?",
    "c": null,
    "o": [
      "Disjoint Set (Union-Find)",
      "Priority Queue",
      "Min-Heap",
      "Stack"
    ]
  },
  {
    "q": "Why is BFS preferred over DFS for finding the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "It visits nodes in increasing order of distance",
      "It uses less memory",
      "It avoids cycles automatically",
      "It sorts nodes before traversal"
    ]
  },
  {
    "q": "What is the main goal of Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Find the minimum spanning tree using edge weights",
      "Find shortest path from a source",
      "Detect all cycles in a graph",
      "Check graph connectivity"
    ]
  },
  {
    "q": "Which is true about time complexity when using a Fibonacci heap in Prim’s algorithm?",
    "c": null,
    "o": [
      "It reduces the complexity to O(E + log V)",
      "It increases the complexity",
      "It doesn't change the complexity",
      "It turns Prim’s into a recursive algorithm"
    ]
  },
  {
    "q": "What happens if Prim’s algorithm is applied to a disconnected graph?",
    "c": null,
    "o": [
      "It fails to generate a complete MST",
      "It generates a spanning forest",
      "It produces incorrect weights",
      "It runs infinitely"
    ]
  },
  {
    "q": "Which of the following statements about Dijkstra's algorithm is FALSE?",
    "c": null,
    "o": [
      "It works with graphs having negative edge weights",
      "It uses a priority queue to pick the next node",
      "It finds the shortest path from a single source to all vertices",
      "It initializes all distances as infinity except for the source"
    ]
  },
  {
    "q": "Which of the following is the correct space complexity of BFS using adjacency list?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E^2)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which algorithm can be directly used to detect a cycle in an undirected graph?",
    "c": null,
    "o": [
      "DFS with parent tracking",
      "Prim’s algorithm",
      "Dijkstra’s algorithm",
      "Topological sort"
    ]
  },
  {
    "q": "What happens if the visited check is missing in DFS?",
    "c": null,
    "o": [
      "The traversal may enter an infinite loop",
      "The traversal will stop immediately",
      "The shortest path is always found",
      "The graph will be disconnected"
    ]
  },
  {
    "q": "Which of these algorithms builds the MST by selecting the smallest available edge at each step regardless of where it connects?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the primary benefit of using Union by Rank in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "To optimize the union-find operations",
      "To increase the MST weight",
      "To sort the edges faster",
      "To traverse in BFS order"
    ]
  },
  {
    "q": "Which traversal uses FIFO (First-In First-Out) approach?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is essential in BFS but not mandatory in DFS?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Set",
      "Dictionary"
    ]
  },
  {
    "q": "What is the time complexity of Kruskal’s algorithm using an optimized union-find structure?",
    "c": null,
    "o": [
      "O(E log V)",
      "O(V^2)",
      "O(V log E)",
      "O(E^2)"
    ]
  },
  {
    "q": "Which step ensures that a node is not visited more than once in BFS?",
    "c": null,
    "o": [
      "Using a visited set",
      "Recursion",
      "Sorting the queue",
      "Removing from the graph"
    ]
  },
  {
    "q": "Which of the following will always be a tree structure?",
    "c": null,
    "o": [
      "Minimum Spanning Tree",
      "Dijkstra’s Output",
      "BFS Traversal Path",
      "DFS Traversal Path"
    ]
  },
  {
    "q": "In which traversal method are all immediate neighbors of a node explored before going deeper?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "Which of the following algorithms can process disconnected graphs and still provide a result?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "What is a typical use case of DFS in graph problems?",
    "c": null,
    "o": [
      "Cycle detection in directed and undirected graphs",
      "Shortest path in weighted graphs",
      "Minimum spanning tree",
      "Top-k node selection"
    ]
  },
  {
    "q": "Which of these algorithms works by expanding the MST one vertex at a time?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which graph traversal can be implemented using recursion without additional data structures?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms does NOT use a priority queue by default?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Prim’s",
      "A* Search"
    ]
  },
  {
    "q": "Which scenario would cause Prim’s algorithm to fail to find a complete spanning tree?",
    "c": null,
    "o": [
      "If the graph is disconnected",
      "If edge weights are not unique",
      "If the graph contains cycles",
      "If the source node is leaf"
    ]
  },
  {
    "q": "Which of the following describes the initialization in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "All distances as infinity except source = 0",
      "All distances as 0",
      "Distances set based on edge weights",
      "Visited nodes pre-filled with source"
    ]
  },
  {
    "q": "Which of these algorithms is more suitable for finding a forest in a disconnected graph?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "BFS",
      "DFS"
    ]
  },
  {
    "q": "What is the minimum number of edges in a connected undirected graph with V vertices?",
    "c": null,
    "o": [
      "V - 1",
      "V",
      "V + 1",
      "2V"
    ]
  },
  {
    "q": "Which of these algorithms uses greedy strategy for shortest path?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS",
      "Floyd-Warshall"
    ]
  },
  {
    "q": "What is the purpose of edge relaxation in Dijkstra's algorithm?",
    "c": null,
    "o": [
      "To update shortest path estimates",
      "To remove cycles",
      "To sort edges",
      "To visit neighbors in reverse"
    ]
  },
  {
    "q": "Which of these algorithms will always produce a tree from a connected graph?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "What is the major reason for using a priority queue in Dijkstra's algorithm?",
    "c": null,
    "o": [
      "To efficiently fetch the next closest unvisited node",
      "To track visited nodes",
      "To remove cycles",
      "To process all edges equally"
    ]
  },
  {
    "q": "Which graph algorithm does NOT require the graph to be weighted?",
    "c": null,
    "o": [
      "BFS",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following data structures can improve Kruskal’s performance significantly?",
    "c": null,
    "o": [
      "Union-Find",
      "Heap",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which of the following graphs can never have a spanning tree?",
    "c": null,
    "o": [
      "Disconnected graph",
      "Connected graph",
      "Weighted graph",
      "Complete graph"
    ]
  },
  {
    "q": "What is the main idea behind Prim’s Algorithm?",
    "c": null,
    "o": [
      "Grow the MST by adding the cheapest edge from the visited set",
      "Sort edges and add smallest one avoiding cycles",
      "Visit nodes depth-first",
      "Choose the heaviest edge at each step"
    ]
  },
  {
    "q": "Which of the following outputs a valid shortest path tree from a source node?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which of the following correctly describes BFS traversal in an unweighted graph?",
    "c": null,
    "o": [
      "It finds the shortest path from the source to all reachable nodes",
      "It always visits the deepest node first",
      "It is implemented using recursion",
      "It uses a priority queue"
    ]
  },
  {
    "q": "What is the first step of Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Sort all edges in increasing order of weight",
      "Select a random vertex as starting point",
      "Traverse the graph using DFS",
      "Build an adjacency matrix"
    ]
  },
  {
    "q": "Which traversal method is better suited for finding all nodes within one level of a starting node?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What will happen if Dijkstra’s algorithm is used on a graph with negative edge weights?",
    "c": null,
    "o": [
      "It may give incorrect shortest path results",
      "It works faster",
      "It throws an error",
      "It produces the correct MST"
    ]
  },
  {
    "q": "Which of the following is used by Prim’s algorithm to track the next edge to add?",
    "c": null,
    "o": [
      "Min-Heap / Priority Queue",
      "Stack",
      "Disjoint Set",
      "Queue"
    ]
  },
  {
    "q": "What will the following DFS code output?",
    "c": "graph = {0: [1, 2], 1: [3], 2: [], 3: [4], 4: []}\nvisited = []\ndef dfs(v):\n    if v not in visited:\n        visited.append(v)\n        for n in graph[v]:\n            dfs(n)\ndfs(0)\nprint(visited)",
    "o": [
      "[0, 1, 3, 4, 2]",
      "[0, 2, 1, 3, 4]",
      "[0, 1, 2, 3, 4]",
      "[0, 3, 1, 2, 4]"
    ]
  },
  {
    "q": "Which condition is sufficient for a graph to have a spanning tree?",
    "c": null,
    "o": [
      "It must be connected",
      "It must be a tree",
      "It must be directed",
      "It must have no cycles"
    ]
  },
  {
    "q": "What is the space complexity of Dijkstra's algorithm using an adjacency list and priority queue?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E^2)",
      "O(V log V)"
    ]
  },
  {
    "q": "Which of the following is a topological property useful for optimizing Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Union by rank and path compression",
      "Recursion depth control",
      "Breadth-level tracking",
      "Greedy backtracking"
    ]
  },
  {
    "q": "Which algorithm guarantees to always return the lightest total weight for a spanning tree?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "DFS",
      "BFS",
      "Topological Sort"
    ]
  },
  {
    "q": "Which algorithm uses a greedy approach by always picking the minimum weight edge that connects two components?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of DFS over BFS?",
    "c": null,
    "o": [
      "DFS may get stuck in deep paths and miss shorter ones",
      "DFS needs more memory than BFS",
      "DFS is slower in all cases",
      "DFS always gives the wrong result"
    ]
  },
  {
    "q": "Which of the following statements is TRUE for BFS traversal of a graph?",
    "c": null,
    "o": [
      "It uses a queue to keep track of nodes to visit",
      "It uses a stack and recursion",
      "It visits the deepest nodes first",
      "It guarantees cycle detection"
    ]
  },
  {
    "q": "What does the union operation in Kruskal’s algorithm ensure?",
    "c": null,
    "o": [
      "That no cycles are formed",
      "That the graph remains connected",
      "That all paths are visited",
      "That the largest edge is selected"
    ]
  },
  {
    "q": "Which algorithm is most efficient for finding the shortest path from a source node in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "In BFS, how are neighbors of a node explored?",
    "c": null,
    "o": [
      "In the order they are enqueued",
      "In reverse order",
      "In sorted order of their value",
      "Using a stack"
    ]
  },
  {
    "q": "Which algorithm is best suited for detecting cycles in an undirected graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Prim’s",
      "BFS"
    ]
  },
  {
    "q": "Which of the following would most likely require a disjoint set data structure?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which algorithm works better on dense graphs using an adjacency matrix?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "What will be the time complexity of BFS in a graph with V vertices and E edges?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which graph algorithm uses the concept of a visited array and a recursion stack to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is a spanning tree?",
    "c": null,
    "o": [
      "A subgraph that connects all vertices without cycles",
      "A tree formed using only leaf nodes",
      "A tree with maximum edge weights",
      "A disconnected graph"
    ]
  },
  {
    "q": "Which of the following algorithms always visits the node closest to the source first?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of the following statements is true for Prim’s algorithm using an adjacency list with a min-heap?",
    "c": null,
    "o": [
      "Its time complexity is O(E log V)",
      "Its time complexity is O(V^2)",
      "It always uses a disjoint set",
      "It requires a sorted edge list"
    ]
  },
  {
    "q": "Which graph algorithm is more suitable for finding the shortest path in a maze (unweighted grid)?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What will happen if we use BFS on a disconnected graph?",
    "c": null,
    "o": [
      "Only nodes in the same component as the start node will be visited",
      "All nodes will still be visited",
      "It will result in an error",
      "It visits nodes in random order"
    ]
  },
  {
    "q": "Which algorithm is guaranteed to produce the optimal shortest paths if edge weights are non-negative?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm would fail to work correctly in a graph with negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Kruskal’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which of the following can result in multiple Minimum Spanning Trees?",
    "c": null,
    "o": [
      "Multiple edges with equal weights",
      "Negative edge weights",
      "Graph with no cycles",
      "Disconnected graph"
    ]
  },
  {
    "q": "Which of the following describes the difference between Prim’s and Kruskal’s algorithms?",
    "c": null,
    "o": [
      "Prim’s builds MST using vertices; Kruskal’s builds it using edges",
      "Kruskal’s requires a connected graph; Prim’s does not",
      "Prim’s works only on weighted graphs; Kruskal’s does not",
      "Prim’s cannot work with adjacency lists"
    ]
  },
  {
    "q": "Which of the following algorithms is primarily used to detect connected components in an undirected graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the key difference between DFS and BFS in terms of data structure used?",
    "c": null,
    "o": [
      "DFS uses stack, BFS uses queue",
      "DFS uses queue, BFS uses stack",
      "Both use stack",
      "Both use queue"
    ]
  },
  {
    "q": "In Kruskal’s algorithm, what ensures that cycles are avoided while building the MST?",
    "c": null,
    "o": [
      "Union-Find data structure",
      "Depth check",
      "DFS traversal",
      "Priority queue"
    ]
  },
  {
    "q": "Which traversal technique visits all nodes at the current depth level before moving to the next depth level?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms can be used to construct a minimum spanning forest in a disconnected graph?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What kind of graph does BFS assume when calculating the shortest path?",
    "c": null,
    "o": [
      "Unweighted graph",
      "Weighted graph with negative weights",
      "Directed Acyclic Graph",
      "Complete Graph"
    ]
  },
  {
    "q": "What data structure does Prim’s algorithm typically use to efficiently pick the next minimum edge?",
    "c": null,
    "o": [
      "Min-Heap or Priority Queue",
      "Stack",
      "Disjoint Set",
      "Hash Map"
    ]
  },
  {
    "q": "Which of these algorithms does not guarantee the shortest path in a weighted graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s Algorithm",
      "BFS (for unweighted)",
      "Bellman-Ford"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what is the significance of the priority queue?",
    "c": null,
    "o": [
      "To always select the node with the smallest tentative distance",
      "To sort all edges before starting",
      "To avoid visiting cycles",
      "To store the spanning tree"
    ]
  },
  {
    "q": "Which of the following correctly describes Kruskal’s algorithm?",
    "c": null,
    "o": [
      "It selects edges in increasing order of weight and adds them if they don’t form a cycle",
      "It expands from a root vertex and connects it to the nearest unvisited vertex",
      "It visits all nodes at the same depth level before going deeper",
      "It computes shortest distances from a single source"
    ]
  },
  {
    "q": "Which traversal method is best suited for finding if a path exists between two nodes in a graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What is the key feature of Dijkstra’s algorithm that ensures optimal paths?",
    "c": null,
    "o": [
      "Greedy selection of minimum distance node",
      "Use of recursion for depth traversal",
      "Edge sorting before traversal",
      "Cycle detection mechanism"
    ]
  },
  {
    "q": "Which of the following is true about Prim’s and Kruskal’s algorithms?",
    "c": null,
    "o": [
      "Both are greedy algorithms for MST",
      "Only Prim’s is greedy",
      "Only Kruskal’s works on weighted graphs",
      "Prim’s always gives better result than Kruskal’s"
    ]
  },
  {
    "q": "Which of these would be visited first in BFS?",
    "c": null,
    "o": [
      "All neighbors of the current node",
      "All children of the last node",
      "The deepest node from root",
      "A random unvisited node"
    ]
  },
  {
    "q": "Which algorithm guarantees a spanning tree only if the graph is connected?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which structure is commonly used in DFS to keep track of the traversal path?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Priority Queue"
    ]
  },
  {
    "q": "What is the typical initial setup for distances in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "All distances are set to infinity except the source node",
      "All distances are zero",
      "Distances are based on degrees of nodes",
      "Distances are initialized randomly"
    ]
  },
  {
    "q": "Which of the following scenarios causes BFS to be less efficient?",
    "c": null,
    "o": [
      "In very wide graphs (high branching factor)",
      "In graphs with negative edges",
      "In graphs with cycles",
      "In graphs with self-loops"
    ]
  },
  {
    "q": "Which algorithm can be used to build MST in both connected and disconnected graphs?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which traversal method would use more memory on wide and shallow graphs?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which of the following is the correct time complexity of Prim’s algorithm using an adjacency matrix?",
    "c": null,
    "o": [
      "O(V^2)",
      "O(E log V)",
      "O(V + E)",
      "O(V log V)"
    ]
  },
  {
    "q": "What is the role of a priority queue in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "To always extract the node with the smallest tentative distance",
      "To store visited nodes",
      "To keep track of parent nodes",
      "To detect cycles"
    ]
  },
  {
    "q": "Which algorithm is more likely to find a path faster in very deep graphs (with fewer branches)?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "What will DFS return in a cyclic graph without a visited set?",
    "c": null,
    "o": [
      "It may result in infinite recursion",
      "It guarantees shortest path",
      "It will throw an error",
      "It will detect the cycle automatically"
    ]
  },
  {
    "q": "Which property is essential for the correctness of Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "All edge weights must be non-negative",
      "Graph must be fully connected",
      "Graph must be a tree",
      "Graph must not contain cycles"
    ]
  },
  {
    "q": "How does Kruskal’s algorithm handle graphs with multiple disconnected components?",
    "c": null,
    "o": [
      "It constructs a minimum spanning forest",
      "It stops after the first component",
      "It only works with connected graphs",
      "It throws an exception"
    ]
  },
  {
    "q": "Which algorithm is best for solving single-source shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "Dijkstra’s",
      "DFS",
      "Prim’s"
    ]
  },
  {
    "q": "Which of the following correctly explains why Dijkstra's algorithm doesn't work with negative weights?",
    "c": null,
    "o": [
      "It assumes once a node's distance is finalized, it cannot be improved",
      "It uses a DFS-like recursion which breaks with negative edges",
      "It doesn’t store edge weights",
      "It doesn't track visited nodes"
    ]
  },
  {
    "q": "Which of these algorithms needs edge weights to function correctly?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "DFS",
      "BFS",
      "Topological Sort"
    ]
  },
  {
    "q": "Which of the following describes the main idea behind BFS traversal?",
    "c": null,
    "o": [
      "Explore all neighbors before moving deeper",
      "Explore the farthest node first",
      "Pick minimum weight edges always",
      "Explore connected components one by one"
    ]
  },
  {
    "q": "Which of the following graph traversal techniques guarantees finding the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which graph traversal can be used to perform a topological sort in a DAG?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is TRUE about Kruskal's algorithm?",
    "c": null,
    "o": [
      "It sorts all edges first before processing",
      "It uses a priority queue for nodes",
      "It processes nodes in a breadth-first manner",
      "It always starts from vertex 0"
    ]
  },
  {
    "q": "Which type of graph is necessary for Prim’s algorithm to construct an MST?",
    "c": null,
    "o": [
      "Connected weighted undirected graph",
      "Directed acyclic graph",
      "Unweighted undirected graph",
      "Disconnected graph"
    ]
  },
  {
    "q": "What will be the output of BFS traversal starting from vertex 0?",
    "c": "graph = {0: [1, 2], 1: [3], 2: [], 3: [4], 4: []}\nvisited = []\nfrom collections import deque\nq = deque([0])\nwhile q:\n    v = q.popleft()\n    if v not in visited:\n        visited.append(v)\n        q.extend(graph[v])\nprint(visited)",
    "o": [
      "[0, 1, 2, 3, 4]",
      "[0, 2, 1, 4, 3]",
      "[0, 1, 3, 4, 2]",
      "[0, 3, 1, 2, 4]"
    ]
  },
  {
    "q": "Which of these algorithms would most benefit from sorting edges?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following statements is true about BFS and DFS?",
    "c": null,
    "o": [
      "BFS uses queue, DFS uses stack (or recursion)",
      "BFS is recursive, DFS is iterative",
      "Both use recursion",
      "BFS is used for cycle detection only"
    ]
  },
  {
    "q": "What makes Kruskal’s algorithm suitable for sparse graphs?",
    "c": null,
    "o": [
      "It considers edges directly and doesn’t rely on adjacency structures",
      "It processes all vertices first",
      "It uses a dense matrix for performance",
      "It does not require sorting edges"
    ]
  },
  {
    "q": "In DFS, what causes nodes to be revisited if a 'visited' set is not used?",
    "c": null,
    "o": [
      "Presence of cycles",
      "Negative edge weights",
      "Unconnected graph",
      "Use of a queue instead of a stack"
    ]
  },
  {
    "q": "Which algorithm builds the MST by growing one component at a time?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the output of the following DFS code snippet?",
    "c": "graph = {1: [2, 3], 2: [4], 3: [], 4: []}\nvisited = []\ndef dfs(v):\n    if v not in visited:\n        visited.append(v)\n        for n in graph[v]:\n            dfs(n)\ndfs(1)\nprint(visited)",
    "o": [
      "[1, 2, 4, 3]",
      "[1, 3, 2, 4]",
      "[1, 4, 2, 3]",
      "[1, 2, 3, 4]"
    ]
  },
  {
    "q": "Which algorithm explores the closest nodes first and is ideal for finding the shortest path in unweighted graphs?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which of these does Dijkstra's algorithm fail to handle correctly?",
    "c": null,
    "o": [
      "Negative edge weights",
      "Cycles",
      "Undirected graphs",
      "Unweighted graphs"
    ]
  },
  {
    "q": "What data structure combination is typically used in Kruskal’s algorithm to avoid cycles?",
    "c": null,
    "o": [
      "Disjoint Set Union-Find",
      "Priority Queue",
      "Stack and Queue",
      "HashMap and Set"
    ]
  },
  {
    "q": "Which traversal method is implemented using a queue?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, once a node's shortest distance is finalized, what does it imply?",
    "c": null,
    "o": [
      "It will not be updated again",
      "It might still change later",
      "It will be visited again",
      "It can be removed from the graph"
    ]
  },
  {
    "q": "Which of the following algorithms uses a greedy approach and always picks the next smallest edge to add?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "BFS",
      "DFS",
      "Topological Sort"
    ]
  },
  {
    "q": "Which of these will result in an incomplete traversal if the graph is disconnected?",
    "c": null,
    "o": [
      "BFS starting from one node",
      "Kruskal’s Algorithm",
      "DFS on each component",
      "Prim’s with edge check"
    ]
  },
  {
    "q": "Which of the following is a similarity between Prim’s and Dijkstra’s algorithms?",
    "c": null,
    "o": [
      "Both use a priority queue to select the next node",
      "Both require sorted edges initially",
      "Both perform cycle detection",
      "Both are used for topological sorting"
    ]
  },
  {
    "q": "What happens if cycles are not handled in DFS?",
    "c": null,
    "o": [
      "Infinite recursion may occur",
      "Shortest path is guaranteed",
      "Only one path is explored",
      "All paths are explored twice"
    ]
  },
  {
    "q": "What is the space complexity of BFS using an adjacency list?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V)"
    ]
  },
  {
    "q": "Which of the following is a key difference between Prim’s and Kruskal’s algorithms?",
    "c": null,
    "o": [
      "Prim’s works with nodes, Kruskal’s with edges",
      "Prim’s works only for dense graphs",
      "Kruskal’s builds spanning trees from leaves",
      "Prim’s always gives better result than Kruskal’s"
    ]
  },
  {
    "q": "What is the time complexity of Kruskal’s algorithm if Union-Find is used with path compression?",
    "c": null,
    "o": [
      "O(E log E)",
      "O(V^2)",
      "O(E + V)",
      "O(V log V)"
    ]
  },
  {
    "q": "Which traversal method can be easily adapted to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is a valid reason for using BFS instead of DFS?",
    "c": null,
    "o": [
      "To find the shortest path in an unweighted graph",
      "To reduce space complexity",
      "To process deep nodes first",
      "To avoid recursion"
    ]
  },
  {
    "q": "Which of these traversal methods guarantees visiting every edge exactly once?",
    "c": null,
    "o": [
      "Neither DFS nor BFS guarantees that",
      "DFS",
      "BFS",
      "Both DFS and BFS"
    ]
  },
  {
    "q": "Which algorithm is typically used to compute a single-source shortest path in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "BFS",
      "DFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which graph algorithm is ideal for detecting whether a graph is bipartite?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What does Prim’s algorithm do when the next chosen edge leads to a visited node?",
    "c": null,
    "o": [
      "It skips that edge and picks the next minimum",
      "It adds the edge anyway",
      "It restarts the algorithm",
      "It throws an error"
    ]
  },
  {
    "q": "Which of the following edge conditions leads to incorrect results in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Presence of negative edge weights",
      "Equal weight edges",
      "Disconnected vertices",
      "Edges with weight zero"
    ]
  },
  {
    "q": "What is the condition for a graph to have a unique Minimum Spanning Tree (MST)?",
    "c": null,
    "o": [
      "All edge weights must be distinct",
      "Graph must be connected",
      "Graph must be a tree",
      "Number of vertices must be even"
    ]
  },
  {
    "q": "Which of the following traversal methods can be implemented using recursion or a stack?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "In BFS traversal, which data structure ensures nodes are visited in correct order?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Set"
    ]
  },
  {
    "q": "Which algorithm uses a greedy approach and builds the MST by growing a single component?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which of the following best describes the main loop of Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Extract minimum distance node and update neighbors",
      "Explore deepest node first",
      "Sort all edges and select one by one",
      "Union all visited components"
    ]
  },
  {
    "q": "Which traversal is most suitable for finding connected components in a graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which algorithm requires edge sorting before execution?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the worst-case time complexity of DFS in an adjacency list representation?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V log V)"
    ]
  },
  {
    "q": "Which of the following is TRUE about BFS and DFS in terms of cycle detection?",
    "c": null,
    "o": [
      "Both can detect cycles",
      "Only DFS can detect cycles",
      "Only BFS can detect cycles",
      "Neither can detect cycles"
    ]
  },
  {
    "q": "What happens if Kruskal’s algorithm is applied to a disconnected graph?",
    "c": null,
    "o": [
      "It produces a minimum spanning forest",
      "It fails to run",
      "It produces a complete graph",
      "It creates a cycle"
    ]
  },
  {
    "q": "Which of the following traversal techniques is guaranteed to visit all vertices of a connected graph?",
    "c": null,
    "o": [
      "Both DFS and BFS",
      "DFS only",
      "BFS only",
      "Neither DFS nor BFS"
    ]
  },
  {
    "q": "What is the key difference in implementation between Kruskal’s and Prim’s algorithms?",
    "c": null,
    "o": [
      "Kruskal’s uses edge list; Prim’s uses adjacency structure",
      "Kruskal’s uses recursion; Prim’s does not",
      "Prim’s uses edge sorting; Kruskal’s does not",
      "Prim’s uses DFS while Kruskal’s uses BFS"
    ]
  },
  {
    "q": "Which algorithm would you choose for building a Minimum Spanning Tree in a dense graph?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the primary use of the 'visited' array or set in DFS or BFS?",
    "c": null,
    "o": [
      "To prevent revisiting the same node",
      "To keep track of edge weights",
      "To store the shortest path",
      "To record parent-child relationships"
    ]
  },
  {
    "q": "Which of the following scenarios is best solved by Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Finding the shortest path in a weighted, non-negative graph",
      "Constructing a minimum spanning tree",
      "Detecting a cycle in a graph",
      "Finding strongly connected components"
    ]
  },
  {
    "q": "How many edges are there in a Minimum Spanning Tree of a connected graph with V vertices?",
    "c": null,
    "o": [
      "V - 1",
      "V",
      "V + 1",
      "2V - 1"
    ]
  },
  {
    "q": "What does BFS do when it visits a node?",
    "c": null,
    "o": [
      "It enqueues all unvisited neighbors",
      "It adds all nodes to the stack",
      "It removes all neighbors",
      "It recurses into children"
    ]
  },
  {
    "q": "Which of the following is a limitation of DFS?",
    "c": null,
    "o": [
      "It may not find the shortest path in unweighted graphs",
      "It cannot handle graphs with cycles",
      "It requires edge sorting",
      "It only works on trees"
    ]
  },
  {
    "q": "In Kruskal’s algorithm, why do we use a disjoint-set (union-find) data structure?",
    "c": null,
    "o": [
      "To detect cycles while adding edges",
      "To sort edges more efficiently",
      "To prioritize nodes with high degree",
      "To store the final MST"
    ]
  },
  {
    "q": "Which graph algorithm maintains a tentative distance for each node and updates it when a shorter path is found?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "DFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path between nodes in a weighted graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the purpose of using a priority queue in Prim’s and Dijkstra’s algorithms?",
    "c": null,
    "o": [
      "To extract the next node with the minimum cost efficiently",
      "To store the graph structure",
      "To maintain visited nodes",
      "To detect cycles"
    ]
  },
  {
    "q": "Which traversal method is more memory-efficient for very deep trees?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "What kind of graph is required for Kruskal’s algorithm to construct a valid MST?",
    "c": null,
    "o": [
      "Connected, weighted, undirected graph",
      "Connected, unweighted, directed graph",
      "A tree",
      "Complete directed graph"
    ]
  },
  {
    "q": "Which traversal technique is best to use in maze-solving problems with all paths equally weighted?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which algorithm grows a forest and connects components by choosing the smallest edge?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "graph = {0: [1, 2], 1: [3], 2: [], 3: [4], 4: []}\nvisited = []\ndef dfs(v):\n    if v not in visited:\n        visited.append(v)\n        for n in graph[v]:\n            dfs(n)\ndfs(0)\nprint(visited)",
    "o": [
      "[0, 1, 3, 4, 2]",
      "[0, 2, 1, 3, 4]",
      "[0, 1, 2, 3, 4]",
      "[0, 1, 2, 4, 3]"
    ]
  },
  {
    "q": "Which of these algorithms starts from an arbitrary vertex and grows the MST by adding the minimum edge?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What makes Kruskal’s algorithm efficient in sparse graphs?",
    "c": null,
    "o": [
      "It doesn’t rely on adjacency structures and processes edges directly",
      "It performs multiple DFS traversals",
      "It builds the MST using recursion",
      "It uses max-heaps instead of sorting"
    ]
  },
  {
    "q": "Which traversal ensures all vertices at the same level are visited before moving deeper?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "Which of the following algorithms is best suited for finding connected components in an undirected graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Why is BFS preferred over DFS for finding the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "Because BFS explores all nodes at the current depth before going deeper",
      "Because DFS doesn’t work on graphs",
      "Because BFS is recursive",
      "Because DFS revisits nodes repeatedly"
    ]
  },
  {
    "q": "What is the best-case time complexity of Dijkstra’s algorithm using a binary heap?",
    "c": null,
    "o": [
      "O((V + E) log V)",
      "O(V^2)",
      "O(E^2)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which of these algorithms can work on disconnected graphs to produce a forest of MSTs?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which algorithm is typically used to calculate shortest paths from a source vertex in graphs with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which data structure is used in BFS to maintain the order of traversal?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Min-Heap",
      "Set"
    ]
  },
  {
    "q": "What happens in Prim’s algorithm if all edge weights are equal?",
    "c": null,
    "o": [
      "Any spanning tree formed will be minimum",
      "The algorithm fails",
      "It always chooses the first edge",
      "It forms a cycle"
    ]
  },
  {
    "q": "Which algorithm’s performance is not affected by negative edge weights?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which traversal strategy is most likely to exhaust memory in graphs with very wide levels?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which traversal method is ideal for topological sorting?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "What is the key difference between BFS and Dijkstra's algorithm in terms of edge weights?",
    "c": null,
    "o": [
      "BFS assumes all edges have equal weight; Dijkstra’s works with weighted edges",
      "BFS works with weighted graphs; Dijkstra’s does not",
      "Both treat all edges equally",
      "Dijkstra’s skips unweighted edges"
    ]
  },
  {
    "q": "Which of these traversal strategies is most likely to reach the deepest node first?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which algorithm is best suited to find a path with the smallest total weight from a source to all vertices?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "BFS",
      "DFS",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "Which of these is essential for Kruskal's algorithm to function efficiently?",
    "c": null,
    "o": [
      "Disjoint Set (Union-Find) structure",
      "Stack for backtracking",
      "Max Heap",
      "Recursive calls"
    ]
  },
  {
    "q": "What would be the output of this BFS code?",
    "c": "graph = {0: [1, 2], 1: [3], 2: [], 3: [], 4: [0]}\nvisited = []\nfrom collections import deque\nq = deque([4])\nwhile q:\n    v = q.popleft()\n    if v not in visited:\n        visited.append(v)\n        q.extend(graph.get(v, []))\nprint(visited)",
    "o": [
      "[4, 0, 1, 2, 3]",
      "[4, 1, 2, 3, 0]",
      "[4, 0, 2, 1, 3]",
      "[4, 0, 1, 3, 2]"
    ]
  },
  {
    "q": "Which MST algorithm performs better for dense graphs?",
    "c": null,
    "o": [
      "Prim’s Algorithm (using adjacency matrix)",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "What causes Dijkstra’s algorithm to fail on graphs with negative weights?",
    "c": null,
    "o": [
      "It assumes shortest distances can’t decrease",
      "It uses recursion",
      "It doesn’t use visited set",
      "It requires acyclic graphs"
    ]
  },
  {
    "q": "Which of the following algorithms is **not** used for finding an MST?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Boruvka’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is true about DFS recursion stack?",
    "c": null,
    "o": [
      "It can be used to detect cycles in directed graphs",
      "It tracks shortest paths",
      "It builds a minimum spanning tree",
      "It is only used for trees"
    ]
  },
  {
    "q": "Which of the following properties makes BFS optimal for shortest-path in unweighted graphs?",
    "c": null,
    "o": [
      "It explores all nodes at current depth before going deeper",
      "It avoids revisiting nodes",
      "It always follows the heaviest edge",
      "It prefers deeper nodes"
    ]
  },
  {
    "q": "Which data structure is essential for implementing DFS iteratively?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Priority Queue",
      "Min Heap"
    ]
  },
  {
    "q": "What is the main similarity between Dijkstra’s and Prim’s algorithms?",
    "c": null,
    "o": [
      "Both use a priority queue to extract the next minimum cost node",
      "Both work on unweighted graphs only",
      "Both are recursive",
      "Both find shortest paths"
    ]
  },
  {
    "q": "Which algorithm sorts all edges and adds them to the MST if they don't form a cycle?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "In a BFS traversal, what happens after a node is dequeued?",
    "c": null,
    "o": [
      "All unvisited neighbors are enqueued",
      "All edges are deleted",
      "Its neighbors are pushed onto a stack",
      "It is added to a recursion stack"
    ]
  },
  {
    "q": "What happens if the graph is disconnected and DFS is run from a single node?",
    "c": null,
    "o": [
      "Only the connected component is visited",
      "The whole graph is visited",
      "DFS throws an error",
      "DFS restarts automatically"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, how is the shortest path to a node updated?",
    "c": null,
    "o": [
      "If a shorter path is found via a neighboring node",
      "After all edges are traversed",
      "Using a stack",
      "When a node is visited twice"
    ]
  },
  {
    "q": "Which of the following statements is true about Prim’s algorithm?",
    "c": null,
    "o": [
      "It adds the smallest edge connecting the MST to a new vertex",
      "It selects the smallest edge in the entire graph regardless of MST",
      "It builds the MST by removing largest edges",
      "It never revisits nodes"
    ]
  },
  {
    "q": "What is a common use of DFS in directed graphs?",
    "c": null,
    "o": [
      "Cycle detection",
      "Shortest path finding",
      "Minimum spanning tree generation",
      "Edge sorting"
    ]
  },
  {
    "q": "Which of the following is a greedy algorithm for MST that uses a priority queue?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which algorithm is preferred when the graph has fewer edges (sparse graph)?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "BFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm can be used to find the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "What is the worst-case time complexity of BFS in a graph represented using an adjacency list?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V log V)"
    ]
  },
  {
    "q": "What will happen if Dijkstra's algorithm is run on a graph with negative edge weights?",
    "c": null,
    "o": [
      "It may produce incorrect results",
      "It works as expected",
      "It throws an error",
      "It will never terminate"
    ]
  },
  {
    "q": "Which of the following statements is true about DFS traversal?",
    "c": null,
    "o": [
      "It can be used for topological sorting",
      "It guarantees shortest path",
      "It is only applicable to trees",
      "It uses a queue"
    ]
  },
  {
    "q": "What data structure is commonly used in Kruskal’s algorithm to keep track of components?",
    "c": null,
    "o": [
      "Disjoint Set (Union-Find)",
      "Priority Queue",
      "Adjacency List",
      "Recursion Stack"
    ]
  },
  {
    "q": "Which of the following is true for Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "It finds shortest paths from a single source to all vertices",
      "It finds shortest paths between all pairs of vertices",
      "It finds the MST",
      "It works for negative weights"
    ]
  },
  {
    "q": "Which algorithm starts by choosing the edge with the smallest weight and adds it if it doesn’t form a cycle?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "In which of the following scenarios is DFS preferred over BFS?",
    "c": null,
    "o": [
      "When the solution is deep and space is limited",
      "When the graph is wide",
      "When we need shortest paths",
      "When edge weights matter"
    ]
  },
  {
    "q": "Which algorithm uses a greedy strategy to build a minimum spanning tree from a start node?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which of the following will NOT affect the correctness of Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Presence of cycles",
      "Disconnected components",
      "Multiple edges with same weight",
      "Edge weights being negative"
    ]
  },
  {
    "q": "Which of the following will complete the minimum spanning tree fastest in a sparse graph?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, which condition helps terminate early when searching for a single destination?",
    "c": null,
    "o": [
      "When the destination node is dequeued from the priority queue",
      "When all nodes are visited",
      "When total path weight exceeds a threshold",
      "When recursion depth exceeds node count"
    ]
  },
  {
    "q": "What is the role of the 'rank' array in Union-Find structure used in Kruskal's algorithm?",
    "c": null,
    "o": [
      "To keep trees shallow and optimize union operations",
      "To store edge weights",
      "To prioritize edges",
      "To track number of MST edges"
    ]
  },
  {
    "q": "Which traversal method can be used to detect a back edge in a directed graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which algorithm maintains a set of nodes already included in the MST?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "How does BFS behave in terms of layers or depth from the starting node?",
    "c": null,
    "o": [
      "It explores nodes level by level from the source",
      "It explores the farthest node first",
      "It skips disconnected nodes",
      "It prioritizes lowest edge weight"
    ]
  },
  {
    "q": "Which of the following statements is FALSE about DFS?",
    "c": null,
    "o": [
      "DFS always finds the shortest path in an unweighted graph",
      "DFS can be implemented recursively",
      "DFS uses a stack (explicit or implicit)",
      "DFS can be used for cycle detection"
    ]
  },
  {
    "q": "Why is sorting edges important in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "To pick the smallest edge first and avoid cycles",
      "To reduce memory usage",
      "To prevent infinite loops",
      "To maintain adjacency list"
    ]
  },
  {
    "q": "What does Dijkstra’s algorithm do after processing a node’s neighbors?",
    "c": null,
    "o": [
      "It updates distances and reorders the priority queue",
      "It removes that node from the graph",
      "It marks all paths from the neighbor as final",
      "It restarts from source"
    ]
  },
  {
    "q": "Which algorithm will fail to produce a correct result in the presence of negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which of the following is TRUE for BFS in an undirected graph?",
    "c": null,
    "o": [
      "It can be used to find the shortest path in terms of number of edges",
      "It guarantees the path with minimum total weight",
      "It always explores the farthest node first",
      "It never visits the same node twice"
    ]
  },
  {
    "q": "Which algorithm sorts edges and adds them greedily without forming cycles?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What condition leads Prim’s algorithm to stop adding new edges?",
    "c": null,
    "o": [
      "All vertices are included in the MST",
      "All edges are explored",
      "Cycle is detected",
      "Maximum depth is reached"
    ]
  },
  {
    "q": "Which of the following algorithms is designed to work efficiently with dense graphs using a matrix?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "How does DFS help in topological sorting of a directed acyclic graph (DAG)?",
    "c": null,
    "o": [
      "By finishing nodes and pushing them onto a stack in post-order",
      "By finding shortest paths",
      "By marking all reachable nodes first",
      "By counting incoming edges"
    ]
  },
  {
    "q": "Which algorithm is guaranteed to visit all vertices reachable from the start node in a connected graph?",
    "c": null,
    "o": [
      "Both DFS and BFS",
      "Only DFS",
      "Only BFS",
      "None of them"
    ]
  },
  {
    "q": "Which graph algorithm can construct a forest if the graph is not connected?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which of the following is a valid reason to prefer BFS over DFS?",
    "c": null,
    "o": [
      "You need to find the shortest path in an unweighted graph",
      "You want to reduce memory usage",
      "You prefer recursive implementation",
      "You want to avoid cycles"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what ensures that the shortest path to a vertex is finalized?",
    "c": null,
    "o": [
      "When it is dequeued from the priority queue",
      "When all its neighbors are visited",
      "When a cycle is detected",
      "When its parent is processed"
    ]
  },
  {
    "q": "Which traversal is best for solving puzzles like mazes and backtracking problems?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which of the following is the correct time complexity of Prim’s algorithm using a binary heap?",
    "c": null,
    "o": [
      "O(E log V)",
      "O(V^2)",
      "O(E^2)",
      "O(V + E)"
    ]
  },
  {
    "q": "What will happen if you run DFS on a graph with a cycle and do not mark visited nodes?",
    "c": null,
    "o": [
      "It may result in an infinite loop",
      "It will find the shortest path",
      "It will still terminate correctly",
      "It will skip some nodes"
    ]
  },
  {
    "q": "Which algorithm is **not** suitable for finding shortest paths in graphs with negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "BFS"
    ]
  },
  {
    "q": "In Prim’s algorithm, which node is selected next to expand the MST?",
    "c": null,
    "o": [
      "The node with the minimum weight edge connecting to the MST",
      "The node with maximum degree",
      "The node with the smallest ID",
      "Any random unvisited node"
    ]
  },
  {
    "q": "Which of the following is the output of Kruskal’s algorithm?",
    "c": null,
    "o": [
      "A set of edges forming a minimum spanning tree",
      "A topological ordering of the graph",
      "A shortest path from a source node",
      "A set of connected components"
    ]
  },
  {
    "q": "Which algorithm processes edges in increasing order of weight?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is a necessary condition for applying BFS or DFS to detect a cycle in an undirected graph?",
    "c": null,
    "o": [
      "Track the parent of each node during traversal",
      "Use a priority queue",
      "Only visit leaf nodes",
      "Sort the nodes first"
    ]
  },
  {
    "q": "In which scenario would BFS use more memory than DFS?",
    "c": null,
    "o": [
      "When the graph has many nodes at each level (i.e., wide graphs)",
      "When the graph is deep",
      "When the graph has cycles",
      "When edge weights are large"
    ]
  },
  {
    "q": "Which of these algorithms is a greedy algorithm used for shortest path finding?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "BFS",
      "DFS",
      "Union-Find"
    ]
  },
  {
    "q": "What is the primary criterion for adding an edge in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "It does not form a cycle with the already included edges",
      "It connects the lowest weight node",
      "It has the maximum cost",
      "It is adjacent to the previously added edge"
    ]
  },
  {
    "q": "What is the key purpose of using a priority queue in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "To efficiently get the next closest unvisited node",
      "To prevent cycles",
      "To sort edges",
      "To implement recursion"
    ]
  },
  {
    "q": "Which of the following is TRUE for Kruskal's algorithm?",
    "c": null,
    "o": [
      "It can generate a minimum spanning forest if the graph is disconnected",
      "It always requires a connected graph",
      "It uses DFS for traversal",
      "It cannot handle weighted graphs"
    ]
  },
  {
    "q": "What is the condition under which a node is added to the MST in Prim’s algorithm?",
    "c": null,
    "o": [
      "When it is connected with the minimum weight edge to the MST set",
      "When it has the maximum number of neighbors",
      "When its distance is infinite",
      "When it is the farthest node from the source"
    ]
  },
  {
    "q": "Which traversal is ideal for searching all vertices reachable from a given node in a shallow graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which of these graph algorithms does NOT involve any edge weights?",
    "c": null,
    "o": [
      "BFS",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "How does DFS ensure a node is not visited more than once?",
    "c": null,
    "o": [
      "By marking it as visited before visiting neighbors",
      "By checking degree of the node",
      "By limiting recursion depth",
      "By using a queue"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what condition guarantees the shortest path to a node is finalized?",
    "c": null,
    "o": [
      "When it is dequeued from the priority queue",
      "When it is inserted into the queue",
      "When all its neighbors are processed",
      "When the destination is found"
    ]
  },
  {
    "q": "Which algorithm builds the MST incrementally by adding the smallest edge that connects a new vertex?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the space complexity of BFS using an adjacency list?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(V)",
      "O(E^2)"
    ]
  },
  {
    "q": "In DFS, when are nodes added to the recursion stack?",
    "c": null,
    "o": [
      "Before exploring their neighbors",
      "After all neighbors are visited",
      "When they are visited a second time",
      "Only when cycles exist"
    ]
  },
  {
    "q": "Which of the following traversal methods can be used to check whether a graph is bipartite?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What happens in Kruskal’s algorithm when adding an edge forms a cycle?",
    "c": null,
    "o": [
      "The edge is discarded",
      "The edge is marked temporarily",
      "The edge weight is increased",
      "The algorithm restarts"
    ]
  },
  {
    "q": "Which algorithm requires sorting of all edges before processing?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm explores all nodes reachable from the source before moving deeper?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "What is the main difference between BFS and Dijkstra's algorithm in implementation?",
    "c": null,
    "o": [
      "BFS uses a queue; Dijkstra’s uses a priority queue",
      "BFS is recursive; Dijkstra’s is not",
      "BFS sorts the graph first; Dijkstra’s does not",
      "Dijkstra’s uses a stack; BFS does not"
    ]
  },
  {
    "q": "Which of the following is TRUE about DFS and BFS?",
    "c": null,
    "o": [
      "DFS uses a stack; BFS uses a queue",
      "Both use queues",
      "DFS guarantees shortest path; BFS does not",
      "BFS uses recursion"
    ]
  },
  {
    "q": "Which algorithm adds the smallest edge connecting any two different components?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "When using DFS for cycle detection in a directed graph, which condition indicates a cycle?",
    "c": null,
    "o": [
      "A visited node is found in the recursion stack",
      "An unvisited node has no outgoing edges",
      "A node is revisited through BFS",
      "An edge weight is negative"
    ]
  },
  {
    "q": "Which condition is required for BFS to find the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "All edge weights must be equal or irrelevant",
      "Graph must be acyclic",
      "Graph must be weighted",
      "DFS must be run first"
    ]
  },
  {
    "q": "Which of the following algorithms can be used to detect connected components in an undirected graph?",
    "c": null,
    "o": [
      "Both DFS and BFS",
      "Only DFS",
      "Only BFS",
      "Only Dijkstra’s"
    ]
  },
  {
    "q": "Which traversal method is best suited for checking whether a graph is connected?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "What is the purpose of the 'visited' set in DFS and BFS?",
    "c": null,
    "o": [
      "To avoid revisiting the same node",
      "To store the shortest path",
      "To sort the nodes",
      "To calculate edge weights"
    ]
  },
  {
    "q": "Which algorithm is most efficient for finding the MST in a dense graph with many vertices?",
    "c": null,
    "o": [
      "Prim’s Algorithm (with adjacency matrix)",
      "Kruskal’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of BFS?",
    "c": null,
    "o": [
      "It uses a stack for implementation",
      "It explores neighbors level by level",
      "It uses a queue",
      "It can find the shortest path in unweighted graphs"
    ]
  },
  {
    "q": "Which statement about Dijkstra’s algorithm is correct?",
    "c": null,
    "o": [
      "It always finds the shortest path from the source to all vertices in a weighted graph with non-negative weights",
      "It works even with negative edge weights",
      "It only finds a single shortest path",
      "It builds a spanning tree"
    ]
  },
  {
    "q": "Which condition is used to skip an edge in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "If it forms a cycle with the MST built so far",
      "If it is a self-loop",
      "If its weight is higher than a threshold",
      "If it is the longest edge"
    ]
  },
  {
    "q": "What is the role of the recursion stack in DFS cycle detection for a directed graph?",
    "c": null,
    "o": [
      "It helps identify back edges that indicate cycles",
      "It stores visited nodes permanently",
      "It stores edge weights temporarily",
      "It avoids adding duplicate edges"
    ]
  },
  {
    "q": "What is the maximum number of edges in a spanning tree of a connected graph with V vertices?",
    "c": null,
    "o": [
      "V - 1",
      "V",
      "V + 1",
      "E"
    ]
  },
  {
    "q": "Which algorithm guarantees no cycle in the result by checking set membership?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which traversal is preferred for shallow and wide graphs to avoid memory overflow?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which algorithm is suitable for traversing a graph to find all nodes connected to a source in minimum steps?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What does the 'find' operation do in the Union-Find structure used in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Determines which component a node belongs to",
      "Adds a node to a queue",
      "Sorts all the graph edges",
      "Builds a minimum spanning tree"
    ]
  },
  {
    "q": "What is the result of running DFS on a tree with no cycles?",
    "c": null,
    "o": [
      "All nodes are visited exactly once",
      "Some nodes are skipped",
      "A cycle is detected",
      "Only leaf nodes are visited"
    ]
  },
  {
    "q": "Why is Dijkstra’s algorithm not suitable for graphs with negative weights?",
    "c": null,
    "o": [
      "Because it assumes once a node’s shortest path is found, it will not change",
      "Because it uses DFS internally",
      "Because it doesn’t use a visited set",
      "Because it removes all negative edges before processing"
    ]
  },
  {
    "q": "Which algorithm builds a spanning tree by always choosing the smallest available edge that connects to the tree?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is NOT required for Prim’s algorithm?",
    "c": null,
    "o": [
      "Sorting all edges before processing",
      "Priority queue (in optimized versions)",
      "Visited set or MST set",
      "Graph connectivity"
    ]
  },
  {
    "q": "In BFS, what ensures that each node is visited only once?",
    "c": null,
    "o": [
      "Maintaining a visited set",
      "Using a stack",
      "Adding nodes based on weight",
      "Marking nodes recursively"
    ]
  },
  {
    "q": "Which of the following is a correct base condition in a recursive DFS?",
    "c": null,
    "o": [
      "If the current node has already been visited, return",
      "If the current node is unvisited, return",
      "If the edge weight is zero, return",
      "If the graph is disconnected, return"
    ]
  },
  {
    "q": "What is the output of a BFS traversal on a graph with a single node?",
    "c": null,
    "o": [
      "Only the single node is visited",
      "No nodes are visited",
      "It enters an infinite loop",
      "All nodes are skipped"
    ]
  },
  {
    "q": "Which traversal is likely to go deeper into the graph quickly?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which algorithm can help detect cycles in an undirected graph?",
    "c": null,
    "o": [
      "DFS with parent tracking",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s without union-find"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Kruskal's algorithm when edges are sorted using a comparison-based sort?",
    "c": null,
    "o": [
      "O(E log E)",
      "O(V^2)",
      "O(E + V)",
      "O(V log V)"
    ]
  },
  {
    "q": "Which of the following operations is used to merge components in Kruskal's algorithm?",
    "c": null,
    "o": [
      "Union",
      "Find",
      "Insert",
      "Extract-Min"
    ]
  },
  {
    "q": "Which traversal is best used for solving word ladder or shortest transformation problems?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which algorithm does NOT require the graph to be connected to work correctly?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "What is the key reason Dijkstra’s algorithm fails with negative weight edges?",
    "c": null,
    "o": [
      "It assumes once a node is processed, its shortest path is final",
      "It requires sorted edges",
      "It uses a max heap",
      "It doesn’t explore all neighbors"
    ]
  },
  {
    "q": "Which algorithm can be used to detect back edges in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS with level tracking",
      "Dijkstra’s with path array",
      "Prim’s with visited array"
    ]
  },
  {
    "q": "In BFS traversal, what condition allows early stopping when searching for a specific node?",
    "c": null,
    "o": [
      "If the target node is found while dequeuing",
      "When all nodes are visited",
      "When edge weight exceeds a threshold",
      "When recursion stack is full"
    ]
  },
  {
    "q": "Which of the following is true about DFS traversal on a tree?",
    "c": null,
    "o": [
      "It will visit all nodes without revisiting any node",
      "It will detect cycles",
      "It needs a visited set",
      "It works only on directed trees"
    ]
  },
  {
    "q": "Which of the following algorithms builds the MST without knowing the number of vertices upfront?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which data structure is primarily used in BFS to maintain traversal order?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Set"
    ]
  },
  {
    "q": "What does Prim’s algorithm do when there are multiple edges with the same weight?",
    "c": null,
    "o": [
      "It picks any one that connects to the MST without forming a cycle",
      "It throws an error",
      "It discards all such edges",
      "It chooses the edge with higher vertex ID"
    ]
  },
  {
    "q": "How can DFS be implemented without recursion?",
    "c": null,
    "o": [
      "Using a stack",
      "Using a queue",
      "Using a priority queue",
      "Using a heap"
    ]
  },
  {
    "q": "Which operation is used in Kruskal’s algorithm to determine if two nodes are in the same component?",
    "c": null,
    "o": [
      "Find",
      "Union",
      "Insert",
      "Enqueue"
    ]
  },
  {
    "q": "Which of these algorithms would be least efficient for very dense graphs with many edges?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm with adjacency matrix",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "Which graph algorithm works efficiently on both directed and undirected graphs for traversal?",
    "c": null,
    "o": [
      "DFS",
      "Prim’s",
      "Kruskal’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "In a connected undirected graph, which of the following algorithms will always visit all vertices?",
    "c": null,
    "o": [
      "BFS",
      "Kruskal’s",
      "Dijkstra’s with early exit",
      "None of the above"
    ]
  },
  {
    "q": "Which traversal method explores nodes by depth before breadth?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "What is the goal of Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "To find the shortest path from a source to all other vertices",
      "To create a spanning tree",
      "To detect cycles",
      "To find the minimum number of edges in a path"
    ]
  },
  {
    "q": "Which algorithm uses a greedy strategy and maintains disjoint sets to construct the MST?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "BFS",
      "DFS"
    ]
  },
  {
    "q": "What is the purpose of using a priority queue in Prim’s algorithm?",
    "c": null,
    "o": [
      "To efficiently select the edge with the minimum weight connecting to the MST",
      "To sort all edges in advance",
      "To store visited nodes",
      "To implement recursive calls"
    ]
  },
  {
    "q": "Which of the following statements about BFS is FALSE?",
    "c": null,
    "o": [
      "It can be used to detect cycles in a graph by using parent tracking",
      "It always uses a stack to implement traversal",
      "It visits nodes level by level",
      "It is suitable for finding the shortest path in unweighted graphs"
    ]
  },
  {
    "q": "How does DFS differ from BFS in terms of data structure usage?",
    "c": null,
    "o": [
      "DFS uses a stack; BFS uses a queue",
      "DFS uses a queue; BFS uses a stack",
      "Both use a queue",
      "DFS and BFS use priority queues"
    ]
  },
  {
    "q": "What is the main idea behind Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Relax edges and update distances using a priority queue",
      "Explore each node’s depth fully before moving on",
      "Choose the largest edge at each step",
      "Randomly select the next node"
    ]
  },
  {
    "q": "Which of these algorithms builds a spanning tree by continuously adding the least expensive edge from any tree vertex?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "In Kruskal’s algorithm, what ensures no cycles are formed when adding a new edge?",
    "c": null,
    "o": [
      "Using the Union-Find data structure",
      "Tracking levels with BFS",
      "Depth-first backtracking",
      "Priority queue of vertex distances"
    ]
  },
  {
    "q": "Which of the following is typically used to improve the efficiency of Dijkstra's algorithm?",
    "c": null,
    "o": [
      "Min-Heap (Priority Queue)",
      "Union-Find Set",
      "Stack",
      "Disjoint Graph"
    ]
  },
  {
    "q": "Which of the following graph algorithms can produce a forest instead of a single spanning tree when the graph is not connected?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "Which of the following is NOT a necessary step in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Discarding negative weight edges",
      "Updating shortest distances",
      "Using a priority queue",
      "Adding all nodes into a recursion stack"
    ]
  },
  {
    "q": "Which traversal is more memory efficient for very deep graphs?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "Which of the following traversal methods is more suitable for pathfinding in unweighted graphs?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What is the time complexity of DFS in an adjacency list representation?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(E^2)"
    ]
  },
  {
    "q": "Which of the following algorithms is based on edge relaxation?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure is ideal for implementing Prim’s algorithm efficiently on sparse graphs?",
    "c": null,
    "o": [
      "Min Heap (Priority Queue)",
      "Max Heap",
      "Simple Queue",
      "Stack"
    ]
  },
  {
    "q": "In Kruskal’s algorithm, how are cycles avoided?",
    "c": null,
    "o": [
      "Using Union-Find to check connected components",
      "Using a visited set",
      "Marking edge weights",
      "Applying DFS after every insertion"
    ]
  },
  {
    "q": "Which algorithm updates shortest path estimates by choosing the next closest unvisited node?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What distinguishes Kruskal’s algorithm from Prim’s algorithm?",
    "c": null,
    "o": [
      "Kruskal’s works edge by edge; Prim’s builds from a single node",
      "Kruskal’s uses recursion; Prim’s does not",
      "Prim’s can work with disconnected graphs; Kruskal’s cannot",
      "Kruskal’s always produces longer MSTs"
    ]
  },
  {
    "q": "What condition indicates a cycle during DFS in a directed graph?",
    "c": null,
    "o": [
      "Visiting a node already in the recursion stack",
      "Encountering a self-loop",
      "Traversing an edge more than once",
      "Reaching a node with no outgoing edges"
    ]
  },
  {
    "q": "Which of the following is a greedy algorithm used for MST construction?",
    "c": null,
    "o": [
      "Both Prim’s and Kruskal’s",
      "Only Prim’s",
      "Only Kruskal’s",
      "Only Dijkstra’s"
    ]
  },
  {
    "q": "Which traversal method can be used for solving topological sorting?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which of the following graph algorithms is most suitable for finding a shortest path in a maze?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which of these is a valid base case to avoid infinite recursion in DFS?",
    "c": null,
    "o": [
      "Check if node is already visited before recursive call",
      "Check if graph is disconnected",
      "Check if node has more than two neighbors",
      "Ensure the recursion depth is even"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what happens when all remaining unvisited nodes are unreachable?",
    "c": null,
    "o": [
      "The algorithm terminates",
      "The algorithm resets all distances",
      "It throws an error",
      "It backtracks to the start node"
    ]
  },
  {
    "q": "What does BFS guarantee when used on an unweighted graph?",
    "c": null,
    "o": [
      "The shortest path in terms of number of edges",
      "The minimum cost path",
      "The deepest traversal path",
      "The maximum spanning tree"
    ]
  },
  {
    "q": "What is a key difference between Kruskal’s and Prim’s algorithm in terms of structure?",
    "c": null,
    "o": [
      "Kruskal’s works with edges; Prim’s works with vertices",
      "Kruskal’s only works with directed graphs",
      "Prim’s requires edge sorting; Kruskal’s does not",
      "Prim’s creates multiple trees"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of BFS?",
    "c": null,
    "o": [
      "It uses more memory in wide graphs",
      "It cannot be used for shortest path problems",
      "It does not visit all nodes",
      "It always gets stuck in cycles"
    ]
  },
  {
    "q": "What role does the union-find structure play in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "It prevents adding edges that form cycles",
      "It tracks shortest paths",
      "It performs topological sorting",
      "It checks node degrees"
    ]
  },
  {
    "q": "Which graph algorithm is likely to use a recursive approach by default?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "Which traversal is more efficient for finding paths in deep but narrow graphs?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "What is required for Prim’s algorithm to begin execution?",
    "c": null,
    "o": [
      "A starting node",
      "Sorted list of edges",
      "A list of components",
      "A recursion stack"
    ]
  },
  {
    "q": "Which of the following best describes the working of Kruskal's algorithm?",
    "c": null,
    "o": [
      "Greedily adds the smallest edge that doesn't form a cycle",
      "Selects the shortest path from the source",
      "Adds all adjacent nodes of the root node first",
      "Explores nodes based on depth"
    ]
  },
  {
    "q": "In DFS, what happens if you forget to mark a node as visited?",
    "c": null,
    "o": [
      "The algorithm may enter an infinite loop",
      "All nodes will be skipped",
      "Traversal will be faster",
      "You will get a spanning tree"
    ]
  },
  {
    "q": "Which algorithm uses the concept of 'greedy edge addition' from an already visited subset of nodes?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "What happens in BFS if you don’t use a visited set or array?",
    "c": null,
    "o": [
      "Some nodes may be visited multiple times",
      "It always finds a cycle",
      "It stops immediately",
      "The graph gets sorted"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "It works with negative edge weights",
      "It finds shortest paths",
      "It uses a priority queue",
      "It updates tentative distances"
    ]
  },
  {
    "q": "Which data structure can be used to optimize the Union-Find operations in Kruskal's algorithm?",
    "c": null,
    "o": [
      "Disjoint Set with path compression",
      "Simple queue",
      "Hash table",
      "Linked list"
    ]
  },
  {
    "q": "What is the main goal of using edge relaxation in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "To find a shorter path to a neighbor node",
      "To balance the graph",
      "To avoid recursion",
      "To discard unused nodes"
    ]
  },
  {
    "q": "Which of the following is TRUE about DFS traversal?",
    "c": null,
    "o": [
      "It explores as far as possible along a branch before backtracking",
      "It uses a queue by default",
      "It always finds the shortest path",
      "It can’t be used in disconnected graphs"
    ]
  },
  {
    "q": "Which type of graph traversal is ideal for finding the shortest number of moves in a chessboard problem?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "When performing DFS on a directed graph, which condition indicates a back edge and hence a cycle?",
    "c": null,
    "o": [
      "Visiting a node already in the recursion stack",
      "Finding a node with degree 2",
      "Traversing an edge with higher weight",
      "Using a self-loop"
    ]
  },
  {
    "q": "Which of the following algorithms is best suited for computing single-source shortest paths in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "Which type of graph does Prim's algorithm require to work correctly?",
    "c": null,
    "o": [
      "Connected graph",
      "Directed acyclic graph",
      "Unweighted graph",
      "Disconnected graph"
    ]
  },
  {
    "q": "Which of the following graph algorithms always produces a tree with minimum total edge weight?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "DFS",
      "BFS",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What does the priority queue store in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Nodes with their current shortest distance estimates",
      "Sorted list of edges",
      "Final path from source to destination",
      "Only visited nodes"
    ]
  },
  {
    "q": "What is the worst-case time complexity of BFS in an adjacency list?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(VE)"
    ]
  },
  {
    "q": "Which of these algorithms is not guaranteed to visit all edges of a graph?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "BFS",
      "DFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What will be the output of running DFS on a tree with no cycles?",
    "c": null,
    "o": [
      "A traversal that visits all nodes once",
      "A list of only the leaf nodes",
      "A list of disconnected components",
      "Nothing—it will terminate early"
    ]
  },
  {
    "q": "In Kruskal’s algorithm, what is the initial step before any edge selection?",
    "c": null,
    "o": [
      "Sort all edges by weight",
      "Start from an arbitrary node",
      "Mark all nodes as visited",
      "Initialize shortest path values"
    ]
  },
  {
    "q": "Which traversal would be ideal to find if a route exists between two cities in a transportation network?",
    "c": null,
    "o": [
      "BFS",
      "Kruskal’s",
      "Prim’s",
      "Bellman-Ford"
    ]
  },
  {
    "q": "Which algorithm explores paths by always choosing the locally optimal edge hoping to find a global minimum?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "DFS",
      "Topological Sort",
      "Floyd-Warshall"
    ]
  },
  {
    "q": "Which traversal algorithm is guaranteed to visit the shallowest nodes first?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what is updated during each iteration?",
    "c": null,
    "o": [
      "The shortest distance of neighboring nodes",
      "The degree of each vertex",
      "The number of connected components",
      "The total weight of the MST"
    ]
  },
  {
    "q": "What kind of edges are added to the MST during Prim’s algorithm?",
    "c": null,
    "o": [
      "Edges with minimum weight connecting to the current tree",
      "The longest edges from the graph",
      "Edges from unvisited components only",
      "Edges forming cycles to improve cost"
    ]
  },
  {
    "q": "Which algorithm is used to detect a cycle in an undirected graph efficiently?",
    "c": null,
    "o": [
      "DFS with parent check",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s without union-find"
    ]
  },
  {
    "q": "Which algorithm assumes all edge weights are non-negative?",
    "c": null,
    "o": [
      "Dijkstra’s",
      "Bellman-Ford",
      "DFS",
      "Kruskal’s"
    ]
  },
  {
    "q": "What will DFS return if run on a disconnected graph?",
    "c": null,
    "o": [
      "Only one connected component",
      "All vertices in the graph",
      "All shortest paths",
      "A minimum spanning tree"
    ]
  },
  {
    "q": "Which of the following algorithms can work without a priority queue?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s (optimized)",
      "None of the above"
    ]
  },
  {
    "q": "In a BFS traversal, what happens when all nodes in the current level are explored?",
    "c": null,
    "o": [
      "The next level nodes are added to the queue",
      "DFS is initiated",
      "Traversal terminates",
      "Graph is converted to a tree"
    ]
  },
  {
    "q": "What will Prim’s algorithm always return for a connected weighted undirected graph?",
    "c": null,
    "o": [
      "A Minimum Spanning Tree",
      "A Maximum Spanning Tree",
      "A Shortest Path Tree",
      "A Cycle Cover"
    ]
  },
  {
    "q": "In Kruskal’s algorithm, which step helps maintain separate components before merging?",
    "c": null,
    "o": [
      "Using disjoint sets (union-find)",
      "Tracking with DFS stack",
      "Building a heap",
      "Recursive traversal"
    ]
  },
  {
    "q": "What type of graph is required for Dijkstra's algorithm to work correctly?",
    "c": null,
    "o": [
      "A graph with non-negative edge weights",
      "A tree",
      "A disconnected graph",
      "A cyclic graph with negative weights"
    ]
  },
  {
    "q": "What does a 'back edge' in DFS indicate when exploring a directed graph?",
    "c": null,
    "o": [
      "A cycle exists",
      "A bridge",
      "A tree edge",
      "A shortest path"
    ]
  },
  {
    "q": "Which traversal method is ideal for detecting connected components in an undirected graph?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "In Prim’s algorithm, how is the next edge chosen?",
    "c": null,
    "o": [
      "It connects the tree to a non-tree vertex with the minimum weight",
      "It connects two unvisited nodes",
      "It connects two visited nodes",
      "It is the longest edge"
    ]
  },
  {
    "q": "Which of the following algorithms builds a forest when the graph is not connected?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What would happen if cycles were not avoided in Kruskal's algorithm?",
    "c": null,
    "o": [
      "The resulting structure wouldn't be a tree",
      "The algorithm would terminate early",
      "The graph would be disconnected",
      "The shortest path would be incorrect"
    ]
  },
  {
    "q": "Which of the following algorithms is suitable for solving the minimum cost to connect all computers in a network?",
    "c": null,
    "o": [
      "Prim’s or Kruskal’s",
      "Dijkstra’s",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "Which graph traversal method can result in visiting fewer nodes if stopped early upon reaching the target?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What is a tree edge in DFS traversal?",
    "c": null,
    "o": [
      "An edge used to discover a new vertex",
      "An edge connecting two visited vertices",
      "An edge forming a cycle",
      "An edge that points to an ancestor"
    ]
  },
  {
    "q": "Which algorithm initializes distances of all vertices to infinity at the start?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms is primarily used for finding the shortest path in a road network with all positive weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS"
    ]
  },
  {
    "q": "What is the output of Kruskal’s algorithm when applied on a graph with multiple components?",
    "c": null,
    "o": [
      "A minimum spanning forest",
      "A single spanning tree",
      "All cycles removed",
      "Shortest path between components"
    ]
  },
  {
    "q": "Which of the following traversal strategies can be used to perform a level order traversal of a tree?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which component does Prim’s algorithm rely on to always choose the next minimum edge efficiently?",
    "c": null,
    "o": [
      "Priority Queue (Min-Heap)",
      "Recursion stack",
      "Union-Find",
      "Adjacency Matrix"
    ]
  },
  {
    "q": "Which traversal method will exhaustively explore all possible paths before backtracking?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "What is the main difference between BFS and DFS in terms of memory usage?",
    "c": null,
    "o": [
      "BFS typically uses more memory due to storing all current-level nodes",
      "DFS uses more memory due to storing all possible paths",
      "Both use equal memory",
      "DFS does not use memory"
    ]
  },
  {
    "q": "In a graph with 'n' nodes and 'n-1' edges, which traversal will always visit every node without redundancy?",
    "c": null,
    "o": [
      "DFS",
      "Prim’s",
      "Kruskal’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "Which of the following is a valid property of a minimum spanning tree?",
    "c": null,
    "o": [
      "It connects all vertices with minimum total edge weight and no cycles",
      "It finds the shortest path between two nodes",
      "It covers only part of the graph",
      "It has the most number of edges possible"
    ]
  },
  {
    "q": "Which algorithm will fail to produce correct results if the graph contains negative weight edges?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "Which of the following best describes the goal of BFS in an unweighted graph?",
    "c": null,
    "o": [
      "To find the shortest path in terms of number of edges",
      "To discover cycles",
      "To build a minimum spanning tree",
      "To explore all weighted paths"
    ]
  },
  {
    "q": "Which of the following traversal algorithms is most appropriate for solving a puzzle with only one solution path?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which graph algorithm works by visiting the node with the minimum current cost estimate?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "Kruskal’s Algorithm",
      "BFS"
    ]
  },
  {
    "q": "What is the main advantage of using BFS over DFS in unweighted graphs?",
    "c": null,
    "o": [
      "It finds the shortest path in terms of number of edges",
      "It uses less memory",
      "It avoids cycles better",
      "It can handle disconnected graphs"
    ]
  },
  {
    "q": "Which of the following is an edge that connects two vertices already in the MST in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "A cycle-forming edge",
      "A bridge",
      "A cross edge",
      "A tree edge"
    ]
  },
  {
    "q": "In DFS, which scenario will lead to the deepest recursion?",
    "c": null,
    "o": [
      "A linear graph (like a linked list)",
      "A complete graph",
      "A tree with many leaves",
      "A graph with no edges"
    ]
  },
  {
    "q": "Why is a visited set or array important in DFS and BFS?",
    "c": null,
    "o": [
      "To avoid infinite loops due to cycles",
      "To track path costs",
      "To create adjacency lists",
      "To calculate degrees"
    ]
  },
  {
    "q": "Which algorithm ensures that no two vertices in the MST are already connected before adding an edge?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "What condition ensures that BFS traversal completes successfully in a connected graph?",
    "c": null,
    "o": [
      "All nodes are reachable from the starting node",
      "No negative weights exist",
      "The graph is acyclic",
      "The graph is directed"
    ]
  },
  {
    "q": "Which structure helps track parent-child relationships in a DFS tree?",
    "c": null,
    "o": [
      "Recursion stack",
      "Priority queue",
      "Union-Find",
      "Degree list"
    ]
  },
  {
    "q": "What happens when DFS is applied to a tree data structure?",
    "c": null,
    "o": [
      "All nodes will be visited exactly once",
      "Only leaf nodes are visited",
      "Some edges are skipped",
      "It cannot be applied"
    ]
  },
  {
    "q": "Which algorithm is used to find the shortest path from a source to all vertices in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "In BFS, which nodes are explored first?",
    "c": null,
    "o": [
      "The nodes closest to the starting node",
      "The nodes farthest from the starting node",
      "Random nodes",
      "Leaf nodes only"
    ]
  },
  {
    "q": "What is the stopping condition in Dijkstra’s algorithm when searching for a shortest path to a specific target?",
    "c": null,
    "o": [
      "When the target node is dequeued from the priority queue",
      "When all nodes are visited",
      "When the target node is first seen",
      "When a cycle is detected"
    ]
  },
  {
    "q": "What is the total number of edges in a Minimum Spanning Tree of a connected graph with N nodes?",
    "c": null,
    "o": [
      "N - 1",
      "N",
      "2N - 1",
      "Depends on the edge weights"
    ]
  },
  {
    "q": "Which of the following algorithms does NOT consider edge weights while traversing?",
    "c": null,
    "o": [
      "BFS",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "In DFS, which traversal order is used by default?",
    "c": null,
    "o": [
      "Pre-order",
      "In-order",
      "Post-order",
      "Level-order"
    ]
  },
  {
    "q": "Which of these is true about Prim’s algorithm?",
    "c": null,
    "o": [
      "It grows the MST one edge at a time from an arbitrary start node",
      "It first sorts all edges by weight",
      "It cannot handle disconnected graphs",
      "It produces cycles if not careful"
    ]
  },
  {
    "q": "Which condition is checked in Union-Find to avoid cycles in Kruskal's algorithm?",
    "c": null,
    "o": [
      "If two vertices are already in the same set",
      "If the edge weight is zero",
      "If the degree of a vertex is high",
      "If the graph is acyclic"
    ]
  },
  {
    "q": "Which traversal is ideal when the shortest path in number of hops is required?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What makes Dijkstra’s algorithm greedy?",
    "c": null,
    "o": [
      "It always selects the node with the smallest tentative distance",
      "It explores all nodes in increasing order",
      "It creates an MST",
      "It uses recursion to minimize edge weights"
    ]
  },
  {
    "q": "Which of the following is a correct application of BFS?",
    "c": null,
    "o": [
      "Finding the shortest path in unweighted graphs",
      "Finding minimum spanning trees",
      "Topological sorting",
      "Cycle detection in directed graphs"
    ]
  },
  {
    "q": "What is the maximum number of edges in a Minimum Spanning Tree of a graph with 20 vertices?",
    "c": null,
    "o": [
      "19",
      "20",
      "38",
      "18"
    ]
  },
  {
    "q": "Which graph algorithm works efficiently when the graph is dense and the edge weights are small?",
    "c": null,
    "o": [
      "Prim’s with adjacency matrix",
      "Kruskal’s with sorted edges",
      "BFS",
      "DFS"
    ]
  },
  {
    "q": "Which of the following algorithms can be used to check if a graph is bipartite?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Kruskal’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "Which data structure is commonly used for implementing Kruskal’s algorithm efficiently?",
    "c": null,
    "o": [
      "Disjoint Set Union (Union-Find)",
      "Stack",
      "Queue",
      "Priority Queue"
    ]
  },
  {
    "q": "What is the goal of edge relaxation in Dijkstra's algorithm?",
    "c": null,
    "o": [
      "To update the shortest distance if a better path is found",
      "To remove unused edges",
      "To build the MST",
      "To check for cycles"
    ]
  },
  {
    "q": "In a connected undirected graph, what does BFS ensure about the visited nodes?",
    "c": null,
    "o": [
      "They are visited in increasing distance from the source",
      "They are visited based on weights",
      "They form a cycle",
      "They are all leaf nodes"
    ]
  },
  {
    "q": "Which traversal is more memory-intensive in a graph with a very wide branching factor?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What happens if Prim’s algorithm is applied to a disconnected graph?",
    "c": null,
    "o": [
      "It only returns the MST of the connected component containing the start node",
      "It returns an error",
      "It returns all possible spanning trees",
      "It converts the graph into a DAG"
    ]
  },
  {
    "q": "Which traversal will always find a path if one exists and terminate immediately on reaching the goal?",
    "c": null,
    "o": [
      "BFS (with early stopping)",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which of the following graph algorithms guarantees no cycles in the result?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "In BFS, which data structure is typically used?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Set"
    ]
  },
  {
    "q": "What kind of traversal is typically used to solve maze-like problems?",
    "c": null,
    "o": [
      "DFS",
      "Prim’s",
      "Kruskal’s",
      "Topological Sort"
    ]
  },
  {
    "q": "What is the primary criterion for edge selection in Prim’s algorithm?",
    "c": null,
    "o": [
      "Minimum weight connecting a tree node to a non-tree node",
      "Maximum weight in the graph",
      "Unvisited nodes in DFS order",
      "Shortest path from the root"
    ]
  },
  {
    "q": "Which of the following algorithms is not directly affected by edge weights?",
    "c": null,
    "o": [
      "BFS",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which algorithm is suitable for finding connected components in a graph?",
    "c": null,
    "o": [
      "DFS or BFS",
      "Prim’s",
      "Dijkstra’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "In Kruskal's algorithm, after sorting edges, what determines if an edge is added?",
    "c": null,
    "o": [
      "Whether the edge connects two different sets",
      "Whether the edge is the lightest",
      "Whether the edge is connected to the source",
      "Whether the degree of the node is less than 2"
    ]
  },
  {
    "q": "What is the function of the 'visited' set in DFS?",
    "c": null,
    "o": [
      "To prevent revisiting nodes and avoid infinite recursion",
      "To store the order of traversal",
      "To store the cost of each edge",
      "To check for edge weights"
    ]
  },
  {
    "q": "Which traversal technique is used to implement topological sorting?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Dijkstra’s"
    ]
  },
  {
    "q": "What makes Dijkstra’s algorithm different from BFS?",
    "c": null,
    "o": [
      "It considers edge weights",
      "It uses recursion",
      "It explores all paths equally",
      "It builds an MST"
    ]
  },
  {
    "q": "Which of the following conditions is true for a graph to have a valid Minimum Spanning Tree?",
    "c": null,
    "o": [
      "The graph must be connected and undirected",
      "The graph must be directed and weighted",
      "The graph must have negative weights",
      "The graph must be acyclic"
    ]
  },
  {
    "q": "Which algorithm is best for traversing a graph to find whether a path exists between two nodes in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "Dijkstra’s",
      "Kruskal’s",
      "Prim’s"
    ]
  },
  {
    "q": "What is the purpose of using a priority queue in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "To efficiently retrieve the next node with the smallest tentative distance",
      "To store the visited nodes",
      "To sort edges by weight",
      "To maintain the recursive path"
    ]
  },
  {
    "q": "What is the time complexity of Kruskal’s algorithm when using Union-Find with path compression?",
    "c": null,
    "o": [
      "O(E log V)",
      "O(V^2)",
      "O(E + V)",
      "O(V log V)"
    ]
  },
  {
    "q": "Which of the following is FALSE about Prim’s algorithm?",
    "c": null,
    "o": [
      "It can work with disconnected graphs and return a complete MST",
      "It uses a greedy approach",
      "It always starts from a selected node",
      "It adds the smallest weight edge that connects to the MST"
    ]
  },
  {
    "q": "How does Kruskal’s algorithm ensure that the MST has no cycles?",
    "c": null,
    "o": [
      "By using Union-Find to check if nodes are in the same component",
      "By using DFS during edge addition",
      "By checking degrees of vertices",
      "By traversing the graph level by level"
    ]
  },
  {
    "q": "What is the output of Dijkstra’s algorithm when applied to a weighted graph?",
    "c": null,
    "o": [
      "Shortest distance from the source node to all other nodes",
      "Minimum spanning tree",
      "Topological ordering of nodes",
      "Set of connected components"
    ]
  },
  {
    "q": "Which algorithm is guaranteed to find a globally optimal solution in shortest-path problems without negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What does BFS use to ensure that all nodes are visited in increasing distance from the source?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Recursion"
    ]
  },
  {
    "q": "Which graph algorithm is most likely to be used for designing network cabling systems with minimal cost?",
    "c": null,
    "o": [
      "Kruskal’s or Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "What kind of data structure is best suited for implementing DFS?",
    "c": null,
    "o": [
      "Stack",
      "Queue",
      "Heap",
      "Priority Queue"
    ]
  },
  {
    "q": "Which of the following is NOT a correct step in Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "Update the distances using only unvisited neighbors with non-negative weights",
      "Remove the node with the smallest distance from the priority queue",
      "Add all visited nodes back into the queue",
      "Set the distance of the source node to zero"
    ]
  },
  {
    "q": "Which of the following algorithms can be used to detect a cycle in a graph?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Prim’s",
      "BFS"
    ]
  },
  {
    "q": "Which of the following conditions can cause Dijkstra’s algorithm to produce incorrect results?",
    "c": null,
    "o": [
      "Presence of negative weight edges",
      "Disconnected components",
      "Positive edge weights",
      "Unweighted graphs"
    ]
  },
  {
    "q": "Which graph algorithm uses edge sorting as its initial step?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "BFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "What is the output of DFS when applied to a graph with multiple disconnected components?",
    "c": null,
    "o": [
      "Traversal of a single connected component unless called again for each unvisited node",
      "Traversal of all nodes regardless of connection",
      "A minimum spanning tree",
      "A shortest path tree"
    ]
  },
  {
    "q": "Which of the following is a property of BFS traversal in an unweighted graph?",
    "c": null,
    "o": [
      "It finds the shortest path in terms of number of edges",
      "It minimizes total edge weights",
      "It works only with DAGs",
      "It avoids revisiting all nodes"
    ]
  },
  {
    "q": "Which graph traversal algorithm would use recursion most naturally?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s",
      "Prim’s"
    ]
  },
  {
    "q": "In Prim’s algorithm, what happens when all adjacent edges of a vertex are already in the MST?",
    "c": null,
    "o": [
      "The algorithm selects the next lightest edge connecting the MST to a new node",
      "The algorithm terminates",
      "The graph is reset",
      "The priority queue is cleared"
    ]
  },
  {
    "q": "What kind of edge in DFS connects a node to its ancestor in the DFS tree?",
    "c": null,
    "o": [
      "Back edge",
      "Tree edge",
      "Forward edge",
      "Cross edge"
    ]
  },
  {
    "q": "Which graph traversal algorithm explores all neighbors before moving to the next level?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "In which scenario would Kruskal's algorithm and Prim's algorithm produce different MSTs?",
    "c": null,
    "o": [
      "When the graph has multiple MSTs with equal total weight",
      "When the graph is disconnected",
      "When the graph is directed",
      "When all edge weights are unique"
    ]
  },
  {
    "q": "Which algorithm will always produce a connected graph as output (assuming input is connected)?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "DFS",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "What structure is best suited to improve Kruskal’s algorithm performance in cycle detection?",
    "c": null,
    "o": [
      "Union-Find",
      "Priority Queue",
      "Stack",
      "Queue"
    ]
  },
  {
    "q": "Which of the following is NOT true about Dijkstra’s algorithm?",
    "c": null,
    "o": [
      "It works with negative weight edges",
      "It uses a greedy approach",
      "It finds the shortest distance from a source",
      "It updates distance estimates when a better path is found"
    ]
  },
  {
    "q": "Which traversal ensures that all paths with equal edge count are explored evenly from the source node?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "Which graph algorithm does not require the graph to be weighted?",
    "c": null,
    "o": [
      "DFS",
      "Dijkstra’s",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "How many edges will be there in a Minimum Spanning Tree for a graph with 100 nodes?",
    "c": null,
    "o": [
      "99",
      "100",
      "98",
      "101"
    ]
  },
  {
    "q": "Which algorithm is more efficient for finding MST in a graph with dense connections?",
    "c": null,
    "o": [
      "Prim’s using adjacency matrix",
      "Kruskal’s using sorted edge list",
      "DFS",
      "Dijkstra’s with min heap"
    ]
  },
  {
    "q": "Which condition leads DFS to visit the maximum number of nodes before backtracking?",
    "c": null,
    "o": [
      "When the graph is a straight path (like a linked list)",
      "When the graph is fully connected",
      "When all nodes have self-loops",
      "When no edges are present"
    ]
  },
    {
        "q": "Which algorithm uses a queue data structure for traversal?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "Which algorithm is based on recursion and uses a stack (implicitly)?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which of the following algorithms guarantees the shortest path in a weighted graph with non-negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "BFS",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "Which algorithm is best suited for finding the shortest path in an unweighted graph?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "What is the time complexity of Dijkstra’s algorithm using a min-heap (priority queue)?",
        "c": null,
        "o": [
            "O((V + E) log V)",
            "O(V^2)",
            "O(V + E)",
            "O(VE)"
        ]
    },
    {
        "q": "Which of the following algorithms builds the MST by adding the lowest weight edge that connects two different components?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which data structure is typically used to detect cycles in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Disjoint Set (Union-Find)",
            "Stack",
            "Queue",
            "Priority Queue"
        ]
    },
    {
        "q": "Prim’s algorithm typically uses which data structure to find the next minimum weight edge?",
        "c": null,
        "o": [
            "Priority Queue",
            "Disjoint Set",
            "Stack",
            "Hash Map"
        ]
    },
    {
        "q": "What is the output of the following DFS traversal starting from node 'A'?",
        "c": "{\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [], \"D\": []}",
        "o": [
            "A, B, D, C",
            "A, C, B, D",
            "A, D, B, C",
            "A, B, C, D"
        ]
    },
    {
        "q": "What is the main difference between Prim’s and Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Prim’s builds from a single node; Kruskal’s builds from edges",
            "Kruskal’s starts from a single node; Prim’s starts from edges",
            "Kruskal’s is only for directed graphs; Prim’s is for undirected graphs",
            "Prim’s doesn’t use any data structure; Kruskal’s uses priority queue"
        ]
    },
    {
        "q": "Which of the following is not required for Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Negative edge weights",
            "Priority queue",
            "Visited set",
            "Graph representation"
        ]
    },
    {
        "q": "In Kruskal’s algorithm, what happens if we don’t use a cycle detection mechanism?",
        "c": null,
        "o": [
            "We may form a cycle",
            "We get the shortest path instead of MST",
            "It will run infinitely",
            "Nothing, it still works fine"
        ]
    },
    {
        "q": "What is the worst-case time complexity of Prim’s algorithm using an adjacency matrix?",
        "c": null,
        "o": [
            "O(V^2)",
            "O((V + E) log V)",
            "O(E log V)",
            "O(V + E)"
        ]
    },
    {
        "q": "What is the purpose of the 'visited' set in DFS and BFS algorithms?",
        "c": null,
        "o": [
            "To avoid visiting the same node multiple times",
            "To keep track of the edge weights",
            "To count total nodes in the graph",
            "To store the shortest path"
        ]
    },
    {
        "q": "Which of these is a valid use-case for BFS?",
        "c": null,
        "o": [
            "Finding shortest path in unweighted graph",
            "Detecting cycles in undirected graph",
            "Topological sorting",
            "Finding strongly connected components"
        ]
    },
    {
        "q": "What does a priority queue do in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Selects the node with the smallest tentative distance",
            "Stores visited nodes",
            "Sorts the entire graph",
            "Detects cycles"
        ]
    },
    {
        "q": "Which algorithm is a greedy approach to solve MST problems?",
        "c": null,
        "o": [
            "Prim’s and Kruskal’s",
            "DFS and BFS",
            "Dijkstra’s and Bellman-Ford",
            "Floyd-Warshall and A*"
        ]
    },
    {
        "q": "Which of the following traversal algorithms guarantees a complete search of all reachable nodes?",
        "c": null,
        "o": [
            "BFS and DFS",
            "Prim’s and Kruskal’s",
            "Dijkstra’s and DFS",
            "DFS and Floyd-Warshall"
        ]
    },
    {
        "q": "How many edges are present in a minimum spanning tree of a connected graph with V vertices?",
        "c": null,
        "o": [
            "V - 1",
            "V",
            "V + 1",
            "Depends on the graph"
        ]
    },
    {
        "q": "Which of the following is a correct statement about DFS traversal?",
        "c": null,
        "o": [
            "It may not find the shortest path in a graph",
            "It always finds the shortest path",
            "It uses a queue for traversal",
            "It builds MST"
        ]
    },
    {
        "q": "Which of the following algorithms is NOT used for finding a Minimum Spanning Tree?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "Borůvka’s Algorithm"
        ]
    },
    {
        "q": "Which traversal algorithm is more suitable for finding connected components in a graph?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Prim’s"
        ]
    },
    {
        "q": "What is the best data structure to represent a sparse graph for algorithms like Dijkstra’s?",
        "c": null,
        "o": [
            "Adjacency List",
            "Adjacency Matrix",
            "2D Array",
            "Linked List"
        ]
    },
    {
        "q": "If all edges in a graph have equal weight, which algorithm is most efficient for shortest path?",
        "c": null,
        "o": [
            "BFS",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "What does Kruskal’s algorithm sort before processing?",
        "c": null,
        "o": [
            "Edges by weight",
            "Vertices by degree",
            "Edges by start node",
            "Vertices alphabetically"
        ]
    },
    {
        "q": "Which of the following is true about BFS and DFS?",
        "c": null,
        "o": [
            "BFS uses queue, DFS uses stack",
            "BFS uses stack, DFS uses queue",
            "Both use stack",
            "Both use queue"
        ]
    },
    {
        "q": "What happens if you apply Prim’s algorithm on a disconnected graph?",
        "c": null,
        "o": [
            "It will fail to find an MST",
            "It will find the shortest path",
            "It will form a spanning tree with cycles",
            "It will throw an exception"
        ]
    },
    {
        "q": "Which of the following is a characteristic of a greedy algorithm like Kruskal’s?",
        "c": null,
        "o": [
            "Makes the locally optimal choice at each step",
            "Explores all paths to find the global optimum",
            "Backtracks when a solution is not optimal",
            "Uses dynamic programming for subproblems"
        ]
    },
    {
        "q": "Which algorithm is most suitable for large graphs with many edges and non-negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s with min-heap",
            "BFS",
            "Prim’s with array",
            "DFS"
        ]
    },
    {
        "q": "Which Python module provides a built-in way to use a priority queue useful for Dijkstra's algorithm?",
        "c": null,
        "o": [
            "heapq",
            "queue",
            "collections",
            "functools"
        ]
    },
    {
        "q": "Which of the following algorithms works by growing a tree one vertex at a time?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which traversal algorithm is guaranteed to visit the closest nodes first?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm initializes all node distances to infinity except for the source node?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "Kruskal’s Algorithm",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "Which condition is essential to run Dijkstra’s algorithm correctly?",
        "c": null,
        "o": [
            "All edge weights must be non-negative",
            "Graph must be a tree",
            "Graph must be unweighted",
            "Graph must be a DAG"
        ]
    },
    {
        "q": "Which of the following is most likely to use a min-heap during its execution?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "BFS",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "What data structure can be used to represent a disjoint set for Kruskal's algorithm?",
        "c": null,
        "o": [
            "Union-Find with Path Compression",
            "Stack",
            "Min-Heap",
            "Adjacency Matrix"
        ]
    },
    {
        "q": "Which of the following is the correct step in BFS implementation?",
        "c": null,
        "o": [
            "Dequeue a node, mark as visited, enqueue its unvisited neighbors",
            "Push node onto stack, mark visited, push neighbors",
            "Visit node, then backtrack",
            "Select edge with minimum weight"
        ]
    },
    {
        "q": "What will DFS traversal look like in a fully connected undirected graph with 3 nodes?",
        "c": "{\"graph\": {\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"C\"], \"C\": [\"A\", \"B\"]}, \"start\": \"A\"}",
        "o": [
            "A, B, C",
            "A, C, B",
            "A, B, A",
            "A, A, C"
        ]
    },
    {
        "q": "Which is a major drawback of using an adjacency matrix for large sparse graphs?",
        "c": null,
        "o": [
            "High memory usage",
            "Slow access to edges",
            "Unordered nodes",
            "Cannot store weights"
        ]
    },
    {
        "q": "Which algorithm is suitable for dense graphs and doesn’t require sorting of edges?",
        "c": null,
        "o": [
            "Prim’s Algorithm (with matrix)",
            "Kruskal’s Algorithm",
            "Dijkstra’s with list",
            "DFS"
        ]
    },
    {
        "q": "Which traversal can be used to detect cycles in an undirected graph?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which of the following does NOT affect the runtime of Kruskal's algorithm?",
        "c": null,
        "o": [
            "The number of vertices' degrees",
            "The number of edges",
            "The time complexity of sorting edges",
            "The efficiency of Union-Find"
        ]
    },
    {
        "q": "Which graph algorithm can be used to find a path from one node to another in a maze?",
        "c": null,
        "o": [
            "BFS",
            "Prim’s",
            "Kruskal’s",
            "Union-Find"
        ]
    },
    {
        "q": "Which part of Dijkstra’s algorithm ensures we always choose the optimal next node?",
        "c": null,
        "o": [
            "Min-priority queue",
            "Visited set",
            "Recursion",
            "DFS stack"
        ]
    },
    {
        "q": "What does the Union operation do in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Merges two disjoint sets",
            "Finds shortest path between nodes",
            "Adds weights to priority queue",
            "Traverses graph in depth-first order"
        ]
    },
    {
        "q": "In DFS traversal, what happens if the recursion stack is not properly handled?",
        "c": null,
        "o": [
            "It may result in a stack overflow",
            "The graph won't be fully traversed",
            "It will become BFS",
            "All paths will be shortest"
        ]
    },
    {
        "q": "Which of the following can handle dynamic addition of edges more efficiently?",
        "c": null,
        "o": [
            "Adjacency List",
            "Adjacency Matrix",
            "Set of Tuples",
            "2D Array"
        ]
    },
    {
        "q": "Which of the following must a graph have to allow a valid Minimum Spanning Tree?",
        "c": null,
        "o": [
            "Graph must be connected",
            "Graph must be directed",
            "Graph must have cycles",
            "Graph must have equal edge weights"
        ]
    },
    {
        "q": "Which of the following shows the initial state of the distance dictionary in Dijkstra’s algorithm?",
        "c": "{'A': 0, 'B': inf, 'C': inf, 'D': inf}",
        "o": [
            "{'A': 0, 'B': inf, 'C': inf, 'D': inf}",
            "{'A': 0, 'B': 0, 'C': 0, 'D': 0}",
            "{'A': inf, 'B': inf, 'C': inf, 'D': inf}",
            "{'A': None, 'B': None, 'C': None, 'D': None}"
        ]
    },
    {
        "q": "Which of the following will run infinitely if a graph contains a negative weight cycle?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "BFS",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "Which of the following graph algorithms is guaranteed to visit each node exactly once?",
        "c": null,
        "o": [
            "DFS and BFS",
            "Dijkstra’s only",
            "Prim’s only",
            "Kruskal’s only"
        ]
    },
    {
        "q": "Which Python standard library provides the `deque` used in BFS implementation?",
        "c": null,
        "o": [
            "collections",
            "heapq",
            "queue",
            "functools"
        ]
    },
    {
        "q": "Which of the following is true about Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "It does not work correctly with negative edge weights",
            "It works with both negative and positive weights",
            "It always uses recursion",
            "It performs better with adjacency matrix"
        ]
    },
    {
        "q": "In Prim’s algorithm, what happens when all adjacent nodes of a vertex are already in the MST?",
        "c": null,
        "o": [
            "It skips to the next minimum edge in the queue",
            "It restarts the algorithm",
            "It forms a cycle",
            "It terminates early"
        ]
    },
    {
        "q": "Which graph algorithm can be used to detect connected components in an undirected graph?",
        "c": null,
        "o": [
            "DFS",
            "Dijkstra’s",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the main goal of a Minimum Spanning Tree algorithm?",
        "c": null,
        "o": [
            "Connect all vertices with minimum total edge weight",
            "Visit all nodes in shortest time",
            "Detect cycles in a graph",
            "Generate all possible paths"
        ]
    },
    {
        "q": "What type of graph is required for Kruskal’s algorithm to work correctly?",
        "c": null,
        "o": [
            "Connected, undirected graph",
            "Directed acyclic graph",
            "Complete weighted graph",
            "Graph with no loops"
        ]
    },
    {
        "q": "What happens if you don’t mark nodes as visited in DFS?",
        "c": null,
        "o": [
            "It may result in infinite recursion or repeated visits",
            "The traversal becomes BFS",
            "It will find shortest path",
            "It will skip disconnected components"
        ]
    },
    {
        "q": "Which one of the following algorithms is most suitable for real-time pathfinding?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "Union-Find"
        ]
    },
    {
        "q": "What is the output of BFS starting from 'A'?",
        "c": "{\"graph\": {\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"E\"], \"D\": [], \"E\": []}, \"start\": \"A\"}",
        "o": [
            "A, B, C, D, E",
            "A, C, B, E, D",
            "A, B, C, E",
            "A, D, E, B, C"
        ]
    },
    {
        "q": "Which algorithm starts from the source node and explores all neighbors at the current depth before moving deeper?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the best-case time complexity of DFS on a graph with V vertices and E edges?",
        "c": null,
        "o": [
            "O(V + E)",
            "O(V^2)",
            "O(E log V)",
            "O(V log E)"
        ]
    },
    {
        "q": "Which of the following algorithms is NOT greedy by nature?",
        "c": null,
        "o": [
            "DFS",
            "Prim’s",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "How is the MST affected if the weight of all edges in the graph is increased by a constant value?",
        "c": null,
        "o": [
            "MST remains the same",
            "MST changes completely",
            "MST becomes a shortest path tree",
            "Algorithm fails to build MST"
        ]
    },
    {
        "q": "In Python, which data structure would you typically use to represent a graph for DFS?",
        "c": null,
        "o": [
            "Dictionary of lists",
            "Set of tuples",
            "2D Matrix",
            "Tuple of arrays"
        ]
    },
    {
        "q": "In BFS traversal, which node is explored first?",
        "c": null,
        "o": [
            "The one closest to the source",
            "The one with lowest weight",
            "The last inserted node",
            "A random neighbor"
        ]
    },
    {
        "q": "Which of the following is true for Kruskal’s algorithm?",
        "c": null,
        "o": [
            "It does not require the graph to be connected to sort edges",
            "It builds the MST from a source node",
            "It requires a priority queue to work",
            "It works on directed graphs only"
        ]
    },
    {
        "q": "Which graph algorithm uses a greedy approach and is optimal for real-time shortest path navigation?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "Kruskal’s Algorithm",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "If a graph has cycles, which algorithm can still compute the MST?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "DFS",
            "BFS",
            "None of the above"
        ]
    },
    {
        "q": "What is the minimum number of edges in a connected undirected graph with N vertices?",
        "c": null,
        "o": [
            "N - 1",
            "N",
            "2N",
            "N + 1"
        ]
    },
    {
        "q": "Which of the following algorithms works best on a dense graph for finding MST?",
        "c": null,
        "o": [
            "Prim’s Algorithm with adjacency matrix",
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which traversal method is more likely to use a queue data structure?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following statements is true about DFS?",
        "c": null,
        "o": [
            "It may not find the shortest path in a graph",
            "It is guaranteed to find the shortest path",
            "It does not visit all nodes",
            "It always results in a spanning tree"
        ]
    },
    {
        "q": "Which Python library provides efficient graph representations and algorithms?",
        "c": null,
        "o": [
            "networkx",
            "pandas",
            "heapq",
            "matplotlib"
        ]
    },
    {
        "q": "Which of the following will result in a different MST if edge weights are changed?",
        "c": null,
        "o": [
            "Both Prim’s and Kruskal’s",
            "Only Kruskal’s",
            "Only Prim’s",
            "None of them"
        ]
    },
    {
        "q": "How can we optimize Dijkstra’s algorithm for better performance?",
        "c": null,
        "o": [
            "Use a min-heap (priority queue)",
            "Use recursion only",
            "Use an adjacency matrix always",
            "Avoid marking nodes as visited"
        ]
    },
    {
        "q": "Which of these traversal methods is generally better for shortest paths in unweighted graphs?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which step is unique to Kruskal’s algorithm and not used in Prim’s?",
        "c": null,
        "o": [
            "Sorting all edges by weight",
            "Selecting the next closest vertex",
            "Marking vertices as visited",
            "Using a priority queue"
        ]
    },
    {
        "q": "What is the time complexity of Kruskal’s algorithm (with efficient union-find)?",
        "c": null,
        "o": [
            "O(E log E)",
            "O(V^2)",
            "O(E + V)",
            "O(V log E)"
        ]
    },
    {
        "q": "Which algorithm will likely visit nodes in alphabetical order if all edge weights are the same?",
        "c": null,
        "o": [
            "BFS with sorted neighbors",
            "DFS with sorted neighbors",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which graph algorithm does NOT require the graph to be connected?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm"
        ]
    },
    {
        "q": "In DFS, which data structure is typically used to manage the order of visiting nodes?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Heap",
            "Set"
        ]
    },
    {
        "q": "What is the role of the 'find' operation in the Union-Find data structure used in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Determine the root representative of a set",
            "Find the shortest path between nodes",
            "Locate the heaviest edge",
            "Identify cycles in a graph"
        ]
    },
    {
        "q": "What makes Prim’s algorithm different from Kruskal’s in terms of edge selection?",
        "c": null,
        "o": [
            "Prim’s chooses edges that connect to the current MST",
            "Prim’s sorts all edges at the start",
            "Prim’s allows cycles",
            "Prim’s only works on trees"
        ]
    },
    {
        "q": "Which of the following is NOT true about BFS?",
        "c": null,
        "o": [
            "It uses a stack",
            "It visits nodes level by level",
            "It is optimal for unweighted shortest paths",
            "It can be implemented with a queue"
        ]
    },
    {
        "q": "Which graph traversal is ideal for checking whether a graph is bipartite?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following is required to ensure Kruskal’s algorithm works correctly?",
        "c": null,
        "o": [
            "Cycle detection using Union-Find",
            "Queue to process vertices",
            "Stack to backtrack",
            "Topological sorting of nodes"
        ]
    },
    {
        "q": "How does Dijkstra’s algorithm handle the update of tentative distances?",
        "c": null,
        "o": [
            "It updates only if the new path is shorter",
            "It always overwrites previous distances",
            "It ignores already visited nodes",
            "It only considers direct neighbors of the source"
        ]
    },
    {
        "q": "What kind of graph does BFS/DFS fail to fully explore if not handled properly?",
        "c": null,
        "o": [
            "Disconnected graph",
            "Complete graph",
            "Tree",
            "DAG"
        ]
    },
    {
        "q": "Which data structure is best suited for BFS implementation?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Set",
            "Heap"
        ]
    },
    {
        "q": "Which of the following conditions is necessary for a graph to have a Minimum Spanning Tree?",
        "c": null,
        "o": [
            "The graph must be connected and undirected",
            "The graph must be directed and weighted",
            "The graph must be cyclic",
            "The graph must be a tree"
        ]
    },
    {
        "q": "Which step in Prim’s algorithm ensures that no cycles are formed?",
        "c": null,
        "o": [
            "Avoiding re-insertion of already visited vertices",
            "Using a sorted edge list",
            "Merging disjoint sets",
            "Sorting vertices alphabetically"
        ]
    },
    {
        "q": "Which of the following is the correct initialization step in BFS?",
        "c": null,
        "o": [
            "Start node is enqueued and marked as visited",
            "All nodes are added to the stack",
            "Start node is pushed onto a stack",
            "All nodes are set to distance infinity"
        ]
    },
    {
        "q": "In Dijkstra’s algorithm, which nodes are added to the priority queue?",
        "c": null,
        "o": [
            "Unvisited neighbors with updated distances",
            "Only nodes with zero weight edges",
            "All nodes regardless of distance",
            "Nodes that form a cycle"
        ]
    },
    {
        "q": "Which algorithm is best suited for graphs where edges are frequently updated or removed?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm",
            "BFS"
        ]
    },
    {
        "q": "Which of the following Python data structures is best suited to track visited nodes?",
        "c": null,
        "o": [
            "Set",
            "List",
            "Dictionary",
            "Tuple"
        ]
    },
    {
        "q": "What is the output of DFS if the graph is a tree and we start from the root?",
        "c": "{\"tree\": {\"1\": [\"2\", \"3\"], \"2\": [\"4\"], \"3\": [], \"4\": []}, \"start\": \"1\"}",
        "o": [
            "1, 2, 4, 3",
            "1, 3, 2, 4",
            "1, 4, 2, 3",
            "1, 2, 3, 4"
        ]
    },
    {
        "q": "Which condition guarantees that Prim’s algorithm will cover all vertices?",
        "c": null,
        "o": [
            "The graph is connected",
            "The graph is a tree",
            "The graph has equal edge weights",
            "The graph has no cycles"
        ]
    },
    {
        "q": "What does a higher degree of a vertex imply in an undirected graph?",
        "c": null,
        "o": [
            "It has more adjacent edges",
            "It lies on the shortest path",
            "It is always included in MST",
            "It must be the source"
        ]
    },
    {
        "q": "What is the worst-case time complexity of BFS in an adjacency list representation?",
        "c": null,
        "o": [
            "O(V + E)",
            "O(V^2)",
            "O(E log V)",
            "O(V log V)"
        ]
    },
    {
        "q": "Which of the following is a characteristic of a tree graph?",
        "c": null,
        "o": [
            "It has no cycles and exactly V-1 edges",
            "It contains cycles and V edges",
            "It is always directed",
            "All nodes have the same degree"
        ]
    },
    {
        "q": "Which graph algorithm requires edge weights to function correctly?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "BFS",
            "Topological Sort"
        ]
    },
    {
        "q": "Which condition causes Dijkstra’s algorithm to produce incorrect results?",
        "c": null,
        "o": [
            "Presence of negative edge weights",
            "Graph contains cycles",
            "Graph has multiple components",
            "Edges are not sorted"
        ]
    },
    {
        "q": "Which of the following is not an application of DFS?",
        "c": null,
        "o": [
            "Finding shortest path in weighted graph",
            "Topological sorting",
            "Cycle detection",
            "Path finding in a maze"
        ]
    },
    {
        "q": "In BFS, what ensures the shortest path in an unweighted graph?",
        "c": null,
        "o": [
            "Level-wise exploration of nodes",
            "Stack-based traversal",
            "Use of union-find",
            "Sorting all neighbors before visiting"
        ]
    },
    {
        "q": "Which of the following is a drawback of adjacency matrix representation?",
        "c": null,
        "o": [
            "High space complexity for sparse graphs",
            "Slow edge lookup",
            "Cannot represent weighted graphs",
            "Only works for undirected graphs"
        ]
    },
    {
        "q": "What will happen if we use Dijkstra’s algorithm on a graph with negative weights?",
        "c": null,
        "o": [
            "It may produce incorrect shortest paths",
            "It will run infinitely",
            "It always finds the longest path",
            "It skips negative edges"
        ]
    },
    {
        "q": "Which traversal algorithm uses recursion implicitly?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which type of edge will never be selected by Kruskal’s algorithm if it forms a cycle?",
        "c": null,
        "o": [
            "Back edge",
            "Tree edge",
            "Forward edge",
            "Cross edge"
        ]
    },
    {
        "q": "What is the best data structure for dynamic graph problems like adding/removing edges efficiently?",
        "c": null,
        "o": [
            "Adjacency List",
            "Adjacency Matrix",
            "2D Array",
            "Flat Dictionary"
        ]
    },
    {
        "q": "Which of the following is true about Prim’s algorithm when implemented with an adjacency matrix?",
        "c": null,
        "o": [
            "It has time complexity O(V^2)",
            "It always requires a min-heap",
            "It cannot be used for dense graphs",
            "It selects edges before vertices"
        ]
    },
    {
        "q": "Which graph algorithm can be used to simulate water flow from one region to another?",
        "c": null,
        "o": [
            "BFS",
            "Kruskal’s",
            "Dijkstra’s",
            "Topological Sort"
        ]
    },
    {
        "q": "Which of the following is necessary to implement cycle detection using DFS?",
        "c": null,
        "o": [
            "Tracking visited and recursion stack",
            "Tracking only visited nodes",
            "Maintaining parent node only",
            "A priority queue"
        ]
    },
    {
        "q": "Which condition would most affect the performance of Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Large number of edges",
            "Small number of vertices",
            "Edges with equal weights",
            "Graph being connected"
        ]
    },
    {
        "q": "Which algorithm grows the MST from one node by adding the smallest adjacent edge?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which of these algorithms can handle disconnected graphs for building a forest of MSTs?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "How many edges are there in a complete undirected graph with n vertices?",
        "c": null,
        "o": [
            "n(n - 1)/2",
            "n^2",
            "n - 1",
            "n(n + 1)/2"
        ]
    },
    {
        "q": "Which of the following ensures correctness in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Greedy selection of shortest tentative distance",
            "Recursive depth-first search",
            "Processing all neighbors in reverse order",
            "Using a sorted list of edges"
        ]
    },
    {
        "q": "Which algorithm is likely to produce a different path if the edge weights are randomized?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "BFS",
            "DFS",
            "Topological Sort"
        ]
    },
    {
        "q": "What is the purpose of the priority queue in Prim’s algorithm?",
        "c": null,
        "o": [
            "To always pick the next minimum weight edge",
            "To store visited nodes",
            "To detect cycles",
            "To sort vertices alphabetically"
        ]
    },
    {
        "q": "Which algorithm can be used to find the shortest path in a graph with non-negative edge weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "In Dijkstra’s algorithm, what is the initial distance value for all nodes except the source?",
        "c": null,
        "o": [
            "Infinity",
            "Zero",
            "Negative One",
            "One"
        ]
    },
    {
        "q": "Which algorithm guarantees the optimal MST even when multiple edges have the same weight?",
        "c": null,
        "o": [
            "Both Prim’s and Kruskal’s",
            "Only Kruskal’s",
            "Only Prim’s",
            "None of them"
        ]
    },
    {
        "q": "Which of the following is most suitable for maze generation and exploration?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "What kind of graph is produced by combining multiple MSTs from disconnected components?",
        "c": null,
        "o": [
            "Spanning Forest",
            "Spanning Tree",
            "DAG",
            "Complete Graph"
        ]
    },
    {
        "q": "Which of the following graph types must be avoided in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Graphs with negative weight edges",
            "Graphs with disconnected components",
            "Directed Acyclic Graphs",
            "Weighted undirected graphs"
        ]
    },
    {
        "q": "Which of the following properties does a Minimum Spanning Tree have?",
        "c": null,
        "o": [
            "It connects all vertices with minimum total edge weight",
            "It includes all cycles in the graph",
            "It always starts from the highest degree vertex",
            "It requires the graph to be directed"
        ]
    },
    {
        "q": "What is the total number of edges in an MST for a graph with 100 nodes?",
        "c": null,
        "o": [
            "99",
            "100",
            "101",
            "98"
        ]
    },
    {
        "q": "Which of the following can be used to implement a min-priority queue efficiently in Python?",
        "c": null,
        "o": [
            "heapq",
            "deque",
            "set",
            "list.sort()"
        ]
    },
    {
        "q": "Which traversal technique can be modified to perform topological sorting on DAGs?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm is most appropriate for building a navigation system where real-time traffic updates are not considered?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "What is the output of this DFS code snippet?",
        "c": "graph = {'A': ['B', 'C'], 'B': ['D'], 'C': [], 'D': []}\nvisited = []\ndef dfs(node):\n    if node not in visited:\n        visited.append(node)\n        for n in graph[node]:\n            dfs(n)\ndfs('A')\nprint(visited)",
        "o": [
            "['A', 'B', 'D', 'C']",
            "['A', 'C', 'B', 'D']",
            "['A', 'B', 'C', 'D']",
            "['A', 'D', 'B', 'C']"
        ]
    },
    {
        "q": "Which of the following is true about BFS in a graph with cycles?",
        "c": null,
        "o": [
            "It needs a visited set to prevent infinite loops",
            "It will always detect cycles automatically",
            "It skips any nodes with edges",
            "It fails if the graph is disconnected"
        ]
    },
    {
        "q": "Which edge selection strategy does Prim’s algorithm use?",
        "c": null,
        "o": [
            "Greedy: Pick the lowest weight edge from current MST",
            "Greedy: Pick the lowest weight edge overall",
            "Recursive DFS",
            "Select randomly"
        ]
    },
    {
        "q": "Which of the following algorithms requires sorting of edges?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "What is the correct data structure to implement a BFS queue in Python?",
        "c": null,
        "o": [
            "collections.deque",
            "heapq",
            "list.sort()",
            "set"
        ]
    },
    {
        "q": "Which graph algorithm does not guarantee shortest path but explores deeply connected nodes?",
        "c": null,
        "o": [
            "DFS",
            "Dijkstra’s",
            "BFS",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm builds an MST without requiring a starting node?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm"
        ]
    },
    {
        "q": "In a graph with cycles, which algorithm can avoid infinite loops during traversal?",
        "c": null,
        "o": [
            "BFS with visited set",
            "DFS without recursion",
            "Kruskal’s using heapq",
            "Dijkstra’s without queue"
        ]
    },
    {
        "q": "What’s the maximum number of edges in a complete undirected graph with 10 nodes?",
        "c": null,
        "o": [
            "45",
            "90",
            "10",
            "50"
        ]
    },
    {
        "q": "Which of the following problems can be solved by both BFS and DFS?",
        "c": null,
        "o": [
            "Finding a path between two nodes",
            "Finding Minimum Spanning Tree",
            "Finding shortest weighted path",
            "Cycle detection in weighted graph"
        ]
    },
    {
        "q": "What is the output of the following BFS traversal?",
        "c": "graph = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': [], 'D': [], 'E': []}\nfrom collections import deque\nvisited = []\nqueue = deque(['A'])\nwhile queue:\n    node = queue.popleft()\n    if node not in visited:\n        visited.append(node)\n        queue.extend(graph[node])\nprint(visited)",
        "o": [
            "['A', 'B', 'C', 'D', 'E']",
            "['A', 'C', 'B', 'D', 'E']",
            "['A', 'B', 'D', 'E', 'C']",
            "['A', 'D', 'B', 'E', 'C']"
        ]
    },
    {
        "q": "What does Dijkstra’s algorithm assume about edge weights?",
        "c": null,
        "o": [
            "They are non-negative",
            "They must be all equal",
            "They can be negative",
            "They must be integers"
        ]
    },
    {
        "q": "Which traversal method is generally more memory-efficient for large graphs?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What is the main use of the Union-Find data structure in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "To detect cycles when adding new edges",
            "To select the minimum edge",
            "To store distances",
            "To store all paths from source"
        ]
    },
    {
        "q": "In Prim’s algorithm, what does the visited set track?",
        "c": null,
        "o": [
            "Vertices already included in MST",
            "Edges already added to MST",
            "Shortest distances from source",
            "Cycle formation history"
        ]
    },
    {
        "q": "Which of these statements is TRUE for Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "It guarantees shortest paths in graphs with non-negative weights",
            "It works best with negative weight graphs",
            "It always uses DFS traversal",
            "It can skip vertices with smaller weights"
        ]
    },
    {
        "q": "What is the output of a DFS if all neighbors are processed in reverse order?",
        "c": "graph = {'A': ['C', 'B'], 'B': [], 'C': []}\nvisited = []\ndef dfs(node):\n    if node not in visited:\n        visited.append(node)\n        for n in reversed(graph[node]):\n            dfs(n)\ndfs('A')\nprint(visited)",
        "o": [
            "['A', 'B', 'C']",
            "['A', 'C', 'B']",
            "['A', 'B']",
            "['A', 'C']"
        ]
    },
    {
        "q": "Which of these algorithms is most suitable for building a spanning tree with minimum total edge weight?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "DFS",
            "BFS",
            "Dijkstra’s Algorithm"
        ]
    },
    {
        "q": "What is the total number of comparisons needed to sort E edges in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "O(E log E)",
            "O(E^2)",
            "O(V log V)",
            "O(V + E)"
        ]
    },
    {
        "q": "Which of the following is a key difference between Prim’s and Kruskal’s algorithms?",
        "c": null,
        "o": [
            "Prim’s grows a single tree, Kruskal’s builds a forest",
            "Kruskal’s requires a start node, Prim’s does not",
            "Prim’s always uses a sorted edge list",
            "Kruskal’s prefers adjacency matrices"
        ]
    },
    {
        "q": "What data structure is best suited for implementing Union-Find operations?",
        "c": null,
        "o": [
            "Disjoint Set",
            "Priority Queue",
            "Stack",
            "Deque"
        ]
    },
    {
        "q": "Which of these is a limitation of DFS?",
        "c": null,
        "o": [
            "May not find the shortest path in graphs",
            "Cannot detect cycles",
            "Can only be used on trees",
            "Requires a sorted edge list"
        ]
    },
    {
        "q": "Which of the following best describes a spanning tree?",
        "c": null,
        "o": [
            "A subgraph that connects all vertices with no cycles",
            "A graph that contains all cycles",
            "A tree with the maximum edge weights",
            "A graph with multiple components"
        ]
    },
    {
        "q": "Which step is common to both Kruskal’s and Dijkstra’s algorithms?",
        "c": null,
        "o": [
            "Edge selection based on minimum weight",
            "Cycle detection",
            "Vertex priority updates",
            "Starting from a source vertex"
        ]
    },
    {
        "q": "What will happen if we don’t track visited nodes in DFS?",
        "c": null,
        "o": [
            "It may enter an infinite loop in cyclic graphs",
            "It will still always find shortest paths",
            "It will only visit leaf nodes",
            "It will switch to BFS behavior"
        ]
    },
    {
        "q": "Which algorithm is ideal for computing single-source shortest path in unweighted graphs?",
        "c": null,
        "o": [
            "BFS",
            "Dijkstra’s",
            "DFS",
            "Kruskal’s"
        ]
    },
    {
        "q": "How many minimum edges are needed to keep an undirected graph with 7 nodes connected?",
        "c": null,
        "o": [
            "6",
            "7",
            "5",
            "8"
        ]
    },
    {
        "q": "What is the result of applying DFS to a tree with no back edges?",
        "c": null,
        "o": [
            "It visits all nodes exactly once",
            "It returns shortest path",
            "It builds an MST",
            "It fails due to missing cycles"
        ]
    },
    {
        "q": "In Python, which of the following is used for efficient edge retrieval in a graph?",
        "c": null,
        "o": [
            "Adjacency list using dictionaries",
            "Set of lists",
            "Tuples inside tuples",
            "Nested for loops"
        ]
    },
    {
        "q": "Which condition is necessary for a graph to have exactly one unique Minimum Spanning Tree?",
        "c": null,
        "o": [
            "All edge weights must be distinct",
            "Graph must be directed",
            "Graph must have only even vertices",
            "All paths must be equal in length"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "import heapq\nheap = []\nheapq.heappush(heap, (3, 'A'))\nheapq.heappush(heap, (1, 'B'))\nheapq.heappush(heap, (2, 'C'))\nprint(heapq.heappop(heap))",
        "o": [
            "(1, 'B')",
            "(3, 'A')",
            "(2, 'C')",
            "(3, 'C')"
        ]
    },
    {
        "q": "Which algorithm builds the MST by connecting the nearest node not yet included?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm"
        ]
    },
    {
        "q": "What is the space complexity of an adjacency list representation of a graph with V vertices and E edges?",
        "c": null,
        "o": [
            "O(V + E)",
            "O(V^2)",
            "O(E^2)",
            "O(VE)"
        ]
    },
    {
        "q": "Which of the following cannot be used to represent a graph in memory?",
        "c": null,
        "o": [
            "Flat tuple",
            "Adjacency list",
            "Adjacency matrix",
            "Edge list"
        ]
    },
    {
        "q": "Which of the following correctly describes the relationship between BFS and queue?",
        "c": null,
        "o": [
            "BFS uses a queue to explore neighbors level-wise",
            "Queue is used to implement the call stack",
            "BFS cannot use a queue",
            "BFS uses a heap queue"
        ]
    },
    {
        "q": "Which of the following problems can be solved using Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Single source shortest path in weighted graph with non-negative weights",
            "MST of a graph with cycles",
            "All pairs shortest path with negative edges",
            "Counting cycles in an undirected graph"
        ]
    },
    {
        "q": "Which of the following is an advantage of using adjacency list over adjacency matrix?",
        "c": null,
        "o": [
            "Efficient space usage for sparse graphs",
            "Faster access time for edge checks",
            "Good for dense graphs",
            "Allows only undirected graphs"
        ]
    },
    {
        "q": "In Dijkstra’s algorithm, what happens when all neighbors of a node are already visited?",
        "c": null,
        "o": [
            "The node is skipped and next node is processed",
            "The algorithm halts",
            "It backtracks to the root",
            "It restarts from source"
        ]
    },
    {
        "q": "Which Python module helps implement efficient heaps for Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "heapq",
            "collections",
            "bisect",
            "math"
        ]
    },
    {
        "q": "Which of the following operations is crucial for preventing cycles in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Union-Find (Disjoint Set)",
            "Min-Heap",
            "DFS recursion",
            "Queue processing"
        ]
    },
    {
        "q": "Which traversal algorithm is guaranteed to visit all nodes in a connected component of an undirected graph?",
        "c": null,
        "o": [
            "BFS",
            "Prim’s",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which of the following algorithms would be best for finding the closest hospital in a city represented as an unweighted graph?",
        "c": null,
        "o": [
            "BFS",
            "Dijkstra’s",
            "DFS",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the maximum number of edges in a simple undirected graph with V vertices?",
        "c": null,
        "o": [
            "V*(V-1)/2",
            "V*(V+1)/2",
            "V^2",
            "V-1"
        ]
    },
    {
        "q": "Which of the following is a reason to prefer an adjacency list over an adjacency matrix?",
        "c": null,
        "o": [
            "Better space efficiency for sparse graphs",
            "Faster access to check if edge exists",
            "Always faster BFS",
            "Allows negative weights"
        ]
    },
    {
        "q": "In DFS, which type of edge can indicate a cycle in a directed graph?",
        "c": null,
        "o": [
            "Back edge",
            "Tree edge",
            "Forward edge",
            "Cross edge"
        ]
    },
    {
        "q": "Which of the following graph representations is best when the graph has very few edges?",
        "c": null,
        "o": [
            "Adjacency list",
            "Adjacency matrix",
            "Boolean grid",
            "Hash table of vertices"
        ]
    },
    {
        "q": "What is the role of the priority queue in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "To extract the vertex with the minimum tentative distance",
            "To track visited vertices",
            "To perform topological sort",
            "To store all the paths"
        ]
    },
    {
        "q": "What does the term 'greedy' mean in the context of Prim’s and Kruskal’s algorithms?",
        "c": null,
        "o": [
            "Choosing the next step based on locally optimal choices",
            "Storing all paths and choosing the longest",
            "Backtracking after every step",
            "Running recursion until all paths are covered"
        ]
    },
    {
        "q": "Which condition must hold true to ensure BFS finds the shortest path in a graph?",
        "c": null,
        "o": [
            "Graph must be unweighted",
            "Graph must be directed",
            "Graph must be cyclic",
            "Graph must have negative weights"
        ]
    },
    {
        "q": "Which algorithm ensures minimum cost to connect all vertices in a connected weighted graph?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "BFS",
            "Dijkstra’s Algorithm",
            "Topological Sort"
        ]
    },
    {
        "q": "Which graph traversal method can be used to detect cycles in a directed graph?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the result of running BFS on a disconnected graph starting from a vertex in one component?",
        "c": null,
        "o": [
            "Only that component will be explored",
            "All components will be explored",
            "BFS will fail",
            "It will return shortest paths to all vertices"
        ]
    },
    {
        "q": "In Kruskal’s algorithm, what should be done after sorting the edges?",
        "c": null,
        "o": [
            "Add edges to the MST while avoiding cycles",
            "Start DFS from the smallest edge",
            "Sort vertices in increasing order",
            "Create a heap of all vertices"
        ]
    },
    {
        "q": "Which of the following will happen if a graph has negative edge weights and you run Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "It may give incorrect shortest paths",
            "It will always fail with error",
            "It will produce the longest path",
            "It will ignore the negative edges"
        ]
    },
    {
        "q": "Which algorithm works better with dense graphs when using adjacency matrix representation?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "BFS"
        ]
    },
    {
        "q": "What does the 'visited' set prevent in BFS and DFS implementations?",
        "c": null,
        "o": [
            "Revisiting the same node",
            "Storing edge weights",
            "Cycle formation",
            "Graph being disconnected"
        ]
    },
    {
        "q": "Which of the following best describes the time complexity of Kruskal’s algorithm?",
        "c": null,
        "o": [
            "O(E log E)",
            "O(V^2)",
            "O(V + E)",
            "O(E^2)"
        ]
    },
    {
        "q": "Which algorithm can be used to check if an undirected graph is connected?",
        "c": null,
        "o": [
            "DFS",
            "Kruskal’s",
            "Dijkstra’s",
            "Bellman-Ford"
        ]
    },
    {
        "q": "What is the purpose of sorting edges in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "To pick the smallest weight edges first",
            "To avoid building a cycle",
            "To identify leaf nodes",
            "To perform topological sort"
        ]
    },
    {
        "q": "Which of the following is TRUE for the edge list representation of a graph?",
        "c": null,
        "o": [
            "It stores all edges as (u, v, weight) tuples",
            "It uses more memory than adjacency matrix",
            "It is fastest for checking if an edge exists",
            "It only supports unweighted graphs"
        ]
    },
    {
        "q": "Which algorithm processes edges in increasing order of weights?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "BFS"
        ]
    },
    {
        "q": "Which of the following graph algorithms does NOT use greedy strategy?",
        "c": null,
        "o": [
            "DFS",
            "Prim’s",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which condition ensures correctness of Prim’s algorithm?",
        "c": null,
        "o": [
            "Graph must be connected",
            "Graph must be a tree",
            "Graph must have cycles",
            "Graph must be directed"
        ]
    },
    {
        "q": "Which algorithm can work correctly on disconnected graphs by generating a spanning forest?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "BFS"
        ]
    },
    {
        "q": "What is the major limitation of using adjacency matrix for very large sparse graphs?",
        "c": null,
        "o": [
            "Wastes a lot of space",
            "Cannot handle weighted edges",
            "Fails on cyclic graphs",
            "Can’t perform DFS"
        ]
    },
    {
        "q": "Which of the following operations in Dijkstra’s algorithm updates the shortest known distances?",
        "c": null,
        "o": [
            "Relaxation",
            "Partitioning",
            "Depth tracking",
            "Union"
        ]
    },
    {
        "q": "Which of the following traversal strategies uses LIFO (last-in, first-out)?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which data structure is ideal for implementing DFS iteratively?",
        "c": null,
        "o": [
            "Stack",
            "Queue",
            "Priority Queue",
            "Set"
        ]
    },
    {
        "q": "What kind of graph structure can cause both DFS and BFS to visit fewer nodes than total vertices?",
        "c": null,
        "o": [
            "Disconnected graph",
            "Complete graph",
            "Tree",
            "Weighted graph"
        ]
    },
    {
        "q": "Which algorithm is guaranteed to find the shortest path from a source to all other vertices in a graph with non-negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "Which edge is safe to add in Kruskal’s algorithm while building an MST?",
        "c": null,
        "o": [
            "An edge that does not form a cycle",
            "The edge with the highest weight",
            "An edge between two visited vertices",
            "Any edge not yet added"
        ]
    },
    {
        "q": "Which traversal method is more memory efficient for deep graphs?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "What is the initial cost value assigned to all nodes in Dijkstra’s algorithm (except the source)?",
        "c": null,
        "o": [
            "Infinity",
            "Zero",
            "Negative Infinity",
            "One"
        ]
    },
    {
        "q": "Which of the following best describes how Prim’s algorithm grows the MST?",
        "c": null,
        "o": [
            "It starts with one vertex and adds the minimum-weight edge to expand the tree",
            "It selects the lightest edge in the graph regardless of connection",
            "It always starts from a leaf node",
            "It adds the heaviest edge at each step"
        ]
    },
    {
        "q": "In a graph traversal, what does the term 'visited' typically refer to?",
        "c": null,
        "o": [
            "A node that has been explored and processed",
            "A node that is about to be removed",
            "An edge that connects two trees",
            "A node with the lowest degree"
        ]
    },
    {
        "q": "Which of the following helps Kruskal’s algorithm to efficiently detect cycles?",
        "c": null,
        "o": [
            "Union-Find data structure",
            "BFS queue",
            "Stack used in DFS",
            "Visited array"
        ]
    },
    {
        "q": "Which traversal can be used to perform topological sorting?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which representation is more space-efficient for sparse graphs?",
        "c": null,
        "o": [
            "Adjacency list",
            "Adjacency matrix",
            "Edge matrix",
            "Boolean grid"
        ]
    },
    {
        "q": "What type of graph does Prim’s algorithm require?",
        "c": null,
        "o": [
            "Connected and weighted",
            "Directed and acyclic",
            "Unweighted and undirected",
            "Cyclic with equal weights"
        ]
    },
    {
        "q": "What is the main reason Dijkstra’s algorithm fails with negative edge weights?",
        "c": null,
        "o": [
            "It assumes once a node's shortest distance is found, it cannot be improved",
            "It cannot detect cycles",
            "It skips zero-weight edges",
            "It only works on trees"
        ]
    },
    {
        "q": "Which type of graph traversal is best for finding the shortest path in an unweighted graph?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Kruskal’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which of the following is used in Kruskal’s algorithm to sort edges?",
        "c": null,
        "o": [
            "Edge weights",
            "Vertex degree",
            "Vertex labels",
            "Path length"
        ]
    },
    {
        "q": "Which data structure is most suitable for implementing Prim’s algorithm efficiently?",
        "c": null,
        "o": [
            "Min-Heap (Priority Queue)",
            "Stack",
            "Deque",
            "Disjoint Set"
        ]
    },
    {
        "q": "What is the main goal of a Minimum Spanning Tree (MST)?",
        "c": null,
        "o": [
            "Connect all nodes with minimum total edge weight",
            "Minimize the number of nodes",
            "Eliminate cycles from a graph",
            "Create the shortest path from source to all nodes"
        ]
    },
    {
        "q": "Which algorithm is used to find shortest paths from a single source in graphs that may contain cycles?",
        "c": null,
        "o": [
            "Dijkstra’s (with non-negative weights)",
            "Kruskal’s",
            "DFS",
            "Prim’s"
        ]
    },
    {
        "q": "Which is the correct time complexity of Dijkstra’s algorithm using a min-heap?",
        "c": null,
        "o": [
            "O((V + E) log V)",
            "O(V^2)",
            "O(E log E)",
            "O(V + E)"
        ]
    },
    {
        "q": "What is the worst-case time complexity of BFS for a graph with V vertices and E edges?",
        "c": null,
        "o": [
            "O(V + E)",
            "O(V^2)",
            "O(E log V)",
            "O(E + V log V)"
        ]
    },
    {
        "q": "Which of the following algorithms can be used to find a path in a maze-like grid?",
        "c": null,
        "o": [
            "DFS",
            "Kruskal’s",
            "Topological Sort",
            "Bellman-Ford"
        ]
    },
    {
        "q": "Which graph algorithm ensures optimal path when all edges have the same weight?",
        "c": null,
        "o": [
            "BFS",
            "Dijkstra’s",
            "DFS",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following must be true for a graph to have a valid Minimum Spanning Tree?",
        "c": null,
        "o": [
            "It must be connected",
            "It must be directed",
            "All edges must have the same weight",
            "It must have no cycles"
        ]
    },
    {
        "q": "Which algorithm is typically used in network routing protocols to find shortest paths?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which data structure enables fast retrieval of the smallest distance node in Dijkstra’s?",
        "c": null,
        "o": [
            "Min Heap",
            "Stack",
            "Deque",
            "Adjacency Matrix"
        ]
    },
    {
        "q": "Which traversal method uses a queue and visits nodes level-by-level?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which step in Kruskal’s algorithm ensures no cycles are formed?",
        "c": null,
        "o": [
            "Union-Find check",
            "Sorting edges",
            "Using a queue",
            "Visiting vertices in order"
        ]
    },
    {
        "q": "Which of the following is the key difference between BFS and Dijkstra’s?",
        "c": null,
        "o": [
            "Dijkstra’s considers edge weights, BFS does not",
            "BFS always uses a min-heap",
            "BFS needs sorted edges, Dijkstra’s does not",
            "Dijkstra’s uses recursion like DFS"
        ]
    },
    {
        "q": "Which representation is best for checking whether an edge exists in O(1) time?",
        "c": null,
        "o": [
            "Adjacency Matrix",
            "Adjacency List",
            "Edge List",
            "Nested Tuples"
        ]
    },
    {
        "q": "Which type of graph traversal is used in cycle detection in undirected graphs?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Kruskal’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which algorithm constructs the MST by adding the next lightest edge that doesn't form a cycle?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS",
            "Topological Sort"
        ]
    },
    {
        "q": "What is a major advantage of using an adjacency list over a matrix in sparse graphs?",
        "c": null,
        "o": [
            "Less memory usage",
            "Faster edge lookups",
            "Better suited for dense graphs",
            "Allows only unweighted edges"
        ]
    },
    {
        "q": "Which graph algorithm is best suited for building a broadcast network with minimum cable cost?",
        "c": null,
        "o": [
            "Minimum Spanning Tree (MST)",
            "Topological Sort",
            "Dijkstra’s Algorithm",
            "Depth-First Search"
        ]
    },
    {
        "q": "Which of the following statements about Dijkstra’s Algorithm is FALSE?",
        "c": null,
        "o": [
            "It works with negative edge weights",
            "It guarantees shortest path for non-negative weights",
            "It uses a priority queue to choose the next node",
            "It starts from a single source vertex"
        ]
    },
    {
        "q": "Which of these graph algorithms is NOT greedy in nature?",
        "c": null,
        "o": [
            "Depth-First Search",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "In which of the following cases will BFS and DFS visit the same nodes in the same order?",
        "c": null,
        "o": [
            "When the graph is a linear chain",
            "When the graph is a complete graph",
            "When the graph is disconnected",
            "Never"
        ]
    },
    {
        "q": "What happens if we run Prim’s algorithm on a disconnected graph?",
        "c": null,
        "o": [
            "It constructs an MST for one component only",
            "It throws an error",
            "It finds the longest path",
            "It visits all nodes correctly"
        ]
    },
    {
        "q": "Which algorithm is ideal for finding the shortest path from a source in a weighted graph where edges can be negative?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "DFS",
            "Prim’s"
        ]
    },
    {
        "q": "What does a cross edge in DFS of a directed graph represent?",
        "c": null,
        "o": [
            "An edge that connects to an already visited node not in the current path",
            "An edge forming a cycle",
            "An edge leading to a deeper node",
            "An edge to a parent"
        ]
    },
    {
        "q": "Which of the following algorithms can be used for maze generation using graphs?",
        "c": null,
        "o": [
            "DFS",
            "Dijkstra’s",
            "Topological Sort",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "Which of the following is true about the output of Kruskal’s algorithm?",
        "c": null,
        "o": [
            "It always forms an MST of the graph if connected",
            "It always returns the longest path",
            "It requires a source node",
            "It doesn't work on weighted graphs"
        ]
    },
    {
        "q": "What does BFS use to explore all neighbors before going deeper?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Heap",
            "Recursion"
        ]
    },
    {
        "q": "What is the minimum number of edges in a connected undirected graph with N vertices?",
        "c": null,
        "o": [
            "N - 1",
            "N",
            "N + 1",
            "N * (N - 1) / 2"
        ]
    },
    {
        "q": "Which of the following algorithms is suitable for finding the shortest path in a graph with all positive weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "In BFS, how are newly discovered vertices stored for future exploration?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Min-Heap",
            "Set"
        ]
    },
    {
        "q": "Which traversal algorithm is naturally recursive?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which algorithm starts with a forest and merges trees?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm"
        ]
    },
    {
        "q": "Which property makes BFS suitable for finding shortest paths in unweighted graphs?",
        "c": null,
        "o": [
            "It explores all nodes level by level",
            "It uses backtracking",
            "It chooses highest degree nodes",
            "It processes edges in sorted order"
        ]
    },
    {
        "q": "Which of the following is the best choice to represent a dense graph?",
        "c": null,
        "o": [
            "Adjacency Matrix",
            "Adjacency List",
            "Edge List",
            "Set of tuples"
        ]
    },
    {
        "q": "What is the worst-case time complexity of DFS for a graph with V vertices and E edges?",
        "c": null,
        "o": [
            "O(V + E)",
            "O(V^2)",
            "O(V + V^2)",
            "O(E log V)"
        ]
    },
    {
        "q": "Which of the following traversal strategies uses FIFO (first-in, first-out)?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which graph representation is inefficient for a sparse graph in terms of space?",
        "c": null,
        "o": [
            "Adjacency Matrix",
            "Adjacency List",
            "Edge List",
            "Hash Map of neighbors"
        ]
    },
    {
        "q": "Which of the following algorithms uses a greedy approach to find MST starting from any node?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which algorithm is used for finding a cycle in an undirected graph?",
        "c": null,
        "o": [
            "DFS",
            "Kruskal’s",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which traversal strategy is generally better for finding a path in a wide graph?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following graph traversal methods is non-recursive by default?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Topological Sort",
            "Bellman-Ford"
        ]
    },
    {
        "q": "Which algorithm works by repeatedly relaxing edges and is capable of detecting negative cycles?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following is NOT typically a use case for Depth-First Search?",
        "c": null,
        "o": [
            "Finding shortest path in unweighted graph",
            "Detecting cycles",
            "Topological sorting",
            "Path existence check"
        ]
    },
    {
        "q": "What is the output of a DFS if there is a cycle and no visited set is used?",
        "c": null,
        "o": [
            "It may enter infinite recursion",
            "It returns shortest path",
            "It performs topological sort",
            "It always finds the MST"
        ]
    },
    {
        "q": "Which graph algorithm relies heavily on disjoint-set (union-find) operations?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "BFS"
        ]
    },
    {
        "q": "In which scenario does BFS outperform DFS?",
        "c": null,
        "o": [
            "When shortest path is needed in an unweighted graph",
            "When traversing deep recursion trees",
            "When edge weights vary widely",
            "When the graph is a tree"
        ]
    },
    {
        "q": "Which of the following graph representations is ideal for dense graphs?",
        "c": null,
        "o": [
            "Adjacency Matrix",
            "Adjacency List",
            "Edge List",
            "Tuple Map"
        ]
    },
    {
        "q": "Which graph algorithm finds the shortest path in a weighted graph with negative edge weights but no negative cycles?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following is NOT required in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Handling negative weights",
            "Min-Heap or Priority Queue",
            "Visited set",
            "Distance array"
        ]
    },
    {
        "q": "Which graph traversal method is typically implemented using a stack (explicitly or implicitly)?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What is the best case time complexity of BFS in a graph with V vertices and E edges?",
        "c": null,
        "o": [
            "O(V + E)",
            "O(V)",
            "O(E)",
            "O(V log V)"
        ]
    },
    {
        "q": "Which of the following does NOT apply to Prim’s algorithm?",
        "c": null,
        "o": [
            "Requires sorting all edges before processing",
            "Starts with a single vertex",
            "Can use a priority queue for optimization",
            "Builds the MST incrementally"
        ]
    },
    {
        "q": "Which graph algorithm can be used to detect the presence of a negative-weight cycle?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "DFS",
            "Prim’s"
        ]
    },
    {
        "q": "What is the purpose of the 'relaxation' step in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "To update the shortest path estimate",
            "To reduce the size of the graph",
            "To eliminate cycles",
            "To initialize all distances to zero"
        ]
    },
    {
        "q": "Which algorithm is more suitable for dense graphs when implemented with adjacency matrix?",
        "c": null,
        "o": [
            "Prim’s",
            "Kruskal’s",
            "DFS",
            "BFS"
        ]
    },
    {
        "q": "Which traversal technique will visit all vertices reachable from the starting vertex in the fewest number of steps?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Kruskal’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which of the following is true about Kruskal’s and Prim’s algorithms?",
        "c": null,
        "o": [
            "Both find the Minimum Spanning Tree",
            "Both require a starting vertex",
            "Both work only on unweighted graphs",
            "Both avoid the use of sorting"
        ]
    },
    {
        "q": "Which of the following is TRUE about BFS and DFS?",
        "c": null,
        "o": [
            "BFS uses a queue, DFS uses a stack",
            "Both always visit nodes in the same order",
            "DFS uses a queue, BFS uses a stack",
            "BFS explores deeper paths before siblings"
        ]
    },
    {
        "q": "Which algorithm is most appropriate for topological sorting of a DAG?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What is the key feature of a priority queue used in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "It always returns the node with the smallest tentative distance",
            "It returns the node with the largest weight",
            "It stores all edges",
            "It prevents cycles"
        ]
    },
    {
        "q": "Which algorithm should be used to find a Minimum Spanning Tree in a graph with equal edge weights?",
        "c": null,
        "o": [
            "Either Kruskal’s or Prim’s",
            "Only Prim’s",
            "Only Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which of the following is a valid application of graph traversal?",
        "c": null,
        "o": [
            "Finding connected components",
            "Calculating factorial",
            "Sorting an array",
            "Binary search"
        ]
    },
    {
        "q": "Which graph representation allows O(1) time complexity for checking if an edge exists?",
        "c": null,
        "o": [
            "Adjacency Matrix",
            "Adjacency List",
            "Edge List",
            "Tuple Set"
        ]
    },
    {
        "q": "Which traversal would use less memory on very deep and narrow trees?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which graph algorithm is ideal when edge weights are uniform?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Dijkstra’s",
            "Bellman-Ford"
        ]
    },
    {
        "q": "Which type of graph traversal ensures visiting vertices level by level?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the main difference between Prim’s and Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Prim’s grows from one node; Kruskal’s adds edges globally",
            "Kruskal’s is recursive; Prim’s is not",
            "Kruskal’s uses DFS; Prim’s uses BFS",
            "Prim’s works only on directed graphs"
        ]
    },
    {
        "q": "Which of the following statements is TRUE about Kruskal’s algorithm?",
        "c": null,
        "o": [
            "It does not require the graph to be connected to function",
            "It always begins from the vertex with the smallest degree",
            "It prioritizes vertices over edges",
            "It uses a priority queue instead of sorting"
        ]
    },
    {
        "q": "What does the 'greedy' strategy in Prim’s algorithm involve?",
        "c": null,
        "o": [
            "Always choosing the next minimum weight edge connected to the tree",
            "Exploring all possible spanning trees",
            "Backtracking after each step",
            "Using DFS to visit each vertex"
        ]
    },
    {
        "q": "What is the output of a BFS traversal starting from a vertex in a disconnected graph?",
        "c": null,
        "o": [
            "All nodes in the same component as the starting node",
            "All nodes in the graph",
            "Only immediate neighbors",
            "All leaf nodes"
        ]
    },
    {
        "q": "Which of the following is best for representing a sparse graph to save memory?",
        "c": null,
        "o": [
            "Adjacency List",
            "Adjacency Matrix",
            "Edge Matrix",
            "Vertex Array"
        ]
    },
    {
        "q": "What is the primary condition for a graph to have a unique Minimum Spanning Tree?",
        "c": null,
        "o": [
            "All edge weights are distinct",
            "Graph must be a tree",
            "Graph should be acyclic",
            "All nodes must be isolated"
        ]
    },
    {
        "q": "Which graph traversal is typically used to detect cycles in a directed graph?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What is the key role of the parent array in Union-Find structure used by Kruskal’s?",
        "c": null,
        "o": [
            "To detect if adding an edge forms a cycle",
            "To sort vertices",
            "To mark visited nodes",
            "To perform DFS traversal"
        ]
    },
    {
        "q": "Which of the following is an advantage of using BFS over DFS in unweighted graphs?",
        "c": null,
        "o": [
            "BFS guarantees the shortest path",
            "BFS is faster in all cases",
            "BFS always visits more nodes",
            "BFS uses less memory"
        ]
    },
    {
        "q": "What is the time complexity of checking for an edge in an adjacency matrix?",
        "c": null,
        "o": [
            "O(1)",
            "O(log V)",
            "O(V)",
            "O(E)"
        ]
    },
    {
        "q": "Which of the following algorithms builds an MST by growing from an arbitrary node?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "Which of the following best describes the priority queue in Prim’s algorithm?",
        "c": null,
        "o": [
            "It stores vertices with their minimum connecting edge weight",
            "It stores all unvisited neighbors",
            "It sorts edges by vertex labels",
            "It maintains the entire MST"
        ]
    },
    {
        "q": "Why does Kruskal’s algorithm sort all edges before processing?",
        "c": null,
        "o": [
            "To always pick the smallest edge and avoid cycles",
            "To remove duplicate edges",
            "To convert the graph to a tree",
            "To prepare for BFS traversal"
        ]
    },
    {
        "q": "What happens if we use DFS on a weighted graph without considering weights?",
        "c": null,
        "o": [
            "It won’t give shortest paths",
            "It gives the MST",
            "It behaves like Dijkstra’s algorithm",
            "It finds only leaf nodes"
        ]
    },
    {
        "q": "Which algorithm is most likely to visit the fewest nodes in a dense weighted graph?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "Kruskal’s Algorithm",
            "BFS"
        ]
    },
    {
        "q": "Which traversal method is suitable for solving mazes with guaranteed shortest path?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Topological Sort"
        ]
    },
    {
        "q": "In which situation would DFS be preferred over BFS?",
        "c": null,
        "o": [
            "When searching deep paths in tree-like structures",
            "When guaranteed shortest path is needed",
            "When working with balanced binary trees",
            "When the graph is sparse"
        ]
    },
    {
        "q": "Which algorithm is based on the greedy approach and uses disjoint sets?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "What is the stopping condition in Prim’s algorithm?",
        "c": null,
        "o": [
            "All vertices are included in the MST",
            "All edges have been visited",
            "A cycle is detected",
            "The minimum weight edge is found"
        ]
    },
    {
        "q": "Which algorithm processes each edge exactly once per iteration?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "DFS"
        ]
    },
    {
        "q": "Which graph algorithm can result in multiple valid outputs depending on edge order?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "BFS",
            "Topological Sort"
        ]
    },
    {
        "q": "In Kruskal’s algorithm, what happens if the edge added connects two vertices in the same set?",
        "c": null,
        "o": [
            "A cycle is formed",
            "The MST is completed",
            "The graph is disconnected",
            "A new component is created"
        ]
    },
    {
        "q": "Which algorithm maintains a visited set and updates the shortest path as it explores the graph?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "DFS",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which of the following graph algorithms can handle disconnected graphs?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Topological Sort"
        ]
    },
    {
        "q": "Which of these is an edge-based MST algorithm?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "What data structure optimizes cycle detection in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Disjoint Set Union (DSU)",
            "Stack",
            "Priority Queue",
            "HashMap"
        ]
    },
    {
        "q": "Which traversal is most useful when you want to explore all vertices reachable from a given start node?",
        "c": null,
        "o": [
            "DFS",
            "Topological Sort",
            "Kruskal’s Algorithm",
            "Union-Find"
        ]
    },
    {
        "q": "Which step in Prim’s algorithm helps in choosing the next minimum edge?",
        "c": null,
        "o": [
            "Using a priority queue",
            "Sorting all edges first",
            "Performing DFS",
            "Initializing visited list"
        ]
    },
    {
        "q": "Which graph algorithm works by choosing the edge with the least weight regardless of the component?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "BFS"
        ]
    },
    {
        "q": "Which of the following algorithms requires the graph to be connected to produce a valid result?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "BFS"
        ]
    },
    {
        "q": "Which of the following traversals would be best to find the shortest path in an unweighted grid?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Kruskal’s Algorithm",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "Which traversal is best suited for detecting cycles in a directed graph?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following is NOT a necessary component in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Edge weight can be negative",
            "Priority queue or min-heap",
            "Distance array",
            "Visited set"
        ]
    },
    {
        "q": "Which algorithm guarantees a globally optimal minimum spanning tree?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "What is the major drawback of the adjacency matrix representation?",
        "c": null,
        "o": [
            "Consumes more memory for sparse graphs",
            "Cannot store weights",
            "Fails in disconnected graphs",
            "Slower than adjacency list for dense graphs"
        ]
    },
    {
        "q": "What is the time complexity of Kruskal’s algorithm using Union-Find with path compression?",
        "c": null,
        "o": [
            "O(E log V)",
            "O(V^2)",
            "O(E + V)",
            "O(V log V)"
        ]
    },
    {
        "q": "Which algorithm is preferred when graph edges are sorted and the goal is to form MST?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm"
        ]
    },
    {
        "q": "Which of the following will increase memory usage significantly in a sparse graph?",
        "c": null,
        "o": [
            "Using an adjacency matrix",
            "Using DFS",
            "Using a queue for BFS",
            "Implementing Union-Find"
        ]
    },
    {
        "q": "Which property must a graph have for Dijkstra’s algorithm to work correctly?",
        "c": null,
        "o": [
            "Non-negative edge weights",
            "No cycles",
            "All vertices must have equal degree",
            "No isolated vertices"
        ]
    },
    {
        "q": "What is the best data structure to use in Prim’s algorithm for efficiency on sparse graphs?",
        "c": null,
        "o": [
            "Min-Heap (Priority Queue)",
            "Adjacency Matrix",
            "Stack",
            "Queue"
        ]
    },
    {
        "q": "In which scenario can both DFS and BFS give the same traversal order?",
        "c": null,
        "o": [
            "In a linear graph (single path)",
            "In a complete graph",
            "In a tree with varying depths",
            "In a cyclic graph"
        ]
    },
    {
        "q": "Which of the following traversal algorithms guarantees visiting the shortest path first in an unweighted graph?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which graph algorithm repeatedly extracts the minimum distance vertex and updates distances of its neighbors?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Bellman-Ford Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which algorithm uses a ‘relaxation’ technique and works even with negative edge weights?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm is based on the idea of maintaining multiple disjoint sets?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "What will be the total number of edges in the MST of a connected graph with V vertices?",
        "c": null,
        "o": [
            "V - 1",
            "V",
            "V + 1",
            "Depends on E"
        ]
    },
    {
        "q": "Which graph algorithm is more efficient for dense graphs when using an adjacency matrix?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "BFS",
            "DFS"
        ]
    },
    {
        "q": "Which of the following data structures is best suited for implementing Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Union-Find (Disjoint Set)",
            "Priority Queue",
            "Stack",
            "Adjacency Matrix"
        ]
    },
    {
        "q": "In Dijkstra’s algorithm, what happens when a shorter path to a node is found?",
        "c": null,
        "o": [
            "The distance is updated",
            "The algorithm stops",
            "A cycle is detected",
            "The node is removed"
        ]
    },
    {
        "q": "Which of the following is FALSE about BFS?",
        "c": null,
        "o": [
            "It uses a stack for traversal",
            "It is suitable for shortest path in unweighted graphs",
            "It uses a queue",
            "It visits nodes level by level"
        ]
    },
    {
        "q": "Which of these algorithms does NOT work on weighted graphs?",
        "c": null,
        "o": [
            "BFS",
            "Dijkstra’s",
            "Prim’s",
            "Bellman-Ford"
        ]
    },
    {
        "q": "Which graph algorithm is used to find the minimum distance from a source to all other vertices in a weighted graph without negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm",
            "Prim’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which traversal algorithm is ideal when you want to visit all nodes at a certain distance before going deeper?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following operations is key in Kruskal’s algorithm to ensure no cycles are formed?",
        "c": null,
        "o": [
            "Union-Find",
            "Priority Queue insertion",
            "Recursive DFS",
            "Edge coloring"
        ]
    },
    {
        "q": "What does the 'find' operation in Union-Find data structure do?",
        "c": null,
        "o": [
            "Finds the root representative of a set",
            "Finds the shortest path",
            "Finds the MST",
            "Finds the largest node in a graph"
        ]
    },
    {
        "q": "Which algorithm cannot be used directly on graphs with negative edge weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm",
            "DFS",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "In BFS, which data structure ensures FIFO order for node processing?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Heap",
            "Set"
        ]
    },
    {
        "q": "Which algorithm is typically more efficient on sparse graphs when using an adjacency list?",
        "c": null,
        "o": [
            "Prim’s with Min-Heap",
            "Kruskal’s with DSU",
            "Dijkstra’s with Matrix",
            "DFS with Matrix"
        ]
    },
    {
        "q": "Which of the following is not guaranteed by Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Unique MST if edge weights are equal",
            "MST of a connected graph",
            "Avoiding cycles",
            "Using the minimum total weight"
        ]
    },
    {
        "q": "Which property of a graph ensures the output of an MST is unique?",
        "c": null,
        "o": [
            "All edge weights are distinct",
            "It is a tree",
            "It has no cycles",
            "It is a DAG"
        ]
    },
    {
        "q": "Which graph algorithm is based on edge selection rather than vertex expansion?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "DFS",
            "Dijkstra’s Algorithm"
        ]
    },
    {
        "q": "Which graph algorithm is most suitable when you need to process edges in increasing order of weight?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "What is the time complexity of BFS for a graph with V vertices and E edges?",
        "c": null,
        "o": [
            "O(V + E)",
            "O(V^2)",
            "O(VE)",
            "O(E log V)"
        ]
    },
    {
        "q": "Which of the following graph algorithms is not used to find shortest paths?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm",
            "Floyd-Warshall Algorithm"
        ]
    },
    {
        "q": "Which of the following is the main goal of DFS in a graph?",
        "c": null,
        "o": [
            "To explore as far along a branch as possible",
            "To visit nodes level by level",
            "To find minimum spanning tree",
            "To ensure shortest path"
        ]
    },
    {
        "q": "Which of these statements about Prim’s and Kruskal’s algorithms is correct?",
        "c": null,
        "o": [
            "Prim’s grows from a single vertex; Kruskal’s selects global edges",
            "Kruskal’s is faster in all cases",
            "Prim’s can’t use priority queues",
            "Both require sorted edges"
        ]
    },
    {
        "q": "In Dijkstra’s algorithm, what is the initial distance set for the source node?",
        "c": null,
        "o": [
            "0",
            "Infinity",
            "-1",
            "1"
        ]
    },
    {
        "q": "Which of the following is a top-down traversal method in graphs?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Kruskal’s",
            "Bellman-Ford"
        ]
    },
    {
        "q": "What kind of data structure is essential for the Bellman-Ford algorithm to store distances?",
        "c": null,
        "o": [
            "Array",
            "Queue",
            "Stack",
            "Tree"
        ]
    },
    {
        "q": "Which traversal method is more likely to use recursion implicitly?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm would you choose to compute shortest paths between all pairs of nodes?",
        "c": null,
        "o": [
            "Floyd-Warshall",
            "Dijkstra’s",
            "Kruskal’s",
            "DFS"
        ]
    },
    {
        "q": "Which of the following conditions can make Dijkstra's algorithm return incorrect results?",
        "c": null,
        "o": [
            "Presence of negative edge weights",
            "Disconnected graph",
            "Cyclic graph",
            "Equal edge weights"
        ]
    },
    {
        "q": "What data structure helps in achieving O(log V) complexity for extracting the minimum in Dijkstra’s?",
        "c": null,
        "o": [
            "Min-Heap",
            "Stack",
            "Queue",
            "HashMap"
        ]
    },
    {
        "q": "Which graph traversal can be easily modified to detect cycles in an undirected graph?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the maximum number of edges in a directed graph with V vertices and no parallel edges?",
        "c": null,
        "o": [
            "V*(V-1)",
            "V*(V+1)/2",
            "V^2",
            "V*(V-1)/2"
        ]
    },
    {
        "q": "Which of the following graph algorithms is not greedy by nature?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Prim’s",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which approach is used by Bellman-Ford to update shortest path estimates?",
        "c": null,
        "o": [
            "Relaxation over all edges repeatedly",
            "Only exploring minimum weight edges",
            "Backtracking",
            "DFS traversal"
        ]
    },
    {
        "q": "Which of the following statements is true for a graph’s MST?",
        "c": null,
        "o": [
            "MST always contains exactly V - 1 edges",
            "MST is unique regardless of edge weights",
            "MST always forms a complete graph",
            "MST requires graph to be directed"
        ]
    },
    {
        "q": "Which traversal algorithm is better for checking bipartite nature of a graph?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm works best for finding shortest paths from a single source in graphs with negative edges but no negative cycles?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following is TRUE about Prim’s and Dijkstra’s algorithms?",
        "c": null,
        "o": [
            "Both use a priority queue and greedy approach",
            "Both solve shortest path problem",
            "Both work only on undirected graphs",
            "Both depend on topological sort"
        ]
    },
    {
        "q": "Which of the following algorithms is primarily used for transitive closure in a graph?",
        "c": null,
        "o": [
            "Floyd-Warshall",
            "Dijkstra’s",
            "Kruskal’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which of the following scenarios is best solved using a minimum spanning tree?",
        "c": null,
        "o": [
            "Connecting all computers in a network with minimum cost",
            "Finding shortest path from source to destination",
            "Finding cycles in a graph",
            "Topological sorting"
        ]
    },
    {
        "q": "Which algorithm guarantees finding the shortest path from one node to all others, even with negative weights?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "DFS"
        ]
    },
    {
        "q": "What is the main difference between BFS and DFS in terms of node visitation?",
        "c": null,
        "o": [
            "BFS visits level by level; DFS goes deep before backtracking",
            "DFS visits all nodes; BFS doesn’t",
            "BFS always uses recursion; DFS uses queue",
            "DFS is faster than BFS in all graphs"
        ]
    },
    {
        "q": "Which of the following algorithms does NOT help in detecting cycles in a graph?",
        "c": null,
        "o": [
            "Dijkstra’s",
            "DFS",
            "Union-Find",
            "Tarjan’s Algorithm"
        ]
    },
    {
        "q": "Which traversal is used to classify edges during DFS traversal?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm will give incorrect results on a graph with negative weight edges?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm",
            "BFS",
            "DFS"
        ]
    },
    {
        "q": "In which case is BFS more suitable than DFS?",
        "c": null,
        "o": [
            "Finding shortest path in unweighted graph",
            "When using a recursive approach",
            "When exploring depth-first",
            "When detecting back edges"
        ]
    },
    {
        "q": "What will be the output of Kruskal’s algorithm on a disconnected graph?",
        "c": null,
        "o": [
            "A forest of minimum spanning trees",
            "A single connected MST",
            "A complete cycle",
            "An empty set"
        ]
    },
    {
        "q": "Which of the following is the correct time complexity of Dijkstra’s algorithm using a binary heap?",
        "c": null,
        "o": [
            "O((V + E) log V)",
            "O(V^2)",
            "O(VE)",
            "O(E log E)"
        ]
    },
    {
        "q": "What is the output of a DFS traversal on a disconnected graph?",
        "c": null,
        "o": [
            "Only nodes in the connected component of the starting vertex",
            "All nodes in the graph",
            "Only nodes with even degrees",
            "Nodes in increasing order"
        ]
    },
    {
        "q": "Which of the following algorithms is used to find bridges and articulation points in a graph?",
        "c": null,
        "o": [
            "Tarjan’s Algorithm",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "In BFS traversal, what happens when a node has already been visited?",
        "c": null,
        "o": [
            "It is skipped",
            "It is re-added to the queue",
            "It causes termination",
            "It is pushed onto a stack"
        ]
    },
    {
        "q": "Which algorithm works for both directed and undirected graphs to find shortest paths?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Prim’s",
            "DFS",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following algorithms cannot be used to find connected components?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "DFS",
            "BFS",
            "Union-Find"
        ]
    },
    {
        "q": "Which of the following is a property of a tree that makes Kruskal’s algorithm terminate?",
        "c": null,
        "o": [
            "A tree has V - 1 edges and no cycles",
            "A tree is always balanced",
            "A tree has only one path between nodes",
            "A tree is always directed"
        ]
    },
    {
        "q": "Which algorithm uses parent tracking to avoid cycles while constructing an MST?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "Which type of graph is guaranteed to have an MST?",
        "c": null,
        "o": [
            "Connected and undirected",
            "Directed acyclic",
            "Complete and directed",
            "Unweighted and disconnected"
        ]
    },
    {
        "q": "Which of the following is NOT a valid use case for DFS?",
        "c": null,
        "o": [
            "Finding shortest paths in weighted graphs",
            "Topological sorting",
            "Cycle detection",
            "Exploring connected components"
        ]
    },
    {
        "q": "Which traversal explores all neighbors of a node before going deeper?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is a key characteristic of the Floyd-Warshall algorithm?",
        "c": null,
        "o": [
            "It finds shortest paths between all pairs of vertices",
            "It only works on trees",
            "It builds a minimum spanning tree",
            "It performs a depth-first search"
        ]
    },
    {
        "q": "Which of the following algorithms performs better on dense graphs for shortest paths?",
        "c": null,
        "o": [
            "Floyd-Warshall",
            "Bellman-Ford",
            "DFS",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which structure is used to track components in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Disjoint Set (Union-Find)",
            "Queue",
            "Stack",
            "Adjacency Matrix"
        ]
    },
    {
        "q": "Which step ensures correctness in Dijkstra’s algorithm when updating neighbors?",
        "c": null,
        "o": [
            "Relaxation",
            "Sorting the graph",
            "Coloring vertices",
            "Running BFS"
        ]
    },
    {
        "q": "Which of the following is true about BFS in terms of memory usage?",
        "c": null,
        "o": [
            "It may consume more memory than DFS in wide graphs",
            "It always uses less memory than DFS",
            "Its memory usage is constant",
            "It doesn’t use any extra memory"
        ]
    },
    {
        "q": "Which is a major drawback of using adjacency matrix for large sparse graphs?",
        "c": null,
        "o": [
            "Wasted memory",
            "Incorrect traversal order",
            "Duplicate edges",
            "Unsorted neighbors"
        ]
    },
    {
        "q": "How many times are the edges relaxed in Bellman-Ford algorithm?",
        "c": null,
        "o": [
            "V - 1 times",
            "E times",
            "V times",
            "Until a cycle is found"
        ]
    },
    {
        "q": "Which algorithm is typically used in networking to find routing paths efficiently?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "What does it mean if a graph traversal visits all nodes and no edge is visited twice?",
        "c": null,
        "o": [
            "The graph is a tree",
            "The graph is cyclic",
            "The graph is disconnected",
            "Traversal is incomplete"
        ]
    },
    {
        "q": "Which of the following algorithms is not designed to find shortest paths?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm",
            "Floyd-Warshall Algorithm"
        ]
    },
    {
        "q": "Which of the following traversal algorithms is most suitable for topological sorting?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What does the Floyd-Warshall algorithm use as its main approach?",
        "c": null,
        "o": [
            "Dynamic Programming",
            "Greedy Technique",
            "Recursion",
            "Backtracking"
        ]
    },
    {
        "q": "Which condition indicates the presence of a negative weight cycle in Bellman-Ford?",
        "c": null,
        "o": [
            "Further relaxation is possible after V - 1 iterations",
            "All distances become zero",
            "The graph becomes disconnected",
            "A node is revisited during DFS"
        ]
    },
    {
        "q": "Which algorithm is most suitable for finding the shortest path in a weighted DAG?",
        "c": null,
        "o": [
            "Topological Sort + Relaxation",
            "Dijkstra’s Algorithm",
            "Floyd-Warshall",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which of the following algorithms can work with negative edge weights (but no negative cycles)?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "BFS"
        ]
    },
    {
        "q": "In an undirected connected graph, how many edges will a Minimum Spanning Tree contain?",
        "c": null,
        "o": [
            "V - 1",
            "V",
            "E - V",
            "2V - 1"
        ]
    },
    {
        "q": "Which of these graph algorithms is ideal for detecting strongly connected components?",
        "c": null,
        "o": [
            "Kosaraju’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "Which statement about DFS is FALSE?",
        "c": null,
        "o": [
            "DFS guarantees the shortest path",
            "DFS can be implemented using a stack",
            "DFS may traverse deeper before neighbors",
            "DFS is useful for topological sorting"
        ]
    },
    {
        "q": "Which traversal technique uses coloring (white-gray-black) for cycle detection in directed graphs?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which of the following algorithms is the least efficient for dense graphs when implemented naively?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "DFS",
            "Prim’s with min-heap",
            "Kruskal’s with DSU"
        ]
    },
    {
        "q": "What does a Minimum Spanning Tree (MST) of a graph ensure?",
        "c": null,
        "o": [
            "Minimum total edge weight connecting all vertices",
            "Shortest path from source to all vertices",
            "Maximum edge weight without cycles",
            "All nodes visited exactly once"
        ]
    },
    {
        "q": "Which algorithm should you use to find the shortest path between two nodes in a DAG?",
        "c": null,
        "o": [
            "Topological Sort + Relaxation",
            "Kruskal’s Algorithm",
            "DFS with Cycle Detection",
            "BFS with Weights"
        ]
    },
    {
        "q": "Which step is performed after each edge is added in Kruskal's algorithm?",
        "c": null,
        "o": [
            "Check for cycle using Union-Find",
            "Rebuild priority queue",
            "Sort vertices",
            "Recompute shortest paths"
        ]
    },
    {
        "q": "Which of these is most efficient for finding MST in a dense graph?",
        "c": null,
        "o": [
            "Prim’s with Min-Heap",
            "Kruskal’s with sorted edges",
            "DFS with Union-Find",
            "Dijkstra’s Algorithm"
        ]
    },
    {
        "q": "What makes Dijkstra’s algorithm greedy?",
        "c": null,
        "o": [
            "It always picks the next closest unvisited node",
            "It updates all paths simultaneously",
            "It revisits nodes for shorter paths",
            "It builds a spanning tree"
        ]
    },
    {
        "q": "Which traversal algorithm can result in stack overflow on deep graphs if implemented recursively?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Kruskal’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which of these algorithms is ideal for finding multiple disconnected components?",
        "c": null,
        "o": [
            "DFS",
            "Prim’s",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What condition must a graph satisfy to have a unique Minimum Spanning Tree?",
        "c": null,
        "o": [
            "All edge weights are distinct",
            "All nodes are connected",
            "Graph is directed",
            "Graph is acyclic"
        ]
    },
    {
        "q": "Which of the following is a valid property of BFS?",
        "c": null,
        "o": [
            "BFS visits nodes in order of increasing distance from the source",
            "BFS is depth-first",
            "BFS is always recursive",
            "BFS skips repeated nodes"
        ]
    },
    {
        "q": "Which algorithm uses the idea of adding the shortest edge from the tree to a new vertex?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "Bellman-Ford"
        ]
    },
    {
        "q": "Which algorithm checks all possible paths and relaxes edges even if visited before?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "DFS"
        ]
    },
    {
        "q": "Which of these is true about BFS in a graph with uniform edge weights?",
        "c": null,
        "o": [
            "It gives the shortest path from the source",
            "It visits deepest nodes first",
            "It always requires a min-heap",
            "It doesn’t guarantee shortest paths"
        ]
    },
    {
        "q": "What is a common application of DFS in directed graphs?",
        "c": null,
        "o": [
            "Topological sorting",
            "Minimum spanning tree",
            "Shortest path",
            "Cycle-free traversal"
        ]
    },
    {
        "q": "Which algorithm is ideal for finding strongly connected components?",
        "c": null,
        "o": [
            "Kosaraju’s Algorithm",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "What happens if you apply Dijkstra’s algorithm on a graph with negative edge weights?",
        "c": null,
        "o": [
            "It may give incorrect shortest paths",
            "It throws an error",
            "It skips those edges",
            "It removes those edges"
        ]
    },
    {
        "q": "Which traversal uses a stack (explicit or implicit) to manage its nodes?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What is the key idea behind the 'greedy' approach in Prim’s algorithm?",
        "c": null,
        "o": [
            "Always choose the lowest weight edge that connects to the tree",
            "Always choose the farthest node",
            "Update all distances in parallel",
            "Avoid visiting the same node"
        ]
    },
    {
        "q": "Which of these algorithms does not rely on edge weights for its correctness?",
        "c": null,
        "o": [
            "DFS",
            "Dijkstra’s",
            "Prim’s",
            "Bellman-Ford"
        ]
    },
    {
        "q": "Which graph algorithm works well even if the input graph is disconnected?",
        "c": null,
        "o": [
            "Kruskal’s",
            "Prim’s",
            "Dijkstra’s",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "In which scenario is BFS guaranteed to give the shortest path?",
        "c": null,
        "o": [
            "When all edge weights are equal",
            "When graph is directed",
            "In any weighted graph",
            "In any tree"
        ]
    },
    {
        "q": "Which graph representation is most space-efficient for sparse graphs?",
        "c": null,
        "o": [
            "Adjacency List",
            "Adjacency Matrix",
            "Edge Matrix",
            "Incidence Matrix"
        ]
    },
    {
        "q": "Which algorithm is commonly used in GPS navigation systems?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "DFS",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which of the following traversal methods is optimal for finding the shortest path in a maze?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which step is essential in Kruskal’s algorithm before selecting edges?",
        "c": null,
        "o": [
            "Sorting edges by weight",
            "Sorting vertices",
            "Constructing adjacency list",
            "Computing degrees of vertices"
        ]
    },
    {
        "q": "What does Union-Find data structure optimize using path compression?",
        "c": null,
        "o": [
            "Finding root parent of a set",
            "Sorting edges",
            "Finding shortest path",
            "Traversing all nodes"
        ]
    },
    {
        "q": "Which traversal method can be used to detect back edges in a graph?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm efficiently handles graphs with negative edges but no negative cycles?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "Which of the following algorithms is best suited for dense graphs with non-negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s with adjacency matrix",
            "Kruskal’s",
            "DFS",
            "BFS"
        ]
    },
    {
        "q": "Which algorithm updates distance values repeatedly using dynamic programming?",
        "c": null,
        "o": [
            "Floyd-Warshall",
            "Prim’s",
            "DFS",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which condition must hold for an MST to be unique?",
        "c": null,
        "o": [
            "All edge weights must be distinct",
            "Graph must be a DAG",
            "No cycles allowed",
            "Graph must be bipartite"
        ]
    },
    {
        "q": "What is the time complexity of Kruskal’s algorithm with a Union-Find structure?",
        "c": null,
        "o": [
            "O(E log E)",
            "O(V^2)",
            "O(E + V)",
            "O(V log V)"
        ]
    },
    {
        "q": "Which of the following algorithms is typically used in applications like airline route planning?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which graph algorithm can be used to test whether a graph is bipartite?",
        "c": null,
        "o": [
            "BFS",
            "Prim’s",
            "Kruskal’s",
            "Bellman-Ford"
        ]
    },
    {
        "q": "What is the minimum number of edges needed to keep a connected graph with V vertices connected?",
        "c": null,
        "o": [
            "V - 1",
            "V",
            "V + 1",
            "2V"
        ]
    },
    {
        "q": "In a directed graph, what kind of edge in DFS represents a back edge?",
        "c": null,
        "o": [
            "An edge pointing to an ancestor in the DFS tree",
            "An edge pointing to a child",
            "An edge to a sibling",
            "An edge not part of DFS"
        ]
    },
    {
        "q": "Which algorithm is used to solve the single-source shortest path problem even in graphs with negative edges?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "Topological Sort"
        ]
    },
    {
        "q": "Which is a valid use-case for finding a Minimum Spanning Tree?",
        "c": null,
        "o": [
            "Laying out electrical wiring with minimal cost",
            "Scheduling tasks with dependencies",
            "Finding strongly connected components",
            "Finding the diameter of a graph"
        ]
    },
    {
        "q": "Which of these statements is TRUE for BFS in an unweighted graph?",
        "c": null,
        "o": [
            "BFS finds the shortest path from the source to all vertices",
            "BFS skips duplicate edges",
            "BFS cannot detect cycles",
            "BFS uses a stack for implementation"
        ]
    },
    {
        "q": "Which algorithm can handle both negative and positive edge weights and computes all-pairs shortest paths?",
        "c": null,
        "o": [
            "Floyd-Warshall",
            "Dijkstra’s",
            "Prim’s",
            "DFS"
        ]
    },
    {
        "q": "What does the ‘parent’ array represent in Union-Find data structure?",
        "c": null,
        "o": [
            "The representative of each set",
            "The minimum edge weight",
            "The depth of DFS tree",
            "The number of neighbors"
        ]
    },
    {
        "q": "Which of the following is a prerequisite for performing topological sorting?",
        "c": null,
        "o": [
            "The graph must be a Directed Acyclic Graph (DAG)",
            "The graph must be connected",
            "All edge weights must be positive",
            "The graph must be undirected"
        ]
    },
    {
        "q": "What is the primary difference between BFS and DFS?",
        "c": null,
        "o": [
            "BFS explores neighbors first, DFS explores depth first",
            "BFS uses a stack, DFS uses a queue",
            "DFS guarantees shortest path, BFS does not",
            "BFS cannot detect cycles, DFS can"
        ]
    },
    {
        "q": "Which of the following algorithms requires edge sorting before execution?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "What data structure is typically used to implement Prim’s algorithm efficiently?",
        "c": null,
        "o": [
            "Min-Heap (Priority Queue)",
            "Stack",
            "Union-Find",
            "Hash Table"
        ]
    },
    {
        "q": "Which graph algorithm is ideal for finding the shortest path in a weighted graph with non-negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "Prim’s Algorithm",
            "Topological Sort"
        ]
    },
    {
        "q": "In a DFS traversal, what is a 'tree edge'?",
        "c": null,
        "o": [
            "An edge that connects a vertex to a newly discovered vertex",
            "An edge that forms a cycle",
            "An edge to a visited ancestor",
            "An edge that connects two already visited nodes"
        ]
    },
    {
        "q": "Which algorithm will always fail if the graph contains negative weight cycles?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What will be the time complexity of Floyd-Warshall for a graph with V vertices?",
        "c": null,
        "o": [
            "O(V^3)",
            "O(V^2)",
            "O(V log V)",
            "O(E log V)"
        ]
    },
    {
        "q": "Which algorithm is more suitable when edge weights are mostly the same or zero?",
        "c": null,
        "o": [
            "BFS",
            "Dijkstra’s",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which of the following algorithms builds a solution by picking edges one at a time from the sorted list?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Bellman-Ford",
            "Floyd-Warshall"
        ]
    },
    {
        "q": "Which of the following graph algorithms can be used to check if a graph is connected?",
        "c": null,
        "o": [
            "DFS",
            "Prim’s",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which of the following is a safe edge to add when building an MST using Kruskal’s algorithm?",
        "c": null,
        "o": [
            "The minimum weight edge that doesn’t form a cycle",
            "The edge with maximum weight",
            "The edge between any two leaf nodes",
            "An edge to a previously visited vertex"
        ]
    },
    {
        "q": "What does a gray node represent in DFS using the white-gray-black coloring method?",
        "c": null,
        "o": [
            "Node is currently being visited",
            "Node has not been visited yet",
            "Node is fully processed",
            "Node is unreachable"
        ]
    },
    {
        "q": "Which algorithm is typically used when we want to find the shortest path in a graph with negative and positive weights?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "DFS"
        ]
    },
    {
        "q": "In Kruskal’s algorithm, what is the reason for using the Union-Find data structure?",
        "c": null,
        "o": [
            "To detect and avoid cycles",
            "To calculate distances",
            "To find neighbors quickly",
            "To track recursion"
        ]
    },
    {
        "q": "Which traversal is more likely to use a queue in its implementation?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the worst-case time complexity of Dijkstra’s algorithm using a min-heap?",
        "c": null,
        "o": [
            "O((V + E) log V)",
            "O(V^2)",
            "O(VE)",
            "O(E log E)"
        ]
    },
    {
        "q": "Which algorithm finds the shortest path from all nodes to all other nodes?",
        "c": null,
        "o": [
            "Floyd-Warshall",
            "Bellman-Ford",
            "Prim’s",
            "DFS"
        ]
    },
    {
        "q": "What is the output of a BFS traversal on a disconnected graph starting from node A?",
        "c": null,
        "o": [
            "Only the component containing A",
            "All components",
            "Shortest path to all nodes",
            "None of the above"
        ]
    },
    {
        "q": "Which algorithm is guaranteed to run in polynomial time even with negative edge weights?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Kruskal’s",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which of the following data structures is used by BFS for storing nodes to be visited?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Priority Queue",
            "Set"
        ]
    },
    {
        "q": "Which algorithm finds the Minimum Spanning Tree without visiting all adjacent vertices?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which traversal ensures the shortest path in an unweighted graph?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Kruskal’s",
            "Topological Sort"
        ]
    },
    {
        "q": "Which algorithm maintains a visited array and a distance array to calculate shortest paths?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "DFS",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which of the following edge types in DFS indicates a cycle in a directed graph?",
        "c": null,
        "o": [
            "Back Edge",
            "Tree Edge",
            "Forward Edge",
            "Cross Edge"
        ]
    },
    {
        "q": "Which algorithm builds the MST by continuously expanding the tree from one node?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "Bellman-Ford Algorithm",
            "DFS"
        ]
    },
    {
        "q": "Which of the following is NOT a valid application of graph algorithms?",
        "c": null,
        "o": [
            "Binary Search Tree balancing",
            "Navigation systems",
            "Social network analysis",
            "Scheduling tasks"
        ]
    },
    {
        "q": "Which algorithm cannot be used if the graph contains negative weight cycles?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Floyd-Warshall",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which traversal method uses LIFO order for visiting nodes?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What is the result of topological sorting on a directed cyclic graph?",
        "c": null,
        "o": [
            "It is not possible",
            "Sorted order of nodes",
            "A spanning tree",
            "All paths from source"
        ]
    },
    {
        "q": "Which of the following algorithms does NOT require a priority queue?",
        "c": null,
        "o": [
            "DFS",
            "Dijkstra’s",
            "Prim’s (efficient version)",
            "A* Search"
        ]
    },
    {
        "q": "What does the Union operation in Union-Find do?",
        "c": null,
        "o": [
            "Merges two disjoint sets into one",
            "Finds the shortest path",
            "Sorts all edges",
            "Checks graph connectivity"
        ]
    },
    {
        "q": "Which traversal is best suited for checking bipartiteness in an undirected graph?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Dijkstra’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which traversal uses a recursive approach and is prone to stack overflow in deep graphs?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Kruskal’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "Which graph traversal can be used to find articulation points?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "Which algorithm ensures that every edge selected does not form a cycle?",
        "c": null,
        "o": [
            "Kruskal’s",
            "Prim’s",
            "Dijkstra’s",
            "DFS"
        ]
    },
    {
        "q": "Which of these algorithms uses edge relaxation as a core step?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Prim’s",
            "DFS",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the main purpose of parent pointers in DFS cycle detection?",
        "c": null,
        "o": [
            "To identify back edges",
            "To track visited levels",
            "To store edge weights",
            "To minimize edge count"
        ]
    },
    {
        "q": "Which graph algorithm is used in detecting bridges (critical connections) in a network?",
        "c": null,
        "o": [
            "Tarjan’s Algorithm",
            "Prim’s Algorithm",
            "Bellman-Ford",
            "BFS"
        ]
    },
    {
        "q": "Which algorithm is optimal for finding MSTs in dense graphs?",
        "c": null,
        "o": [
            "Prim’s with Min-Heap",
            "Kruskal’s",
            "DFS",
            "Bellman-Ford"
        ]
    },
    {
        "q": "Which of the following operations does Prim’s algorithm perform repeatedly?",
        "c": null,
        "o": [
            "Selects the smallest edge connecting a new vertex to the MST",
            "Sorts all edges by weight",
            "Detects cycles using Union-Find",
            "Performs topological sorting"
        ]
    },
    {
        "q": "Which traversal is used in Kosaraju’s algorithm for finding strongly connected components?",
        "c": null,
        "o": [
            "DFS (two passes)",
            "BFS (level order)",
            "Prim’s followed by DFS",
            "Dijkstra’s followed by BFS"
        ]
    },
    {
        "q": "Which of the following problems can be solved using BFS in a graph?",
        "c": null,
        "o": [
            "Shortest path in an unweighted graph",
            "Minimum spanning tree",
            "Topological sorting",
            "Longest path"
        ]
    },
    {
        "q": "What is the primary difference between Kruskal’s and Prim’s algorithms?",
        "c": null,
        "o": [
            "Kruskal’s builds forests, Prim’s expands a single tree",
            "Kruskal’s uses a queue, Prim’s uses a stack",
            "Prim’s uses DFS, Kruskal’s uses BFS",
            "Kruskal’s avoids weights, Prim’s uses them"
        ]
    },
    {
        "q": "In an undirected graph, what is a bridge?",
        "c": null,
        "o": [
            "An edge whose removal increases the number of connected components",
            "An edge with the maximum weight",
            "An edge that connects to a leaf node",
            "A shortcut added for optimization"
        ]
    },
    {
        "q": "Which graph algorithm can work correctly only if there are no cycles?",
        "c": null,
        "o": [
            "Topological Sort",
            "Kruskal’s Algorithm",
            "Bellman-Ford",
            "DFS"
        ]
    },
    {
        "q": "What is the space complexity of an adjacency matrix for a graph with V vertices?",
        "c": null,
        "o": [
            "O(V^2)",
            "O(E)",
            "O(V)",
            "O(V+E)"
        ]
    },
    {
        "q": "In which case will Dijkstra’s algorithm return incorrect results?",
        "c": null,
        "o": [
            "If the graph contains negative edge weights",
            "If the graph is cyclic",
            "If the graph is a tree",
            "If all edge weights are the same"
        ]
    },
    {
        "q": "Which algorithm is generally faster for dense graphs with non-negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s with adjacency matrix",
            "Bellman-Ford",
            "Kruskal’s",
            "BFS"
        ]
    },
    {
        "q": "Which algorithm guarantees shortest paths but requires multiple edge relaxations?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "Topological Sort"
        ]
    },
    {
        "q": "Which traversal algorithm is best suited to determine if a path exists between two nodes?",
        "c": null,
        "o": [
            "DFS",
            "Prim’s",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What is the key concept behind edge relaxation in shortest path algorithms?",
        "c": null,
        "o": [
            "Updating a shorter known path to a node",
            "Increasing edge weights to avoid cycles",
            "Deleting visited nodes",
            "Adding edges to the spanning tree"
        ]
    },
    {
        "q": "Which traversal algorithm is used in Tarjan’s algorithm to find strongly connected components?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Prim’s",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What is a characteristic of a tree edge in DFS?",
        "c": null,
        "o": [
            "Connects a node to a newly discovered vertex",
            "Connects a node back to an ancestor",
            "Connects two fully explored vertices",
            "Forms a cross connection in another component"
        ]
    },
    {
        "q": "Which algorithm is used to find shortest paths from a single source to all other vertices in a weighted graph with non-negative weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Floyd-Warshall",
            "Prim’s Algorithm",
            "Topological Sort"
        ]
    },
    {
        "q": "What happens in Prim’s algorithm when all adjacent edges of the current MST are already included?",
        "c": null,
        "o": [
            "The next minimum-weight edge connecting an unvisited node is selected",
            "The algorithm terminates immediately",
            "The graph is reset and traversal starts over",
            "An exception is thrown"
        ]
    },
    {
        "q": "In a connected graph, how many minimum spanning trees can there be if all edge weights are unique?",
        "c": null,
        "o": [
            "Exactly one",
            "More than one",
            "Zero",
            "Equal to the number of vertices"
        ]
    },
    {
        "q": "Which of the following can detect cycles in an undirected graph?",
        "c": null,
        "o": [
            "DFS with parent tracking",
            "Prim’s Algorithm",
            "Kruskal’s without Union-Find",
            "Dijkstra’s"
        ]
    },
    {
        "q": "What is the worst-case time complexity of BFS on a graph with V vertices and E edges?",
        "c": null,
        "o": [
            "O(V + E)",
            "O(V^2)",
            "O(E log V)",
            "O(V log E)"
        ]
    },
    {
        "q": "Which graph algorithm is used to detect negative cycles?",
        "c": null,
        "o": [
            "Bellman-Ford",
            "Dijkstra’s",
            "Prim’s",
            "DFS"
        ]
    },
  {
    "q": "Which algorithm is commonly used to find the shortest path from a single source to all vertices in a graph with non-negative weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What data structure is commonly used to efficiently implement the Union-Find in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Disjoint Set Union (DSU)",
      "Priority Queue",
      "Adjacency List",
      "Stack"
    ]
  },
  {
    "q": "Which traversal method uses a queue to maintain nodes to visit next?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What is the primary purpose of edge relaxation in shortest path algorithms?",
    "c": null,
    "o": [
      "To update the shortest known distance to a vertex",
      "To detect cycles in the graph",
      "To find connected components",
      "To build a minimum spanning tree"
    ]
  },
  {
    "q": "Which algorithm can handle graphs with negative edge weights but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "In DFS, what does a back edge indicate in a directed graph?",
    "c": null,
    "o": [
      "A cycle exists",
      "A leaf node",
      "A disconnected node",
      "A tree edge"
    ]
  },
  {
    "q": "Which algorithm builds a minimum spanning tree by adding the smallest edge that connects a new vertex to the growing tree?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What is the time complexity of BFS in a graph with V vertices and E edges?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which graph algorithm is used for topological sorting?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s",
      "Kruskal’s"
    ]
  },
  {
    "q": "What is the main advantage of using adjacency lists over adjacency matrices?",
    "c": null,
    "o": [
      "Efficient space usage for sparse graphs",
      "Faster edge existence checks",
      "Easier to implement",
      "Better for dense graphs"
    ]
  },
    {
        "q": "Which algorithm uses a priority queue to greedily select the next edge with the smallest weight?",
        "c": null,
        "o": [
            "Prim’s Algorithm",
            "Kruskal’s Algorithm",
            "DFS",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "What is the output of running BFS starting from a given node in an unweighted graph?",
        "c": null,
        "o": [
            "Shortest path distances to all reachable nodes",
            "All nodes in depth-first order",
            "Minimum spanning tree edges",
            "All cycles in the graph"
        ]
    },
    {
        "q": "Which property must hold true for a graph to be a Directed Acyclic Graph (DAG)?",
        "c": null,
        "o": [
            "No cycles exist",
            "All vertices are connected",
            "It has weighted edges",
            "It is undirected"
        ]
    },
    {
        "q": "Which algorithm repeatedly picks the smallest edge and uses Union-Find to avoid cycles?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "In Dijkstra’s algorithm, what data structure is commonly used to efficiently extract the next node with the smallest tentative distance?",
        "c": null,
        "o": [
            "Min-Heap (Priority Queue)",
            "Stack",
            "Queue",
            "Set"
        ]
    },
    {
        "q": "Which of the following is true about a Minimum Spanning Tree (MST)?",
        "c": null,
        "o": [
            "It connects all vertices with minimum total edge weight",
            "It finds the shortest path between two vertices",
            "It detects cycles in a graph",
            "It only works for directed graphs"
        ]
    },
    {
        "q": "Which algorithm uses depth-first traversal to assign finishing times to nodes in preparation for a second pass?",
        "c": null,
        "o": [
            "Kosaraju’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which algorithm guarantees to find shortest paths even if the graph has edges with negative weights (but no negative cycles)?",
        "c": null,
        "o": [
            "Bellman-Ford Algorithm",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "What is the main disadvantage of using an adjacency matrix to represent graphs?",
        "c": null,
        "o": [
            "Consumes O(V^2) space, inefficient for sparse graphs",
            "Difficult to check if an edge exists",
            "Does not support weighted edges",
            "Cannot represent directed graphs"
        ]
    },
    {
        "q": "Which graph algorithm is used to find the shortest path from all vertices to all other vertices?",
        "c": null,
        "o": [
            "Floyd-Warshall Algorithm",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "What is the purpose of a 'visited' array in graph traversal algorithms like DFS and BFS?",
        "c": null,
        "o": [
            "To keep track of nodes already explored",
            "To store edge weights",
            "To maintain the order of nodes",
            "To count the total number of edges"
        ]
    },
    {
        "q": "Which of these graph representations allows for O(1) time complexity to check if an edge exists between two vertices?",
        "c": null,
        "o": [
            "Adjacency Matrix",
            "Adjacency List",
            "Edge List",
            "Incidence Matrix"
        ]
    },
    {
        "q": "Which algorithm is commonly used to find cycles in a directed graph?",
        "c": null,
        "o": [
            "DFS with recursion stack",
            "BFS",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "Which algorithm can be used to find the shortest path in a weighted DAG?",
        "c": null,
        "o": [
            "Topological Sort followed by relaxation",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm",
            "Prim’s Algorithm"
        ]
    },
    {
        "q": "What is the advantage of using a min-priority queue in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Efficiently select the next vertex with the smallest tentative distance",
            "Avoid revisiting nodes",
            "Keep track of all visited nodes",
            "Store the shortest path trees"
        ]
    },
    {
        "q": "Which algorithm is most efficient for finding an MST in a graph with many edges?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which of the following is NOT a characteristic of DFS?",
        "c": null,
        "o": [
            "Uses a queue to keep track of nodes",
            "Can be implemented recursively",
            "Explores as far as possible along each branch",
            "Can detect cycles in a graph"
        ]
    },
    {
        "q": "What technique does Union-Find use to optimize repeated find operations?",
        "c": null,
        "o": [
            "Path compression",
            "Priority queue",
            "Dynamic programming",
            "Memoization"
        ]
    },
    {
        "q": "Which graph algorithm is especially useful for scheduling tasks with dependencies?",
        "c": null,
        "o": [
            "Topological Sort",
            "DFS",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "Which of the following is true about the edges in a Minimum Spanning Tree?",
        "c": null,
        "o": [
            "They connect all vertices with minimum total weight without cycles",
            "They include every edge in the graph",
            "They always form a cycle",
            "They only exist in directed graphs"
        ]
    },
    {
        "q": "Which algorithm can detect negative weight cycles in a graph?",
        "c": null,
        "o": [
            "Bellman-Ford Algorithm",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "In BFS, what data structure is primarily used to track the order of nodes to be visited?",
        "c": null,
        "o": [
            "Queue",
            "Stack",
            "Priority Queue",
            "Set"
        ]
    },
    {
        "q": "Which of the following best describes the time complexity of Kruskal’s algorithm?",
        "c": null,
        "o": [
            "O(E log E)",
            "O(V^2)",
            "O(V + E)",
            "O(E + V log V)"
        ]
    },
    {
        "q": "In which scenario is Prim’s algorithm preferred over Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Dense graphs with many edges",
            "Sparse graphs with few edges",
            "Graphs with negative edge weights",
            "Directed graphs"
        ]
    },
    {
        "q": "Which graph algorithm uses a recursive stack to keep track of nodes during traversal?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Prim’s"
        ]
    },
    {
        "q": "What is the key idea behind the edge relaxation step in shortest path algorithms?",
        "c": null,
        "o": [
            "Updating the shortest distance if a better path is found",
            "Adding new edges to the graph",
            "Removing cycles from the graph",
            "Sorting edges by weight"
        ]
    },
    {
        "q": "Which of the following algorithms is NOT guaranteed to work correctly on graphs with negative edge weights?",
        "c": null,
        "o": [
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm",
            "Floyd-Warshall Algorithm",
            "Johnson’s Algorithm"
        ]
    },
    {
        "q": "Which of these is NOT a property of a Minimum Spanning Tree?",
        "c": null,
        "o": [
            "It contains cycles",
            "It connects all vertices",
            "It has minimum total edge weight",
            "It is a subset of edges of the graph"
        ]
    },
    {
        "q": "Which traversal algorithm explores vertices in layers based on their distance from the source node?",
        "c": null,
        "o": [
            "BFS",
            "DFS",
            "Prim’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "What kind of graph can topological sort be applied to?",
        "c": null,
        "o": [
            "Directed Acyclic Graph (DAG)",
            "Undirected Graph",
            "Cyclic Graph",
            "Weighted Graph"
        ]
    },
    {
        "q": "In the Union-Find data structure, what is the purpose of the 'find' operation?",
        "c": null,
        "o": [
            "To determine which subset a particular element belongs to",
            "To merge two subsets into one",
            "To count the number of subsets",
            "To add a new element to the structure"
        ]
    },
    {
        "q": "Which of the following is NOT a step in Dijkstra’s algorithm?",
        "c": null,
        "o": [
            "Relaxing edges",
            "Updating distances",
            "Adding nodes to MST",
            "Selecting the vertex with the smallest tentative distance"
        ]
    },
    {
        "q": "What is the main difference between Prim’s and Kruskal’s MST algorithms?",
        "c": null,
        "o": [
            "Prim’s grows one tree, Kruskal’s grows a forest of trees",
            "Prim’s works only for directed graphs, Kruskal’s only for undirected",
            "Kruskal’s uses BFS, Prim’s uses DFS",
            "Kruskal’s is faster for dense graphs"
        ]
    },
    {
        "q": "Which algorithm uses a color-coding system (white, gray, black) to keep track of node states?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Prim’s"
        ]
    },
    {
        "q": "Which algorithm is commonly used to find the shortest paths between all pairs of vertices?",
        "c": null,
        "o": [
            "Floyd-Warshall Algorithm",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm",
            "Kruskal’s Algorithm"
        ]
    },
    {
        "q": "In which data structure are the graph edges stored for Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Edge List",
            "Adjacency Matrix",
            "Adjacency List",
            "Priority Queue"
        ]
    },
    {
        "q": "Which algorithm requires the graph to be acyclic to produce correct results?",
        "c": null,
        "o": [
            "Topological Sort",
            "Dijkstra’s Algorithm",
            "Prim’s Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which type of edge in DFS traversal indicates a cycle in a directed graph?",
        "c": null,
        "o": [
            "Back Edge",
            "Forward Edge",
            "Cross Edge",
            "Tree Edge"
        ]
    },
    {
        "q": "What is the time complexity of Prim’s algorithm when implemented with a binary heap and adjacency list?",
        "c": null,
        "o": [
            "O(E log V)",
            "O(V^2)",
            "O(V + E)",
            "O(E log E)"
        ]
    },
    {
        "q": "Which of the following is true about BFS in an unweighted graph?",
        "c": null,
        "o": [
            "It finds the shortest path from the source to all vertices",
            "It always finds the minimum spanning tree",
            "It cannot detect cycles",
            "It requires a priority queue"
        ]
    },
    {
        "q": "Which of the following best describes a connected graph?",
        "c": null,
        "o": [
            "There is a path between every pair of vertices",
            "No cycles exist in the graph",
            "All vertices have the same degree",
            "Graph contains weighted edges"
        ]
    },
    {
        "q": "In Dijkstra’s algorithm, how are vertices typically selected for processing?",
        "c": null,
        "o": [
            "By choosing the vertex with the minimum tentative distance",
            "By selecting vertices in alphabetical order",
            "By using a stack to store vertices",
            "By randomly selecting vertices"
        ]
    },
    {
        "q": "Which of the following graph representations is most efficient for sparse graphs?",
        "c": null,
        "o": [
            "Adjacency List",
            "Adjacency Matrix",
            "Edge List",
            "Incidence Matrix"
        ]
    },
    {
        "q": "What does the 'cycle detection' feature in DFS rely on?",
        "c": null,
        "o": [
            "Checking if a vertex is revisited during recursion",
            "Using a queue to track visited nodes",
            "Sorting the edges by weight",
            "Using Union-Find data structure"
        ]
    },
    {
        "q": "Which algorithm is used to find the minimum spanning tree by sorting edges?",
        "c": null,
        "o": [
            "Kruskal’s Algorithm",
            "Prim’s Algorithm",
            "Dijkstra’s Algorithm",
            "Bellman-Ford Algorithm"
        ]
    },
    {
        "q": "Which traversal method can be used to perform a topological sort of a DAG?",
        "c": null,
        "o": [
            "DFS",
            "BFS",
            "Dijkstra’s",
            "Kruskal’s"
        ]
    },
    {
        "q": "In which scenario would you use Dijkstra’s algorithm instead of BFS?",
        "c": null,
        "o": [
            "When the graph has weighted edges",
            "When the graph is unweighted",
            "When the graph is directed and acyclic",
            "When you need to find minimum spanning tree"
        ]
    },
    {
        "q": "Which data structure helps efficiently manage disjoint sets in Kruskal’s algorithm?",
        "c": null,
        "o": [
            "Union-Find",
            "Queue",
            "Stack",
            "Heap"
        ]
    },
    {
        "q": "Which of the following statements is true about BFS?",
        "c": null,
        "o": [
            "It visits nodes level by level",
            "It uses recursion to traverse",
            "It prioritizes deeper nodes",
            "It cannot be used on disconnected graphs"
        ]
    },
    {
        "q": "Which algorithm can be used to detect if a graph is bipartite?",
        "c": null,
        "o": [
            "BFS with 2-coloring",
            "DFS for cycle detection",
            "Kruskal’s Algorithm",
            "Prim’s Algorithm"
        ]
    },
  {
    "q": "What is the main advantage of using adjacency lists over adjacency matrices?",
    "c": null,
    "o": [
      "Adjacency lists use less memory for sparse graphs",
      "Adjacency lists provide faster edge existence checks",
      "Adjacency lists are easier to implement",
      "Adjacency lists only work for undirected graphs"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path in a weighted graph by repeatedly relaxing edges up to V-1 times?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What type of graph does Prim’s algorithm require?",
    "c": null,
    "o": [
      "Connected weighted undirected graph",
      "Disconnected graph",
      "Directed acyclic graph",
      "Unweighted graph"
    ]
  },
  {
    "q": "Which traversal method uses a queue data structure?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Topological Sort",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "In DFS, what does a forward edge represent?",
    "c": null,
    "o": [
      "An edge from a node to a descendant in the DFS tree",
      "An edge to an ancestor",
      "An edge to a visited node in another subtree",
      "An edge creating a cycle"
    ]
  },
  {
    "q": "Which algorithm constructs the MST by sorting all edges first?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What is the key difference between BFS and DFS?",
    "c": null,
    "o": [
      "BFS uses a queue; DFS uses a stack or recursion",
      "BFS works only on weighted graphs; DFS on unweighted",
      "DFS is faster than BFS in all cases",
      "DFS uses a queue; BFS uses a stack"
    ]
  },
  {
    "q": "Which algorithm detects cycles by checking for back edges during traversal?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which of the following algorithms is suitable for finding shortest paths in graphs with negative edges but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which algorithm is used to find the strongly connected components of a directed graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What does the 'relaxation' step do in shortest path algorithms?",
    "c": null,
    "o": [
      "Updates the shortest known distance to a vertex if a shorter path is found",
      "Removes edges from the graph",
      "Adds new vertices to the graph",
      "Detects cycles in the graph"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a stack explicitly or implicitly?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What is the output of running a topological sort on a Directed Acyclic Graph (DAG)?",
    "c": null,
    "o": [
      "A linear ordering of vertices respecting edge directions",
      "A minimum spanning tree",
      "The shortest path between two nodes",
      "The strongly connected components"
    ]
  },
  {
    "q": "Which MST algorithm is best suited for graphs with fewer edges?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What data structure is essential for implementing Dijkstra’s algorithm efficiently?",
    "c": null,
    "o": [
      "Min-priority queue",
      "Stack",
      "Queue",
      "Disjoint Set Union (DSU)"
    ]
  },
  {
    "q": "Which algorithm can be used to detect cycles in an undirected graph?",
    "c": null,
    "o": [
      "DFS with parent tracking",
      "BFS",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "Which of the following is a characteristic of a Minimum Spanning Tree (MST)?",
    "c": null,
    "o": [
      "It is a subset of edges connecting all vertices without cycles",
      "It contains all edges of the graph",
      "It only applies to directed graphs",
      "It maximizes the total edge weight"
    ]
  },
  {
    "q": "What does the 'union' operation in the Union-Find data structure accomplish?",
    "c": null,
    "o": [
      "Combines two disjoint sets into a single set",
      "Finds the representative of a set",
      "Removes an element from a set",
      "Counts the number of sets"
    ]
  },
  {
    "q": "Which algorithm is preferred for finding the shortest path in a graph with negative edges but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "In BFS, what structure is used to keep track of the next nodes to visit?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Disjoint Set Union"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path in a graph using edge relaxation and can handle negative weights?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the primary purpose of the 'visited' array in DFS and BFS?",
    "c": null,
    "o": [
      "To avoid revisiting nodes and prevent infinite loops",
      "To store edge weights",
      "To track the shortest path",
      "To store the parent of each node"
    ]
  },
  {
    "q": "Which data structure is used in Kruskal’s algorithm to detect cycles?",
    "c": null,
    "o": [
      "Union-Find (Disjoint Set Union)",
      "Stack",
      "Queue",
      "Priority Queue"
    ]
  },
  {
    "q": "What kind of graph does Dijkstra’s algorithm require to guarantee correct results?",
    "c": null,
    "o": [
      "Graph with non-negative edge weights",
      "Graph with negative edge weights",
      "Disconnected graph",
      "Graph with cycles"
    ]
  },
  {
    "q": "Which graph traversal algorithm visits nodes in layers based on their distance from the source node?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is a 'back edge' in DFS traversal?",
    "c": null,
    "o": [
      "An edge that connects a vertex to its ancestor, indicating a cycle",
      "An edge that connects two unrelated vertices",
      "An edge that leads to a leaf node",
      "An edge that is part of the MST"
    ]
  },
  {
    "q": "Which MST algorithm starts with a single vertex and grows the spanning tree by adding the cheapest edge?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which algorithm uses two DFS passes to find strongly connected components?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Tarjan’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "q": "What is the worst-case time complexity of BFS or DFS on a graph with V vertices and E edges?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V log E)"
    ]
  },
  {
    "q": "In a graph, what is the definition of a 'cut edge' (bridge)?",
    "c": null,
    "o": [
      "An edge whose removal increases the number of connected components",
      "An edge that connects two leaf nodes",
      "An edge that forms a cycle",
      "An edge with maximum weight"
    ]
  },
  {
    "q": "What is the key difference between BFS and DFS?",
    "c": null,
    "o": [
      "BFS explores neighbors level by level; DFS explores as deep as possible before backtracking",
      "BFS uses recursion; DFS uses iteration",
      "DFS finds shortest paths; BFS does not",
      "DFS uses a queue; BFS uses a stack"
    ]
  },
  {
    "q": "Which algorithm is most efficient for finding the Minimum Spanning Tree in a dense graph?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which algorithm requires sorting edges before processing them?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "In Dijkstra’s algorithm, what happens if the graph contains negative edge weights?",
    "c": null,
    "o": [
      "Algorithm may give incorrect shortest paths",
      "Algorithm works correctly",
      "Algorithm finds MST instead",
      "Algorithm detects cycles"
    ]
  },
  {
    "q": "Which of these algorithms can be used to detect cycles in a directed graph?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure does BFS primarily use to store nodes to visit next?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Priority Queue",
      "Set"
    ]
  },
  {
    "q": "What is the time complexity of Kruskal’s algorithm when edges are sorted using a good sorting algorithm?",
    "c": null,
    "o": [
      "O(E log E)",
      "O(V^2)",
      "O(V + E)",
      "O(E + V log V)"
    ]
  },
  {
    "q": "Which MST algorithm is better suited for sparse graphs?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which algorithm uses a stack or recursion to traverse graph nodes?",
    "c": null,
    "o": [
      "DFS",
      "BFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is a strongly connected component in a directed graph?",
    "c": null,
    "o": [
      "A maximal set of vertices where each vertex is reachable from every other vertex",
      "A cycle containing all vertices",
      "A subgraph with no edges",
      "A spanning tree"
    ]
  },
  {
    "q": "Which graph traversal method is better for finding the shortest path in an unweighted graph?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the main advantage of the Union-Find data structure in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Efficiently detects cycles while building MST",
      "Keeps track of shortest paths",
      "Stores weights of edges",
      "Performs BFS traversal"
    ]
  },
  {
    "q": "Which algorithm is used for finding shortest paths from a single source in graphs that may contain negative weights?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "In DFS, what does it mean if a vertex is marked 'gray'?",
    "c": null,
    "o": [
      "The vertex is currently being explored",
      "The vertex has not been visited",
      "The vertex exploration is complete",
      "The vertex is disconnected"
    ]
  },
  {
    "q": "Which of the following graph algorithms does NOT guarantee to find the shortest path if negative weights exist?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Floyd-Warshall Algorithm",
      "Johnson’s Algorithm"
    ]
  },
  {
    "q": "What is the key characteristic of a Minimum Spanning Tree?",
    "c": null,
    "o": [
      "It connects all vertices with the minimum total edge weight",
      "It finds the shortest path from a source to all nodes",
      "It detects cycles",
      "It works only on directed graphs"
    ]
  },
  {
    "q": "Which graph algorithm uses a priority queue to select the next edge or node?",
    "c": null,
    "o": [
      "Prim’s and Dijkstra’s Algorithms",
      "DFS and BFS",
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Prim’s algorithm implemented with an adjacency matrix?",
    "c": null,
    "o": [
      "O(V^2)",
      "O(E log V)",
      "O(V + E)",
      "O(E log E)"
    ]
  },
  {
    "q": "Which graph traversal algorithm uses a FIFO data structure?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the purpose of the 'parent' array in DFS or BFS implementations?",
    "c": null,
    "o": [
      "To reconstruct the path or track traversal tree",
      "To store visited status",
      "To hold edge weights",
      "To count node degrees"
    ]
  },
  {
    "q": "What is the space complexity of storing a graph using an adjacency list with V vertices and E edges?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E^2)",
      "O(V)"
    ]
  },
  {
    "q": "Which algorithm can find the shortest path between all pairs of vertices in a weighted graph?",
    "c": null,
    "o": [
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What condition must be met for a graph to have a valid topological ordering?",
    "c": null,
    "o": [
      "It must be a Directed Acyclic Graph (DAG)",
      "It must be connected",
      "It must be undirected",
      "It must contain cycles"
    ]
  },
  {
    "q": "In Kruskal’s algorithm, why are edges sorted before processing?",
    "c": null,
    "o": [
      "To pick edges in order of increasing weight",
      "To process nodes in BFS order",
      "To prioritize edges with the highest weight",
      "To group edges by their connected components"
    ]
  },
  {
    "q": "Which graph traversal method is generally preferred for finding shortest paths in unweighted graphs?",
    "c": null,
    "o": [
      "BFS",
      "DFS",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which MST algorithm starts with an empty forest and adds edges incrementally?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "q": "What is a necessary data structure for implementing efficient BFS?",
    "c": null,
    "o": [
      "Queue",
      "Stack",
      "Heap",
      "Disjoint Set"
    ]
  },
  {
    "q": "Which algorithm is used to detect cycles in an undirected graph using Union-Find?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "DFS",
      "BFS"
    ]
  },
  {
    "q": "What is a cross edge in DFS of a directed graph?",
    "c": null,
    "o": [
      "An edge that connects a vertex to another vertex already visited but not its ancestor",
      "An edge that forms a cycle",
      "An edge leading to an unvisited vertex",
      "An edge connecting two components"
    ]
  },
  {
    "q": "What is the time complexity of BFS on a graph represented with adjacency list?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which algorithm uses a min-priority queue to select the next vertex with the smallest tentative distance?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which data structure is primarily used to efficiently manage connected components in Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Union-Find (Disjoint Set Union)",
      "Queue",
      "Stack",
      "Heap"
    ]
  },
  {
    "q": "Which traversal method uses a FIFO queue to explore nodes?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "What does a 'tree edge' represent in DFS traversal?",
    "c": null,
    "o": [
      "An edge used to discover a new vertex",
      "An edge that forms a cycle",
      "An edge connecting two disconnected components",
      "An edge leading to a previously visited vertex"
    ]
  },
  {
    "q": "Which graph algorithm is designed to find shortest paths even if the graph contains negative weight edges but no negative cycles?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the output of a topological sort?",
    "c": null,
    "o": [
      "A linear ordering of nodes such that for every directed edge u → v, u comes before v",
      "A minimum spanning tree",
      "The shortest path tree from a source",
      "The set of strongly connected components"
    ]
  },
  {
    "q": "Which of the following graph representations is most memory efficient for sparse graphs?",
    "c": null,
    "o": [
      "Adjacency List",
      "Adjacency Matrix",
      "Edge List",
      "Incidence Matrix"
    ]
  },
  {
    "q": "In DFS, what is the significance of a 'back edge'?",
    "c": null,
    "o": [
      "It indicates the presence of a cycle",
      "It indicates a path to a new node",
      "It is used to find shortest paths",
      "It is part of the MST"
    ]
  },
  {
    "q": "Which MST algorithm can be implemented efficiently using a priority queue and adjacency list?",
    "c": null,
    "o": [
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which algorithm detects strongly connected components in a directed graph?",
    "c": null,
    "o": [
      "Kosaraju’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "What is the primary purpose of the 'coloring' method (white, gray, black) in DFS?",
    "c": null,
    "o": [
      "To track the state of each vertex during traversal",
      "To color nodes for visualization",
      "To mark nodes with weights",
      "To assign priority in traversal"
    ]
  },
  {
    "q": "Which algorithm finds the minimum spanning tree by repeatedly adding the smallest edge that does not form a cycle?",
    "c": null,
    "o": [
      "Kruskal’s Algorithm",
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm"
    ]
  },
  {
    "q": "Which algorithm uses a queue and explores nodes level by level?",
    "c": null,
    "o": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "q": "In graph algorithms, what does 'relaxing an edge' mean?",
    "c": null,
    "o": [
      "Updating the shortest path estimate to a vertex",
      "Removing an edge from the graph",
      "Adding a new edge",
      "Merging two sets"
    ]
  },
  {
    "q": "Which algorithm is used to detect negative weight cycles in a graph?",
    "c": null,
    "o": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "Which data structure helps efficiently manage disjoint sets during Kruskal’s algorithm?",
    "c": null,
    "o": [
      "Union-Find",
      "Queue",
      "Stack",
      "Priority Queue"
    ]
  },
  {
    "q": "What is the time complexity of DFS on a graph with V vertices and E edges?",
    "c": null,
    "o": [
      "O(V + E)",
      "O(V^2)",
      "O(E log V)",
      "O(V log E)"
    ]
  },
  {
    "q": "Which algorithm finds the shortest path from a single source to all vertices in a graph with non-negative edge weights?",
    "c": null,
    "o": [
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "q": "What is the main difference between an adjacency matrix and adjacency list representation?",
    "c": null,
    "o": [
      "Adjacency matrix uses O(V^2) space; adjacency list uses O(V + E)",
      "Adjacency list stores weights; adjacency matrix does not",
      "Adjacency matrix is only for directed graphs",
      "Adjacency list allows O(1) edge existence checks"
    ]
  },
  {
    "q": "Which traversal technique is used for cycle detection in directed graphs?",
    "c": null,
    "o": [
      "DFS with recursion stack",
      "BFS",
      "Prim’s Algorithm",
      "Kruskal’s Algorithm"
    ]
  }
]