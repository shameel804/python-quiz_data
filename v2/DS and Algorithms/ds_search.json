[
  {
    "q": "Which searching algorithm is more efficient for a sorted list?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Random Search"
    ]
  },
  {
    "q": "What is the time complexity of linear search in the worst case?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which sorting algorithm repeatedly swaps adjacent elements if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following is the best case time complexity for Insertion Sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the average time complexity of Merge Sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which sorting algorithm works by selecting the smallest element from an unsorted list and swapping it with the element at the beginning?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is not comparison-based?",
    "c": null,
    "o": [
      "None of the above",
      "Merge Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which built-in Python function returns a new sorted list from the items of any iterable?",
    "c": null,
    "o": [
      "sorted()",
      "list.sort()",
      "arr.sort()",
      "sort()"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "arr = [5, 2, 9, 1]\narr.sort()\nprint(arr)",
    "o": [
      "[1, 2, 5, 9]",
      "[5, 2, 9, 1]",
      "[9, 5, 2, 1]",
      "[1, 9, 2, 5]"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is based on the divide-and-conquer strategy?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "arr = [3, 1, 4, 2]\nprint(sorted(arr, reverse=True))",
    "o": [
      "[4, 3, 2, 1]",
      "[1, 2, 3, 4]",
      "[3, 1, 4, 2]",
      "[2, 4, 1, 3]"
    ]
  },
  {
    "q": "Which search algorithm is suitable for an unsorted list?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Hash Search",
      "Jump Search"
    ]
  },
  {
    "q": "What is required for binary search to work correctly?",
    "c": null,
    "o": [
      "The list must be sorted",
      "All elements must be unique",
      "The list must have an odd number of elements",
      "The list must be in descending order"
    ]
  },
  {
    "q": "Which of the following will sort the list in-place in Python?",
    "c": "lst = [4, 2, 9, 1]\nlst.sort()",
    "o": [
      "[1, 2, 4, 9]",
      "[4, 2, 9, 1]",
      "[9, 4, 2, 1]",
      "[2, 1, 9, 4]"
    ]
  },
  {
    "q": "What is the key difference between list.sort() and sorted() in Python?",
    "c": null,
    "o": [
      "list.sort() modifies the list in-place, while sorted() returns a new list",
      "sorted() modifies the list in-place, while list.sort() returns a new list",
      "Both return a new sorted list",
      "Both modify the original list"
    ]
  },
  {
    "q": "Which of the following algorithms has the best average-case time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following will perform a binary search correctly?",
    "c": "import bisect\narr = [1, 2, 3, 4, 5]\nprint(bisect.bisect_left(arr, 3))",
    "o": [
      "2",
      "3",
      "1",
      "4"
    ]
  },
  {
    "q": "In which case does bubble sort perform the fewest number of comparisons?",
    "c": null,
    "o": [
      "When the list is already sorted",
      "When the list is in reverse order",
      "When all elements are the same",
      "When the list is partially sorted"
    ]
  },
  {
    "q": "Which of these sorting algorithms is not stable?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Merge Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "arr = [3, 5, 2, 1, 4]\nprint(sorted(arr)[0])",
    "o": [
      "1",
      "2",
      "3",
      "5"
    ]
  },
  {
    "q": "Which algorithm divides the list into smaller parts and then combines the sorted parts?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "arr = [8, 3, 7, 2]\narr.sort(reverse=True)\nprint(arr)",
    "o": [
      "[8, 7, 3, 2]",
      "[2, 3, 7, 8]",
      "[3, 2, 7, 8]",
      "[2, 7, 3, 8]"
    ]
  },
  {
    "q": "Which sorting algorithm is preferred when the list is nearly sorted?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the purpose of the partition function in Quick Sort?",
    "c": null,
    "o": [
      "To divide the array into two parts around a pivot",
      "To merge two sorted halves",
      "To find the median of the array",
      "To reverse the array"
    ]
  },
  {
    "q": "Which algorithm has O(n^2) time complexity in both worst and average cases?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the main advantage of quick sort over merge sort?",
    "c": null,
    "o": [
      "Better cache performance",
      "Always faster",
      "More stable",
      "Less complex code"
    ]
  },
  {
    "q": "Which algorithm finds an element by checking each item one by one?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Depth-first Search",
      "Jump Search"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "arr = [10, 7, 4]\nprint(sorted(arr, key=lambda x: -x))",
    "o": [
      "[10, 7, 4]",
      "[4, 7, 10]",
      "[7, 10, 4]",
      "[10, 4, 7]"
    ]
  },
  {
    "q": "Which sorting algorithm uses the concept of a pivot to partition the list?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following algorithms is considered in-place and unstable?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "arr = [5, 1, 4, 2]\narr.sort()\nprint(arr[-1])",
    "o": [
      "5",
      "4",
      "2",
      "1"
    ]
  },
  {
    "q": "Which of these algorithms generally performs well on small datasets and is simple to implement?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which search algorithm eliminates half of the remaining elements with each step?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Exponential Search"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "arr = [2, 4, 6, 8]\nprint(4 in arr)",
    "o": [
      "True",
      "False",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which sorting algorithm's average and worst-case time complexity is O(n^2)?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the best case time complexity of Binary Search?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which built-in method can sort a list of strings alphabetically?",
    "c": "names = [\"banana\", \"apple\", \"cherry\"]\nnames.sort()\nprint(names)",
    "o": [
      "[\"apple\", \"banana\", \"cherry\"]",
      "[\"banana\", \"apple\", \"cherry\"]",
      "[\"cherry\", \"banana\", \"apple\"]",
      "[\"apple\", \"cherry\", \"banana\"]"
    ]
  },
  {
    "q": "Which algorithm would you choose for sorting a linked list?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which function will sort a list without modifying the original one?",
    "c": "nums = [3, 1, 4]\nprint(sorted(nums))",
    "o": [
      "[1, 3, 4]",
      "[3, 1, 4]",
      "[4, 3, 1]",
      "[1, 4, 3]"
    ]
  },
  {
    "q": "Which search algorithm requires the data to be sorted beforehand?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Depth First Search",
      "Breadth First Search"
    ]
  },
  {
    "q": "What will be the output of the code below?",
    "c": "lst = [10, 20, 15, 5]\nlst.sort()\nprint(lst[1])",
    "o": [
      "10",
      "15",
      "5",
      "20"
    ]
  },
  {
    "q": "Which of these sorting algorithms has the same complexity for best, average, and worst cases?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What does the following return?",
    "c": "data = [1, 3, 5, 7]\nprint(3 in data)",
    "o": [
      "True",
      "False",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of these is most suitable when minimizing memory usage is critical?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Radix Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "Which sorting algorithm uses a binary search to find the correct location to insert the current element?",
    "c": null,
    "o": [
      "Binary Insertion Sort",
      "Selection Sort",
      "Bubble Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "a = [3, 1, 4]\na.sort()\nprint(a == sorted(a))",
    "o": [
      "True",
      "False",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which sorting algorithm has a recursive implementation and works well with divide and conquer?",
    "c": null,
    "o": [
      "Merge Sort",
      "Insertion Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "In binary search, what happens if the element is not found in the list?",
    "c": null,
    "o": [
      "Search ends after log₂(n) comparisons",
      "Search continues infinitely",
      "The list is modified",
      "Element is inserted automatically"
    ]
  },
  {
    "q": "What is the auxiliary space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is stable by nature?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of the following searches is not based on comparison?",
    "c": null,
    "o": [
      "Hash Table Search",
      "Linear Search",
      "Binary Search",
      "Jump Search"
    ]
  },
  {
    "q": "What will the following Python code print?",
    "c": "arr = [2, 3, 1, 5]\nsorted_arr = sorted(arr)\nprint(arr == sorted_arr)",
    "o": [
      "False",
      "True",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which sorting algorithm is generally the fastest in practice for large datasets?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the worst-case space complexity of quick sort?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the result of this Python code?",
    "c": "nums = [1, 2, 3]\nnums.sort(reverse=True)\nprint(nums)",
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[2, 1, 3]",
      "[1, 3, 2]"
    ]
  },
  {
    "q": "Which sorting algorithm performs better than others when the array is almost sorted?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which algorithm sorts by building a sorted portion of the list one element at a time?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which Python module provides functions for maintaining a list in sorted order without having to sort it repeatedly?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "collections",
      "sortlib"
    ]
  },
  {
    "q": "Which algorithm splits the list around a pivot and recursively sorts the partitions?",
    "c": null,
    "o": [
      "Quick Sort",
      "Selection Sort",
      "Heap Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which algorithm does NOT require extra memory allocation?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Radix Sort",
      "Bucket Sort"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "arr = [9, 1, 8, 2]\nprint(sorted(arr)[-2])",
    "o": [
      "8",
      "9",
      "2",
      "1"
    ]
  },
  {
    "q": "Which of the following algorithms has the same time complexity for best and worst case?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of the following is the fastest for small datasets?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What will the following output?",
    "c": "arr = [1, 2, 3, 4]\nprint(5 in arr)",
    "o": [
      "False",
      "True",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is NOT in-place?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which search algorithm is used to search in an infinite sorted array?",
    "c": null,
    "o": [
      "Exponential Search",
      "Binary Search",
      "Linear Search",
      "Jump Search"
    ]
  },
  {
    "q": "Which of the following is true about binary search?",
    "c": null,
    "o": [
      "Works only on sorted arrays",
      "Works on both sorted and unsorted arrays",
      "Always faster than linear search",
      "Does not need a pivot"
    ]
  },
  {
    "q": "Which of the following is a stable sorting algorithm?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Heap Sort",
      "Selection Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which built-in Python function returns a new sorted list from the iterable passed?",
    "c": null,
    "o": [
      "sorted()",
      "sort()",
      "order()",
      "arr.sort()"
    ]
  },
  {
    "q": "What is the time complexity of binary search in a sorted array?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following algorithms requires two pointers for partitioning?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Insertion Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of the following code snippets sorts the list in descending order?",
    "c": "data = [10, 4, 6]\ndata.sort(reverse=True)\nprint(data)",
    "o": [
      "[10, 6, 4]",
      "[4, 6, 10]",
      "[6, 10, 4]",
      "[10, 4, 6]"
    ]
  },
  {
    "q": "Which algorithm is often used for external sorting?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which searching technique is best suited for dynamic data with frequent updates?",
    "c": null,
    "o": [
      "Hashing",
      "Binary Search",
      "Linear Search",
      "Jump Search"
    ]
  },
  {
    "q": "What is the worst-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which data structure is most suitable for implementing binary search?",
    "c": null,
    "o": [
      "Sorted List",
      "Hash Map",
      "Set",
      "Linked List"
    ]
  },
  {
    "q": "Which of the following algorithms uses repeated swapping of adjacent elements?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Quick Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which algorithm always divides the array in half for searching?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Fibonacci Search"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "arr = [2, 1, 3]\nprint(sorted(arr, reverse=False))",
    "o": [
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[2, 1, 3]",
      "[1, 3, 2]"
    ]
  },
  {
    "q": "Which algorithm is considered efficient for large datasets and has average-case O(n log n) time complexity?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "arr = [4, 1, 7, 3]\narr.sort()\nprint(arr[0])",
    "o": [
      "1",
      "4",
      "3",
      "7"
    ]
  },
  {
    "q": "Which sorting algorithm is known for worst-case time complexity of O(n log n) and is stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will the following code return?",
    "c": "lst = [1, 2, 3, 4]\nprint(sorted(lst, reverse=True)[-1])",
    "o": [
      "2",
      "4",
      "3",
      "1"
    ]
  },
  {
    "q": "What is the time complexity of the built-in sorted() function in Python?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which of the following will raise an error if used on a list?",
    "c": "arr = [3, 1, 2]\nprint(arr.sorted())",
    "o": [
      "AttributeError",
      "TypeError",
      "None",
      "It works fine"
    ]
  },
  {
    "q": "Which of the following algorithms does NOT use comparison to sort elements?",
    "c": null,
    "o": [
      "Counting Sort",
      "Merge Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which algorithm is preferred when the number of elements is very small?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Heap Sort",
      "Radix Sort"
    ]
  },
  {
    "q": "What is the behavior of list.sort() if the list contains mixed data types?",
    "c": null,
    "o": [
      "TypeError is raised",
      "Sorts alphabetically",
      "Sorts numerically",
      "Sorts randomly"
    ]
  },
  {
    "q": "What is the time complexity of accessing an element during binary search?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the purpose of the `key` parameter in Python's sorted() function?",
    "c": null,
    "o": [
      "To specify a function to be called on each list element prior to making comparisons",
      "To specify the maximum number of comparisons",
      "To reverse the list after sorting",
      "To sort only a portion of the list"
    ]
  },
  {
    "q": "Which of the following algorithms is NOT based on the divide-and-conquer technique?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Binary Search"
    ]
  },
  {
    "q": "What is the best case time complexity of Bubble Sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following code snippets correctly performs binary search using Python’s bisect module?",
    "c": "import bisect\narr = [1, 2, 3, 4, 5]\nprint(bisect.bisect_right(arr, 3))",
    "o": [
      "3",
      "2",
      "4",
      "5"
    ]
  },
  {
    "q": "Which Python module can be used to perform a heap sort-like behavior?",
    "c": null,
    "o": [
      "heapq",
      "bisect",
      "collections",
      "array"
    ]
  },
  {
    "q": "What happens if we apply binary search on an unsorted list?",
    "c": null,
    "o": [
      "It may give incorrect results",
      "It will always return -1",
      "It sorts the list first",
      "It works fine"
    ]
  },
  {
    "q": "Which algorithm maintains a sorted sublist and inserts new elements into it?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "arr = [1, 4, 2, 5]\nprint(sorted(arr, key=lambda x: -x))",
    "o": [
      "[5, 4, 2, 1]",
      "[1, 2, 4, 5]",
      "[4, 5, 2, 1]",
      "[1, 4, 2, 5]"
    ]
  },
  {
    "q": "Which sorting algorithm divides the array into halves, sorts them, and merges them?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which built-in function is used to sort lists of tuples based on the second element?",
    "c": "data = [(1, 'b'), (2, 'a'), (3, 'c')]\nprint(sorted(data, key=lambda x: x[1]))",
    "o": [
      "[(2, 'a'), (1, 'b'), (3, 'c')]",
      "[(1, 'b'), (2, 'a'), (3, 'c')]",
      "[(1, 'b'), (3, 'c'), (2, 'a')]",
      "[(3, 'c'), (2, 'a'), (1, 'b')]"
    ]
  },
  {
    "q": "What is the key advantage of merge sort over quick sort?",
    "c": null,
    "o": [
      "Stable sorting",
      "Lower memory usage",
      "Faster on average",
      "Easier to implement"
    ]
  },
  {
    "q": "Which of the following is true about selection sort?",
    "c": null,
    "o": [
      "It selects the minimum element and places it at the front",
      "It divides the array in halves",
      "It uses a pivot to sort",
      "It repeatedly swaps adjacent elements"
    ]
  },
  {
    "q": "What does this code do?",
    "c": "lst = [7, 2, 5]\nprint(lst.sort())",
    "o": [
      "None",
      "[2, 5, 7]",
      "Error",
      "[7, 2, 5]"
    ]
  },
  {
    "q": "Which algorithm works well when memory is limited and does not require recursion?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of these sorting algorithms is most efficient when a nearly sorted list is given as input?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which sorting algorithm is best suited for sorting data that is continuously being received (streaming data)?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Merge Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "nums = [7, 2, 9]\nprint(sorted(nums, reverse=False))",
    "o": [
      "[2, 7, 9]",
      "[9, 7, 2]",
      "[7, 2, 9]",
      "[2, 9, 7]"
    ]
  },
  {
    "q": "Which sorting algorithm always takes O(n^2) time complexity regardless of input?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which search algorithm is ideal when elements are uniformly distributed?",
    "c": null,
    "o": [
      "Jump Search",
      "Linear Search",
      "Binary Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "arr = [3, 2, 1]\narr.sort()\nprint(arr == [1, 2, 3])",
    "o": [
      "True",
      "False",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of these is NOT a property of merge sort?",
    "c": null,
    "o": [
      "In-place",
      "Stable",
      "Divide and Conquer",
      "Consistent O(n log n) time complexity"
    ]
  },
  {
    "q": "Which sorting algorithm is preferred when time is critical but memory usage isn't a concern?",
    "c": null,
    "o": [
      "Merge Sort",
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What does the bisect module help with in Python?",
    "c": null,
    "o": [
      "Binary Search and Insert Positioning",
      "Heap Sorting",
      "Bubble Sorting",
      "Linear Searching"
    ]
  },
  {
    "q": "Which of the following algorithms can be optimized with an early exit if no swaps are needed?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Quick Sort",
      "Merge Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the best-case time complexity of quick sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "What is returned by the following code?",
    "c": "data = [10, 30, 20]\ndata.sort()\nprint(data)",
    "o": [
      "[10, 20, 30]",
      "[30, 10, 20]",
      "[20, 30, 10]",
      "[10, 30, 20]"
    ]
  },
  {
    "q": "Which algorithm sorts by finding the position of the minimum element repeatedly?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which function would you use to sort a list of strings in reverse alphabetical order?",
    "c": "words = [\"apple\", \"banana\", \"cherry\"]\nprint(sorted(words, reverse=True))",
    "o": [
      "[\"cherry\", \"banana\", \"apple\"]",
      "[\"apple\", \"banana\", \"cherry\"]",
      "[\"banana\", \"cherry\", \"apple\"]",
      "[\"apple\", \"cherry\", \"banana\"]"
    ]
  },
  {
    "q": "Which algorithm would likely perform better on a very small array?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Heap Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following is NOT a built-in function or method for sorting in Python?",
    "c": null,
    "o": [
      "sortlist()",
      "sorted()",
      "list.sort()",
      "sorted(iterable)"
    ]
  },
  {
    "q": "Which of these is a characteristic of the quick sort algorithm?",
    "c": null,
    "o": [
      "It uses a pivot element to partition the list",
      "It always requires additional O(n) space",
      "It is a stable sort",
      "It does not use recursion"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "arr = [1, 2, 3, 4]\nprint(sorted(arr, reverse=True)[0])",
    "o": [
      "4",
      "1",
      "2",
      "3"
    ]
  },
  {
    "q": "Which algorithm is commonly used in Python's built-in `sort()` and `sorted()`?",
    "c": null,
    "o": [
      "Timsort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the major advantage of Timsort over traditional algorithms like merge sort and quick sort?",
    "c": null,
    "o": [
      "It combines merge sort and insertion sort for better performance on real-world data",
      "It uses more memory",
      "It’s slower in average case",
      "It doesn’t need recursion"
    ]
  },
  {
    "q": "Which of the following algorithms maintains two subarrays: sorted and unsorted?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What will the following output?",
    "c": "arr = [10, 5, 3, 8]\narr.sort()\nprint(arr[2])",
    "o": [
      "8",
      "10",
      "5",
      "3"
    ]
  },
  {
    "q": "Which is a non-comparison-based sorting algorithm?",
    "c": null,
    "o": [
      "Counting Sort",
      "Quick Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of the following built-in functions modifies the original list?",
    "c": null,
    "o": [
      "list.sort()",
      "sorted()",
      "reversed()",
      "enumerate()"
    ]
  },
  {
    "q": "Which sorting algorithm performs poorly on large lists due to its O(n²) time complexity?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Timsort"
    ]
  },
  {
    "q": "Which of these searches always has O(n) time complexity regardless of list ordering?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Hash Search"
    ]
  },
  {
    "q": "What will the following Python code return?",
    "c": "arr = [5, 4, 3, 2, 1]\narr.sort()\nprint(arr)",
    "o": [
      "[1, 2, 3, 4, 5]",
      "[5, 4, 3, 2, 1]",
      "[1, 3, 2, 4, 5]",
      "[2, 3, 1, 5, 4]"
    ]
  },
  {
    "q": "Which algorithm does not divide the array during sorting?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Quick Sort",
      "Timsort"
    ]
  },
  {
    "q": "Which Python module is specifically designed for working with heaps?",
    "c": null,
    "o": [
      "heapq",
      "bisect",
      "collections",
      "math"
    ]
  },
  {
    "q": "Which of the following sorting algorithms can degrade to O(n²) in the worst case if the pivot is poorly chosen?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Heap Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which algorithm is generally fastest on partially sorted datasets?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Heap Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which of the following algorithms uses a heap data structure?",
    "c": null,
    "o": [
      "Heap Sort",
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which sorting algorithm is guaranteed to make at most n swaps?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "What is the main limitation of binary search?",
    "c": null,
    "o": [
      "It requires a sorted list",
      "It uses too much memory",
      "It only works on strings",
      "It modifies the list"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "arr = [10, 20, 5, 15]\narr.sort()\nprint(arr[1])",
    "o": [
      "10",
      "15",
      "5",
      "20"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is *not* comparison-based?",
    "c": null,
    "o": [
      "Counting Sort",
      "Quick Sort",
      "Merge Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which search algorithm is best suited for large sorted datasets?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Depth First Search",
      "Breadth First Search"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "nums = [1, 5, 3]\nnums.sort()\nprint(nums)",
    "o": [
      "[1, 3, 5]",
      "[5, 3, 1]",
      "[3, 5, 1]",
      "[1, 5, 3]"
    ]
  },
  {
    "q": "Which sorting algorithm maintains the relative order of equal elements?",
    "c": null,
    "o": [
      "Stable Sorts like Merge Sort",
      "Heap Sort",
      "Selection Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which function is used to insert an element in sorted order using the bisect module?",
    "c": null,
    "o": [
      "bisect.insort()",
      "bisect.search()",
      "bisect.push()",
      "bisect.insert()"
    ]
  },
  {
    "q": "Which is a major disadvantage of selection sort?",
    "c": null,
    "o": [
      "Poor performance on large datasets",
      "Requires extra memory",
      "Only works for integers",
      "Not deterministic"
    ]
  },
  {
    "q": "What does the following code return?",
    "c": "data = [\"z\", \"a\", \"c\"]\ndata.sort()\nprint(data)",
    "o": [
      "[\"a\", \"c\", \"z\"]",
      "[\"z\", \"a\", \"c\"]",
      "[\"c\", \"z\", \"a\"]",
      "[\"z\", \"c\", \"a\"]"
    ]
  },
  {
    "q": "Which sorting algorithm is both stable and has worst-case O(n log n) complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the average-case complexity of insertion sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which algorithm sorts elements by repeatedly moving the maximum to the end?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the worst-case time complexity of binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which sorting algorithm divides the list into sublists and sorts them recursively before merging?",
    "c": null,
    "o": [
      "Merge Sort",
      "Insertion Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the key difference between list.sort() and sorted() in Python?",
    "c": null,
    "o": [
      "list.sort() modifies the list in place, while sorted() returns a new list",
      "list.sort() is slower than sorted()",
      "sorted() can’t sort strings",
      "list.sort() only works on tuples"
    ]
  },
  {
    "q": "Which algorithm is optimal when most of the array is already sorted?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of these is true about quick sort?",
    "c": null,
    "o": [
      "It can have O(n²) time in the worst case",
      "It always takes O(n log n) time",
      "It uses a queue to sort",
      "It is a stable sort"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "lst = [4, 2, 5, 1]\nprint(sorted(lst)[1])",
    "o": [
      "2",
      "4",
      "5",
      "1"
    ]
  },
  {
    "q": "Which of the following best describes the performance of selection sort?",
    "c": null,
    "o": [
      "O(n²) in all cases",
      "O(n log n) average case",
      "O(n) best case",
      "O(log n) best case"
    ]
  },
  {
    "q": "What is the auxiliary space required by merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n²)"
    ]
  },
  {
    "q": "Which search algorithm works by jumping ahead by a fixed number of steps?",
    "c": null,
    "o": [
      "Jump Search",
      "Binary Search",
      "Linear Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "What is the return type of sorted() function in Python?",
    "c": null,
    "o": [
      "List",
      "None",
      "Tuple",
      "Iterator"
    ]
  },
  {
    "q": "Which of the following is most efficient on large datasets if memory is not a constraint?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "data = [6, 3, 9, 1]\ndata.sort()\nprint(data[-1])",
    "o": [
      "9",
      "6",
      "3",
      "1"
    ]
  },
  {
    "q": "Which algorithm is not adaptive (does not take advantage of existing order)?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort",
      "Timsort"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "a = [3, 6, 2]\na.sort()\nprint(a)",
    "o": [
      "[2, 3, 6]",
      "[3, 6, 2]",
      "[6, 3, 2]",
      "[2, 6, 3]"
    ]
  },
  {
    "q": "Which algorithm is preferred when memory usage needs to be minimal?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Counting Sort",
      "Radix Sort"
    ]
  },
  {
    "q": "Which sorting technique works well with linked lists due to non-contiguous memory?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following is the correct behavior of list.sort() when used without parameters?",
    "c": null,
    "o": [
      "It sorts the list in ascending order in-place",
      "It returns a new sorted list",
      "It sorts the list in descending order",
      "It raises an error"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "arr = [4, 3, 1, 2]\nsorted_arr = sorted(arr)\nprint(arr == sorted_arr)",
    "o": [
      "False",
      "True",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which algorithm is often used in parallel sorting systems because it easily divides the data?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which search algorithm's time complexity increases with the square root of the list length?",
    "c": null,
    "o": [
      "Jump Search",
      "Linear Search",
      "Binary Search",
      "Exponential Search"
    ]
  },
  {
    "q": "Which of the following statements is true about Python's sorted() function?",
    "c": null,
    "o": [
      "It returns a new sorted list and does not modify the original",
      "It sorts the original list in-place",
      "It can only be used with numbers",
      "It raises an error if the list is empty"
    ]
  },
  {
    "q": "What is the worst-case time complexity of the built-in sorted() function in Python?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following is not a valid argument for sorted()?",
    "c": null,
    "o": [
      "sort_order",
      "key",
      "reverse",
      "iterable"
    ]
  },
  {
    "q": "What is the default behavior of Python's sort when used on strings?",
    "c": null,
    "o": [
      "Lexicographical (alphabetical) order",
      "Length-based sorting",
      "Numeric conversion",
      "Reverse order"
    ]
  },
  {
    "q": "Which algorithm divides the list using a pivot and places elements smaller than pivot on one side?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Insertion Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which search algorithm first finds a range where the target lies and then applies binary search?",
    "c": null,
    "o": [
      "Exponential Search",
      "Jump Search",
      "Linear Search",
      "Depth First Search"
    ]
  },
  {
    "q": "Which of these is the most appropriate when you need a guaranteed O(n log n) sorting algorithm?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is printed by this code?",
    "c": "items = [3, 6, 1, 5]\nprint(sorted(items)[-1])",
    "o": [
      "6",
      "5",
      "3",
      "1"
    ]
  },
  {
    "q": "Which sorting algorithm is typically slower but useful for educational purposes?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which is true for Python’s sort stability?",
    "c": null,
    "o": [
      "sorted() and list.sort() are both stable",
      "Only sorted() is stable",
      "Only list.sort() is stable",
      "Neither are stable"
    ]
  },
  {
    "q": "Which module allows you to search and insert in sorted lists efficiently?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "random",
      "math"
    ]
  },
  {
    "q": "Which of the following sorting algorithms has O(n²) time complexity in the average case?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Timsort"
    ]
  },
  {
    "q": "Which of these functions sorts in-place and returns None?",
    "c": "nums = [9, 1, 4]\nprint(nums.sort())",
    "o": [
      "None",
      "[1, 4, 9]",
      "[9, 1, 4]",
      "Error"
    ]
  },
  {
    "q": "Which sorting algorithm minimizes the number of swaps made?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which Python built-in function is best suited to sort items based on a custom comparison key?",
    "c": null,
    "o": [
      "sorted() with key parameter",
      "list.sort() without arguments",
      "max()",
      "filter()"
    ]
  },
  {
    "q": "What will the output be?",
    "c": "data = [1, 10, 5]\ndata.sort()\nprint(data[0])",
    "o": [
      "1",
      "5",
      "10",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is true regarding binary search?",
    "c": null,
    "o": [
      "It requires a sorted array to work correctly",
      "It works on unsorted arrays",
      "It takes O(n) time in the best case",
      "It always returns the index of the last element"
    ]
  },
  {
    "q": "Which is the correct way to sort a list of tuples by the second item?",
    "c": "data = [(1, 3), (2, 2), (3, 1)]\nprint(sorted(data, key=lambda x: x[1]))",
    "o": [
      "[(3, 1), (2, 2), (1, 3)]",
      "[(1, 3), (2, 2), (3, 1)]",
      "[(1, 3), (3, 1), (2, 2)]",
      "[(2, 2), (3, 1), (1, 3)]"
    ]
  },
  {
    "q": "What is the best case time complexity of binary search?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What happens if list.sort() is called on a list of incompatible data types?",
    "c": null,
    "o": [
      "TypeError is raised",
      "The list is sorted by default rules",
      "None is returned",
      "The incompatible items are removed"
    ]
  },
  {
    "q": "Which sorting algorithm can be implemented efficiently using recursion and a stack?",
    "c": null,
    "o": [
      "Quick Sort",
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of the following can be used to sort a dictionary by its keys?",
    "c": "d = {'b': 2, 'a': 1, 'c': 3}\nprint(sorted(d))",
    "o": [
      "['a', 'b', 'c']",
      "[1, 2, 3]",
      "[('a', 1), ('b', 2), ('c', 3)]",
      "{'a': 1, 'b': 2, 'c': 3}"
    ]
  },
  {
    "q": "Which function inserts an element into the correct position in a sorted list using bisect?",
    "c": null,
    "o": [
      "bisect.insort()",
      "bisect.append()",
      "bisect.place()",
      "bisect.insert()"
    ]
  },
  {
    "q": "Which sorting algorithm is used internally by Python’s `sorted()` function?",
    "c": null,
    "o": [
      "Timsort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of these has the lowest best-case time complexity?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the default sorting behavior of the sorted() function on numbers?",
    "c": null,
    "o": [
      "Ascending order",
      "Descending order",
      "Random order",
      "Even numbers first"
    ]
  },
  {
    "q": "What does the bisect.bisect_left() function return?",
    "c": null,
    "o": [
      "The insertion point for a value to maintain order in a sorted list (to the left of existing equal elements)",
      "The index of the largest value smaller than the target",
      "The midpoint of the list",
      "The number of times the value appears"
    ]
  },
  {
    "q": "Which algorithm repeatedly places the current element in its correct position among sorted elements on the left?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Bubble Sort",
      "Selection Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which built-in function is used to sort any iterable in Python?",
    "c": null,
    "o": [
      "sorted()",
      "sort()",
      "arrange()",
      "order()"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "lst = [2, 1, 4, 3]\nlst.sort(reverse=True)\nprint(lst)",
    "o": [
      "[4, 3, 2, 1]",
      "[1, 2, 3, 4]",
      "[2, 1, 4, 3]",
      "[3, 4, 1, 2]"
    ]
  },
  {
    "q": "Which sorting algorithm works well when memory space is restricted and recursion is not allowed?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Heap Sort",
      "Radix Sort"
    ]
  },
  {
    "q": "Which of the following sorting algorithms does not use recursion?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which function call would sort a list of integers in descending order?",
    "c": null,
    "o": [
      "sorted(numbers, reverse=True)",
      "numbers.sort(reverse=False)",
      "sorted(numbers, key='desc')",
      "sort(numbers, order='descending')"
    ]
  },
  {
    "q": "What is the result of this code snippet?",
    "c": "arr = [10, 8, 15, 2]\nprint(sorted(arr)[::2])",
    "o": [
      "[2, 10]",
      "[10, 2]",
      "[15, 8]",
      "[8, 15]"
    ]
  },
  {
    "q": "Which sorting algorithm starts by finding the minimum element and placing it at the beginning?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which function sorts the list in-place and does not return the sorted list?",
    "c": null,
    "o": [
      "list.sort()",
      "sorted()",
      "reversed()",
      "filter()"
    ]
  },
  {
    "q": "Which of the following is true about bubble sort?",
    "c": null,
    "o": [
      "It compares adjacent elements and swaps them if needed",
      "It divides the list into halves",
      "It is a stable sort with O(n log n) complexity",
      "It is used in Python’s built-in sort"
    ]
  },
  {
    "q": "Which code would find the correct index to insert 5 in a sorted list?",
    "c": "import bisect\nlst = [1, 3, 6, 8]\nprint(bisect.bisect(lst, 5))",
    "o": [
      "2",
      "3",
      "1",
      "4"
    ]
  },
  {
    "q": "Which of these best describes how merge sort works?",
    "c": null,
    "o": [
      "Divide the array, sort each half, and merge them",
      "Pick a pivot and partition elements",
      "Iterate and swap adjacent elements",
      "Select the minimum repeatedly and build the result"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "a = [1, 2, 3]\nsorted_a = sorted(a, reverse=True)\nprint(a == sorted_a)",
    "o": [
      "False",
      "True",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which built-in Python method is most appropriate when you want to sort a list of dictionaries by a specific key?",
    "c": null,
    "o": [
      "sorted(list_of_dicts, key=lambda x: x['key'])",
      "sort(list_of_dicts, 'key')",
      "list_of_dicts.sort('key')",
      "sort_by(list_of_dicts, key='key')"
    ]
  },
  {
    "q": "Which of the following is a key characteristic of binary search?",
    "c": null,
    "o": [
      "It repeatedly divides the search interval in half",
      "It checks each element sequentially",
      "It always starts from the last index",
      "It sorts the array before searching"
    ]
  },
  {
    "q": "Which Python sorting method modifies the list and returns `None`?",
    "c": "data = [3, 1, 2]\nresult = data.sort()\nprint(result)",
    "o": [
      "None",
      "[1, 2, 3]",
      "[3, 1, 2]",
      "Error"
    ]
  },
  {
    "q": "Which sorting algorithm is *not* adaptive?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Timsort"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "nums = [7, 5, 3]\nprint(sorted(nums)[1])",
    "o": [
      "5",
      "3",
      "7",
      "None"
    ]
  },
  {
    "q": "Which search algorithm checks every item in the list until it finds a match?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Exponential Search"
    ]
  },
  {
    "q": "What is the time complexity of the worst case for linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which sorting algorithm is most commonly used in competitive programming for its average-case speed?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "data = ['b', 'c', 'a']\ndata.sort()\nprint(data)",
    "o": [
      "['a', 'b', 'c']",
      "['b', 'c', 'a']",
      "['c', 'b', 'a']",
      "['a', 'c', 'b']"
    ]
  },
  {
    "q": "Which algorithm performs best when the data is small and mostly sorted?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which is the correct method to sort a list in descending order?",
    "c": null,
    "o": [
      "list.sort(reverse=True)",
      "list.sort(descending=True)",
      "list.sorted(order='desc')",
      "sort(list, reverse=False)"
    ]
  },
  {
    "q": "Which of the following statements is true about selection sort?",
    "c": null,
    "o": [
      "It minimizes the number of swaps",
      "It uses recursion",
      "It is adaptive",
      "It is faster than merge sort for large data"
    ]
  },
  {
    "q": "What will the following code return?",
    "c": "arr = [4, 5, 1, 2]\nsorted_arr = sorted(arr)\nprint(sorted_arr[-2])",
    "o": [
      "4",
      "5",
      "2",
      "1"
    ]
  },
  {
    "q": "Which search technique is best suited when the input data is unstructured?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "What is the space complexity of insertion sort?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which Python function can be used to sort an iterable without modifying the original?",
    "c": null,
    "o": [
      "sorted()",
      "list.sort()",
      "arrange()",
      "modify_sort()"
    ]
  },
  {
    "q": "Which of the following is required before performing binary search on a list?",
    "c": null,
    "o": [
      "The list must be sorted",
      "The list must contain unique elements",
      "The list must contain only integers",
      "The list must be reversed"
    ]
  },
  {
    "q": "What will the following Python code output?",
    "c": "data = [5, 1, 4]\nprint(sorted(data, reverse=True)[2])",
    "o": [
      "1",
      "4",
      "5",
      "None"
    ]
  },
  {
    "q": "Which of the following is true about insertion sort?",
    "c": null,
    "o": [
      "It builds the final sorted array one item at a time",
      "It requires a lot of memory",
      "It uses divide and conquer",
      "It is not suitable for small data sets"
    ]
  },
  {
    "q": "Which of these is the best case for bubble sort?",
    "c": null,
    "o": [
      "When the list is already sorted",
      "When the list is in descending order",
      "When the list is randomly ordered",
      "All of the above"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "nums = [3, 2, 1]\nnums.sort()\nprint(nums == [1, 2, 3])",
    "o": [
      "True",
      "False",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which algorithm always makes the same number of comparisons regardless of input?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the best case time complexity of selection sort?",
    "c": null,
    "o": [
      "O(n²)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which method sorts a list without modifying the original one?",
    "c": "names = [\"Bob\", \"Alice\", \"Eve\"]\nprint(sorted(names))",
    "o": [
      "[\"Alice\", \"Bob\", \"Eve\"]",
      "[\"Bob\", \"Alice\", \"Eve\"]",
      "[\"Eve\", \"Bob\", \"Alice\"]",
      "None"
    ]
  },
  {
    "q": "Which search algorithm works by checking mid-point of current range?",
    "c": null,
    "o": [
      "Binary Search",
      "Jump Search",
      "Linear Search",
      "Hash Search"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "items = [1, 4, 2, 5]\nitems.sort()\nprint(items)",
    "o": [
      "[1, 2, 4, 5]",
      "[1, 4, 2, 5]",
      "[5, 4, 2, 1]",
      "[1, 5, 4, 2]"
    ]
  },
  {
    "q": "Which algorithm typically has the best performance for real-world datasets?",
    "c": null,
    "o": [
      "Timsort",
      "Bubble Sort",
      "Counting Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the average case time complexity of binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which Python function would sort a list of tuples by the second element?",
    "c": "pairs = [(2, 'b'), (1, 'a'), (3, 'c')]\nprint(sorted(pairs, key=lambda x: x[1]))",
    "o": [
      "[(1, 'a'), (2, 'b'), (3, 'c')]",
      "[(3, 'c'), (2, 'b'), (1, 'a')]",
      "[(2, 'b'), (1, 'a'), (3, 'c')]",
      "[(1, 'a'), (3, 'c'), (2, 'b')]"
    ]
  },
  {
    "q": "Which sorting algorithm has the highest worst-case time complexity?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which sorting algorithm is generally the most intuitive but inefficient?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which sorting algorithm works by comparing each pair of adjacent items and swapping them if they are in the wrong order?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Insertion Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "a = [1, 2, 3]\nb = sorted(a, reverse=True)\nprint(a, b)",
    "o": [
      "[1, 2, 3] [3, 2, 1]",
      "[3, 2, 1] [3, 2, 1]",
      "[1, 2, 3] [1, 2, 3]",
      "[3, 2, 1] [1, 2, 3]"
    ]
  },
  {
    "q": "Which sorting algorithm divides the list into two parts using a pivot element?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Heap Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which algorithm is most suitable for data that changes frequently (dynamic list)?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Merge Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which module provides a way to efficiently insert or find elements in a sorted list?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "math",
      "collections"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "lst = [2, 1, 3]\nlst.sort(reverse=False)\nprint(lst)",
    "o": [
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[2, 1, 3]",
      "[1, 3, 2]"
    ]
  },
  {
    "q": "Which built-in function allows custom sorting logic using a key?",
    "c": null,
    "o": [
      "sorted()",
      "reversed()",
      "max()",
      "filter()"
    ]
  },
  {
    "q": "Which of these statements is true about list.sort()?",
    "c": null,
    "o": [
      "It returns None and sorts the list in-place",
      "It returns a new sorted list",
      "It sorts tuples only",
      "It cannot be used on strings"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "arr = [3, 6, 2, 5]\nprint(sorted(arr)[1])",
    "o": [
      "3",
      "2",
      "5",
      "6"
    ]
  },
  {
    "q": "Which of the following is NOT a property of merge sort?",
    "c": null,
    "o": [
      "In-place sorting",
      "Stable sort",
      "Divide and conquer",
      "Recursive implementation"
    ]
  },
  {
    "q": "What does bisect.bisect_right return?",
    "c": null,
    "o": [
      "Index to insert while maintaining order (to the right of existing equal items)",
      "Index of the first occurrence of the value",
      "Index of last occurrence",
      "Midpoint index"
    ]
  },
  {
    "q": "Which sorting algorithm has the best performance on nearly sorted data?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which algorithm works best when memory is limited?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Timsort",
      "Counting Sort"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "a = [4, 2, 9, 1]\na.sort()\nprint(a[::2])",
    "o": [
      "[1, 4]",
      "[4, 9]",
      "[2, 1]",
      "[1, 2]"
    ]
  },
  {
    "q": "Which of these algorithms is the most efficient for large datasets with integer keys?",
    "c": null,
    "o": [
      "Counting Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "a = [5, 3, 2, 4]\nprint(sorted(a)[-1])",
    "o": [
      "5",
      "4",
      "2",
      "3"
    ]
  },
  {
    "q": "Which algorithm finds the smallest item and places it at the beginning of the list repeatedly?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which sorting algorithm is based on partitioning the list around a pivot?",
    "c": null,
    "o": [
      "Quick Sort",
      "Heap Sort",
      "Selection Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which Python sorting method is stable and uses a hybrid sorting algorithm internally?",
    "c": null,
    "o": [
      "sorted()",
      "list.sort()",
      "heapq.sort()",
      "random.sort()"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "data = ['bat', 'apple', 'cat']\ndata.sort()\nprint(data)",
    "o": [
      "['apple', 'bat', 'cat']",
      "['bat', 'apple', 'cat']",
      "['cat', 'bat', 'apple']",
      "['bat', 'cat', 'apple']"
    ]
  },
  {
    "q": "Which function is used to return a new list from any iterable in sorted order?",
    "c": null,
    "o": [
      "sorted()",
      "sort()",
      "order()",
      "arrange()"
    ]
  },
  {
    "q": "What is the best case time complexity of Bubble Sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following Python modules is best for maintaining a sorted list dynamically?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "random",
      "math"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "numbers = [6, 1, 9, 3]\nprint(sorted(numbers)[::2])",
    "o": [
      "[1, 6]",
      "[6, 3]",
      "[9, 1]",
      "[1, 3]"
    ]
  },
  {
    "q": "Which of these is a characteristic of stable sorting algorithms?",
    "c": null,
    "o": [
      "They preserve the relative order of equal elements",
      "They always run in O(1) space",
      "They require a stack",
      "They work only on integers"
    ]
  },
  {
    "q": "Which algorithm is preferred for sorting linked lists?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the primary disadvantage of merge sort?",
    "c": null,
    "o": [
      "It uses extra space",
      "It is unstable",
      "It performs poorly on large datasets",
      "It cannot be implemented recursively"
    ]
  },
  {
    "q": "Which of the following operations is not supported by the bisect module?",
    "c": null,
    "o": [
      "Delete from sorted list",
      "Insert in sorted order",
      "Find insertion point",
      "Work with sorted data"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "arr = [3, 1, 4, 2]\narr.sort()\nprint(arr[1])",
    "o": [
      "2",
      "1",
      "3",
      "4"
    ]
  },
  {
    "q": "Which sorting algorithm is best suited for nearly sorted data and small datasets?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which algorithm guarantees O(n log n) time in all cases?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "nums = [1, 3, 2]\nsorted_nums = sorted(nums)\nprint(nums == sorted_nums)",
    "o": [
      "False",
      "True",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which method modifies the original list while sorting?",
    "c": null,
    "o": [
      "list.sort()",
      "sorted()",
      "reversed()",
      "filter()"
    ]
  },
  {
    "q": "What is the average-case time complexity of quick sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n²)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "What is the main advantage of bubble sort?",
    "c": null,
    "o": [
      "Simplicity of implementation",
      "Performance on large datasets",
      "Minimal memory usage",
      "Divide and conquer strategy"
    ]
  },
  {
    "q": "Which sorting function is best when sorting complex objects based on custom rules?",
    "c": null,
    "o": [
      "sorted() with key parameter",
      "list.sort() with reverse",
      "min()",
      "heapq.sort()"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "items = ['z', 'a', 'm']\nprint(sorted(items)[0])",
    "o": [
      "a",
      "z",
      "m",
      "None"
    ]
  },
  {
    "q": "Which algorithm has the highest number of swaps in worst case?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the expected time complexity of binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which of the following algorithms is adaptive and stable?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of the following is required by Python’s `bisect.insort()`?",
    "c": null,
    "o": [
      "The list must be sorted",
      "All elements must be unique",
      "It must be a tuple list",
      "The list must be reversed"
    ]
  },
  {
    "q": "Which of the following is true about merge sort?",
    "c": null,
    "o": [
      "It divides the list and merges sorted parts",
      "It selects the smallest item in each iteration",
      "It only works on lists of integers",
      "It is the fastest sorting algorithm in all cases"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "nums = [2, 5, 1]\nprint(sorted(nums, reverse=True)[-1])",
    "o": [
      "5",
      "2",
      "1",
      "None"
    ]
  },
  {
    "q": "Which of these algorithms uses divide-and-conquer and requires additional space?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "data = [3, 6, 1, 5]\ndata.sort()\nprint(data[-2])",
    "o": [
      "5",
      "6",
      "3",
      "1"
    ]
  },
  {
    "q": "Which algorithm sorts by selecting the smallest unsorted element and swapping it with the element at the current position?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following will sort a list of strings by their lengths?",
    "c": "words = ['apple', 'cat', 'banana']\nprint(sorted(words, key=len))",
    "o": [
      "['cat', 'apple', 'banana']",
      "['banana', 'apple', 'cat']",
      "['apple', 'banana', 'cat']",
      "['apple', 'cat', 'banana']"
    ]
  },
  {
    "q": "What does the `key` parameter in `sorted()` do?",
    "c": null,
    "o": [
      "Specifies a function to extract comparison key",
      "Reverses the list",
      "Specifies the starting index",
      "Limits the number of elements to sort"
    ]
  },
  {
    "q": "Which built-in function would you use to maintain a sorted list when inserting new values?",
    "c": null,
    "o": [
      "bisect.insort()",
      "sorted.insert()",
      "heapq.add()",
      "list.sort()"
    ]
  },
  {
    "q": "What is the time complexity of `bisect.bisect_left()`?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is a key advantage of merge sort over quick sort?",
    "c": null,
    "o": [
      "Worst-case time is always O(n log n)",
      "In-place sorting",
      "Faster average time",
      "Lower space complexity"
    ]
  },
  {
    "q": "Which Python module allows working with priority queues (heap-based sorting)?",
    "c": null,
    "o": [
      "heapq",
      "bisect",
      "math",
      "collections"
    ]
  },
  {
    "q": "Which algorithm will perform best for small arrays with many already sorted elements?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "What will be printed?",
    "c": "numbers = [4, 2, 9]\nnumbers.sort()\nprint(numbers == [2, 4, 9])",
    "o": [
      "True",
      "False",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which method returns a new sorted list from any iterable, leaving the original intact?",
    "c": null,
    "o": [
      "sorted()",
      "list.sort()",
      "reversed()",
      "heapq.sort()"
    ]
  },
  {
    "q": "Which sorting algorithm has O(n²) average and worst-case complexity but is stable and adaptive?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of these is true about binary search?",
    "c": null,
    "o": [
      "It only works on sorted data",
      "It always runs in O(n)",
      "It works faster on unsorted arrays",
      "It uses recursion only"
    ]
  },
  {
    "q": "Which keyword argument of `sorted()` allows reverse order sorting?",
    "c": null,
    "o": [
      "reverse=True",
      "descending=True",
      "order='desc'",
      "sort='reverse'"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "a = [10, 30, 20]\nprint(sorted(a)[1])",
    "o": [
      "20",
      "10",
      "30",
      "None"
    ]
  },
  {
    "q": "Which of the following algorithms is not comparison-based?",
    "c": null,
    "o": [
      "Counting Sort",
      "Merge Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which method is best to maintain a sorted list as you insert values?",
    "c": null,
    "o": [
      "bisect.insort()",
      "sorted().append()",
      "list.sort().append()",
      "sorted().insert()"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "arr = ['z', 'x', 'a']\narr.sort(reverse=True)\nprint(arr[0])",
    "o": [
      "z",
      "a",
      "x",
      "None"
    ]
  },
  {
    "q": "What is the worst-case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which algorithm performs the best in nearly sorted or small datasets?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Heap Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "Which of the following algorithms divides the array into halves recursively?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What does `key=str.lower` do in sorted()?",
    "c": null,
    "o": [
      "Sorts strings case-insensitively",
      "Sorts strings in uppercase",
      "Removes capital letters",
      "Sorts by string length"
    ]
  },
  {
    "q": "Which algorithm is generally fastest for large unsorted datasets?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following is a property of stable sorting algorithms?",
    "c": null,
    "o": [
      "They maintain the relative order of equal items",
      "They use less memory",
      "They are always faster",
      "They only work on integers"
    ]
  },
  {
    "q": "Which statement is true about the list.sort() method?",
    "c": null,
    "o": [
      "It sorts the list in-place and returns None",
      "It returns a new sorted list",
      "It reverses the list before sorting",
      "It returns a copy of the sorted list"
    ]
  },
  {
    "q": "What is the time complexity of linear search in the best case?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these is true about Python’s built-in sort mechanism?",
    "c": null,
    "o": [
      "It uses Timsort which is stable and efficient",
      "It uses selection sort",
      "It always performs in O(n^2)",
      "It can only sort numbers"
    ]
  },
  {
    "q": "What happens if you try to sort a list with both strings and integers?",
    "c": "data = ['a', 1, 'b']\ndata.sort()",
    "o": [
      "TypeError",
      "['a', 'b', 1]",
      "[1, 'a', 'b']",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is true about binary search?",
    "c": null,
    "o": [
      "It only works on sorted sequences",
      "It has linear time complexity",
      "It can be used on strings only",
      "It is faster than hash lookup"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "nums = [8, 3, 6, 1]\nprint(sorted(nums)[-2])",
    "o": [
      "6",
      "3",
      "1",
      "8"
    ]
  },
  {
    "q": "Which search algorithm has a time complexity of O(n) in both best and worst cases when the list is unsorted?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "Which sorting algorithm is NOT in-place?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the role of a 'pivot' in quick sort?",
    "c": null,
    "o": [
      "To divide the list into elements less than and greater than it",
      "To track the current index",
      "To reverse the list",
      "To hold the maximum value temporarily"
    ]
  },
  {
    "q": "Which function from the bisect module would you use to insert while maintaining order?",
    "c": null,
    "o": [
      "insort()",
      "insert()",
      "append()",
      "push()"
    ]
  },
  {
    "q": "What is the default behavior of `sorted()` when applied to a list of strings?",
    "c": "words = ['apple', 'banana', 'cherry']\nprint(sorted(words))",
    "o": [
      "Sorted alphabetically",
      "Sorted by length",
      "Sorted by reverse order",
      "Raises an error"
    ]
  },
  {
    "q": "Which of these functions sorts in-place and returns None?",
    "c": null,
    "o": [
      "list.sort()",
      "sorted()",
      "reversed()",
      "enumerate()"
    ]
  },
  {
    "q": "Which is the correct function to use if we want a case-insensitive sort?",
    "c": "data = ['Apple', 'banana', 'Cherry']\nprint(sorted(data, key=str.lower))",
    "o": [
      "['Apple', 'banana', 'Cherry']",
      "['banana', 'Cherry', 'Apple']",
      "['Cherry', 'banana', 'Apple']",
      "['banana', 'Apple', 'Cherry']"
    ]
  },
  {
    "q": "Which algorithm is most efficient when sorting a small array that is already mostly sorted?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the time complexity of searching for an element in a Python list using the `in` keyword?",
    "c": "mylist = [1, 3, 5, 7]\nprint(3 in mylist)",
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following sorts is not stable?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Timsort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What happens when `list.sort()` is used on a list of numbers?",
    "c": "a = [4, 1, 2]\na.sort()\nprint(a)",
    "o": [
      "[1, 2, 4]",
      "[4, 2, 1]",
      "[2, 1, 4]",
      "[4, 1, 2]"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is stable and also used in Python internally?",
    "c": null,
    "o": [
      "Timsort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "data = [2, 3, 1, 5]\ndata.sort(reverse=True)\nprint(data)",
    "o": [
      "[5, 3, 2, 1]",
      "[1, 2, 3, 5]",
      "[2, 3, 1, 5]",
      "[5, 1, 3, 2]"
    ]
  },
  {
    "q": "Which sorting algorithm works well for large datasets and guarantees performance?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "numbers = [4, 9, 1, 3]\nprint(sorted(numbers)[::2])",
    "o": [
      "[1, 4]",
      "[1, 3]",
      "[4, 9]",
      "[3, 9]"
    ]
  },
  {
    "q": "Which sorting algorithm divides the list and conquers by sorting and merging?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which built-in Python function returns a sorted version of any iterable?",
    "c": null,
    "o": [
      "sorted()",
      "sort()",
      "order()",
      "arrange()"
    ]
  },
  {
    "q": "Which of these sorting algorithms is recursive and uses partitioning logic?",
    "c": null,
    "o": [
      "Quick Sort",
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "What is the time complexity of binary search in the best case?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(n log n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is not adaptive?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort",
      "Timsort"
    ]
  },
  {
    "q": "Which sorting function is preferred when sorting large datasets in Python?",
    "c": null,
    "o": [
      "sorted()",
      "list.sort()",
      "sort()",
      "quick_sort()"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "data = [3, 1, 4, 1, 5]\ndata.sort()\nprint(data[-3])",
    "o": [
      "3",
      "1",
      "4",
      "5"
    ]
  },
  {
    "q": "Which module provides tools for binary search in Python?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "math",
      "collections"
    ]
  },
  {
    "q": "What is the average-case time complexity of merge sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "Which sorting algorithm selects the minimum element and swaps it with the first unsorted element?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which function should you use to insert elements into a sorted list?",
    "c": null,
    "o": [
      "bisect.insort()",
      "sorted().append()",
      "list.sort().append()",
      "insert_sorted()"
    ]
  },
  {
    "q": "Which sorting algorithm is best for linked lists?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "items = ['dog', 'cat', 'apple']\nprint(sorted(items))",
    "o": [
      "['apple', 'cat', 'dog']",
      "['dog', 'cat', 'apple']",
      "['dog', 'apple', 'cat']",
      "['cat', 'apple', 'dog']"
    ]
  },
  {
    "q": "Which of the following search methods is best for unsorted lists?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "Which sorting algorithm has the best average-case performance for large datasets?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "values = [7, 2, 5, 1]\nvalues.sort()\nprint(values[::2])",
    "o": [
      "[1, 5]",
      "[2, 7]",
      "[1, 2]",
      "[7, 2]"
    ]
  },
  {
    "q": "Which search algorithm is efficient only on sorted data?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Exponential Search",
      "Depth First Search"
    ]
  },
  {
    "q": "Which is true about Python's `sorted()` function?",
    "c": null,
    "o": [
      "Returns a new sorted list and doesn't change the original",
      "Sorts the list in-place",
      "Only works on numbers",
      "Always sorts in descending order"
    ]
  },
  {
    "q": "Which of the following algorithms is NOT based on comparisons?",
    "c": null,
    "o": [
      "Counting Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the time complexity of binary search on a sorted list of size n?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which function from the `bisect` module returns the leftmost index to insert a value?",
    "c": null,
    "o": [
      "bisect_left()",
      "bisect_right()",
      "insort()",
      "search_left()"
    ]
  },
  {
    "q": "What is the space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "data = ['one', 'Two', 'three']\nprint(sorted(data, key=str.lower))",
    "o": [
      "['one', 'Three', 'Two']",
      "['one', 'three', 'Two']",
      "['one', 'Two', 'three']",
      "['Two', 'one', 'three']"
    ]
  },
  {
    "q": "Which sorting algorithm is considered the most intuitive but inefficient for large lists?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Heap Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "Which of the following statements about selection sort is true?",
    "c": null,
    "o": [
      "It selects the minimum element and puts it at the correct position",
      "It swaps adjacent elements repeatedly",
      "It uses a pivot for partitioning",
      "It merges subarrays in sorted order"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "nums = [9, 7, 5]\nnums.sort()\nprint(nums[1])",
    "o": [
      "7",
      "5",
      "9",
      "6"
    ]
  },
  {
    "q": "Which sorting algorithm divides the input, sorts each half, and merges them?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the return value of list.sort() in Python?",
    "c": null,
    "o": [
      "None",
      "The sorted list",
      "Boolean value",
      "An iterator"
    ]
  },
  {
    "q": "Which of these algorithms is preferred for sorting very large datasets?",
    "c": null,
    "o": [
      "Merge Sort",
      "Insertion Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following sorting algorithms does NOT use the divide-and-conquer strategy?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Quick Sort",
      "Timsort"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "arr = [2, 4, 1, 3]\nprint(sorted(arr)[-3])",
    "o": [
      "2",
      "1",
      "3",
      "4"
    ]
  },
  {
    "q": "Which built-in function can be used to sort a dictionary by its keys?",
    "c": "my_dict = {'b': 2, 'a': 1, 'c': 3}\nprint(sorted(my_dict))",
    "o": [
      "['a', 'b', 'c']",
      "['b', 'a', 'c']",
      "{'a': 1, 'b': 2, 'c': 3}",
      "[1, 2, 3]"
    ]
  },
  {
    "q": "Which of the following is a stable sort algorithm?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Selection Sort",
      "Heap Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the key advantage of quick sort over merge sort?",
    "c": null,
    "o": [
      "In-place sorting (no extra space)",
      "Always faster",
      "Easier to implement",
      "Stable sorting"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "items = [5, 10, 2, 8]\nprint(sorted(items, reverse=True)[1])",
    "o": [
      "8",
      "10",
      "5",
      "2"
    ]
  },
  {
    "q": "What is the worst-case time complexity of binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which Python module provides a priority queue using a heap?",
    "c": null,
    "o": [
      "heapq",
      "bisect",
      "queue",
      "collections"
    ]
  },
  {
    "q": "What does the key argument in sorted() accept?",
    "c": null,
    "o": [
      "A function to extract sort criteria from each element",
      "The index to start sorting",
      "Boolean True or False",
      "A lambda that returns True"
    ]
  },
  {
    "q": "Which of these is not a built-in sorting function in Python?",
    "c": null,
    "o": [
      "sorter()",
      "sorted()",
      "list.sort()",
      "key parameter with sorted()"
    ]
  },
  {
    "q": "What happens if you use sort() on a list with incompatible types in Python 3?",
    "c": "data = ['a', 1, 'b']\ndata.sort()",
    "o": [
      "TypeError",
      "['a', 'b', 1]",
      "['a', 1, 'b']",
      "No output"
    ]
  },
  {
    "q": "Which sorting algorithm is most commonly used in embedded systems where memory is limited?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Bubble Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "What will be the output of the following?",
    "c": "a = [4, 1, 3, 2]\na.sort(reverse=False)\nprint(a[::2])",
    "o": [
      "[1, 3]",
      "[4, 3]",
      "[1, 2]",
      "[3, 1]"
    ]
  },
  {
    "q": "Which algorithm has a worst-case time of O(n log n) and is stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Selection Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which searching algorithm examines every element until it finds the target?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Hash Search"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "nums = [1, 4, 3, 2]\nnums.sort()\nprint(nums[-1])",
    "o": [
      "4",
      "3",
      "1",
      "2"
    ]
  },
  {
    "q": "Which sorting algorithm repeatedly compares and swaps adjacent elements?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the time complexity of insertion sort in the worst case?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which Python built-in function is best suited for creating a sorted copy of a list?",
    "c": null,
    "o": [
      "sorted()",
      "sort()",
      "list.sort()",
      "reverse()"
    ]
  },
  {
    "q": "Which search algorithm is used in the bisect module?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Exponential Search"
    ]
  },
  {
    "q": "Which of the following is true about merge sort?",
    "c": null,
    "o": [
      "It is a stable, divide-and-conquer algorithm",
      "It is in-place and unstable",
      "It uses pivoting to sort",
      "It only works on integers"
    ]
  },
  {
    "q": "What will the following code return?",
    "c": "data = [6, 3, 1]\nsorted_data = sorted(data)\nprint(data == sorted_data)",
    "o": [
      "False",
      "True",
      "None",
      "TypeError"
    ]
  },
  {
    "q": "Which Python list method modifies the list in place and does not return anything?",
    "c": null,
    "o": [
      "list.sort()",
      "sorted()",
      "filter()",
      "map()"
    ]
  },
  {
    "q": "What does `reverse=True` do in the `sorted()` function?",
    "c": null,
    "o": [
      "Sorts in descending order",
      "Reverses the list after sorting",
      "Skips every second element",
      "Sorts only the first half of the list"
    ]
  },
  {
    "q": "Which sorting algorithm is not suitable for linked lists due to its random access requirements?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which module provides both binary search and insertion functions in Python?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "math",
      "collections"
    ]
  },
  {
    "q": "Which of these algorithms is NOT stable by default?",
    "c": null,
    "o": [
      "Heap Sort",
      "Insertion Sort",
      "Bubble Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "What does the following print?",
    "c": "data = [2, 1, 3]\ndata.sort()\nprint(data[1])",
    "o": [
      "2",
      "1",
      "3",
      "None"
    ]
  },
  {
    "q": "What is the key idea behind insertion sort?",
    "c": null,
    "o": [
      "Build a sorted list one element at a time",
      "Select the minimum repeatedly",
      "Swap adjacent items until sorted",
      "Divide and conquer"
    ]
  },
  {
    "q": "What happens when you call sorted() on a tuple?",
    "c": "t = (5, 1, 3)\nprint(sorted(t))",
    "o": [
      "[1, 3, 5]",
      "(1, 3, 5)",
      "[5, 1, 3]",
      "TypeError"
    ]
  },
  {
    "q": "Which algorithm is most likely to outperform others on small data sets with few out-of-order elements?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What is the space complexity of quick sort (excluding recursion stack)?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What will the output be?",
    "c": "arr = [2, 4, 3, 1]\nprint(sorted(arr, reverse=True)[0])",
    "o": [
      "4",
      "1",
      "3",
      "2"
    ]
  },
  {
    "q": "Which sorting algorithm minimizes the number of swaps made during sorting?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which method is used to search a sorted list and return the insertion index to maintain order?",
    "c": null,
    "o": [
      "bisect.bisect_left()",
      "list.index()",
      "sorted().index()",
      "heapq.index()"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "nums = [10, 5, 8, 1]\nnums.sort(reverse=False)\nprint(nums[2])",
    "o": [
      "8",
      "5",
      "1",
      "10"
    ]
  },
  {
    "q": "Which of the following will create a new sorted list from an iterable without changing the original?",
    "c": null,
    "o": [
      "sorted()",
      "list.sort()",
      "sort()",
      "reversed()"
    ]
  },
  {
    "q": "What is the average-case time complexity of selection sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following sorts is guaranteed to be stable and in-place in Python?",
    "c": null,
    "o": [
      "Timsort",
      "Heap Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which function in `bisect` returns the rightmost position to insert the element?",
    "c": null,
    "o": [
      "bisect.bisect_right()",
      "bisect.bisect_left()",
      "bisect.insort()",
      "bisect.insert_right()"
    ]
  },
  {
    "q": "Which of the following statements about linear search is TRUE?",
    "c": null,
    "o": [
      "It works on both sorted and unsorted lists",
      "It requires sorted data",
      "It is faster than binary search on large datasets",
      "It uses a pivot"
    ]
  },
  {
    "q": "What is the best-case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following will raise an error?",
    "c": "data = [3, 'a', 5]\ndata.sort()",
    "o": [
      "TypeError",
      "[3, 5, 'a']",
      "[3, 'a', 5]",
      "[5, 'a', 3]"
    ]
  },
  {
    "q": "Which is an example of a comparison-based sorting algorithm?",
    "c": null,
    "o": [
      "Heap Sort",
      "Counting Sort",
      "Radix Sort",
      "Bucket Sort"
    ]
  },
  {
    "q": "What does the `key` parameter in `list.sort()` affect?",
    "c": null,
    "o": [
      "The criteria used for comparison during sorting",
      "The number of items sorted",
      "The reverse order of the list",
      "The start index of sorting"
    ]
  },
  {
    "q": "Which of the following algorithms sorts by building a final sorted array one element at a time?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "numbers = [9, 7, 5, 3]\nprint(sorted(numbers)[-1])",
    "o": [
      "9",
      "3",
      "5",
      "7"
    ]
  },
  {
    "q": "Which sorting algorithm works best when memory is severely limited?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Heap Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "Which of the following is not a valid usage of the `sorted()` function?",
    "c": null,
    "o": [
      "sorted(data, order=True)",
      "sorted(data)",
      "sorted(data, reverse=True)",
      "sorted(data, key=str.lower)"
    ]
  },
  {
    "q": "What is the worst-case time complexity of merge sort?",
    "c": null,
    "o": [
      "O(n log n)",
      "O(n^2)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "q": "What will the following code return?",
    "c": "arr = [3, 1, 2]\narr.sort()\nprint(arr)",
    "o": [
      "[1, 2, 3]",
      "[3, 1, 2]",
      "[2, 1, 3]",
      "None"
    ]
  },
  {
    "q": "Which algorithm uses a tree-based structure and guarantees O(log n) time for search?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "data = ['c', 'a', 'b']\nprint(sorted(data))",
    "o": [
      "['a', 'b', 'c']",
      "['c', 'b', 'a']",
      "['c', 'a', 'b']",
      "['b', 'c', 'a']"
    ]
  },
  {
    "q": "Which module is typically used in Python to perform efficient heap operations?",
    "c": null,
    "o": [
      "heapq",
      "bisect",
      "math",
      "queue"
    ]
  },
  {
    "q": "Which of these is a major advantage of Timsort over other algorithms?",
    "c": null,
    "o": [
      "Combines merge and insertion sort for better performance on real-world data",
      "Requires less space than quick sort",
      "Always faster than heap sort",
      "It’s the simplest to implement"
    ]
  },
  {
    "q": "Which sorting algorithm is best suited for sorting linked lists?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What will be printed?",
    "c": "x = [2, 4, 1, 3]\ny = sorted(x)\nprint(x == y)",
    "o": [
      "False",
      "True",
      "None",
      "TypeError"
    ]
  },
  {
    "q": "Which sorting algorithm is not stable?",
    "c": null,
    "o": [
      "Heap Sort",
      "Bubble Sort",
      "Merge Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which algorithm is faster than bubble sort but still has O(n^2) complexity?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What does the `key` argument in `sorted()` accept?",
    "c": null,
    "o": [
      "A function that transforms each element before comparison",
      "A boolean value for ascending or descending",
      "An integer index to start sorting from",
      "An option to enable binary search"
    ]
  },
  {
    "q": "Which of the following statements about the `list.sort()` method is TRUE?",
    "c": null,
    "o": [
      "It modifies the list in place and returns None",
      "It returns a new sorted list",
      "It works only for numeric lists",
      "It cannot accept a custom sorting function"
    ]
  },
  {
    "q": "Which searching algorithm is best suited for finding an element in a large sorted list?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Depth First Search"
    ]
  },
  {
    "q": "What will the following Python code output?",
    "c": "lst = ['b', 'a', 'c']\nlst.sort()\nprint(lst[0])",
    "o": [
      "a",
      "b",
      "c",
      "None"
    ]
  },
  {
    "q": "Which of the following sorts has a best-case time complexity of O(n)?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the primary drawback of selection sort?",
    "c": null,
    "o": [
      "It makes too many swaps",
      "It has high space complexity",
      "It requires recursion",
      "It is not deterministic"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "data = [3, 2, 1]\nprint(sorted(data, reverse=False))",
    "o": [
      "[1, 2, 3]",
      "[3, 2, 1]",
      "[3, 1, 2]",
      "[2, 3, 1]"
    ]
  },
  {
    "q": "Which of the following is FALSE about merge sort?",
    "c": null,
    "o": [
      "It sorts in place",
      "It is a divide-and-conquer algorithm",
      "It has stable behavior",
      "Its time complexity is O(n log n)"
    ]
  },
  {
    "q": "Which algorithm uses divide-and-conquer and a pivot to sort?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Selection Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which is TRUE about the `sorted()` function?",
    "c": null,
    "o": [
      "It returns a new sorted list from the elements of any iterable",
      "It can only sort lists",
      "It modifies the list in-place",
      "It sorts only strings and integers"
    ]
  },
  {
    "q": "Which sorting algorithm has the same time complexity in best, average, and worst cases?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What will the following print?",
    "c": "arr = [4, 2, 5, 1]\nprint(sorted(arr)[1])",
    "o": [
      "2",
      "4",
      "1",
      "5"
    ]
  },
  {
    "q": "Which is a feature of bubble sort?",
    "c": null,
    "o": [
      "Swaps adjacent elements repeatedly",
      "Always performs in O(n log n)",
      "Is faster than quick sort",
      "Divides the list before sorting"
    ]
  },
  {
    "q": "What is the worst-case space complexity of merge sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n^2)"
    ]
  },
  {
    "q": "Which Python sort algorithm is used internally for both `sorted()` and `list.sort()`?",
    "c": null,
    "o": [
      "Timsort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which searching algorithm is most appropriate for real-time systems due to predictable behavior?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "Which sorting algorithm is typically the fastest for average-case performance?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "nums = [1, 5, 3, 2]\nnums.sort()\nprint(nums[0], nums[-1])",
    "o": [
      "1 5",
      "5 1",
      "1 2",
      "2 5"
    ]
  },
  {
    "q": "Which of these algorithms is generally best for nearly sorted data?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Heap Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of these is true about Python's `sorted()` function?",
    "c": null,
    "o": [
      "It returns a new sorted list and does not modify the original iterable",
      "It modifies the original list and returns None",
      "It sorts in reverse order by default",
      "It can only be used with numbers"
    ]
  },
  {
    "q": "What will this code return?",
    "c": "a = [10, 20, 30]\nb = sorted(a, reverse=True)\nprint(a == b)",
    "o": [
      "False",
      "True",
      "None",
      "TypeError"
    ]
  },
  {
    "q": "Which algorithm has a time complexity of O(n^2) for worst-case and average-case scenarios?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of the following uses divide-and-conquer strategy?",
    "c": null,
    "o": [
      "Merge Sort",
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "Which is true about binary search?",
    "c": null,
    "o": [
      "It only works on sorted data",
      "It works on any iterable",
      "It is slower than linear search on average",
      "It is implemented in the heapq module"
    ]
  },
  {
    "q": "What does the `reverse=True` argument do in sorting functions?",
    "c": null,
    "o": [
      "Sorts the data in descending order",
      "Removes duplicates before sorting",
      "Sorts the second half of the data",
      "Ignores case sensitivity"
    ]
  },
  {
    "q": "Which function from the bisect module can be used to insert while maintaining sort order?",
    "c": null,
    "o": [
      "insort()",
      "insert()",
      "push()",
      "add()"
    ]
  },
  {
    "q": "What is the typical use of the `key` parameter in `sorted()`?",
    "c": null,
    "o": [
      "To provide a function to extract comparison values",
      "To specify which list index to sort",
      "To reverse the output",
      "To sort in-place"
    ]
  },
  {
    "q": "What is the worst-case time complexity of Quick Sort?",
    "c": null,
    "o": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ]
  },
  {
    "q": "Which sorting algorithm repeatedly moves the smallest unsorted element to its final position?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which Python module is most commonly used for binary searching?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "math",
      "random"
    ]
  },
  {
    "q": "Which sorting algorithm is considered stable and also used by Python’s internal sort?",
    "c": null,
    "o": [
      "Timsort",
      "Quick Sort",
      "Selection Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which of the following Python sorting approaches is best when you need to sort complex objects using a custom rule?",
    "c": null,
    "o": [
      "Using `sorted()` with a key function",
      "Using `list.sort()` without any parameters",
      "Using bubble sort manually",
      "Using a while loop to compare elements"
    ]
  },
  {
    "q": "What is the output of the following Python code?",
    "c": "arr = [1, 5, 3, 2]\nprint(sorted(arr, key=lambda x: -x))",
    "o": [
      "[5, 3, 2, 1]",
      "[1, 2, 3, 5]",
      "[1, 5, 3, 2]",
      "[2, 3, 5, 1]"
    ]
  },
  {
    "q": "Which of the following is FALSE about Python’s built-in sorting?",
    "c": null,
    "o": [
      "sorted() modifies the original list in place",
      "sorted() returns a new sorted list",
      "list.sort() sorts in place and returns None",
      "Both `sorted()` and `list.sort()` support the `key` argument"
    ]
  },
  {
    "q": "Which of the following is a disadvantage of quick sort?",
    "c": null,
    "o": [
      "Worst-case time complexity is O(n²)",
      "It is not in-place",
      "It requires O(n) extra memory",
      "It is not recursive"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "x = [1, 2, 3]\ny = x.sort()\nprint(y)",
    "o": [
      "None",
      "[1, 2, 3]",
      "[3, 2, 1]",
      "TypeError"
    ]
  },
  {
    "q": "Which sorting algorithm is least efficient for large datasets?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which algorithm repeatedly inserts elements into the correct position of the sorted part of the array?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of these is NOT a feature of Timsort?",
    "c": null,
    "o": [
      "Worst-case time complexity of O(n²)",
      "Stable sort",
      "Based on insertion and merge sort",
      "Used by Python internally"
    ]
  },
  {
    "q": "Which of these operations is performed by `bisect.insort()`?",
    "c": null,
    "o": [
      "Inserts into a sorted list while maintaining the order",
      "Sorts the list in reverse",
      "Finds the largest element",
      "Performs a binary search"
    ]
  },
  {
    "q": "Which of the following algorithms is an in-place sorting algorithm?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Counting Sort",
      "Bucket Sort"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "data = [6, 2, 9, 1]\ndata.sort(reverse=True)\nprint(data[0])",
    "o": [
      "9",
      "1",
      "2",
      "6"
    ]
  },
  {
    "q": "What is the space complexity of selection sort?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which sorting algorithm typically performs better on small data sets and is often used as part of hybrid algorithms like Timsort?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Counting Sort"
    ]
  },
  {
    "q": "What happens if you try to sort a list containing both integers and strings?",
    "c": "arr = [1, 'a', 2]\nsorted(arr)",
    "o": [
      "TypeError",
      "[1, 2, 'a']",
      "[1, 'a', 2]",
      "['a', 1, 2]"
    ]
  },
  {
    "q": "Which of the following algorithms is always stable?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which algorithm selects a pivot element and partitions the array around it?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Merge Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "arr = [7, 3, 5, 1]\narr.sort()\nprint(arr[::2])",
    "o": [
      "[1, 5]",
      "[3, 7]",
      "[1, 3]",
      "[5, 7]"
    ]
  },
  {
    "q": "Which sorting algorithm works by repeatedly finding the minimum element from unsorted part?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following can be used to sort in descending order?",
    "c": "data = [4, 1, 3]\nprint(sorted(data, reverse=True))",
    "o": [
      "[4, 3, 1]",
      "[1, 3, 4]",
      "[3, 1, 4]",
      "[1, 4, 3]"
    ]
  },
  {
    "q": "What is the average case time complexity of binary search?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which built-in function is used to sort dictionary keys alphabetically?",
    "c": "d = {'z': 9, 'a': 1, 'k': 5}\nprint(sorted(d))",
    "o": [
      "['a', 'k', 'z']",
      "[1, 5, 9]",
      "['z', 'a', 'k']",
      "{'a': 1, 'k': 5, 'z': 9}"
    ]
  },
  {
    "q": "Which of these algorithms is not comparison-based?",
    "c": null,
    "o": [
      "Counting Sort",
      "Merge Sort",
      "Heap Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What does the `key=lambda x: x.lower()` do in sorted()?",
    "c": "names = ['Alice', 'bob', 'Charlie']\nprint(sorted(names, key=lambda x: x.lower()))",
    "o": [
      "['Alice', 'bob', 'Charlie']",
      "['Charlie', 'Alice', 'bob']",
      "['bob', 'Alice', 'Charlie']",
      "['Alice', 'Charlie', 'bob']"
    ]
  },
  {
    "q": "Which sorting algorithm always divides the input array in half?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following is true about `list.sort()`?",
    "c": null,
    "o": [
      "It modifies the original list in-place",
      "It returns a sorted list",
      "It cannot take a key argument",
      "It raises an error on duplicates"
    ]
  },
  {
    "q": "What is the main advantage of merge sort over quick sort?",
    "c": null,
    "o": [
      "Merge sort guarantees O(n log n) in worst case",
      "Merge sort is always faster",
      "Merge sort uses less memory",
      "Merge sort is easier to implement"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "nums = [10, 2, 30]\nprint(sorted(nums, key=str))",
    "o": [
      "[10, 2, 30]",
      "[10, 30, 2]",
      "[2, 10, 30]",
      "[2, 30, 10]"
    ]
  },
  {
    "q": "Which is the best-case time complexity of linear search?",
    "c": null,
    "o": [
      "O(1)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of the following is used to perform efficient binary search in Python?",
    "c": null,
    "o": [
      "bisect module",
      "heapq module",
      "math module",
      "random module"
    ]
  },
  {
    "q": "Which of the following algorithms is stable and has O(n log n) average time complexity?",
    "c": null,
    "o": [
      "Merge Sort",
      "Heap Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which sorting algorithm is not adaptive (i.e., does not benefit from partial ordering)?",
    "c": null,
    "o": [
      "Selection Sort",
      "Insertion Sort",
      "Timsort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which of the following best describes the role of a pivot in Quick Sort?",
    "c": null,
    "o": [
      "To partition the array into elements less than and greater than itself",
      "To store the smallest element",
      "To count the number of swaps",
      "To avoid recursion"
    ]
  },
  {
    "q": "What is printed by the following code?",
    "c": "arr = [2, 5, 1, 3]\narr.sort()\nprint(arr[-2])",
    "o": [
      "3",
      "2",
      "5",
      "1"
    ]
  },
  {
    "q": "Which of these sorting algorithms is commonly used in practice because of its speed and in-place behavior?",
    "c": null,
    "o": [
      "Quick Sort",
      "Bubble Sort",
      "Merge Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which statement about binary search is TRUE?",
    "c": null,
    "o": [
      "It requires sorted data",
      "It works on all unsorted data",
      "It has a time complexity of O(n)",
      "It returns a boolean result only"
    ]
  },
  {
    "q": "Which algorithm is best suited for external sorting (sorting huge datasets on disk)?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will the following code return?",
    "c": "a = [6, 2, 8, 4]\nprint(sorted(a)[::2])",
    "o": [
      "[2, 6]",
      "[2, 8]",
      "[6, 4]",
      "[8, 2]"
    ]
  },
  {
    "q": "Which built-in Python function returns a new sorted list from any iterable?",
    "c": null,
    "o": [
      "sorted()",
      "sort()",
      "arr.sort()",
      "reverse()"
    ]
  },
  {
    "q": "Which algorithm has O(n^2) worst-case time and is generally the simplest to implement?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Heap Sort",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which of the following built-in functions is most appropriate for sorting strings by length?",
    "c": "words = ['apple', 'kiwi', 'banana']\nprint(sorted(words, key=len))",
    "o": [
      "['kiwi', 'apple', 'banana']",
      "['banana', 'apple', 'kiwi']",
      "['apple', 'kiwi', 'banana']",
      "['apple', 'banana', 'kiwi']"
    ]
  },
  {
    "q": "Which of the following is NOT a property of merge sort?",
    "c": null,
    "o": [
      "It sorts in-place without extra memory",
      "It is a stable sort",
      "It has O(n log n) time in all cases",
      "It divides the input recursively"
    ]
  },
  {
    "q": "Which Python statement is used to sort a list without modifying the original?",
    "c": null,
    "o": [
      "sorted(my_list)",
      "my_list.sort()",
      "my_list[::-1]",
      "reversed(my_list)"
    ]
  },
  {
    "q": "Which sorting method does NOT work well for linked lists due to poor data locality?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "x = [1, 3, 2, 4]\nx.sort(reverse=True)\nprint(x[1])",
    "o": [
      "3",
      "2",
      "4",
      "1"
    ]
  },
  {
    "q": "Which module provides efficient functions for maintaining a sorted list?",
    "c": null,
    "o": [
      "bisect",
      "math",
      "heapq",
      "collections"
    ]
  },
  {
    "q": "Which sorting algorithm is ideal for datasets where insertions happen frequently during runtime?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which sorting algorithm is guaranteed to take O(n log n) time even in the worst case?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "arr = ['python', 'java', 'c++']\narr.sort(key=lambda x: len(x))\nprint(arr)",
    "o": [
      "['c++', 'java', 'python']",
      "['python', 'java', 'c++']",
      "['java', 'python', 'c++']",
      "['java', 'c++', 'python']"
    ]
  },
  {
    "q": "Which of these is a stable sorting algorithm?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Heap Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What is the correct way to sort a list of strings case-insensitively?",
    "c": "names = ['bob', 'Alice', 'charlie']\nprint(sorted(names, key=str.lower))",
    "o": [
      "['Alice', 'bob', 'charlie']",
      "['bob', 'Alice', 'charlie']",
      "['charlie', 'bob', 'Alice']",
      "['bob', 'charlie', 'Alice']"
    ]
  },
  {
    "q": "Which sorting algorithm is typically fastest in practice but has worst-case O(n^2)?",
    "c": null,
    "o": [
      "Quick Sort",
      "Selection Sort",
      "Bubble Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which function is used to find the position to insert an element in a sorted list while maintaining order?",
    "c": null,
    "o": [
      "bisect.bisect()",
      "list.index()",
      "heapq.insert()",
      "sorted.index()"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "a = [3, 6, 1]\nprint(sorted(a, reverse=True)[-1])",
    "o": [
      "1",
      "6",
      "3",
      "None"
    ]
  },
  {
    "q": "Which sort does NOT divide the list into smaller segments?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Timsort"
    ]
  },
  {
    "q": "What is a defining characteristic of heap sort?",
    "c": null,
    "o": [
      "It uses a binary heap to organize elements",
      "It is recursive and unstable",
      "It is stable and uses linear time",
      "It divides the input into halves"
    ]
  },
  {
    "q": "Which of the following statements about `sorted()` is TRUE?",
    "c": null,
    "o": [
      "It returns a new sorted list and leaves the original unchanged",
      "It modifies the original list",
      "It only works on strings",
      "It requires the list to be sorted first"
    ]
  },
  {
    "q": "Which of the following has a time complexity of O(n) in the best case?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "x = [5, 2, 8, 6]\nprint(sorted(x, key=lambda n: -n))",
    "o": [
      "[8, 6, 5, 2]",
      "[2, 5, 6, 8]",
      "[5, 2, 8, 6]",
      "[2, 6, 8, 5]"
    ]
  },
  {
    "q": "Which of the following modules is best for efficient binary search operations?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "random",
      "collections"
    ]
  },
  {
    "q": "Which Python sorting method is preferred when sorting large lists in-place with custom logic?",
    "c": null,
    "o": [
      "list.sort() with key",
      "sorted() with key",
      "reversed()",
      "enumerate()"
    ]
  },
  {
    "q": "Which of the following sorting algorithms divides the array and uses recursion to sort each half?",
    "c": null,
    "o": [
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which of the following searching techniques does NOT require the data to be sorted?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Exponential Search"
    ]
  },
  {
    "q": "What will this code return?",
    "c": "arr = [10, 2, 7, 1]\narr.sort()\nprint(arr[-1])",
    "o": [
      "10",
      "7",
      "2",
      "1"
    ]
  },
  {
    "q": "Which sorting algorithm performs best when all elements are identical or nearly equal?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Quick Sort",
      "Merge Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which built-in Python function is most appropriate for sorting based on custom object attributes?",
    "c": null,
    "o": [
      "sorted() with key",
      "sort() with reverse",
      "max() with key",
      "filter() with lambda"
    ]
  },
  {
    "q": "Which of the following is TRUE about `list.sort()`?",
    "c": null,
    "o": [
      "It returns None and modifies the list in-place",
      "It returns a new sorted list",
      "It only works on integers",
      "It raises an error if key is provided"
    ]
  },
  {
    "q": "What is the correct way to sort a list of tuples by the second item?",
    "c": "data = [(1, 3), (2, 2), (3, 1)]\nprint(sorted(data, key=lambda x: x[1]))",
    "o": [
      "[(3, 1), (2, 2), (1, 3)]",
      "[(1, 3), (2, 2), (3, 1)]",
      "[(1, 2), (2, 3), (3, 1)]",
      "[(3, 1), (1, 3), (2, 2)]"
    ]
  },
  {
    "q": "What is the best-case time complexity of bubble sort?",
    "c": null,
    "o": [
      "O(n)",
      "O(n^2)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "q": "Which of these is NOT true about Timsort?",
    "c": null,
    "o": [
      "It is not recursive",
      "It is a hybrid algorithm",
      "It is stable",
      "It is used in Python's built-in sorting"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "names = ['Sam', 'john', 'ALICE']\nnames.sort(key=str.lower)\nprint(names)",
    "o": [
      "['ALICE', 'john', 'Sam']",
      "['john', 'Sam', 'ALICE']",
      "['Sam', 'john', 'ALICE']",
      "['john', 'ALICE', 'Sam']"
    ]
  },
  {
    "q": "Which algorithm uses repeated swapping of adjacent elements to move large elements to the end?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which searching method has the worst-case time complexity of O(n)?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Exponential Search"
    ]
  },
  {
    "q": "What happens if you call `list.sort()` on a list of mixed types (e.g., int and str)?",
    "c": "lst = [3, 'hello', 2]\nlst.sort()",
    "o": [
      "TypeError",
      "['hello', 2, 3]",
      "[2, 3, 'hello']",
      "None"
    ]
  },
  {
    "q": "Which sorting algorithm uses a binary heap data structure?",
    "c": null,
    "o": [
      "Heap Sort",
      "Merge Sort",
      "Quick Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which method would you use to sort a list in-place in descending order?",
    "c": "arr = [1, 4, 2]\narr.sort(reverse=True)\nprint(arr)",
    "o": [
      "[4, 2, 1]",
      "[1, 2, 4]",
      "[2, 1, 4]",
      "[4, 1, 2]"
    ]
  },
  {
    "q": "Which of the following is TRUE about binary search?",
    "c": null,
    "o": [
      "It requires the list to be sorted",
      "It works on unsorted arrays",
      "It has a worst-case time complexity of O(n)",
      "It modifies the original list"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "arr = [4, 2, 9, 1]\narr = sorted(arr)\nprint(arr[1])",
    "o": [
      "2",
      "1",
      "4",
      "9"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is NOT stable by default?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What is the purpose of the `key` parameter in the `sorted()` function?",
    "c": null,
    "o": [
      "To specify a custom sort order",
      "To sort the dictionary by key",
      "To reverse the sorting",
      "To change the original list"
    ]
  },
  {
    "q": "Which algorithm is NOT suitable for large datasets due to its O(n²) average time complexity?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "Which function in Python returns the sorted version of any iterable?",
    "c": null,
    "o": [
      "sorted()",
      "list.sort()",
      "reverse()",
      "order()"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "a = [9, 1, 4, 2]\nprint(sorted(a)[-2])",
    "o": [
      "4",
      "2",
      "1",
      "9"
    ]
  },
  {
    "q": "Which sorting algorithm has the worst-case time complexity of O(n log n)?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which searching algorithm divides the list into blocks and performs linear search within each block?",
    "c": null,
    "o": [
      "Jump Search",
      "Binary Search",
      "Linear Search",
      "Exponential Search"
    ]
  },
  {
    "q": "Which module provides efficient binary search insertion methods in Python?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "math",
      "os"
    ]
  },
  {
    "q": "Which of these is TRUE about the `list.sort()` method?",
    "c": null,
    "o": [
      "It returns None and sorts the list in-place",
      "It returns a sorted list",
      "It cannot sort strings",
      "It sorts dictionaries"
    ]
  },
  {
    "q": "What is the main benefit of Timsort over other algorithms?",
    "c": null,
    "o": [
      "It combines merge and insertion sort and is optimized for real-world data",
      "It uses a pivot strategy for performance",
      "It is based on heaps",
      "It is purely recursive"
    ]
  },
  {
    "q": "Which sort is best when memory usage needs to be minimal?",
    "c": null,
    "o": [
      "Selection Sort",
      "Merge Sort",
      "Counting Sort",
      "Bucket Sort"
    ]
  },
  {
    "q": "What happens when `sorted()` is used with a tuple?",
    "c": "t = (3, 1, 2)\nprint(sorted(t))",
    "o": [
      "[1, 2, 3]",
      "(1, 2, 3)",
      "[3, 1, 2]",
      "{1, 2, 3}"
    ]
  },
  {
    "q": "Which of the following is FALSE about insertion sort?",
    "c": null,
    "o": [
      "It performs poorly on large lists",
      "It is not adaptive",
      "It works well on nearly sorted data",
      "It has a best-case time of O(n)"
    ]
  },
  {
    "q": "Which sorting algorithm maintains relative order of equal elements?",
    "c": null,
    "o": [
      "Stable sort",
      "Quick sort",
      "Heap sort",
      "Selection sort"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "lst = [5, 4, 3, 2, 1]\nlst.sort()\nprint(lst)",
    "o": [
      "[1, 2, 3, 4, 5]",
      "[5, 4, 3, 2, 1]",
      "[2, 1, 3, 5, 4]",
      "[3, 2, 4, 5, 1]"
    ]
  },
  {
    "q": "Which of the following best describes the time complexity of binary search in worst-case?",
    "c": null,
    "o": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "Which algorithm is optimal for sorting linked lists?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Bubble Sort",
      "Heap Sort"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "arr = [3, 1, 2]\nprint(sorted(arr, reverse=False)[1])",
    "o": [
      "2",
      "1",
      "3",
      "None"
    ]
  },
  {
    "q": "Which Python function is used to perform in-place sorting?",
    "c": null,
    "o": [
      "list.sort()",
      "sorted()",
      "order()",
      "reversed()"
    ]
  },
  {
    "q": "Which of the following sorting algorithms does NOT rely on comparisons?",
    "c": null,
    "o": [
      "Counting Sort",
      "Quick Sort",
      "Bubble Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "numbers = [3, 1, 4]\nsorted_numbers = sorted(numbers)\nprint(numbers == sorted_numbers)",
    "o": [
      "False",
      "True",
      "None",
      "TypeError"
    ]
  },
  {
    "q": "Which method can be used to sort a list of dictionaries by a key 'age'?",
    "c": "data = [{'name': 'Tom', 'age': 30}, {'name': 'Bob', 'age': 25}]\nprint(sorted(data, key=lambda x: x['age']))",
    "o": [
      "[{'name': 'Bob', 'age': 25}, {'name': 'Tom', 'age': 30}]",
      "[{'name': 'Tom', 'age': 30}, {'name': 'Bob', 'age': 25}]",
      "[{'age': 25, 'name': 'Bob'}, {'age': 30, 'name': 'Tom'}]",
      "[{'name': 'Bob'}, {'name': 'Tom'}]"
    ]
  },
  {
    "q": "Which built-in Python method reverses the list in place?",
    "c": null,
    "o": [
      "list.reverse()",
      "sorted(reverse=True)",
      "reversed()",
      "list.sort()"
    ]
  },
  {
    "q": "What is the average case time complexity of linear search?",
    "c": null,
    "o": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "x = [1, 2, 3]\ny = sorted(x)\ny[0] = 99\nprint(x[0])",
    "o": [
      "1",
      "99",
      "0",
      "None"
    ]
  },
  {
    "q": "Which sorting algorithm divides the input list and then combines the results in sorted order?",
    "c": null,
    "o": [
      "Merge Sort",
      "Selection Sort",
      "Insertion Sort",
      "Bubble Sort"
    ]
  },
  {
    "q": "Which searching algorithm exponentially increases the range of search and then uses binary search?",
    "c": null,
    "o": [
      "Exponential Search",
      "Jump Search",
      "Linear Search",
      "Binary Search"
    ]
  },
  {
    "q": "Which of the following operations can `bisect.insort()` perform?",
    "c": null,
    "o": [
      "Insert an element while keeping list sorted",
      "Insert at a specific index",
      "Sort the list",
      "Remove an element"
    ]
  },
  {
    "q": "Which sorting algorithm is used by Python's built-in `sorted()` function?",
    "c": null,
    "o": [
      "Timsort",
      "Quicksort",
      "Heapsort",
      "Bubblesort"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "a = [1, 2, 3, 4]\nprint(sorted(a, reverse=True)[0])",
    "o": [
      "4",
      "1",
      "3",
      "2"
    ]
  },
  {
    "q": "Which of the following sorting algorithms is both stable and has a time complexity of O(n log n)?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Heap Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "Which algorithm is the most efficient for searching in a **sorted list**?",
    "c": null,
    "o": [
      "Binary Search",
      "Linear Search",
      "Jump Search",
      "Exponential Search"
    ]
  },
  {
    "q": "Which Python module is commonly used for maintaining a sorted list on the fly?",
    "c": null,
    "o": [
      "bisect",
      "heapq",
      "array",
      "random"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "arr = ['B', 'a', 'A', 'b']\nprint(sorted(arr, key=str.lower))",
    "o": [
      "['a', 'A', 'B', 'b']",
      "['A', 'B', 'a', 'b']",
      "['B', 'b', 'A', 'a']",
      "['A', 'a', 'B', 'b']"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of quick sort?",
    "c": null,
    "o": [
      "Stable",
      "Divide-and-conquer",
      "In-place",
      "Recursive"
    ]
  },
  {
    "q": "Which is the best-case time complexity of binary search?",
    "c": null,
    "o": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "q": "What is the primary reason to prefer merge sort over quick sort for linked lists?",
    "c": null,
    "o": [
      "Efficient node merging without random access",
      "Better average-case time",
      "Less memory required",
      "Easier to code"
    ]
  },
  {
    "q": "Which of the following is TRUE about Python’s `reversed()` function?",
    "c": "arr = [1, 2, 3]\nprint(list(reversed(arr)))",
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "[2, 1, 3]",
      "[3, 1, 2]"
    ]
  },
  {
    "q": "Which algorithm is based on the idea of repeatedly moving the largest element to the end?",
    "c": null,
    "o": [
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "Which searching algorithm checks elements by skipping blocks?",
    "c": null,
    "o": [
      "Jump Search",
      "Binary Search",
      "Linear Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "Which function sorts a list without modifying the original list?",
    "c": null,
    "o": [
      "sorted()",
      "list.sort()",
      "reverse()",
      "del()"
    ]
  },
  {
    "q": "Which of the following is TRUE about `list.sort()`?",
    "c": null,
    "o": [
      "It returns None",
      "It returns a new list",
      "It sorts tuples only",
      "It reverses a list"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "nums = [3, 1, 4]\nsorted(nums)\nprint(nums)",
    "o": [
      "[3, 1, 4]",
      "[1, 3, 4]",
      "[4, 3, 1]",
      "[1, 4, 3]"
    ]
  },
  {
    "q": "Which of these sorting algorithms typically has the lowest number of swaps?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "data = [1, 2, 3]\nsorted_data = sorted(data, reverse=True)\nprint(sorted_data[2])",
    "o": [
      "1",
      "2",
      "3",
      "None"
    ]
  },
  {
    "q": "Which searching algorithm is best for linked lists?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Exponential Search"
    ]
  },
  {
    "q": "Which of the following is true for Python's `sort()` method?",
    "c": null,
    "o": [
      "It modifies the original list and returns None",
      "It creates a new list and returns it",
      "It works only with integers",
      "It cannot sort strings"
    ]
  },
  {
    "q": "Which sorting algorithm is based on divide and conquer and is not stable?",
    "c": null,
    "o": [
      "Quick Sort",
      "Merge Sort",
      "Bubble Sort",
      "Insertion Sort"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "x = ['a', 'abc', 'ab']\nx.sort(key=len)\nprint(x)",
    "o": [
      "['a', 'ab', 'abc']",
      "['abc', 'ab', 'a']",
      "['a', 'abc', 'ab']",
      "['ab', 'a', 'abc']"
    ]
  },
  {
    "q": "Which of these sorting algorithms is most efficient for nearly sorted data?",
    "c": null,
    "o": [
      "Insertion Sort",
      "Bubble Sort",
      "Quick Sort",
      "Merge Sort"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "numbers = [10, 20, 30]\nnumbers.sort()\nprint(numbers == sorted(numbers))",
    "o": [
      "True",
      "False",
      "None",
      "TypeError"
    ]
  },
  {
    "q": "Which searching algorithm is efficient when the element is expected to be close to the beginning?",
    "c": null,
    "o": [
      "Linear Search",
      "Binary Search",
      "Jump Search",
      "Interpolation Search"
    ]
  },
  {
    "q": "What is the main reason merge sort is used over quick sort for linked lists?",
    "c": null,
    "o": [
      "It does not require random access",
      "It uses less memory",
      "It is faster on arrays",
      "It is easier to implement"
    ]
  },
  {
    "q": "Which of the following algorithms always runs in O(n log n) time?",
    "c": null,
    "o": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Selection Sort"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "arr = [7, 3, 5, 9]\narr.sort()\nprint(arr[1:3])",
    "o": [
      "[5, 7]",
      "[3, 5]",
      "[3, 5, 7]",
      "[7, 3]"
    ]
  },
  {
    "q": "Which Python function gives a reversed **iterator** instead of list?",
    "c": null,
    "o": [
      "reversed()",
      "reverse()",
      "list[::-1]",
      "sort(reverse=True)"
    ]
  },
  {
    "q": "Which sorting algorithm repeatedly finds the maximum element and moves it to the end?",
    "c": null,
    "o": [
      "Selection Sort",
      "Bubble Sort",
      "Insertion Sort",
      "Quick Sort"
    ]
  },
  {
    "q": "Which built-in function will sort a tuple and return a list?",
    "c": "t = (5, 1, 4)\nprint(sorted(t))",
    "o": [
      "[1, 4, 5]",
      "(1, 4, 5)",
      "[5, 4, 1]",
      "{1, 4, 5}"
    ]
  },
    {
        "q": "What is the time complexity of Linear Search in the worst case?",
        "c": null,
        "o": [
            "O(n)",
            "O(log n)",
            "O(n^2)",
            "O(1)"
        ]
    },
    {
        "q": "Which of the following code snippets correctly implements Binary Search for a sorted array?",
        "c": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "o": [
            "Returns the index of target if found, else -1",
            "Always returns 0",
            "Returns the target value",
            "Raises an exception if target not found"
        ]
    },
    {
        "q": "Which sorting algorithm repeatedly swaps adjacent elements if they are in the wrong order?",
        "c": null,
        "o": [
            "Bubble Sort",
            "Selection Sort",
            "Insertion Sort",
            "Merge Sort"
        ]
    },
    {
        "q": "What is the output of the following Selection Sort implementation for the array [64, 34, 25, 12, 22]?",
        "c": "def selection_sort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\narr = [64, 34, 25, 12, 22]\nprint(selection_sort(arr))",
        "o": [
            "[12, 22, 25, 34, 64]",
            "[64, 34, 25, 22, 12]",
            "[12, 25, 22, 34, 64]",
            "[64, 22, 25, 34, 12]"
        ]
    },
    {
        "q": "Which sorting algorithm maintains a sorted subarray and inserts elements into it one by one?",
        "c": null,
        "o": [
            "Insertion Sort",
            "Bubble Sort",
            "Quick Sort",
            "Merge Sort"
        ]
    },
    {
        "q": "What is the time complexity of Merge Sort in the average case?",
        "c": null,
        "o": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ]
    },
    {
        "q": "What is the output of the following Quick Sort partition function for the array [10, 7, 8, 9, 1, 5] with pivot as the last element?",
        "c": "def partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\narr = [10, 7, 8, 9, 1, 5]\nresult = partition(arr, 0, len(arr)-1)\nprint(arr, result)",
        "o": [
            "[1, 7, 8, 9, 5, 10], 4",
            "[10, 7, 8, 9, 1, 5], 5",
            "[1, 7, 8, 5, 9, 10], 3",
            "[10, 7, 8, 9, 5, 1], 4"
        ]
    },
    {
        "q": "What does the built-in sorted() function in Python return when applied to a list?",
        "c": "lst = [5, 2, 8, 1, 9]\nprint(sorted(lst))",
        "o": [
            "[1, 2, 5, 8, 9]",
            "[9, 8, 5, 2, 1]",
            "[5, 2, 8, 1, 9]",
            "None"
        ]
    },
    {
        "q": "How does list.sort() differ from sorted() in Python?",
        "c": null,
        "o": [
            "list.sort() modifies the list in-place, sorted() returns a new list",
            "list.sort() returns a new list, sorted() modifies in-place",
            "Both modify the list in-place",
            "Both return a new list"
        ]
    },
    {
        "q": "Which of the following is true about Binary Search?",
        "c": null,
        "o": [
            "It requires the input array to be sorted",
            "It has O(n) time complexity in the worst case",
            "It can be applied to unsorted arrays",
            "It uses a divide-and-conquer approach for sorting"
        ]
    },
    {
        "q": "What is the space complexity of Linear Search?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n^2)"
        ]
    },
    {
        "q": "Which of the following correctly implements the comparison condition in Binary Search for finding the first occurrence of a target?",
        "c": "def binary_search_first(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
        "o": [
            "Returns the index of the first occurrence of target",
            "Returns the index of the last occurrence of target",
            "Returns -1 if target is found",
            "Always returns the middle index"
        ]
    },
    {
        "q": "Which sorting algorithm is considered unstable because it may swap equal elements?",
        "c": null,
        "o": [
            "Quick Sort",
            "Merge Sort",
            "Insertion Sort",
            "Bubble Sort"
        ]
    },
    {
        "q": "What is the output of the following Bubble Sort implementation for the array [5, 3, 8, 6, 2] after the first pass?",
        "c": "def bubble_sort_pass(arr):\n    n = len(arr)\n    for i in range(n-1):\n        if arr[i] > arr[i+1]:\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n    return arr\narr = [5, 3, 8, 6, 2]\nprint(bubble_sort_pass(arr))",
        "o": [
            "[3, 5, 6, 2, 8]",
            "[5, 3, 8, 6, 2]",
            "[2, 3, 5, 6, 8]",
            "[5, 3, 6, 2, 8]"
        ]
    },
    {
        "q": "What is the best-case time complexity of Insertion Sort?",
        "c": null,
        "o": [
            "O(n)",
            "O(n^2)",
            "O(n log n)",
            "O(1)"
        ]
    },
    {
        "q": "Which of the following is a key characteristic of Merge Sort?",
        "c": null,
        "o": [
            "It is a stable sorting algorithm",
            "It has O(n) time complexity",
            "It modifies the array in-place without extra space",
            "It is not a divide-and-conquer algorithm"
        ]
    },
    {
        "q": "What is the output of the following Quick Sort implementation for choosing the pivot as the first element for the array [3, 8, 2, 5, 1, 4, 7, 6]?",
        "c": "def partition(arr, low, high):\n    pivot = arr[low]\n    i = low + 1\n    j = high\n    while True:\n        while i <= j and arr[i] <= pivot:\n            i += 1\n        while i <= j and arr[j] > pivot:\n            j -= 1\n        if i <= j:\n            arr[i], arr[j] = arr[j], arr[i]\n        else:\n            break\n    arr[low], arr[j] = arr[j], arr[low]\n    return j\narr = [3, 8, 2, 5, 1, 4, 7, 6]\nresult = partition(arr, 0, len(arr)-1)\nprint(arr, result)",
        "o": [
            "[1, 2, 3, 5, 8, 4, 7, 6], 2",
            "[3, 8, 2, 5, 1, 4, 7, 6], 0",
            "[1, 2, 3, 8, 5, 4, 7, 6], 3",
            "[3, 2, 1, 5, 8, 4, 7, 6], 1"
        ]
    },
    {
        "q": "What happens when you use sorted() with the reverse=True parameter?",
        "c": "lst = [1, 3, 2, 5, 4]\nprint(sorted(lst, reverse=True))",
        "o": [
            "[5, 4, 3, 2, 1]",
            "[1, 2, 3, 4, 5]",
            "[1, 3, 2, 5, 4]",
            "None"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() on a list?",
        "c": "lst = [4, 2, 5, 1, 3]\nlst.sort()\nprint(lst)",
        "o": [
            "[1, 2, 3, 4, 5]",
            "[5, 4, 3, 2, 1]",
            "[4, 2, 5, 1, 3]",
            "None"
        ]
    },
    {
        "q": "Which of the following is a prerequisite for Binary Search to work correctly?",
        "c": null,
        "o": [
            "The input array must be sorted",
            "The input array must be unsorted",
            "The input array must contain unique elements",
            "The input array must be of even length"
        ]
    },
    {
        "q": "What is the best-case time complexity of Linear Search when the target is at the first position?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n^2)"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the last occurrence of a target?",
        "c": "def binary_search_last(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
        "o": [
            "Returns the index of the last occurrence of target",
            "Returns the index of the first occurrence of target",
            "Returns -1 if target is found",
            "Always returns the middle index"
        ]
    },
    {
        "q": "Which sorting algorithm is most suitable for nearly sorted arrays?",
        "c": null,
        "o": [
            "Insertion Sort",
            "Quick Sort",
            "Bubble Sort",
            "Merge Sort"
        ]
    },
    {
        "q": "What is the output of the following Bubble Sort implementation after two passes for the array [9, 7, 5, 3, 1]?",
        "c": "def bubble_sort_two_passes(arr):\n    n = len(arr)\n    for i in range(2):\n        for j in range(n-1-i):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\narr = [9, 7, 5, 3, 1]\nprint(bubble_sort_two_passes(arr))",
        "o": [
            "[5, 7, 3, 1, 9]",
            "[9, 7, 5, 3, 1]",
            "[7, 5, 3, 1, 9]",
            "[3, 5, 7, 1, 9]"
        ]
    },
    {
        "q": "What is the average-case time complexity of Selection Sort?",
        "c": null,
        "o": [
            "O(n^2)",
            "O(n log n)",
            "O(n)",
            "O(log n)"
        ]
    },
    {
        "q": "Which of the following is a key feature of Quick Sort?",
        "c": null,
        "o": [
            "It uses a pivot to partition the array",
            "It is a stable sorting algorithm",
            "It requires O(n) extra space",
            "It performs best on sorted arrays"
        ]
    },
    {
        "q": "What is the output of the following Merge Sort merge function for merging [1, 3, 5] and [2, 4, 6]?",
        "c": "def merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\nprint(merge([1, 3, 5], [2, 4, 6]))",
        "o": [
            "[1, 2, 3, 4, 5, 6]",
            "[1, 3, 5, 2, 4, 6]",
            "[2, 4, 6, 1, 3, 5]",
            "[1, 2, 3, 5, 4, 6]"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of tuples by the second element?",
        "c": "pairs = [(1, 'b'), (3, 'a'), (2, 'c')]\nprint(sorted(pairs, key=lambda x: x[1]))",
        "o": [
            "[(3, 'a'), (1, 'b'), (2, 'c')]",
            "[(1, 'b'), (2, 'c'), (3, 'a')]",
            "[(2, 'c'), (1, 'b'), (3, 'a')]",
            "[(3, 'a'), (2, 'c'), (1, 'b')]"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with reverse=True?",
        "c": "lst = [3, 1, 4, 2, 5]\nlst.sort(reverse=True)\nprint(lst)",
        "o": [
            "[5, 4, 3, 2, 1]",
            "[1, 2, 3, 4, 5]",
            "[3, 1, 4, 2, 5]",
            "None"
        ]
    },
    {
        "q": "Which of the following is a limitation of Binary Search?",
        "c": null,
        "o": [
            "It requires the array to be sorted",
            "It has O(n^2) time complexity",
            "It cannot find duplicate elements",
            "It only works for integer arrays"
        ]
    },
    {
        "q": "What is the primary disadvantage of Linear Search compared to Binary Search?",
        "c": null,
        "o": [
            "Linear Search has O(n) time complexity for all cases",
            "Linear Search requires a sorted array",
            "Linear Search uses more memory",
            "Linear Search cannot find the target"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search iteratively to find the ceiling of a number (smallest element greater than or equal to target)?",
        "c": "def binary_search_ceiling(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left if left < len(arr) else -1",
        "o": [
            "Returns the index of the smallest element >= target or -1 if none exists",
            "Returns the index of the largest element <= target",
            "Returns the index of the target or -1 if not found",
            "Always returns the last index"
        ]
    },
    {
        "q": "Which sorting algorithm performs best when the input array is already sorted?",
        "c": null,
        "o": [
            "Insertion Sort",
            "Selection Sort",
            "Quick Sort",
            "Merge Sort"
        ]
    },
    {
        "q": "What is the output of the following Selection Sort implementation after the first pass for the array [8, 4, 6, 2, 7]?",
        "c": "def selection_sort_pass(arr):\n    min_idx = 0\n    for j in range(1, len(arr)):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[0], arr[min_idx] = arr[min_idx], arr[0]\n    return arr\narr = [8, 4, 6, 2, 7]\nprint(selection_sort_pass(arr))",
        "o": [
            "[2, 4, 6, 8, 7]",
            "[8, 4, 6, 2, 7]",
            "[4, 8, 6, 2, 7]",
            "[2, 8, 6, 4, 7]"
        ]
    },
    {
        "q": "What is the worst-case space complexity of Quick Sort?",
        "c": null,
        "o": [
            "O(log n)",
            "O(n)",
            "O(n^2)",
            "O(1)"
        ]
    },
    {
        "q": "Which of the following is true about Bubble Sort?",
        "c": null,
        "o": [
            "It is a stable sorting algorithm",
            "It has O(n log n) time complexity",
            "It requires O(n) extra space",
            "It is a divide-and-conquer algorithm"
        ]
    },
    {
        "q": "What is the output of the following Merge Sort implementation for splitting an array [7, 2, 9, 4] into two halves?",
        "c": "def merge_sort_split(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    return left, right\narr = [7, 2, 9, 4]\nprint(merge_sort_split(arr))",
        "o": [
            "([7, 2], [9, 4])",
            "([7, 9], [2, 4])",
            "([7, 4], [2, 9])",
            "([7, 2, 9], [4])"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of dictionaries by a specific key?",
        "c": "data = [{'name': 'John', 'age': 30}, {'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 35}]\nprint(sorted(data, key=lambda x: x['age']))",
        "o": [
            "[{'name': 'Alice', 'age': 25}, {'name': 'John', 'age': 30}, {'name': 'Bob', 'age': 35}]",
            "[{'name': 'Bob', 'age': 35}, {'name': 'John', 'age': 30}, {'name': 'Alice', 'age': 25}]",
            "[{'name': 'John', 'age': 30}, {'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 35}]",
            "[{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 35}, {'name': 'John', 'age': 30}]"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a custom comparison function using the key parameter?",
        "c": "lst = ['banana', 'apple', 'cherry']\nlst.sort(key=lambda x: x[-1])\nprint(lst)",
        "o": [
            "['banana', 'apple', 'cherry']",
            "['cherry', 'banana', 'apple']",
            "['apple', 'banana', 'cherry']",
            "None"
        ]
    },
    {
        "q": "Which of the following is a key requirement for Binary Search to be efficient?",
        "c": null,
        "o": [
            "The array must be sorted",
            "The array must contain duplicates",
            "The array must be of fixed size",
            "The array must be unsorted"
        ]
    },
    {
        "q": "What is the average-case time complexity of Linear Search?",
        "c": null,
        "o": [
            "O(n)",
            "O(log n)",
            "O(n^2)",
            "O(1)"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the floor of a number (largest element less than or equal to target)?",
        "c": "def binary_search_floor(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
        "o": [
            "Returns the index of the largest element <= target or -1 if none exists",
            "Returns the index of the smallest element >= target",
            "Returns the index of the target or -1 if not found",
            "Always returns the first index"
        ]
    },
    {
        "q": "Which sorting algorithm is least efficient for large, randomly ordered arrays?",
        "c": null,
        "o": [
            "Bubble Sort",
            "Quick Sort",
            "Merge Sort",
            "Insertion Sort"
        ]
    },
    {
        "q": "What is the output of the following Insertion Sort implementation after the first pass for the array [10, 5, 8, 12, 3]?",
        "c": "def insertion_sort_pass(arr):\n    key = arr[1]\n    j = 0\n    while j >= 0 and arr[j] > key:\n        arr[j + 1] = arr[j]\n        j -= 1\n    arr[j + 1] = key\n    return arr\narr = [10, 5, 8, 12, 3]\nprint(insertion_sort_pass(arr))",
        "o": [
            "[5, 10, 8, 12, 3]",
            "[10, 5, 8, 12, 3]",
            "[5, 8, 10, 12, 3]",
            "[10, 8, 5, 12, 3]"
        ]
    },
    {
        "q": "What is the best-case time complexity of Quick Sort?",
        "c": null,
        "o": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ]
    },
    {
        "q": "Which of the following is a characteristic of Selection Sort?",
        "c": null,
        "o": [
            "It always finds the minimum element in the unsorted portion",
            "It is a stable sorting algorithm",
            "It requires O(n log n) time complexity",
            "It uses divide-and-conquer strategy"
        ]
    },
    {
        "q": "What is the output of the following Merge Sort implementation for merging two sorted arrays [2, 4, 6] and [1, 3, 5]?",
        "c": "def merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\nprint(merge([2, 4, 6], [1, 3, 5]))",
        "o": [
            "[1, 2, 3, 4, 5, 6]",
            "[2, 1, 4, 3, 6, 5]",
            "[1, 3, 5, 2, 4, 6]",
            "[2, 4, 6, 1, 3, 5]"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of strings case-insensitively?",
        "c": "words = ['Apple', 'banana', 'Cherry']\nprint(sorted(words, key=str.lower))",
        "o": [
            "['Apple', 'banana', 'Cherry']",
            "['banana', 'Apple', 'Cherry']",
            "['Cherry', 'Apple', 'banana']",
            "['Apple', 'Cherry', 'banana']"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort by absolute values?",
        "c": "lst = [-3, 1, -2, 4, -1]\nlst.sort(key=abs)\nprint(lst)",
        "o": [
            "[1, -1, -2, -3, 4]",
            "[-3, -2, -1, 1, 4]",
            "[4, -3, -2, 1, -1]",
            "None"
        ]
    },
    {
        "q": "Which of the following is a requirement for Binary Search to function correctly?",
        "c": null,
        "o": [
            "The input must be sorted in ascending or descending order",
            "The input must contain only positive numbers",
            "The input must have duplicate elements",
            "The input must be of odd length"
        ]
    },
    {
        "q": "What is the space complexity of Binary Search?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n^2)"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to count occurrences of a target in a sorted array?",
        "c": "def count_occurrences(arr, target):\n    def binary_search_first(arr, target):\n        left, right = 0, len(arr) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                result = mid\n                right = mid - 1\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    def binary_search_last(arr, target):\n        left, right = 0, len(arr) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                result = mid\n                left = mid + 1\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    first = binary_search_first(arr, target)\n    last = binary_search_last(arr, target)\n    return last - first + 1 if first != -1 else 0",
        "o": [
            "Returns the number of occurrences of target",
            "Returns the index of the first occurrence",
            "Returns the index of the last occurrence",
            "Returns -1 if target is found"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when memory usage is a primary concern?",
        "c": null,
        "o": [
            "Selection Sort",
            "Merge Sort",
            "Quick Sort",
            "Bubble Sort"
        ]
    },
    {
        "q": "What is the output of the following Bubble Sort implementation after three passes for the array [6, 4, 2, 8, 1]?",
        "c": "def bubble_sort_three_passes(arr):\n    n = len(arr)\n    for i in range(3):\n        for j in range(n-1-i):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\narr = [6, 4, 2, 8, 1]\nprint(bubble_sort_three_passes(arr))",
        "o": [
            "[2, 4, 6, 1, 8]",
            "[6, 4, 2, 8, 1]",
            "[4, 2, 6, 1, 8]",
            "[2, 4, 1, 6, 8]"
        ]
    },
    {
        "q": "What is the best-case time complexity of Selection Sort?",
        "c": null,
        "o": [
            "O(n^2)",
            "O(n log n)",
            "O(n)",
            "O(log n)"
        ]
    },
    {
        "q": "Which of the following is true about Insertion Sort?",
        "c": null,
        "o": [
            "It is a stable sorting algorithm",
            "It requires O(n) extra space",
            "It has O(n log n) worst-case time complexity",
            "It uses a divide-and-conquer approach"
        ]
    },
    {
        "q": "What is the output of the following Quick Sort partition function when the pivot is the first element for the array [5, 3, 7, 2, 9, 1]?",
        "c": "def partition(arr, low, high):\n    pivot = arr[low]\n    i = low + 1\n    j = high\n    while True:\n        while i <= j and arr[i] <= pivot:\n            i += 1\n        while i <= j and arr[j] > pivot:\n            j -= 1\n        if i <= j:\n            arr[i], arr[j] = arr[j], arr[i]\n        else:\n            break\n    arr[low], arr[j] = arr[j], arr[low]\n    return j\narr = [5, 3, 7, 2, 9, 1]\nresult = partition(arr, 0, len(arr)-1)\nprint(arr, result)",
        "o": [
            "[1, 3, 2, 5, 9, 7], 3",
            "[5, 3, 7, 2, 9, 1], 0",
            "[3, 1, 2, 5, 7, 9], 2",
            "[1, 3, 5, 2, 9, 7], 4"
        ]
    },
    {
        "q": "What is the result of using sorted() to sort a list of tuples by the first element in descending order?",
        "c": "pairs = [(3, 'a'), (1, 'b'), (2, 'c')]\nprint(sorted(pairs, key=lambda x: x[0], reverse=True))",
        "o": [
            "[(3, 'a'), (2, 'c'), (1, 'b')]",
            "[(1, 'b'), (2, 'c'), (3, 'a')]",
            "[(2, 'c'), (1, 'b'), (3, 'a')]",
            "[(3, 'a'), (1, 'b'), (2, 'c')]"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort by string length in descending order?",
        "c": "lst = ['cat', 'elephant', 'dog']\nlst.sort(key=len, reverse=True)\nprint(lst)",
        "o": [
            "['elephant', 'cat', 'dog']",
            "['cat', 'dog', 'elephant']",
            "['dog', 'cat', 'elephant']",
            "None"
        ]
    },
    {
        "q": "Which of the following is a drawback of Binary Search?",
        "c": null,
        "o": [
            "It requires the input to be sorted",
            "It has O(n) average-case time complexity",
            "It cannot handle large datasets",
            "It only works with floating-point numbers"
        ]
    },
    {
        "q": "What is the key difference between Linear Search and Binary Search in terms of input requirements?",
        "c": null,
        "o": [
            "Binary Search requires a sorted array, Linear Search does not",
            "Linear Search requires a sorted array, Binary Search does not",
            "Both require a sorted array",
            "Neither requires a sorted array"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the index of the first element greater than the target?",
        "c": "def binary_search_next_greater(arr, target):\n    left, right = 0, len(arr) - 1\n    result = len(arr)\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] > target:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result",
        "o": [
            "Returns the index of the first element greater than target or len(arr) if none exists",
            "Returns the index of the first element less than target",
            "Returns the index of the target or -1 if not found",
            "Always returns the middle index"
        ]
    },
    {
        "q": "Which sorting algorithm is best suited for linked lists due to its sequential access pattern?",
        "c": null,
        "o": [
            "Insertion Sort",
            "Quick Sort",
            "Selection Sort",
            "Bubble Sort"
        ]
    },
    {
        "q": "What is the output of the following Selection Sort implementation after two passes for the array [7, 3, 9, 1, 5]?",
        "c": "def selection_sort_two_passes(arr):\n    for i in range(2):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\narr = [7, 3, 9, 1, 5]\nprint(selection_sort_two_passes(arr))",
        "o": [
            "[1, 3, 9, 7, 5]",
            "[7, 3, 9, 1, 5]",
            "[3, 7, 9, 1, 5]",
            "[1, 7, 9, 3, 5]"
        ]
    },
    {
        "q": "What is the worst-case time complexity of Merge Sort?",
        "c": null,
        "o": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ]
    },
    {
        "q": "Which of the following is a characteristic of Quick Sort?",
        "c": null,
        "o": [
            "It performs in-place partitioning",
            "It is always stable",
            "It requires O(n) extra space for recursion",
            "It is not a divide-and-conquer algorithm"
        ]
    },
    {
        "q": "What is the output of the following Bubble Sort implementation for the first pass with an optimization to check if any swaps occurred for the array [4, 2, 6, 1, 3]?",
        "c": "def bubble_sort_one_pass(arr):\n    n = len(arr)\n    swapped = False\n    for j in range(n-1):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\n            swapped = True\n    return arr, swapped\narr = [4, 2, 6, 1, 3]\nprint(bubble_sort_one_pass(arr))",
        "o": [
            "([2, 4, 1, 3, 6], True)",
            "([4, 2, 6, 1, 3], False)",
            "([2, 4, 6, 1, 3], True)",
            "([4, 2, 1, 3, 6], True)"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of dictionaries by multiple keys (e.g., first by age, then by name)?",
        "c": "data = [{'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 25}, {'name': 'Charlie', 'age': 30}]\nprint(sorted(data, key=lambda x: (x['age'], x['name'])))",
        "o": [
            "[{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 25}, {'name': 'Charlie', 'age': 30}]",
            "[{'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 25}, {'name': 'Charlie', 'age': 30}]",
            "[{'name': 'Charlie', 'age': 30}, {'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 25}]",
            "[{'name': 'Alice', 'age': 25}, {'name': 'Charlie', 'age': 30}, {'name': 'Bob', 'age': 25}]"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort by the second character of strings?",
        "c": "lst = ['cat', 'dog', 'bat']\nlst.sort(key=lambda x: x[1])\nprint(lst)",
        "o": [
            "['cat', 'bat', 'dog']",
            "['dog', 'cat', 'bat']",
            "['bat', 'cat', 'dog']",
            "None"
        ]
    },
    {
        "q": "Which of the following is true about Binary Search's applicability?",
        "c": null,
        "o": [
            "It can be used on sorted arrays with duplicates",
            "It only works on arrays without duplicates",
            "It requires O(n) space complexity",
            "It is efficient for unsorted arrays"
        ]
    },
    {
        "q": "What is the main benefit of using Binary Search over Linear Search for large sorted datasets?",
        "c": null,
        "o": [
            "Binary Search reduces time complexity to O(log n)",
            "Binary Search uses less memory",
            "Binary Search works on unsorted data",
            "Binary Search is stable"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the index of the smallest element greater than or equal to the target?",
        "c": "def binary_search_ceiling(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] >= target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return left if left < len(arr) else -1",
        "o": [
            "Returns the index of the smallest element >= target or -1 if none exists",
            "Returns the index of the largest element <= target",
            "Returns the index of the target or -1 if not found",
            "Always returns the last index"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient for arrays with many duplicate elements?",
        "c": null,
        "o": [
            "Merge Sort",
            "Quick Sort",
            "Bubble Sort",
            "Selection Sort"
        ]
    },
    {
        "q": "What is the output of the following Insertion Sort implementation after three passes for the array [8, 3, 5, 1, 4]?",
        "c": "def insertion_sort_three_passes(arr):\n    for i in range(1, 4):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\narr = [8, 3, 5, 1, 4]\nprint(insertion_sort_three_passes(arr))",
        "o": [
            "[3, 5, 1, 8, 4]",
            "[8, 3, 5, 1, 4]",
            "[3, 5, 8, 1, 4]",
            "[1, 3, 5, 8, 4]"
        ]
    },
    {
        "q": "What is the average-case time complexity of Quick Sort?",
        "c": null,
        "o": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ]
    },
    {
        "q": "Which of the following is a feature of Merge Sort?",
        "c": null,
        "o": [
            "It guarantees O(n log n) time complexity for all cases",
            "It is an in-place sorting algorithm",
            "It is unstable",
            "It requires O(1) space complexity"
        ]
    },
    {
        "q": "What is the output of the following Quick Sort partition function when the pivot is the last element for the array [6, 2, 8, 4, 1, 9]?",
        "c": "def partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\narr = [6, 2, 8, 4, 1, 9]\nresult = partition(arr, 0, len(arr)-1)\nprint(arr, result)",
        "o": [
            "[6, 2, 8, 4, 1, 9], 5",
            "[2, 4, 1, 6, 8, 9], 4",
            "[1, 2, 4, 6, 8, 9], 3",
            "[6, 2, 1, 4, 8, 9], 2"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of strings by their last character?",
        "c": "words = ['apple', 'banana', 'cherry']\nprint(sorted(words, key=lambda x: x[-1]))",
        "o": [
            "['banana', 'apple', 'cherry']",
            "['cherry', 'apple', 'banana']",
            "['apple', 'banana', 'cherry']",
            "['banana', 'cherry', 'apple']"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort numbers by their remainder when divided by 3?",
        "c": "lst = [4, 7, 2, 5, 1]\nlst.sort(key=lambda x: x % 3)\nprint(lst)",
        "o": [
            "[1, 4, 7, 2, 5]",
            "[2, 5, 1, 4, 7]",
            "[7, 4, 1, 2, 5]",
            "None"
        ]
    },
    {
        "q": "Which of the following is a limitation of Binary Search when applied to large datasets?",
        "c": null,
        "o": [
            "It requires the dataset to be sorted beforehand",
            "It has O(n) time complexity",
            "It cannot handle duplicate elements",
            "It only works with integer arrays"
        ]
    },
    {
        "q": "What is the key factor that makes Binary Search more efficient than Linear Search for large datasets?",
        "c": null,
        "o": [
            "Binary Search eliminates half the search space in each iteration",
            "Binary Search uses less memory",
            "Binary Search works on unsorted arrays",
            "Binary Search is stable"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the index of the largest element less than the target?",
        "c": "def binary_search_floor(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
        "o": [
            "Returns the index of the largest element < target or -1 if none exists",
            "Returns the index of the smallest element >= target",
            "Returns the index of the target or -1 if not found",
            "Always returns the first index"
        ]
    },
    {
        "q": "Which sorting algorithm is preferred when stability is a requirement?",
        "c": null,
        "o": [
            "Merge Sort",
            "Quick Sort",
            "Selection Sort",
            "Bubble Sort"
        ]
    },
    {
        "q": "What is the output of the following Bubble Sort implementation after two passes with an optimization to stop if no swaps occur for the array [5, 3, 1, 4, 2]?",
        "c": "def bubble_sort_two_passes(arr):\n    n = len(arr)\n    for i in range(2):\n        swapped = False\n        for j in range(n-1-i):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr\narr = [5, 3, 1, 4, 2]\nprint(bubble_sort_two_passes(arr))",
        "o": [
            "[3, 1, 4, 2, 5]",
            "[5, 3, 1, 4, 2]",
            "[1, 3, 4, 2, 5]",
            "[3, 1, 2, 4, 5]"
        ]
    },
    {
        "q": "What is the space complexity of Insertion Sort?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n^2)"
        ]
    },
    {
        "q": "Which of the following is a disadvantage of Selection Sort?",
        "c": null,
        "o": [
            "It is not stable",
            "It requires O(n log n) time complexity",
            "It uses O(n) extra space",
            "It is a divide-and-conquer algorithm"
        ]
    },
    {
        "q": "What is the output of the following Quick Sort partition function when the pivot is the middle element for the array [9, 3, 7, 1, 5, 8, 2]?",
        "c": "def partition(arr, low, high):\n    mid = (low + high) // 2\n    pivot = arr[mid]\n    arr[mid], arr[high] = arr[high], arr[mid]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\narr = [9, 3, 7, 1, 5, 8, 2]\nresult = partition(arr, 0, len(arr)-1)\nprint(arr, result)",
        "o": [
            "[1, 3, 2, 5, 9, 8, 7], 3",
            "[9, 3, 7, 1, 5, 8, 2], 4",
            "[1, 3, 2, 5, 7, 8, 9], 2",
            "[3, 1, 7, 2, 5, 8, 9], 5"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of tuples by the sum of their elements?",
        "c": "pairs = [(1, 2), (3, 4), (2, 1)]\nprint(sorted(pairs, key=lambda x: x[0] + x[1]))",
        "o": [
            "[(1, 2), (2, 1), (3, 4)]",
            "[(3, 4), (2, 1), (1, 2)]",
            "[(2, 1), (1, 2), (3, 4)]",
            "[(3, 4), (1, 2), (2, 1)]"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort numbers by their distance from 5?",
        "c": "lst = [2, 7, 4, 6, 3]\nlst.sort(key=lambda x: abs(x - 5))\nprint(lst)",
        "o": [
            "[5, 4, 6, 3, 2, 7]",
            "[2, 3, 4, 6, 7]",
            "[7, 6, 4, 3, 2]",
            "[4, 5, 6, 3, 2, 7]"
        ]
    },
    {
        "q": "Which of the following is true about Binary Search's efficiency?",
        "c": null,
        "o": [
            "It is most efficient for sorted arrays",
            "It is efficient for unsorted arrays",
            "It requires O(n) space complexity",
            "It cannot handle large datasets"
        ]
    },
    {
        "q": "What is the worst-case scenario for Linear Search?",
        "c": null,
        "o": [
            "Target is at the end of the array or not present",
            "Target is at the start of the array",
            "Array is sorted",
            "Array contains duplicates"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the index where a target should be inserted to maintain sorted order?",
        "c": "def binary_search_insert(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left",
        "o": [
            "Returns the index where target should be inserted",
            "Returns the index of the target or -1 if not found",
            "Returns the index of the last element",
            "Returns the middle index"
        ]
    },
    {
        "q": "Which sorting algorithm has the least number of swaps in the worst case?",
        "c": null,
        "o": [
            "Selection Sort",
            "Bubble Sort",
            "Insertion Sort",
            "Quick Sort"
        ]
    },
    {
        "q": "What is the output of the following Selection Sort implementation after three passes for the array [10, 6, 8, 4, 2]?",
        "c": "def selection_sort_three_passes(arr):\n    for i in range(3):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\narr = [10, 6, 8, 4, 2]\nprint(selection_sort_three_passes(arr))",
        "o": [
            "[2, 4, 6, 10, 8]",
            "[10, 6, 8, 4, 2]",
            "[4, 6, 8, 10, 2]",
            "[2, 6, 8, 4, 10]"
        ]
    },
    {
        "q": "What is the space complexity of Quick Sort in the worst case?",
        "c": null,
        "o": [
            "O(n)",
            "O(log n)",
            "O(1)",
            "O(n^2)"
        ]
    },
    {
        "q": "Which of the following is a property of Bubble Sort?",
        "c": null,
        "o": [
            "It can terminate early if the array is sorted",
            "It is a divide-and-conquer algorithm",
            "It requires O(n log n) time complexity",
            "It is unstable"
        ]
    },
    {
        "q": "What is the output of the following Merge Sort implementation for splitting an array [5, 2, 9, 1, 7, 6, 3] into two halves?",
        "c": "def merge_sort_split(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    return left, right\narr = [5, 2, 9, 1, 7, 6, 3]\nprint(merge_sort_split(arr))",
        "o": [
            "([5, 2, 9, 1], [7, 6, 3])",
            "([5, 2, 9], [1, 7, 6, 3])",
            "([5, 2, 9, 1, 7], [6, 3])",
            "([5, 2, 9, 1, 7, 6], [3])"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of strings by the number of vowels?",
        "c": "def count_vowels(s):\n    return sum(1 for c in s.lower() if c in 'aeiou')\nwords = ['cat', 'elephant', 'dog']\nprint(sorted(words, key=count_vowels))",
        "o": [
            "['cat', 'dog', 'elephant']",
            "['elephant', 'cat', 'dog']",
            "['dog', 'cat', 'elephant']",
            "['cat', 'elephant', 'dog']"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort numbers by their square values?",
        "c": "lst = [-3, 2, -1, 4]\nlst.sort(key=lambda x: x*x)\nprint(lst)",
        "o": [
            "[-1, 2, -3, 4]",
            "[4, -3, 2, -1]",
            "[-3, -1, 2, 4]",
            "None"
        ]
    },
    {
        "q": "Which of the following is a requirement for Binary Search to handle duplicates correctly?",
        "c": null,
        "o": [
            "The array must be sorted",
            "The array must have unique elements",
            "The array must be unsorted",
            "The array must have even length"
        ]
    },
    {
        "q": "What is the primary reason Linear Search is used despite its inefficiency for large datasets?",
        "c": null,
        "o": [
            "It works on unsorted arrays",
            "It has O(log n) time complexity",
            "It requires less memory than Binary Search",
            "It is stable"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the number of elements less than a target in a sorted array?",
        "c": "def count_less_than(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result + 1",
        "o": [
            "Returns the count of elements less than target",
            "Returns the count of elements greater than target",
            "Returns the index of the target or -1 if not found",
            "Returns the total number of elements"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient for arrays with few unique elements?",
        "c": null,
        "o": [
            "Merge Sort",
            "Quick Sort",
            "Selection Sort",
            "Bubble Sort"
        ]
    },
    {
        "q": "What is the output of the following Insertion Sort implementation after two passes for the array [9, 5, 7, 3, 1]?",
        "c": "def insertion_sort_two_passes(arr):\n    for i in range(1, 3):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\narr = [9, 5, 7, 3, 1]\nprint(insertion_sort_two_passes(arr))",
        "o": [
            "[5, 7, 9, 3, 1]",
            "[9, 5, 7, 3, 1]",
            "[5, 9, 7, 3, 1]",
            "[7, 5, 9, 3, 1]"
        ]
    },
    {
        "q": "What is the worst-case time complexity of Quick Sort when the pivot is always the smallest or largest element?",
        "c": null,
        "o": [
            "O(n^2)",
            "O(n log n)",
            "O(n)",
            "O(log n)"
        ]
    },
    {
        "q": "Which of the following is a benefit of Bubble Sort?",
        "c": null,
        "o": [
            "It is simple to implement",
            "It has O(n log n) time complexity",
            "It requires O(n) extra space",
            "It is a divide-and-conquer algorithm"
        ]
    },
    {
        "q": "What is the output of the following Quick Sort partition function when the pivot is the first element for the array [8, 4, 6, 2, 7, 1, 3]?",
        "c": "def partition(arr, low, high):\n    pivot = arr[low]\n    i = low + 1\n    j = high\n    while True:\n        while i <= j and arr[i] <= pivot:\n            i += 1\n        while i <= j and arr[j] > pivot:\n            j -= 1\n        if i <= j:\n            arr[i], arr[j] = arr[j], arr[i]\n        else:\n            break\n    arr[low], arr[j] = arr[j], arr[low]\n    return j\narr = [8, 4, 6, 2, 7, 1, 3]\nresult = partition(arr, 0, len(arr)-1)\nprint(arr, result)",
        "o": [
            "[3, 4, 6, 2, 7, 1, 8], 6",
            "[8, 4, 6, 2, 7, 1, 3], 0",
            "[4, 6, 2, 7, 1, 3, 8], 5",
            "[1, 4, 6, 2, 7, 3, 8], 4"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of strings by their first vowel's position?",
        "c": "def first_vowel_pos(s):\n    for i, c in enumerate(s.lower()):\n        if c in 'aeiou':\n            return i\n    return len(s)\nwords = ['sky', 'sea', 'tree']\nprint(sorted(words, key=first_vowel_pos))",
        "o": [
            "['sea', 'tree', 'sky']",
            "['sky', 'sea', 'tree']",
            "['tree', 'sea', 'sky']",
            "['sea', 'sky', 'tree']"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort numbers by their distance from 10?",
        "c": "lst = [8, 12, 9, 11, 7]\nlst.sort(key=lambda x: abs(x - 10))\nprint(lst)",
        "o": [
            "[10, 9, 11, 8, 12, 7]",
            "[7, 8, 9, 11, 12]",
            "[12, 11, 9, 8, 7]",
            "[8, 9, 11, 12, 7]"
        ]
    },
    {
        "q": "Which of the following is true about Binary Search's implementation?",
        "c": null,
        "o": [
            "It can be implemented iteratively or recursively",
            "It requires O(n) space complexity",
            "It is only implemented recursively",
            "It cannot handle sorted arrays"
        ]
    },
    {
        "q": "What is the main advantage of Linear Search for small datasets?",
        "c": null,
        "o": [
            "It is simple and requires no preprocessing",
            "It has O(log n) time complexity",
            "It requires a sorted array",
            "It is more efficient than Binary Search"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the index of the first element strictly greater than the target?",
        "c": "def binary_search_next_strictly_greater(arr, target):\n    left, right = 0, len(arr) - 1\n    result = len(arr)\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] > target:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result",
        "o": [
            "Returns the index of the first element strictly greater than target or len(arr) if none exists",
            "Returns the index of the first element less than or equal to target",
            "Returns the index of the target or -1 if not found",
            "Always returns the middle index"
        ]
    },
    {
        "q": "Which sorting algorithm is most suitable for arrays that are frequently updated with new elements?",
        "c": null,
        "o": [
            "Insertion Sort",
            "Quick Sort",
            "Selection Sort",
            "Merge Sort"
        ]
    },
    {
        "q": "What is the output of the following Bubble Sort implementation after one pass for the array [7, 2, 9, 4, 6]?",
        "c": "def bubble_sort_one_pass(arr):\n    n = len(arr)\n    for j in range(n-1):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\narr = [7, 2, 9, 4, 6]\nprint(bubble_sort_one_pass(arr))",
        "o": [
            "[2, 7, 4, 6, 9]",
            "[7, 2, 9, 4, 6]",
            "[7, 2, 4, 6, 9]",
            "[2, 7, 9, 4, 6]"
        ]
    },
    {
        "q": "What is the average-case space complexity of Merge Sort?",
        "c": null,
        "o": [
            "O(n)",
            "O(1)",
            "O(n log n)",
            "O(n^2)"
        ]
    },
    {
        "q": "Which of the following is a characteristic of Selection Sort?",
        "c": null,
        "o": [
            "It performs a fixed number of swaps",
            "It is a stable sorting algorithm",
            "It has O(n log n) time complexity",
            "It uses a divide-and-conquer approach"
        ]
    },
    {
        "q": "What is the output of the following Quick Sort partition function when the pivot is the last element for the array [4, 8, 2, 6, 1, 3, 5]?",
        "c": "def partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\narr = [4, 8, 2, 6, 1, 3, 5]\nresult = partition(arr, 0, len(arr)-1)\nprint(arr, result)",
        "o": [
            "[4, 2, 1, 3, 5, 8, 6], 4",
            "[4, 8, 2, 6, 1, 3, 5], 5",
            "[2, 1, 3, 4, 5, 6, 8], 3",
            "[4, 2, 1, 6, 3, 8, 5], 2"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of tuples by the second element in descending order?",
        "c": "pairs = [(1, 'c'), (2, 'a'), (3, 'b')]\nprint(sorted(pairs, key=lambda x: x[1], reverse=True))",
        "o": [
            "[(1, 'c'), (3, 'b'), (2, 'a')]",
            "[(2, 'a'), (3, 'b'), (1, 'c')]",
            "[(3, 'b'), (1, 'c'), (2, 'a')]",
            "[(2, 'a'), (1, 'c'), (3, 'b')]"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort strings by their length in ascending order?",
        "c": "lst = ['apple', 'bat', 'cherry']\nlst.sort(key=len)\nprint(lst)",
        "o": [
            "['bat', 'apple', 'cherry']",
            "['cherry', 'apple', 'bat']",
            "['apple', 'bat', 'cherry']",
            "None"
        ]
    },
    {
        "q": "Which of the following is true about Binary Search's performance on sorted arrays?",
        "c": null,
        "o": [
            "It has O(log n) time complexity in all cases",
            "It has O(n) time complexity in the worst case",
            "It requires O(n) space complexity",
            " It only works for integer arrays"
        ]
    },
    {
        "q": "What is the primary use case for Linear Search in practical applications?",
        "c": null,
        "o": [
            "When the array is small or unsorted",
            "When the array is large and sorted",
            "When memory is a constraint",
            "When stability is required"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the index of the last element less than or equal to the target?",
        "c": "def binary_search_floor(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
        "o": [
            "Returns the index of the last element <= target or -1 if none exists",
            "Returns the index of the first element >= target",
            "Returns the index of the target or -1 if not found",
            "Always returns the last index"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient for arrays that are partially sorted?",
        "c": null,
        "o": [
            "Insertion Sort",
            "Quick Sort",
            "Selection Sort",
            "Merge Sort"
        ]
    },
    {
        "q": "What is the output of the following Selection Sort implementation after one pass for the array [6, 3, 8, 2, 5]?",
        "c": "def selection_sort_one_pass(arr):\n    min_idx = 0\n    for j in range(1, len(arr)):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    arr[0], arr[min_idx] = arr[min_idx], arr[0]\n    return arr\narr = [6, 3, 8, 2, 5]\nprint(selection_sort_one_pass(arr))",
        "o": [
            "[2, 3, 8, 6, 5]",
            "[6, 3, 8, 2, 5]",
            "[3, 6, 8, 2, 5]",
            "[2, 6, 8, 3, 5]"
        ]
    },
    {
        "q": "What is the best-case space complexity of Bubble Sort?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n^2)"
        ]
    },
    {
        "q": "Which of the following is a feature of Quick Sort?",
        "c": null,
        "o": [
            "It performs well with random pivots",
            "It is always stable",
            "It requires O(n) extra space",
            "It has O(n) time complexity"
        ]
    },
    {
        "q": "What is the output of the following Merge Sort merge function for merging [1, 3, 5] and [2, 4]?",
        "c": "def merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\nprint(merge([1, 3, 5], [2, 4]))",
        "o": [
            "[1, 2, 3, 4, 5]",
            "[1, 3, 5, 2, 4]",
            "[2, 4, 1, 3, 5]",
            "[1, 2, 3, 5, 4]"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of dictionaries by a nested key?",
        "c": "data = [{'info': {'id': 3}}, {'info': {'id': 1}}, {'info': {'id': 2}}]\nprint(sorted(data, key=lambda x: x['info']['id']))",
        "o": [
            "[{'info': {'id': 1}}, {'info': {'id': 2}}, {'info': {'id': 3}}]",
            "[{'info': {'id': 3}}, {'info': {'id': 2}}, {'info': {'id': 1}}]",
            "[{'info': {'id': 2}}, {'info': {'id': 1}}, {'info': {'id': 3}}]",
            "[{'info': {'id': 1}}, {'info': {'id': 3}}, {'info': {'id': 2}}]"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort strings by the number of consonants?",
        "c": "def count_consonants(s):\n    return sum(1 for c in s.lower() if c.isalpha() and c not in 'aeiou')\nlst = ['cat', 'dog', 'bird']\nlst.sort(key=count_consonants)\nprint(lst)",
        "o": [
            "['cat', 'dog', 'bird']",
            "['dog', 'cat', 'bird']",
            "['bird', 'cat', 'dog']",
            "None"
        ]
    },
    {
        "q": "Which of the following is true about Binary Search's implementation for finding boundaries?",
        "c": null,
        "o": [
            "It can be modified to find the first or last occurrence of a target",
            "It cannot handle duplicate elements",
            "It requires O(n) space complexity",
            "It is only used for unsorted arrays"
        ]
    },
    {
        "q": "What is the key reason Linear Search is less efficient than Binary Search for sorted arrays?",
        "c": null,
        "o": [
            "Linear Search checks every element sequentially",
            "Linear Search requires a sorted array",
            "Linear Search has O(log n) time complexity",
            "Linear Search is stable"
        ]
    },
    {
        "q": "Which of the following code snippets implements Binary Search to find the index of the first element greater than or equal to the target?",
        "c": "def binary_search_ceiling(arr, target):\n    left, right = 0, len(arr) - 1\n    result = len(arr)\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] >= target:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result if result < len(arr) else -1",
        "o": [
            "Returns the index of the first element >= target or -1 if none exists",
            "Returns the index of the last element <= target",
            "Returns the index of the target or -1 if not found",
            "Always returns the first index"
        ]
    },
    {
        "q": "Which sorting algorithm is most suitable for sorting data that is too large to fit in memory?",
        "c": null,
        "o": [
            "Merge Sort",
            "Quick Sort",
            "Selection Sort",
            "Insertion Sort"
        ]
    },
    {
        "q": "What is the output of the following Bubble Sort implementation after one pass with an optimization to track swaps for the array [3, 1, 4, 2, 5]?",
        "c": "def bubble_sort_one_pass(arr):\n    n = len(arr)\n    swapped = False\n    for j in range(n-1):\n        if arr[j] > arr[j+1]:\n            arr[j], arr[j+1] = arr[j+1], arr[j]\n            swapped = True\n    return arr, swapped\narr = [3, 1, 4, 2, 5]\nprint(bubble_sort_one_pass(arr))",
        "o": [
            "([1, 3, 2, 4, 5], True)",
            "([3, 1, 4, 2, 5], False)",
            "([1, 3, 4, 2, 5], True)",
            "([3, 1, 2, 4, 5], True)"
        ]
    },
    {
        "q": "What is the worst-case space complexity of Selection Sort?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(n log n)",
            "O(n^2)"
        ]
    },
    {
        "q": "Which of the following is a characteristic of Insertion Sort?",
        "c": null,
        "o": [
            "It performs well on small or nearly sorted arrays",
            "It requires O(n log n) time complexity",
            "It is unstable",
            "It uses a divide-and-conquer approach"
        ]
    },
    {
        "q": "What is the output of the following Quick Sort partition function when the pivot is the middle element for the array [7, 2, 9, 4, 6, 1, 3]?",
        "c": "def partition(arr, low, high):\n    mid = (low + high) // 2\n    pivot = arr[mid]\n    arr[mid], arr[high] = arr[high], arr[mid]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\narr = [7, 2, 9, 4, 6, 1, 3]\nresult = partition(arr, 0, len(arr)-1)\nprint(arr, result)",
        "o": [
            "[2, 1, 3, 4, 6, 9, 7], 3",
            "[7, 2, 9, 4, 6, 1, 3], 4",
            "[2, 1, 3, 4, 7, 6, 9], 2",
            "[7, 2, 3, 4, 6, 1, 9], 5"
        ]
    },
    {
        "q": "What is the result of using sorted() with a key function to sort a list of strings by the number of unique characters?",
        "c": "def unique_chars(s):\n    return len(set(s))\nwords = ['apple', 'banana', 'cat']\nprint(sorted(words, key=unique_chars))",
        "o": [
            "['cat', 'apple', 'banana']",
            "['banana', 'apple', 'cat']",
            "['apple', 'cat', 'banana']",
            "['cat', 'banana', 'apple']"
        ]
    },
    {
        "q": "What is the effect of calling list.sort() with a key function to sort numbers by their digit sum?",
        "c": "def digit_sum(n):\n    return sum(int(d) for d in str(abs(n)))\nlst = [12, 45, 9, 18]\nlst.sort(key=digit_sum)\nprint(lst)",
        "o": [
            "[12, 9, 18, 45]",
            "[45, 18, 9, 12]",
            "[9, 12, 18, 45]",
            "None"
        ]
    },
    {
        "q": "Which of the following is true about Binary Search's applicability to rotated sorted arrays?",
        "c": null,
        "o": [
            "It can be adapted to find elements in rotated sorted arrays",
            "It cannot be used on rotated sorted arrays",
            "It requires O(n) time complexity for rotated arrays",
            "It only works for unsorted rotated arrays"
        ]
    },
    {
        "q": "Which searching algorithm requires the list to be sorted beforehand?",
        "c": null,
        "o": [
            "Binary search",
            "Linear search",
            "Jump search",
            "Interpolation search"
        ]
    },
    {
        "q": "What is the time complexity of linear search in the worst case?",
        "c": null,
        "o": [
            "O(n)",
            "O(1)",
            "O(log n)",
            "O(n²)"
        ]
    },
    {
        "q": "Which sorting algorithm works by repeatedly finding the minimum element from the unsorted part?",
        "c": null,
        "o": [
            "Selection sort",
            "Bubble sort",
            "Insertion sort",
            "Merge sort"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "\nnumbers = [5, 2, 8, 1, 6]\nnumbers.sort()\nprint(numbers)\n",
        "o": [
            "[1, 2, 5, 6, 8]",
            "[5, 2, 8, 1, 6]",
            "[8, 6, 5, 2, 1]",
            "None"
        ]
    },
    {
        "q": "Which sorting algorithm has the best average-case time complexity?",
        "c": null,
        "o": [
            "Quick sort",
            "Bubble sort",
            "Insertion sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the main difference between sorted() and list.sort() in Python?",
        "c": null,
        "o": [
            "sorted() returns a new list, list.sort() sorts in place",
            "list.sort() returns a new list, sorted() sorts in place",
            "There is no difference",
            "sorted() only works with tuples"
        ]
    },
    {
        "q": "Which algorithm uses a divide-and-conquer approach for sorting?",
        "c": null,
        "o": [
            "Merge sort",
            "Bubble sort",
            "Insertion sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the time complexity of binary search in the worst case?",
        "c": null,
        "o": [
            "O(log n)",
            "O(n)",
            "O(n log n)",
            "O(1)"
        ]
    },
    {
        "q": "Which of the following is NOT a stable sorting algorithm?",
        "c": null,
        "o": [
            "Quick sort (basic implementation)",
            "Merge sort",
            "Insertion sort",
            "Bubble sort"
        ]
    },
    {
        "q": "What does this code snippet do?",
        "c": "\ndef search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return i\n    return -1\n",
        "o": [
            "Implements linear search",
            "Implements binary search",
            "Implements bubble sort",
            "Implements selection sort"
        ]
    },
    {
        "q": "In bubble sort, after each pass:",
        "c": null,
        "o": [
            "The largest element in the unsorted part bubbles to its correct position",
            "The smallest element in the unsorted part bubbles to its correct position",
            "The array becomes completely sorted",
            "The array becomes reverse sorted"
        ]
    },
    {
        "q": "What is the main advantage of insertion sort over more advanced algorithms like quicksort or mergesort?",
        "c": null,
        "o": [
            "Efficient for small datasets",
            "Faster for large datasets",
            "Requires no additional memory",
            "Works only on sorted arrays"
        ]
    },
    {
        "q": "Which Python function would you use to sort a list in descending order?",
        "c": "\nsorted([3, 1, 4, 2], reverse=True)\n",
        "o": [
            "sorted() with reverse=True parameter",
            "sorted() with ascending=False parameter",
            "sort() with descending=True parameter",
            "reverse_sort()"
        ]
    },
    {
        "q": "What is the worst-case time complexity of quicksort?",
        "c": null,
        "o": [
            "O(n²)",
            "O(n log n)",
            "O(n)",
            "O(log n)"
        ]
    },
    {
        "q": "Which algorithm is being implemented by this code?",
        "c": "\ndef sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i-1\n        while j >= 0 and key < arr[j]:\n            arr[j+1] = arr[j]\n            j -= 1\n        arr[j+1] = key\n",
        "o": [
            "Insertion sort",
            "Selection sort",
            "Bubble sort",
            "Merge sort"
        ]
    },
    {
        "q": "Which searching algorithm has a time complexity of O(1) in the best case?",
        "c": null,
        "o": [
            "Linear search",
            "Binary search",
            "Jump search",
            "All of the above"
        ]
    },
    {
        "q": "What is the main disadvantage of binary search compared to linear search?",
        "c": null,
        "o": [
            "Requires a sorted array",
            "Slower time complexity",
            "Cannot handle duplicate values",
            "Only works with integers"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when the input is already mostly sorted?",
        "c": null,
        "o": [
            "Insertion sort",
            "Quick sort",
            "Merge sort",
            "Heap sort"
        ]
    },
    {
        "q": "What is the output of the following code?",
        "c": "\narr = [3, 1, 4, 2]\nprint(sorted(arr, key=lambda x: -x))\n",
        "o": [
            "[4, 3, 2, 1]",
            "[1, 2, 3, 4]",
            "[3, 1, 4, 2]",
            "[2, 4, 1, 3]"
        ]
    },
    {
        "q": "In the context of sorting algorithms, what does 'stable' mean?",
        "c": null,
        "o": [
            "Maintains relative order of equal elements",
            "Never changes the original array",
            "Always sorts in ascending order",
            "Has consistent time complexity"
        ]
    },
    {
        "q": "Which algorithm uses a pivot element to partition the array?",
        "c": null,
        "o": [
            "Quick sort",
            "Merge sort",
            "Bubble sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the space complexity of merge sort?",
        "c": null,
        "o": [
            "O(n)",
            "O(1)",
            "O(log n)",
            "O(n²)"
        ]
    },
    {
        "q": "Which Python method modifies the list in place and returns None?",
        "c": null,
        "o": [
            "list.sort()",
            "sorted()",
            "list.order()",
            "list.arrange()"
        ]
    },
    {
        "q": "What is the best-case time complexity of bubble sort?",
        "c": null,
        "o": [
            "O(n)",
            "O(n²)",
            "O(n log n)",
            "O(1)"
        ]
    },
    {
        "q": "Which searching algorithm would be most efficient for searching in a very large, uniformly distributed dataset?",
        "c": null,
        "o": [
            "Interpolation search",
            "Binary search",
            "Linear search",
            "Jump search"
        ]
    },
    {
        "q": "What does this code implement?",
        "c": "\ndef func(arr, low, high, x):\n    if high >= low:\n        mid = (high + low) // 2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid] > x:\n            return func(arr, low, mid - 1, x)\n        else:\n            return func(arr, mid + 1, high, x)\n    else:\n        return -1\n",
        "o": [
            "Recursive binary search",
            "Iterative binary search",
            "Quick sort partition",
            "Merge sort merge step"
        ]
    },
    {
        "q": "Which sorting algorithm is NOT comparison-based?",
        "c": null,
        "o": [
            "Counting sort",
            "Merge sort",
            "Quick sort",
            "Heap sort"
        ]
    },
    {
        "q": "What is the advantage of using Python's built-in sorted() function over implementing your own sort?",
        "c": null,
        "o": [
            "It's implemented in C and highly optimized",
            "It only works with numeric data",
            "It has better worst-case time complexity",
            "It doesn't require extra memory"
        ]
    },
    {
        "q": "Which algorithm would be most suitable for sorting a linked list?",
        "c": null,
        "o": [
            "Merge sort",
            "Quick sort",
            "Bubble sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the main characteristic of an in-place sorting algorithm?",
        "c": null,
        "o": [
            "Uses constant extra space",
            "Is always stable",
            "Has O(n log n) time complexity",
            "Cannot be implemented recursively"
        ]
    },
    {
        "q": "Which of these is NOT a valid way to sort a list of tuples by their second element?",
        "c": null,
        "o": [
            "sorted(tuples, key=1)",
            "sorted(tuples, key=lambda x: x[1])",
            "tuples.sort(key=lambda x: x[1])",
            "sorted(tuples, key=operator.itemgetter(1))"
        ]
    },
    {
        "q": "In the worst case, how many comparisons does linear search make for an array of size n?",
        "c": null,
        "o": [
            "n",
            "n/2",
            "log n",
            "n²"
        ]
    },
    {
        "q": "Which sorting algorithm is particularly efficient when dealing with small datasets?",
        "c": null,
        "o": [
            "Insertion sort",
            "Merge sort",
            "Quick sort",
            "Heap sort"
        ]
    },
    {
        "q": "What is the time complexity of the merge step in merge sort?",
        "c": null,
        "o": [
            "O(n)",
            "O(1)",
            "O(log n)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of these statements about Python's sorted() function is FALSE?",
        "c": null,
        "o": [
            "It modifies the original list",
            "It returns a new list",
            "It accepts a key function",
            "It can sort different data types"
        ]
    },
    {
        "q": "What is the main advantage of exponential search over binary search?",
        "c": null,
        "o": [
            "Works better with unbounded/infinite arrays",
            "Has better worst-case time complexity",
            "Doesn't require sorted input",
            "Uses less memory"
        ]
    },
    {
        "q": "Which of these sorting algorithms is both stable and in-place?",
        "c": null,
        "o": [
            "Insertion sort",
            "Merge sort",
            "Heap sort",
            "Quick sort"
        ]
    },
    {
        "q": "What will be the output of this code?",
        "c": "\narr = ['banana', 'apple', 'cherry']\nprint(sorted(arr, key=lambda x: len(x)))\n",
        "o": [
            "['apple', 'banana', 'cherry']",
            "['banana', 'apple', 'cherry']",
            "['cherry', 'apple', 'banana']",
            "Error"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for searching in a rotated sorted array?",
        "c": null,
        "o": [
            "Modified binary search",
            "Linear search",
            "Jump search",
            "Fibonacci search"
        ]
    },
    {
        "q": "What is the key difference between bubble sort and selection sort?",
        "c": null,
        "o": [
            "Bubble sort swaps adjacent elements, selection sort selects smallest",
            "Selection sort is stable, bubble sort isn't",
            "Bubble sort has better time complexity",
            "Selection sort works on linked lists"
        ]
    },
    {
        "q": "Which of these is NOT a valid optimization for quicksort?",
        "c": null,
        "o": [
            "Always choosing the first element as pivot",
            "Median-of-three pivot selection",
            "Insertion sort for small subarrays",
            "Tail recursion elimination"
        ]
    },
    {
        "q": "What does this implementation represent?",
        "c": "\ndef search(arr, x):\n    n = len(arr)\n    step = int(n**0.5)\n    prev = 0\n    while arr[min(step, n)-1] < x:\n        prev = step\n        step += int(n**0.5)\n        if prev >= n:\n            return -1\n    for i in range(prev, min(step, n)):\n        if arr[i] == x:\n            return i\n    return -1\n",
        "o": [
            "Jump search",
            "Binary search",
            "Exponential search",
            "Interpolation search"
        ]
    },
    {
        "q": "When would you prefer timsort over quicksort?",
        "c": null,
        "o": [
            "When stability is required",
            "When worst-case O(n²) is unacceptable",
            "When memory is extremely limited",
            "Both A and B"
        ]
    },
    {
        "q": "What is the time complexity of the Dutch National Flag problem solution?",
        "c": null,
        "o": [
            "O(n)",
            "O(n log n)",
            "O(n²)",
            "O(1)"
        ]
    },
    {
        "q": "Which of these statements about Python's sorted() is TRUE?",
        "c": null,
        "o": [
            "Uses timsort algorithm internally",
            "Guaranteed to be stable only for numeric types",
            "Has O(1) space complexity",
            "Cannot sort dictionaries"
        ]
    },
    {
        "q": "What is the main advantage of shell sort over insertion sort?",
        "c": null,
        "o": [
            "Better average-case time complexity",
            "Stable sorting",
            "Easier to implement",
            "No advantage"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for finding the kth smallest element?",
        "c": null,
        "o": [
            "Quickselect",
            "Quicksort then index",
            "Heapsort",
            "Mergesort"
        ]
    },
    {
        "q": "What is the space complexity of the standard recursive quicksort implementation?",
        "c": null,
        "o": [
            "O(log n)",
            "O(n)",
            "O(1)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of these is a valid way to sort a list of objects by multiple attributes?",
        "c": "\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\npeople = [Person('Alice', 32), Person('Bob', 25), Person('Alice', 25)]\n",
        "o": [
            "sorted(people, key=lambda x: (x.name, x.age))",
            "people.sort(key='name', then='age')",
            "sorted(people, by=['name', 'age'])",
            "sorted(people, keys=('name', 'age'))"
        ]
    },
    {
        "q": "What makes introsort superior to basic quicksort?",
        "c": null,
        "o": [
            "Avoids O(n²) worst-case while maintaining average performance",
            "Is always stable",
            "Uses less memory",
            "Easier to implement"
        ]
    },
    {
        "q": "Which searching algorithm is best suited for searching in a sorted, uniformly distributed array?",
        "c": null,
        "o": [
            "Interpolation search",
            "Binary search",
            "Linear search",
            "Exponential search"
        ]
    },
    {
        "q": "What is the main characteristic of a comparison-based sorting algorithm?",
        "c": null,
        "o": [
            "Only uses comparisons between elements",
            "Always runs in O(n log n) time",
            "Cannot be implemented in-place",
            "Requires extra O(n) space"
        ]
    },
    {
        "q": "Which of these sorting algorithms is NOT adaptive?",
        "c": null,
        "o": [
            "Selection sort",
            "Insertion sort",
            "Bubble sort",
            "Shell sort"
        ]
    },
    {
        "q": "What is the key advantage of radix sort over comparison-based sorts?",
        "c": null,
        "o": [
            "Can achieve O(n) time complexity for fixed-length keys",
            "Is always stable",
            "Works well with any data type",
            "Uses minimal extra space"
        ]
    },
    {
        "q": "Which Python function would you use to sort a list while keeping track of the original indices?",
        "c": null,
        "o": [
            "sorted(enumerate(arr), key=lambda x: x[1])",
            "arr.sort(with_indices=True)",
            "sorted(arr, track_indices=True)",
            "enumerate(sorted(arr))"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding the closest elements to a target value in a sorted array?",
        "c": null,
        "o": [
            "Binary search with post-processing",
            "Linear search",
            "Jump search",
            "Fibonacci search"
        ]
    },
    {
        "q": "What is the key characteristic of the counting sort algorithm?",
        "c": null,
        "o": [
            "Non-comparison based, works with integer keys",
            "Comparison-based, works with any data type",
            "In-place sorting with O(1) space complexity",
            "Divide-and-conquer approach"
        ]
    },
    {
        "q": "What will be the output of this code snippet?",
        "c": "\ndata = [(1, 'a'), (3, 'b'), (2, 'c')]\nprint(sorted(data, key=lambda x: x[0], reverse=True))\n",
        "o": [
            "[(3, 'b'), (2, 'c'), (1, 'a')]",
            "[(1, 'a'), (2, 'c'), (3, 'b')]",
            "[('a', 1), ('b', 3), ('c', 2)]",
            "Error"
        ]
    },
    {
        "q": "Which sorting algorithm is particularly efficient when the range of input data (k) is not significantly greater than the number of elements (n)?",
        "c": null,
        "o": [
            "Counting sort",
            "Merge sort",
            "Quick sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the main advantage of ternary search over binary search?",
        "c": null,
        "o": [
            "Potentially fewer comparisons for some datasets",
            "Works on unsorted arrays",
            "Has better worst-case time complexity",
            "Requires less memory"
        ]
    },
    {
        "q": "Which of these is NOT a valid way to implement a stable sort in Python?",
        "c": null,
        "o": [
            "Using list.sort() with random pivot selection",
            "Using sorted() with tuple keys",
            "Using the 'functools.cmp_to_key' function",
            "Using a custom class with __lt__ method"
        ]
    },
    {
        "q": "What does this implementation represent?",
        "c": "\ndef sort(arr):\n    max_num = max(arr)\n    count = [0] * (max_num + 1)\n    output = [0] * len(arr)\n    \n    for num in arr:\n        count[num] += 1\n    \n    for i in range(1, len(count)):\n        count[i] += count[i-1]\n    \n    for num in reversed(arr):\n        output[count[num]-1] = num\n        count[num] -= 1\n    \n    return output\n",
        "o": [
            "Counting sort",
            "Radix sort",
            "Bucket sort",
            "Merge sort"
        ]
    },
    {
        "q": "When would you prefer bucket sort over comparison-based sorting algorithms?",
        "c": null,
        "o": [
            "When input is uniformly distributed over a range",
            "When stability is required",
            "When memory usage must be minimized",
            "When worst-case performance is critical"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find duplicates in a sorted array?",
        "c": null,
        "o": [
            "O(n)",
            "O(log n)",
            "O(n log n)",
            "O(n²)"
        ]
    },
    {
        "q": "Which of these statements about Python's sorted() function is FALSE?",
        "c": null,
        "o": [
            "It guarantees O(n) space complexity for all inputs",
            "It uses a stable sorting algorithm",
            "It can accept any iterable as input",
            "It allows custom sorting via key functions"
        ]
    },
    {
        "q": "What is the main advantage of using the 'key' parameter in Python's sorted() over the 'cmp' parameter?",
        "c": null,
        "o": [
            "Only transforms each element once (O(n)) rather than comparing multiple times (O(n log n))",
            "Works with non-comparable elements",
            "Provides better worst-case performance",
            "Allows for more complex comparison logic"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for sorting a large dataset that doesn't fit in memory?",
        "c": null,
        "o": [
            "External merge sort",
            "In-memory quick sort",
            "Bubble sort",
            "Insertion sort"
        ]
    },
    {
        "q": "What is the main difference between the lower_bound() and upper_bound() functions in binary search?",
        "c": null,
        "o": [
            "lower_bound finds first element not less than value, upper_bound finds first element greater",
            "lower_bound works on unsorted arrays",
            "upper_bound has better time complexity",
            "lower_bound is stable, upper_bound isn't"
        ]
    },
    {
        "q": "Which of these sorting algorithms is both comparison-based and has O(n) best-case time complexity?",
        "c": null,
        "o": [
            "Bubble sort",
            "Merge sort",
            "Heap sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the key advantage of using the 'bisect' module in Python for searching?",
        "c": null,
        "o": [
            "Provides efficient binary search operations on sorted lists",
            "Works faster than linear search on unsorted lists",
            "Automatically sorts any input list",
            "Supports fuzzy matching"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in a sorted, rotated array?",
        "c": null,
        "o": [
            "Modified binary search that finds the pivot point",
            "Linear search from both ends",
            "Standard binary search",
            "Interpolation search"
        ]
    },
    {
        "q": "What is the space complexity of the most efficient implementation of heap sort?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of these is a valid way to sort a dictionary by values in Python?",
        "c": null,
        "o": [
            "sorted(d.items(), key=lambda x: x[1])",
            "d.sort_values()",
            "sorted(d, key=lambda x: x.value)",
            "dict.sort(key=values)"
        ]
    },
    {
        "q": "What is the main advantage of interpolation search over binary search?",
        "c": null,
        "o": [
            "O(log log n) average case for uniformly distributed data",
            "Works on unsorted arrays",
            "Simpler implementation",
            "Better worst-case performance"
        ]
    },
    {
        "q": "Which sorting algorithm would be most efficient for sorting a nearly-sorted array where each element is at most k positions away from its sorted position?",
        "c": null,
        "o": [
            "Insertion sort",
            "Merge sort",
            "Quick sort with random pivot",
            "Selection sort"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in a sorted array with non-uniform access costs?",
        "c": null,
        "o": [
            "Binary search with weighted midpoints",
            "Standard binary search",
            "Linear search from the middle",
            "Fibonacci search"
        ]
    },
    {
        "q": "What is the key advantage of using a randomized quicksort over a deterministic quicksort?",
        "c": null,
        "o": [
            "Avoids worst-case O(n²) scenarios with high probability",
            "Always runs faster",
            "Uses less memory",
            "Produces stable sorts"
        ]
    },
    {
        "q": "What will be the output of this Python code?",
        "c": "\nfrom bisect import bisect_left\ndata = [1, 3, 5, 7, 9]\nprint(bisect_left(data, 6))\n",
        "o": [
            "3",
            "2",
            "6",
            "Error"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when you need to sort a stream of incoming data (online sorting)?",
        "c": null,
        "o": [
            "Insertion sort",
            "Merge sort",
            "Heap sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find the median of an unsorted array?",
        "c": null,
        "o": [
            "O(n) average case using quickselect",
            "O(n log n) using sorting",
            "O(log n) using binary search",
            "O(n²) using brute force"
        ]
    },
    {
        "q": "Which of these is NOT a valid optimization for merge sort?",
        "c": null,
        "o": [
            "Using bubble sort for small subarrays",
            "Eliminating the copy step with alternating directions",
            "Using insertion sort for small subarrays",
            "Parallelizing the merge operations"
        ]
    },
    {
        "q": "What does this Python implementation represent?",
        "c": "\ndef search(arr, target):\n    low, high = 0, len(arr)-1\n    while arr[high] != arr[low] and target >= arr[low] and target <= arr[high]:\n        pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])\n        if arr[pos] == target:\n            return pos\n        if arr[pos] < target:\n            low = pos + 1\n        else:\n            high = pos - 1\n    if target == arr[low]:\n        return low\n    return -1\n",
        "o": [
            "Interpolation search",
            "Exponential search",
            "Modified binary search",
            "Jump search"
        ]
    },
    {
        "q": "When would you prefer cycle sort over other in-place sorting algorithms?",
        "c": null,
        "o": [
            "When minimizing write operations is critical",
            "When stability is required",
            "When memory is not a constraint",
            "When dealing with floating-point numbers"
        ]
    },
    {
        "q": "What is the main advantage of using the 'key' function in Python's sorting functions over implementing __lt__ in a custom class?",
        "c": null,
        "o": [
            "Allows multiple sorting strategies without modifying the class",
            "Provides better performance",
            "Makes the sort stable",
            "Works with non-comparable objects"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for finding all duplicates in a sorted array?",
        "c": null,
        "o": [
            "Single pass with adjacent element comparison",
            "Using a hash set",
            "Binary search for each element",
            "Brute force comparison"
        ]
    },
    {
        "q": "What is the space complexity of the most efficient implementation of merge sort for linked lists?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of these statements about Python's sorted() function is TRUE?",
        "c": null,
        "o": [
            "It guarantees stable sorting for all input types",
            "It modifies the original sequence",
            "It only works with homogeneous data types",
            "It uses quicksort for small arrays"
        ]
    },
    {
        "q": "What is the main advantage of using the 'bisect' module over implementing binary search manually in Python?",
        "c": null,
        "o": [
            "More maintainable and less error-prone",
            "Faster execution speed",
            "Supports more data types",
            "Works on unsorted data"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when the input consists of many equal elements?",
        "c": null,
        "o": [
            "3-way quicksort (Dutch National Flag)",
            "Standard quicksort",
            "Selection sort",
            "Bubble sort"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find the intersection of two sorted arrays?",
        "c": null,
        "o": [
            "O(m + n) using merge-like approach",
            "O(m log n) using binary search",
            "O(mn) using nested loops",
            "O(n log m) using hashing"
        ]
    },
    {
        "q": "Which of these is a valid way to sort a pandas DataFrame by multiple columns?",
        "c": null,
        "o": [
            "df.sort_values(by=['col1', 'col2'])",
            "df.order_by('col1', 'col2')",
            "sorted(df, key=['col1', 'col2'])",
            "df.sort(['col1', 'col2'])"
        ]
    },
    {
        "q": "What is the main advantage of using a skip list over binary search for searching?",
        "c": null,
        "o": [
            "Easier to implement and more flexible for dynamic data",
            "Faster for small datasets",
            "Requires less memory",
            "Provides better worst-case guarantees"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in an array that is first increasing then decreasing?",
        "c": null,
        "o": [
            "Modified binary search to find peak element",
            "Linear search from both ends",
            "Standard binary search",
            "Interpolation search"
        ]
    },
    {
        "q": "What is the key advantage of using a stable sorting algorithm?",
        "c": null,
        "o": [
            "Preserves relative order of equal elements",
            "Always runs in O(n log n) time",
            "Uses constant extra space",
            "Works with any data type"
        ]
    },
    {
        "q": "Which Python function would you use to efficiently maintain a sorted list as new elements are inserted?",
        "c": null,
        "o": [
            "bisect.insort()",
            "list.insert() followed by sorted()",
            "heapq.heappush()",
            "list.append() followed by sort()"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in a sorted array that has been rotated at an unknown pivot point?",
        "c": null,
        "o": [
            "Modified binary search that first finds the pivot",
            "Linear search from both ends",
            "Standard binary search",
            "Interpolation search"
        ]
    },
    {
        "q": "What is the key advantage of Timsort over traditional merge sort?",
        "c": null,
        "o": [
            "Optimizes for real-world data patterns (runs, partial ordering)",
            "Has better worst-case time complexity",
            "Uses less memory",
            "Easier to implement"
        ]
    },
    {
        "q": "What will this Python code output?",
        "c": "\nfrom bisect import bisect_right\nnums = [1, 2, 2, 2, 3, 4]\nprint(bisect_right(nums, 2))\n",
        "o": [
            "4",
            "2",
            "3",
            "5"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when the input consists of many duplicate keys?",
        "c": null,
        "o": [
            "3-way quicksort (Dutch National Flag partitioning)",
            "Standard quicksort",
            "Selection sort",
            "Bubble sort"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find all pairs in a sorted array that sum to a target value?",
        "c": null,
        "o": [
            "O(n) using two pointers",
            "O(n log n) using binary search",
            "O(n²) using nested loops",
            "O(log n) using divide and conquer"
        ]
    },
    {
        "q": "Which of these is NOT a valid optimization for binary search?",
        "c": null,
        "o": [
            "Using recursion instead of iteration for better performance",
            "Calculating mid with low + (high-low)//2 to avoid overflow",
            "Using interpolation for better guess of mid",
            "Eliminating tail recursion"
        ]
    },
    {
        "q": "What does this Python implementation represent?",
        "c": "\ndef sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr)//2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return sort(left) + middle + sort(right)\n",
        "o": [
            "Quicksort with 3-way partitioning",
            "Merge sort with optimized merging",
            "Bucket sort with dynamic buckets",
            "Selection sort with early termination"
        ]
    },
    {
        "q": "When would you prefer radix sort over comparison-based sorting algorithms?",
        "c": null,
        "o": [
            "When sorting fixed-length strings or integers",
            "When stability is required",
            "When memory is extremely limited",
            "When the data is nearly sorted"
        ]
    },
    {
        "q": "What is the main advantage of using 'functools.cmp_to_key' in Python's sorting functions?",
        "c": null,
        "o": [
            "Allows legacy comparison functions to work with the key parameter",
            "Provides better performance than lambda functions",
            "Makes any sort stable automatically",
            "Enables sorting of non-comparable objects"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for finding the smallest missing positive integer in an unsorted array?",
        "c": null,
        "o": [
            "Modified cycle sort that ignores non-positive numbers",
            "Sorting then linear scan",
            "Hash set approach",
            "Binary search after sorting"
        ]
    },
    {
        "q": "What is the space complexity of the most efficient implementation of quicksort?",
        "c": null,
        "o": [
            "O(log n) due to recursion stack",
            "O(n) for auxiliary arrays",
            "O(1) for in-place implementations",
            "O(n log n) for caching"
        ]
    },
    {
        "q": "Which of these statements about Python's list.sort() method is FALSE?",
        "c": null,
        "o": [
            "It returns a new sorted list",
            "It sorts the list in place",
            "It uses Timsort algorithm",
            "It accepts a key function parameter"
        ]
    },
    {
        "q": "What is the main advantage of using exponential search over binary search?",
        "c": null,
        "o": [
            "Works better with unbounded/infinite arrays",
            "Has better worst-case time complexity",
            "Doesn't require sorted input",
            "Uses less memory"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when you need the top k elements from a large unsorted dataset?",
        "c": null,
        "o": [
            "Quickselect to find the kth element then partition",
            "Full quicksort of the entire array",
            "Merge sort with early termination",
            "Insertion sort with size limit"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to merge k sorted arrays?",
        "c": null,
        "o": [
            "O(n log k) using a min-heap",
            "O(kn) using iterative merging",
            "O(n log n) by concatenating then sorting",
            "O(n²) using nested loops"
        ]
    },
    {
        "q": "Which of these is a valid way to sort a list of strings case-insensitively in Python?",
        "c": null,
        "o": [
            "sorted(lst, key=lambda x: x.lower())",
            "sorted(lst, case_sensitive=False)",
            "lst.sort(ignore_case=True)",
            "sorted(lst, cmp=lambda a,b: a.lower()==b.lower())"
        ]
    },
    {
        "q": "What is the key advantage of using a skip list over binary search trees for searching?",
        "c": null,
        "o": [
            "Simpler implementation and good average-case performance",
            "Guaranteed O(log n) worst-case time",
            "Uses less memory per node",
            "Supports range queries more efficiently"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in a 2D matrix where rows and columns are sorted?",
        "c": null,
        "o": [
            "Step-wise linear search starting from top-right corner",
            "Binary search on each row",
            "Convert to 1D array then binary search",
            "Linear search through all elements"
        ]
    },
    {
        "q": "What is the main characteristic of an adaptive sorting algorithm?",
        "c": null,
        "o": [
            "Runs faster when input is partially sorted",
            "Always runs in O(n log n) time",
            "Uses constant extra space",
            "Works with any comparison function"
        ]
    },
    {
        "q": "Which Python module would you use to efficiently implement a priority queue with sorting capabilities?",
        "c": null,
        "o": [
            "heapq",
            "bisect",
            "queue",
            "collections"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding the first occurrence of an element in a sorted array with duplicates?",
        "c": null,
        "o": [
            "Binary search that continues searching left after finding a match",
            "Linear search from the beginning",
            "Standard binary search",
            "Interpolation search"
        ]
    },
    {
        "q": "What is the key advantage of using insertion sort in Timsort's implementation?",
        "c": null,
        "o": [
            "Efficient for small subarrays due to low constant factors",
            "Provides better worst-case performance",
            "Works well with linked lists",
            "Requires no additional memory"
        ]
    },
    {
        "q": "What will this Python code output?",
        "c": "\nimport heapq\nnums = [3, 1, 4, 1, 5, 9, 2]\nheapq.heapify(nums)\nprint(heapq.heappop(nums))\n",
        "o": [
            "1",
            "3",
            "9",
            "2"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when you need to sort data that is being streamed in real-time?",
        "c": null,
        "o": [
            "Insertion sort",
            "Merge sort",
            "Quick sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the time complexity of finding the k smallest elements in an unsorted array using a max-heap?",
        "c": null,
        "o": [
            "O(n log k)",
            "O(n log n)",
            "O(k log n)",
            "O(nk)"
        ]
    },
    {
        "q": "Which of these is NOT a valid optimization for merge sort?",
        "c": null,
        "o": [
            "Using bubble sort for small subarrays",
            "In-place merging to reduce space usage",
            "Eliminating recursion with bottom-up approach",
            "Parallelizing the merge operations"
        ]
    },
    {
        "q": "What does this Python implementation represent?",
        "c": "\ndef search(arr, target):\n    if arr[0] == target:\n        return 0\n    i = 1\n    while i < len(arr) and arr[i] <= target:\n        i *= 2\n    return binary_search(arr, i//2, min(i, len(arr)-1), target)\n",
        "o": [
            "Exponential search",
            "Jump search",
            "Fibonacci search",
            "Interpolation search"
        ]
    },
    {
        "q": "When would you prefer counting sort over radix sort?",
        "c": null,
        "o": [
            "When the range of keys is small compared to number of items",
            "When dealing with floating-point numbers",
            "When stability is not required",
            "When memory is extremely limited"
        ]
    },
    {
        "q": "What is the main advantage of using 'key=str.lower' when sorting strings in Python?",
        "c": null,
        "o": [
            "Performs case-insensitive sorting",
            "Speeds up the sorting process",
            "Makes the sort stable",
            "Allows sorting of non-string elements"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for finding the majority element in an unsorted array?",
        "c": null,
        "o": [
            "Boyer-Moore majority vote algorithm (O(n) time, O(1) space)",
            "Sorting then counting (O(n log n) time)",
            "Hash map approach (O(n) time and space)",
            "Divide and conquer approach"
        ]
    },
    {
        "q": "What is the space complexity of the most efficient implementation of merge sort for arrays?",
        "c": null,
        "o": [
            "O(n)",
            "O(1)",
            "O(log n)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of these statements about Python's sorted() function is TRUE?",
        "c": null,
        "o": [
            "It is guaranteed to be stable",
            "It modifies the original sequence",
            "It uses quicksort for small arrays",
            "It cannot sort dictionaries"
        ]
    },
    {
        "q": "What is the main advantage of using the 'bisect' module's functions over manual binary search implementation?",
        "c": null,
        "o": [
            "Reduces implementation errors and edge cases",
            "Provides better time complexity",
            "Works with unsorted data",
            "Supports more data types"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when the input array has many inverted pairs?",
        "c": null,
        "o": [
            "Insertion sort",
            "Merge sort",
            "Quick sort",
            "Selection sort"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find the closest pair in a sorted array?",
        "c": null,
        "o": [
            "O(n) using linear scan",
            "O(log n) using binary search",
            "O(n log n) using sorting",
            "O(n²) using nested loops"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in a sorted array that has been circularly rotated an unknown number of times?",
        "c": null,
        "o": [
            "Modified binary search that compares mid with endpoints",
            "Linear search from both ends",
            "Standard binary search",
            "Jump search with step size n/2"
        ]
    },
    {
        "q": "What is the key advantage of using a randomized pivot selection in quicksort?",
        "c": null,
        "o": [
            "Makes worst-case O(n²) behavior extremely unlikely",
            "Guarantees O(n log n) time complexity",
            "Eliminates need for partitioning",
            "Makes the sort stable"
        ]
    },
    {
        "q": "What will this Python code output?",
        "c": "\nfrom bisect import bisect_left\ndata = [10, 20, 30, 40, 50]\nprint(bisect_left(data, 35))\n",
        "o": [
            "3",
            "2",
            "4",
            "-1"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when you need to frequently retrieve the k smallest elements from a dynamically changing dataset?",
        "c": null,
        "o": [
            "Min-heap implementation",
            "Maintaining a fully sorted array",
            "Using selection sort with early termination",
            "Quickselect after each update"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find the longest increasing subsequence in an array?",
        "c": null,
        "o": [
            "O(n log n) using patience sorting",
            "O(n²) using dynamic programming",
            "O(2ⁿ) using brute force",
            "O(n³) using all possible subsequences"
        ]
    },
    {
        "q": "Which of these is NOT a valid optimization for binary search implementations?",
        "c": null,
        "o": [
            "Using recursion instead of iteration for better readability",
            "Calculating mid as low + (high-low)//2 to prevent overflow",
            "Using branchless comparisons for pipelining",
            "Eliminating redundant comparisons in the loop"
        ]
    },
    {
        "q": "What does this Python implementation represent?",
        "c": "\ndef sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n",
        "o": [
            "Optimized bubble sort with early termination",
            "Standard selection sort",
            "Insertion sort with gap sequence",
            "Cocktail shaker sort"
        ]
    },
    {
        "q": "When would you prefer bucket sort over comparison-based sorting algorithms?",
        "c": null,
        "o": [
            "When input is uniformly distributed across a known range",
            "When stability is absolutely required",
            "When memory usage must be minimized",
            "When worst-case performance is critical"
        ]
    },
    {
        "q": "What is the main advantage of using Python's 'key' parameter over the older 'cmp' parameter for sorting?",
        "c": null,
        "o": [
            "Transforms each element only once (O(n)) vs comparing multiple times (O(n log n))",
            "Provides better worst-case performance guarantees",
            "Works with non-comparable objects",
            "Makes all sorts automatically stable"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for finding all anagrams in a list of strings?",
        "c": null,
        "o": [
            "Group using sorted string as key (O(n k log k) time)",
            "Brute force compare all pairs (O(n² k) time)",
            "Sort the entire list lexicographically (O(n log n) time)",
            "Use a trie data structure (O(n k) time)"
        ]
    },
    {
        "q": "What is the space complexity of the most efficient implementation of quicksort for arrays?",
        "c": null,
        "o": [
            "O(log n) due to recursion stack",
            "O(n) for auxiliary arrays",
            "O(1) for in-place versions",
            "O(n log n) for caching"
        ]
    },
    {
        "q": "Which of these statements about Python's list.sort() method is FALSE?",
        "c": null,
        "o": [
            "It returns a new sorted list while keeping original unchanged",
            "It modifies the list in place",
            "It uses Timsort algorithm",
            "It accepts both key and reverse parameters"
        ]
    },
    {
        "q": "What is the main advantage of using interpolation search over binary search for certain datasets?",
        "c": null,
        "o": [
            "O(log log n) average case for uniform distributions",
            "Works on unsorted arrays",
            "Simpler implementation",
            "Better worst-case guarantees"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when the input array consists of many equal elements?",
        "c": null,
        "o": [
            "3-way quicksort (Dutch National Flag partitioning)",
            "Standard quicksort",
            "Selection sort",
            "Bubble sort"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to merge two sorted arrays?",
        "c": null,
        "o": [
            "O(m+n) using merge-like approach",
            "O(m log n) using binary search",
            "O(mn) using nested loops",
            "O(log(m+n)) using divide and conquer"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in a sorted array that has been rotated at an unknown pivot point?",
        "c": null,
        "o": [
            "Modified binary search comparing mid with endpoints",
            "Linear search from both ends",
            "Standard binary search",
            "Fibonacci search"
        ]
    },
    {
        "q": "What is the key advantage of using insertion sort for small subarrays in Timsort?",
        "c": null,
        "o": [
            "Lower constant factors make it faster for small n",
            "Better worst-case time complexity",
            "Reduces space complexity to O(1)",
            "Makes the algorithm stable"
        ]
    },
    {
        "q": "What will be the output of this Python code?",
        "c": "\nfrom bisect import bisect_left\ndata = [1, 3, 5, 7, 9]\nprint(bisect_left(data, 6))\n",
        "o": [
            "3",
            "2",
            "4",
            "-1"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when you need to maintain a collection that is always sorted as new elements are inserted?",
        "c": null,
        "o": [
            "Binary search tree or bisect.insort",
            "Quicksort after each insertion",
            "Merge sort with incremental merging",
            "Selection sort with early termination"
        ]
    },
    {
        "q": "What is the time complexity of finding the median of two sorted arrays of size m and n?",
        "c": null,
        "o": [
            "O(log(min(m,n))) using binary search",
            "O(m+n) using merge approach",
            "O(mn) using brute force",
            "O(1) using direct calculation"
        ]
    },
    {
        "q": "Which of these is NOT a valid optimization for quicksort?",
        "c": null,
        "o": [
            "Using bubble sort for small subarrays",
            "Median-of-three pivot selection",
            "Insertion sort for small subarrays",
            "Tail recursion elimination"
        ]
    },
    {
        "q": "What does this Python implementation represent?",
        "c": "\ndef search(arr, target):\n    low, high = 0, len(arr)-1\n    while arr[high] != arr[low] and target >= arr[low] and target <= arr[high]:\n        pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])\n        if arr[pos] == target:\n            return pos\n        if arr[pos] < target:\n            low = pos + 1\n        else:\n            high = pos - 1\n    if target == arr[low]:\n        return low\n    return -1\n",
        "o": [
            "Interpolation search",
            "Exponential search",
            "Modified binary search",
            "Jump search"
        ]
    },
    {
        "q": "When would you prefer cycle sort over other in-place sorting algorithms?",
        "c": null,
        "o": [
            "When minimizing write operations is critical",
            "When stability is required",
            "When memory is not a constraint",
            "When dealing with floating-point numbers"
        ]
    },
    {
        "q": "What is the main advantage of using Python's 'key' function over implementing __lt__ in a custom class?",
        "c": null,
        "o": [
            "Allows multiple sorting strategies without modifying the class",
            "Provides better performance",
            "Makes the sort stable",
            "Works with non-comparable objects"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for finding all duplicates in a sorted array?",
        "c": null,
        "o": [
            "Single pass comparing adjacent elements",
            "Using a hash set",
            "Binary search for each element",
            "Brute force comparison"
        ]
    },
    {
        "q": "What is the space complexity of the most efficient implementation of merge sort for linked lists?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of these statements about Python's sorted() function is TRUE?",
        "c": null,
        "o": [
            "It guarantees stable sorting for all input types",
            "It modifies the original sequence",
            "It only works with homogeneous data types",
            "It uses quicksort for small arrays"
        ]
    },
    {
        "q": "What is the main advantage of using the 'bisect' module over manual binary search?",
        "c": null,
        "o": [
            "More maintainable and less error-prone",
            "Faster execution speed",
            "Supports more data types",
            "Works on unsorted data"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when the input consists of many equal elements?",
        "c": null,
        "o": [
            "3-way quicksort (Dutch National Flag)",
            "Standard quicksort",
            "Selection sort",
            "Bubble sort"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find the intersection of two sorted arrays?",
        "c": null,
        "o": [
            "O(m + n) using merge-like approach",
            "O(m log n) using binary search",
            "O(mn) using nested loops",
            "O(n log m) using hashing"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in a sorted array that has been rotated at an unknown pivot point?",
        "c": null,
        "o": [
            "Modified binary search comparing mid with endpoints",
            "Linear search from both ends",
            "Standard binary search",
            "Jump search with step size n/2"
        ]
    },
    {
        "q": "What is the key advantage of using insertion sort for small subarrays in Timsort?",
        "c": null,
        "o": [
            "Lower constant factors make it faster for small n",
            "Better worst-case time complexity",
            "Reduces space complexity to O(1)",
            "Makes the algorithm stable"
        ]
    },
    {
        "q": "What will this Python code output?",
        "c": "\nfrom bisect import bisect_left\ndata = [10, 20, 30, 40, 50]\nprint(bisect_left(data, 35))\n",
        "o": [
            "3",
            "2",
            "4",
            "-1"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when you need to frequently retrieve the k smallest elements from a dynamically changing dataset?",
        "c": null,
        "o": [
            "Min-heap implementation",
            "Maintaining a fully sorted array",
            "Selection sort with early termination",
            "Quickselect after each update"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find the longest increasing subsequence in an array?",
        "c": null,
        "o": [
            "O(n log n) using patience sorting",
            "O(n²) using dynamic programming",
            "O(2ⁿ) using brute force",
            "O(n³) using all possible subsequences"
        ]
    },
    {
        "q": "Which of these is NOT a valid optimization for binary search implementations?",
        "c": null,
        "o": [
            "Using recursion instead of iteration for better readability",
            "Calculating mid as low + (high-low)//2 to prevent overflow",
            "Using branchless comparisons for pipelining",
            "Eliminating redundant comparisons in the loop"
        ]
    },
    {
        "q": "What does this Python implementation represent?",
        "c": "\ndef sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n",
        "o": [
            "Optimized bubble sort with early termination",
            "Standard selection sort",
            "Insertion sort with gap sequence",
            "Cocktail shaker sort"
        ]
    },
    {
        "q": "When would you prefer bucket sort over comparison-based sorting algorithms?",
        "c": null,
        "o": [
            "When input is uniformly distributed across a known range",
            "When stability is absolutely required",
            "When memory usage must be minimized",
            "When worst-case performance is critical"
        ]
    },
    {
        "q": "What is the main advantage of using Python's 'key' parameter over the older 'cmp' parameter for sorting?",
        "c": null,
        "o": [
            "Transforms each element only once (O(n)) vs comparing multiple times (O(n log n))",
            "Provides better worst-case performance guarantees",
            "Works with non-comparable objects",
            "Makes all sorts automatically stable"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for finding all anagrams in a list of strings?",
        "c": null,
        "o": [
            "Group using sorted string as key (O(n k log k) time)",
            "Brute force compare all pairs (O(n² k) time)",
            "Sort the entire list lexicographically (O(n log n) time)",
            "Use a trie data structure (O(n k) time)"
        ]
    },
    {
        "q": "What is the space complexity of the most efficient implementation of quicksort for arrays?",
        "c": null,
        "o": [
            "O(log n) due to recursion stack",
            "O(n) for auxiliary arrays",
            "O(1) for in-place versions",
            "O(n log n) for caching"
        ]
    },
    {
        "q": "Which of these statements about Python's list.sort() method is FALSE?",
        "c": null,
        "o": [
            "It returns a new sorted list while keeping original unchanged",
            "It modifies the list in place",
            "It uses Timsort algorithm",
            "It accepts both key and reverse parameters"
        ]
    },
    {
        "q": "What is the main advantage of using interpolation search over binary search for certain datasets?",
        "c": null,
        "o": [
            "O(log log n) average case for uniform distributions",
            "Works on unsorted arrays",
            "Simpler implementation",
            "Better worst-case guarantees"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when the input array consists of many equal elements?",
        "c": null,
        "o": [
            "3-way quicksort (Dutch National Flag partitioning)",
            "Standard quicksort",
            "Selection sort",
            "Bubble sort"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to merge two sorted arrays?",
        "c": null,
        "o": [
            "O(m+n) using merge-like approach",
            "O(m log n) using binary search",
            "O(mn) using nested loops",
            "O(log(m+n)) using divide and conquer"
        ]
    },
    {
        "q": "Which searching algorithm is most efficient for finding an element in a sorted array that has been rotated an unknown number of times?",
        "c": null,
        "o": [
            "Modified binary search comparing mid with endpoints",
            "Linear search from both ends",
            "Standard binary search",
            "Fibonacci search"
        ]
    },
    {
        "q": "What is the key advantage of using a randomized pivot selection in quicksort?",
        "c": null,
        "o": [
            "Makes worst-case O(n²) behavior extremely unlikely",
            "Guarantees O(n log n) time complexity",
            "Eliminates need for partitioning",
            "Makes the sort stable"
        ]
    },
    {
        "q": "What will this Python code output?",
        "c": "\nfrom bisect import bisect_left\ndata = [10, 20, 30, 40, 50]\nprint(bisect_left(data, 35))\n",
        "o": [
            "3",
            "2",
            "4",
            "-1"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when you need to maintain a collection that is always sorted as new elements are inserted?",
        "c": null,
        "o": [
            "Binary search tree or bisect.insort",
            "Quicksort after each insertion",
            "Merge sort with incremental merging",
            "Selection sort with early termination"
        ]
    },
    {
        "q": "What is the time complexity of finding the median of two sorted arrays of size m and n?",
        "c": null,
        "o": [
            "O(log(min(m,n))) using binary search",
            "O(m+n) using merge approach",
            "O(mn) using brute force",
            "O(1) using direct calculation"
        ]
    },
    {
        "q": "Which of these is NOT a valid optimization for quicksort?",
        "c": null,
        "o": [
            "Using bubble sort for small subarrays",
            "Median-of-three pivot selection",
            "Insertion sort for small subarrays",
            "Tail recursion elimination"
        ]
    },
    {
        "q": "What does this Python implementation represent?",
        "c": "\ndef search(arr, target):\n    low, high = 0, len(arr)-1\n    while arr[high] != arr[low] and target >= arr[low] and target <= arr[high]:\n        pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])\n        if arr[pos] == target:\n            return pos\n        if arr[pos] < target:\n            low = pos + 1\n        else:\n            high = pos - 1\n    if target == arr[low]:\n        return low\n    return -1\n",
        "o": [
            "Interpolation search",
            "Exponential search",
            "Modified binary search",
            "Jump search"
        ]
    },
    {
        "q": "When would you prefer cycle sort over other in-place sorting algorithms?",
        "c": null,
        "o": [
            "When minimizing write operations is critical",
            "When stability is required",
            "When memory is not a constraint",
            "When dealing with floating-point numbers"
        ]
    },
    {
        "q": "What is the main advantage of using Python's 'key' function over implementing __lt__ in a custom class?",
        "c": null,
        "o": [
            "Allows multiple sorting strategies without modifying the class",
            "Provides better performance",
            "Makes the sort stable",
            "Works with non-comparable objects"
        ]
    },
    {
        "q": "Which algorithm would be most efficient for finding all duplicates in a sorted array?",
        "c": null,
        "o": [
            "Single pass comparing adjacent elements",
            "Using a hash set",
            "Binary search for each element",
            "Brute force comparison"
        ]
    },
    {
        "q": "What is the space complexity of the most efficient implementation of merge sort for linked lists?",
        "c": null,
        "o": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n log n)"
        ]
    },
    {
        "q": "Which of these statements about Python's sorted() function is TRUE?",
        "c": null,
        "o": [
            "It guarantees stable sorting for all input types",
            "It modifies the original sequence",
            "It only works with homogeneous data types",
            "It uses quicksort for small arrays"
        ]
    },
    {
        "q": "What is the main advantage of using the 'bisect' module over manual binary search?",
        "c": null,
        "o": [
            "More maintainable and less error-prone",
            "Faster execution speed",
            "Supports more data types",
            "Works on unsorted data"
        ]
    },
    {
        "q": "Which sorting algorithm is most efficient when the input consists of many equal elements?",
        "c": null,
        "o": [
            "3-way quicksort (Dutch National Flag partitioning)",
            "Standard quicksort",
            "Selection sort",
            "Bubble sort"
        ]
    },
    {
        "q": "What is the time complexity of the most efficient algorithm to find the intersection of two sorted arrays?",
        "c": null,
        "o": [
            "O(m+n) using merge-like approach",
            "O(m log n) using binary search",
            "O(mn) using nested loops",
            "O(n log m) using hashing"
        ]
    }
]