[
  {
    "q": "What is the output of the following code snippet?\n",
    "c": "\ndef add_numbers(a, b):\n    return a + b\n\nprint(add_numbers(5, 10))",
    "o": [
      "15",
      "5",
      "10",
      "50"
    ]
  },
  {
    "q": "\nWhich of the following is a valid function call in Python?\n",
    "c": "",
    "o": [
      "my_function()",
      "my_function",
      "my-function(x)",
      "my-function(x, y)"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef say_hello(name):\n    print(f\"Hello, {name}!\")\n\nsay_hello(\"Alice\")",
    "o": [
      "Hello, Alice!",
      "Hello, world!",
      "world",
      "None"
    ]
  },
  {
    "q": "\nWhich of the following is a valid Python function definition?\n",
    "c": "",
    "o": [
      "def add_numbers(a, b): return a + b",
      "def add_numbers(a, b) { return a + b }",
      "def add_numbers(a, b) -> a + b",
      "def add_numbers(a, b); return a + b"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef multiply_numbers(a=2, b=3):\n    return a * b\n\nprint(multiply_numbers())",
    "o": [
      "6",
      "5",
      "8",
      "9"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define a function that takes an arbitrary number of arguments in Python?\n",
    "c": "",
    "o": [
      "def my_function(*args):",
      "def my_function(args):",
      "def my_function(**kwargs):",
      "def my_function(*args, **kwargs):"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef add_numbers(a, b):\n    return a + b\n\nprint(add_numbers(b=5, a=10))",
    "o": [
      "15",
      "5",
      "10",
      "50"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define a function that takes a variable number of keyword arguments in Python?\n",
    "c": "",
    "o": [
      "def my_function(**kwargs):",
      "def my_function(*args):",
      "def my_function(args):",
      "def my_function(*args, **kwargs):"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(5))",
    "o": [
      "120",
      "5",
      "10",
      "20"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef sum_of_squares(a, b):\n    return a**2 + b**2\n\nprint(sum_of_squares(3, 4))",
    "o": [
      "25",
      "7",
      "9",
      "12"
    ]
  },
  {
    "q": "\nWhich of the following is a valid Python lambda function that returns the sum of two numbers?\n",
    "c": "",
    "o": [
      "lambda x, y: x + y",
      "lambda x, y: return x + y",
      "lambda x + y",
      "lambda x, y: sum(x, y)"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef print_twice(s):\n    print(s)\n    print(s)\n\nprint_twice(\"Hello\")",
    "o": [
      "Hello Hello",
      "Hello",
      "\"HelloHello\"",
      "\"(Hello),(Hello)"
    ]
  },
  {
    "q": "\n// Which of the following is a valid way to define a recursive function in Python?\n// ",
    "c": "",
    "o": [
      "def my_function(n):",
      "def my_function(n, recursion=True):",
      "def my_function(n): recursion=True",
      "def my_function(n, recursion=False):"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef print_even_numbers(n):\n    if n % 2 == 0:\n        print(n)\n    if n > 0:\n        print_even_numbers(n-1)\n\nprint_even_numbers(6)",
    "o": [
      "6 4 2 0",
      "0 2 4 6",
      "2 4 6",
      "6 4 2"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to pass a function as an argument to another function in Python?\n",
    "c": "",
    "o": [
      "my_function(another_function)",
      "my_function.add(another_function)",
      "my_function[another_function]",
      "my_function.call(another_function)"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef add_numbers(a, b):\n    result = a + b\n    print(f\"The result is {result}\")\n\nadd_numbers(3, 4)",
    "o": [
      "The result is 7",
      "The result is 3",
      "The result is 4",
      "The result is 12"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef multiply_by_two(x):\n    return x * 2\n\nmy_list = [1, 2, 3, 4]\nresult = map(multiply_by_two, my_list)\nprint(list(result))",
    "o": [
      "[2, 4, 6, 8]",
      "[1, 2, 3, 4]",
      "[1, 4, 9, 16]",
      "[(1, 2), (3, 4)]"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define a global variable in Python?\n",
    "c": "",
    "o": [
      "global my_var",
      "my_var = 42",
      "def my_var(): return 42",
      "my_var == 42"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define a local variable inside a function in Python?\n",
    "c": "",
    "o": [
      "my_var = 42",
      "local my_var = 42",
      "my_var == 42",
      "global my_var = 42"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef power_of_two(n):\n    if n == 0:\n        return 1\n    else:\n        return 2 * power_of_two(n-1)\n\nprint(power_of_two(4))",
    "o": [
      "16",
      "2",
      "4",
      "8"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define a lambda function that takes three arguments?\n",
    "c": "",
    "o": [
      "lambda x, y, z: x + y + z",
      "lambda (x, y, z): x + y + z",
      "lambda x y z: x + y + z",
      "lambda x y, z: x + y + z"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 10\n\ndef my_function():\n    x = 5\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "5 10",
      "5 5",
      "10 10",
      "10 5"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define a function with a default argument in Python?\n",
    "c": "",
    "o": [
      "def my_function(n=2):",
      "def my_function(n): default=2",
      "def my_function(n): n=2",
      "def my_function(default=2, n):"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef print_odd_numbers(n):\n    if n % 2 != 0:\n        print(n)\n    if n > 0:\n        print_odd_numbers(n-1)\n\nprint_odd_numbers(7)",
    "o": [
      "7 5 3 1",
      "0 2 4 6 7",
      "1 3 5 7",
      "7 5 3 1 0"
    ]
  },
  {
    "q": "\n// Which of the following is a valid way to define an anonymous function that returns the square of a number?\n// ",
    "c": "",
    "o": [
      "lambda x: x*x",
      "lambda x: x^2",
      "def(x): return x*x",
      "def(x): x^2"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    global x\n    x = 10\n\nmy_function()\nprint(x)",
    "o": [
      "10",
      "5",
      "15",
      "20"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "4",
      "12",
      "120"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define a lambda function that takes no arguments and returns the string \"Hello, world!\"?\n",
    "c": "",
    "o": [
      "lambda: \"Hello, world!\"",
      "lambda(): \"Hello, world!\"",
      "lambda x: \"Hello, world!\"",
      "lambda x(): \"Hello, world!\""
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    x = x + 1\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "UnboundLocalError",
      "6 6",
      "6 5",
      "5 6"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef countdown(n):\n    if n == 0:\n        print(\"Blastoff!\")\n    else:\n        print(n)\n        countdown(n-1)\n\ncountdown(3)",
    "o": [
      "3 2 1 Blastoff!",
      "0 1 2 Blastoff!",
      "1 2 3 Blastoff!",
      "3 2 1 0 Blastoff!"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    global x\n    x = x + 1\n\nprint(x)\nmy_function()\nprint(x)",
    "o": [
      "5 6",
      "5 5",
      "6 6",
      "6 5"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    return x + 1\n\nmy_list = [1, 2, 3]\nnew_list = map(my_function, my_list)\nprint(list(new_list))",
    "o": [
      "[2, 3, 4]",
      "[1, 2, 3]",
      "2 3 4",
      "1 2 3"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x=5):\n    return x + 1\n\nprint(my_function())\nprint(my_function(10))",
    "o": [
      "6 11",
      "6 10",
      "5 11",
      "5 10"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    x = 10\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "10 5",
      "5 10",
      "10 10",
      "5 5"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 1:\n        return 1\n    else:\n        return x * my_function(x-1)\n\nprint(my_function(4))",
    "o": [
      "24",
      "4",
      "12",
      "120"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    x = 10\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "10 5",
      "10 10",
      "5 10",
      "5 5"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x, y):\n    return x + y\n\nmy_dict = {'x': 1, 'y': 2}\nprint(my_function(**my_dict))",
    "o": [
      "3",
      "{'x': 1, 'y': 2}",
      "1 2",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    global x\n    x = 10\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "10 10",
      "5 10",
      "10 5",
      "5 5"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x, y=5):\n    return x + y\n\nprint(my_function(2))\nprint(my_function(2, 2))",
    "o": [
      "7 4",
      "7 5",
      "2 7",
      "2 4"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function():\n    x = 10\n\nprint(x)",
    "o": [
      "NameError: name 'x' is not defined",
      "10",
      "None",
      "TypeError"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define an anonymous function that takes two arguments and returns the larger of the two arguments?\n",
    "c": "",
    "o": [
      "lambda x, y: x if x > y else y",
      "lambda x, y: x > y ? x : y",
      "lambda x, y: max(x, y)",
      "lambda x, y: min(x, y)"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    x = 10\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "10 5",
      "10 10",
      "5 10",
      "5 5"
    ]
  },
  {
    "q": "\nWhich of the following is a valid way to define an anonymous function that takes a single argument and returns True if the argument is positive and False otherwise?\n",
    "c": "",
    "o": [
      "lambda x: x > 0",
      "lambda x: x < 0",
      "lambda x: x >= 0",
      "lambda x: x == 0"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x, y):\n    return x * y\n\nmy_dict = {'x': 2, 'y': 3}\nprint(my_function(**my_dict))",
    "o": [
      "6",
      "{'x': 2, 'y': 3}",
      "2 3",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    x = 10\n\nprint(my_function())",
    "o": [
      "None",
      "10",
      "5",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b, c):\n    return a + b + c\n\nprint(my_function(1, 2, 3))\nprint(my_function(a=1, b=2, c=3))\nprint(my_function(c=3, b=2, a=1))",
    "o": [
      "6 6 6",
      "6 6",
      "6 TypeError",
      "6 6 TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 10\n\ndef my_function():\n    global x\n    x = 5\n\nmy_function()\nprint(x)",
    "o": [
      "5",
      "10",
      "None",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(*args):\n    return sum(args)\n\nprint(my_function(1, 2, 3))\nprint(my_function(4, 5, 6, 7))",
    "o": [
      "6 22",
      "123 4567",
      "6 22 123 4567",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b, c=0, d=0):\n    return a + b + c + d\n\nprint(my_function(1, 2))\nprint(my_function(1, 2, 3))\nprint(my_function(1, 2, 3, 4))",
    "o": [
      "3 6 10",
      "3 6 7",
      "1 2 3",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b, c):\n    print(a, b, c)\n\nmy_list = [1, 2, 3]\nmy_function(*my_list)",
    "o": [
      "1 2 3",
      "1 2 None",
      "1 [2, 3] None",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b, *args):\n    print(a, b, args)\n\nmy_function(1, 2, 3, 4, 5)",
    "o": [
      "1 2 (3, 4, 5)",
      "1 2 [3, 4, 5]",
      "1 2 3 4 5",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a=0, b=0, c=0):\n    return a + b + c\n\nprint(my_function(b=2, a=1, c=3))",
    "o": [
      "6",
      "3",
      "1 2 3",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function():\n    x = 10\n\nmy_function()\nprint(x)",
    "o": [
      "NameError: name 'x' is not defined",
      "10",
      "None",
      "undefined"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 10\n\ndef my_function():\n    global x\n    x = 20\n\nmy_function()\nprint(x)",
    "o": [
      "20",
      "10",
      "None",
      "NameError: name 'x' is not defined"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b=2, c=3):\n    print(a, b, c)\n\nmy_function(1, c=5)",
    "o": [
      "1 2 5",
      "1 2 3",
      "1 5 3",
      "TypeError"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 10\n\ndef my_function(x):\n    x += 5\n    return x\n\nmy_function(x)\nprint(x)",
    "o": [
      "10",
      "15",
      "None",
      "NameError: name 'x' is not defined"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 10\n\ndef my_function():\n    x = 20\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "20 10",
      "10 20",
      "20 20",
      "10 10"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is greater than 10 and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x: x > 10",
      "lambda x: if x > 10: True else: False",
      "lambda x: x > 10 ? True : False",
      "lambda x: x > 10 and True or False"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b=2, c=3):\n    print(a, b, c)\n\nmy_function(1, c=5, b=4)",
    "o": [
      "1 4 5",
      "1 2 3",
      "1 3 5",
      "TypeError: my_function() got multiple values for argument 'b'"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 10\n\ndef my_function():\n    global x\n    x += 5\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "15 15",
      "10 15",
      "15 10",
      "10 10"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 10\n\ndef my_function(x):\n    x += 5\n    print(x)\n\nmy_function(x)\nprint(x)",
    "o": [
      "15 10",
      "10 15",
      "15 15",
      "10 10"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b, c):\n    print(a, b, c)\n\nmy_dict = {'b': 2, 'c': 3, 'a': 1}\nmy_function(**my_dict)",
    "o": [
      "1 2 3",
      "1 3 2",
      "2 3 1",
      "TypeError: my_function() got an unexpected keyword argument 'a'"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns its square if x is positive and 0 otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x: x**2 if x > 0 else 0",
      "lambda x: x^2 if x > 0 else 0",
      "lambda x: x*x if x > 0 else 0",
      "lambda x: x*x if x > 0, 0"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    x[0] = 5\n\nmy_list = [1, 2, 3]\nmy_function(my_list)\nprint(my_list)",
    "o": [
      "[5, 2, 3]",
      "[1, 2, 3]",
      "[1, 5, 3]",
      "[1, 2, 5]"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is divisible by 3 and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x: x % 3 == 0",
      "lambda x: if x % 3 == 0: True else: False",
      "lambda x: x % 3 == 0 and True or False",
      "lambda x: x % 3"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b, c=3):\n    print(a, b, c)\n\nmy_function(1, c=5, 2)",
    "o": [
      "SyntaxError: positional argument follows keyword argument",
      "1 2 5",
      "1 2 3",
      "1 5 2"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes two arguments, x and y, and returns the larger of the two?\n// ",
    "c": "",
    "o": [
      "lambda x, y: x if x > y else y",
      "lambda x, y: max(x, y)",
      "lambda x, y: x > y ? x : y",
      "lambda x, y: y if x > y else x"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b=2, c=3):\n    print(a, b, c)\n\nmy_function(1, c=4)",
    "o": [
      "1 2 4",
      "1 4 3",
      "1 2 3",
      "SyntaxError: positional argument follows keyword argument"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b):\n    return a + b, a - b\n\nresult = my_function(3, 2)\nprint(result[0])",
    "o": [
      "5",
      "3",
      "2",
      "(3, 2)"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    x = 3\n\nmy_function()\nprint(x)",
    "o": [
      "5",
      "3",
      "0",
      "NameError: name 'x' is not defined"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is a string and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x: isinstance(x, str)",
      "lambda x: type(x) == 'str'",
      "lambda x: x is str",
      "lambda x: x.__class__ == str"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    global x\n    x = 3\n\nmy_function()\nprint(x)",
    "o": [
      "3",
      "5",
      "0",
      "NameError: name 'x' is not defined"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b=2, c=3):\n    print(a, b, c)\n\nmy_function(1, 4)",
    "o": [
      "1 4 3",
      "1 2 4",
      "1 2 3",
      "SyntaxError: positional argument follows keyword argument"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b):\n    return a + b, a - b\n\nresult1, result2 = my_function(3, 2)\nprint(result1, result2)",
    "o": [
      "5 1",
      "3 2",
      "(3, 2)",
      "TypeError: cannot unpack non-iterable int object"
    ]
  },
  {
    "q": "\nWhich of the following is the correct way to define a lambda function that takes two arguments, x and y, and returns True if x is divisible by y and False otherwise?\n",
    "c": "",
    "o": [
      "lambda x, y: x%y == 0",
      "lambda x, y: x//y == 0",
      "lambda x, y: x/y == 0",
      "lambda x, y: x%y == 1"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    x = x + 3\n\nmy_function()\nprint(x)",
    "o": [
      "UnboundLocalError",
      "3",
      "5",
      "0"
    ]
  },
  {
    "q": "\nWhich of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is an even number and False otherwise?\n",
    "c": "",
    "o": [
      "lambda x: x%2 == 0",
      "lambda x: x%2 == 1",
      "lambda x: x//2 == 0",
      "lambda x: x//2 == 1"
    ]
  },
  {
    "q": "What is the output of the following code snippet?\n",
    "c": "\nx = 5\n\ndef my_function():\n    global x\n    x = x + 3\n\nmy_function()\nprint(x)",
    "o": [
      "8",
      "3",
      "5",
      "NameError: name 'x' is not defined"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b=2, c=3):\n    print(a, b, c)\n\nmy_function(1, c=4)",
    "o": [
      "1 2 4",
      "1 4 2",
      "1 2 3",
      "TypeError: my_function() got multiple values for argument 'c'"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b):\n    return a + b, a - b\n\nresult = my_function(3, 2)\nprint(result[1])",
    "o": [
      "1",
      "3",
      "2",
      "TypeError: 'int' object is not subscriptable"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b=2, c=3):\n    print(a, b, c)\n\nmy_function(b=4, a=1)",
    "o": [
      "1 4 3",
      "1 2 4",
      "1 2 3",
      "TypeError: my_function() got multiple values for argument 'a'"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a=1, b=2, c=3):\n    print(a, b, c)\n\nmy_function(c=4)",
    "o": [
      "1 2 4",
      "1 2 3",
      "1 3 4",
      "4 2 3"
    ]
  },
  {
    "q": "\nWhich of the following is the correct way to define a lambda function that takes a single argument, x, and returns the absolute value of x?\n",
    "c": "",
    "o": [
      "lambda x: abs(x)",
      "lambda x: x ** 2",
      "lambda x: -x",
      "lambda x: x"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(a, b):\n    a = b\n\nx = 1\ny = 2\nmy_function(x, y)\nprint(x)",
    "o": [
      "1",
      "2",
      "None",
      "SyntaxError"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns the square root of x?\n// ",
    "c": "",
    "o": [
      "lambda x: math.sqrt(x)",
      "lambda x: x ** 2",
      "lambda x: -x",
      "lambda x: x"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x <= 1:\n        return 1\n    else:\n        return x * my_function(x - 1)\n\nprint(my_function(5))",
    "o": [
      "120",
      "1",
      "5",
      "15"
    ]
  },
  {
    "q": "\nWhich of the following is the correct way to define a lambda function that takes a single argument, x, and returns the square of x if x is greater than 0, and the absolute value of x otherwise?\n",
    "c": "",
    "o": [
      "lambda x: x ** 2 if x > 0 else abs(x)",
      "lambda x: x ** 2 if x < 0 else abs(x)",
      "lambda x: abs(x) if x > 0 else x ** 2",
      "lambda x: abs(x) if x < 0 else x ** 2"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 1\n\ndef my_function():\n    x = 2\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "2 1",
      "1 2",
      "2 2",
      "1 1"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x, y):\n    x = y\n    y = x\n\na = 1\nb = 2\nmy_function(a, b)\nprint(a, b)",
    "o": [
      "1 2",
      "2 1",
      "1 1",
      "2 2"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    x += 1\n    return x\n\na = 1\nb = my_function(a)\nprint(a, b)",
    "o": [
      "1 2",
      "2 1",
      "1 1",
      "2 2"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 1\n\ndef my_function():\n    global x\n    x = 2\n    print(x)\n\nmy_function()\nprint(x)",
    "o": [
      "2 2",
      "1 2",
      "2 1",
      "1 1"
    ]
  },
  {
    "q": "\nWhich of the following is the correct way to define a lambda function that takes a single argument, x, and returns the length of x if x is a string, and None otherwise?\n",
    "c": "",
    "o": [
      "lambda x: len(x) if isinstance(x, str) else None",
      "lambda x: len(x) if type(x) == None",
      "lambda x: x if x.__class__ == str else None",
      "lambda x: len(x) if x.__name__ == 'str' else None"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x, y):\n    if y == 0:\n        return 1\n    else:\n        return x * my_function(x, y - 1)\n\nprint(my_function(2, 3))",
    "o": [
      "8",
      "6",
      "9",
      "10"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is a list or a tuple, and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x: isinstance(x, (list, tuple))",
      "lambda x: type(x) in (list, tuple)",
      "lambda x: x.__class__ in (list, tuple)",
      "lambda x: x.__class__.__name__ in ('list', 'tuple')"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x <= 0:\n        return 1\n    else:\n        return x * my_function(x - 2)\n\nprint(my_function(5))",
    "o": [
      "15",
      "120",
      "21",
      "25"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is a dictionary, and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x: isinstance(x, dict)",
      "lambda x: type(x) == dict",
      "lambda x: x.__class__ == dict",
      "lambda x: x.__class__.__name__ == 'dict'"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 0:\n        return 1\n    else:\n        return x * my_function(x // 2)\n\nprint(my_function(10))",
    "o": [
      "100",
      "1",
      "10",
      "320"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x < 0:\n        return 0\n    else:\n        return x + my_function(x - 1)\n\nprint(my_function(5))",
    "o": [
      "15",
      "10",
      "20",
      "25"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes two arguments, x and y, and returns True if x is a string that contains y, and False otherwise? \n// ",
    "c": "",
    "o": [
      "lambda x, y: y in x",
      "lambda x, y: x in y",
      "lambda x, y: y.startswith(x)",
      "lambda x, y: y.endswith(x)"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\nx = 10\n\ndef my_function():\n    global x\n    x = 20\n\nmy_function()\nprint(x)",
    "o": [
      "20",
      "10",
      "30",
      "NameError: x is not defined"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is a boolean value, and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x: isinstance(x, bool)",
      "lambda x: type(x) == bool",
      "lambda x: x.__class__ == bool",
      "lambda x: x.__class__.__name__ == 'bool'"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x <= 1:\n        return 1\n    else:\n        return x * my_function(x - 2)\n\nprint(my_function(4))",
    "o": [
      "8",
      "1",
      "2",
      "4"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes two arguments, x and y, and returns True if x is equal to y, and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x, y: x == y",
      "lambda x, y: x != y",
      "lambda x, y: x is y",
      "lambda x, y: x is not y"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x < 1:\n        return 1\n    else:\n        return x * my_function(x // 2)\n\nprint(my_function(8))",
    "o": [
      "64",
      "1",
      "8",
      "16"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 0:\n        return 0\n    else:\n        return x + my_function(x - 1)\n\nprint(my_function(5))",
    "o": [
      "15",
      "10",
      "20",
      "25"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 1:\n        return 1\n    else:\n        return x + my_function(x // 2)\n\nprint(my_function(6))",
    "o": [
      "10",
      "1",
      "6",
      "9"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is a list, and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x: isinstance(x, list)",
      "lambda x: type(x) == list",
      "lambda x: x.__class__ == list",
      "lambda x: x.__class__.__name__ == 'list'"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 1:\n        return 1\n    else:\n        return x * my_function(x - 1)\n\nprint(my_function(4))",
    "o": [
      "24",
      "1",
      "2",
      "6"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes two arguments, x and y, and returns True if x is less than or equal to y, and False otherwise?  \n// ",
    "c": "",
    "o": [
      "lambda x, y: x <= y",
      "lambda x, y: x < y",
      "lambda x, y: x >= y",
      "lambda x, y: x > y"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x <= 1:\n        return 1\n    else:\n        return my_function(x - 1) + my_function(x - 2)\n\nprint(my_function(6))",
    "o": [
      "13",
      "5",
      "10",
      "8"
    ]
  },
  {
    "q": "\n// Which of the following is the correct way to define a lambda function that takes two arguments, x and y, and returns True if x is greater than or equal to y, and False otherwise?\n// ",
    "c": "",
    "o": [
      "lambda x, y: x >= y",
      "lambda x, y: x <= y",
      "lambda x, y: x > y",
      "lambda x, y: x < y"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 1:\n        return 1\n    elif x == 2:\n        return 2\n    else:\n        return my_function(x - 1) + my_function(x - 2)\n\nprint(my_function(5))",
    "o": [
      "8",
      "3",
      "5",
      "13"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 0:\n        return 0\n    else:\n        return my_function(x - 1) + x\n\nprint(my_function(4))",
    "o": [
      "10",
      "4",
      "12",
      "16"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 0:\n        return 1\n    else:\n        return 2 * my_function(x - 1)\n\nprint(my_function(4))",
    "o": [
      "16",
      "4",
      "12",
      "8"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 0:\n        return 0\n    else:\n        return my_function(x // 2) + 1\n\nprint(my_function(10))",
    "o": [
      "4",
      "2",
      "3",
      "5"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 0:\n        return 1\n    else:\n        return x * my_function(x - 1)\n\nprint(my_function(4))",
    "o": [
      "24",
      "4",
      "8",
      "12"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 0:\n        return 1\n    else:\n        return my_function(x // 2) + my_function(x // 2)\n\nprint(my_function(10))",
    "o": [
      "16",
      "2",
      "4",
      "5"
    ]
  },
  {
    "q": "\nWhich of the following is the correct way to define a lambda function that takes two arguments, x and y, and returns the larger of the two?\n",
    "c": "",
    "o": [
      "lambda x, y: x if x > y else y",
      "lambda x, y: x if x < y else y",
      "lambda x, y: x > y",
      "lambda x, y: x < y"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 1:\n        return 1\n    else:\n        return x + my_function(x - 1)\n\nprint(my_function(5))",
    "o": [
      "15",
      "5",
      "10",
      "20"
    ]
  },
  {
    "q": "\nWhich of the following is the correct way to define a lambda function that takes a single argument, x, and returns True if x is even, and False otherwise?\n",
    "c": "",
    "o": [
      "lambda x: x % 2 == 0",
      "lambda x: x % 2 == 1",
      "lambda x: x % 2",
      "lambda x: x // 2 == 0"
    ]
  },
  {
    "q": "\nWhat is the output of the following code snippet?\n",
    "c": "\ndef my_function(x):\n    if x == 1:\n        return 1\n    else:\n        return x * my_function(x - 1)\n\nprint(my_function(5))",
    "o": [
      "120",
      "5",
      "10",
      "20"
    ]
  },
  {
    "q": "What is the output of the following code snippet using default arguments?",
    "c": "def greet(name, message='Hi'):\n    return f'{message}, {name}!'\n\nprint(greet('Bob'))",
    "o": [
      "Hi, Bob!",
      "Bob, Hi!",
      "Hi!",
      "None"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with a variable number of arguments?",
    "c": null,
    "o": [
      "def my_func(*args): return sum(args)",
      "def my_func(args): return sum(args)",
      "def my_func(*args, **kwargs): return args + kwargs",
      "def my_func(args*): return sum(args)"
    ]
  },
  {
    "q": "What is the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "4",
      "1",
      "0"
    ]
  },
  {
    "q": "Which statement best describes recursion in Python?",
    "c": null,
    "o": [
      "A function that calls itself to solve a problem",
      "A function that uses loops instead of calling itself",
      "A function that only works with global variables",
      "A function that cannot return a value"
    ]
  },
  {
    "q": "What is the output of the following code using an anonymous function?",
    "c": "multiply = lambda x, y: x * y\nprint(multiply(3, 4))",
    "o": [
      "12",
      "7",
      "34",
      "None"
    ]
  },
  {
    "q": "Which of the following is a correct way to define an anonymous function in Python?",
    "c": null,
    "o": [
      "lambda x: x + 1",
      "function(x): x + 1",
      "def lambda x: x + 1",
      "lambda(x): x + 1"
    ]
  },
  {
    "q": "What is the output of the following code involving global and local variables?",
    "c": "x = 10\ndef update_value():\n    global x\n    x = 20\nupdate_value()\nprint(x)",
    "o": [
      "20",
      "10",
      "None",
      "Error"
    ]
  },
  {
    "q": "What is the difference between global and local variables in Python?",
    "c": null,
    "o": [
      "Global variables are defined outside functions and accessible everywhere, while local variables are defined inside functions and only accessible there",
      "Global variables are only used inside functions, while local variables are used outside",
      "Global variables cannot be modified, while local variables can",
      "There is no difference between global and local variables"
    ]
  },
  {
    "q": "What is the output of the following code with keyword arguments?",
    "c": "def describe_person(name, age):\n    return f'{name} is {age} years old'\n\nprint(describe_person(age=25, name='Charlie'))",
    "o": [
      "Charlie is 25 years old",
      "25 is Charlie years old",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following correctly uses a default argument in Python?",
    "c": null,
    "o": [
      "def power(base, exp=2): return base ** exp",
      "def power(base=2, exp): return base ** exp",
      "def power(base, exp=): return base ** exp",
      "def power(base, 2=exp): return base ** exp"
    ]
  },
  {
    "q": "What is the output of the following code with multiple arguments?",
    "c": "def sum_values(*numbers):\n    return sum(numbers)\n\nprint(sum_values(1, 2, 3, 4))",
    "o": [
      "10",
      "1",
      "4",
      "Error"
    ]
  },
  {
    "q": "Which type of argument allows a function to accept a dictionary of key-value pairs?",
    "c": null,
    "o": [
      "**kwargs",
      "*args",
      "args",
      "kwargs"
    ]
  },
  {
    "q": "What is the output of this recursive function calculating Fibonacci numbers?",
    "c": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(5))",
    "o": [
      "5",
      "3",
      "8",
      "1"
    ]
  },
  {
    "q": "What happens if a recursive function in Python has no base case?",
    "c": null,
    "o": [
      "It causes a stack overflow error",
      "It runs forever without error",
      "It automatically stops after 100 calls",
      "It returns None"
    ]
  },
  {
    "q": "What is the output of the following recursive code?",
    "c": "def count_down(n):\n    if n <= 0:\n        return 'Done'\n    print(n)\n    return count_down(n-1)\n\nprint(count_down(3))",
    "o": [
      "3\n2\n1\nDone",
      "Done",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a valid use case for recursion?",
    "c": null,
    "o": [
      "Calculating the factorial of a number",
      "Printing 'Hello' 10 times",
      "Adding two numbers",
      "Checking if a number is even"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with a list?",
    "c": "numbers = [1, 2, 3, 4]\nresult = list(map(lambda x: x * 2, numbers))\nprint(result)",
    "o": [
      "[2, 4, 6, 8]",
      "[1, 2, 3, 4]",
      "8",
      "Error"
    ]
  },
  {
    "q": "Which of the following anonymous functions correctly adds 5 to a number?",
    "c": null,
    "o": [
      "lambda x: x + 5",
      "lambda x: x * 5",
      "lambda: x + 5",
      "lambda x + 5"
    ]
  },
  {
    "q": "What is the output of this code using an anonymous function with filter?",
    "c": "numbers = [1, 2, 3, 4, 5]\nevens = list(filter(lambda x: x % 2 == 0, numbers))\nprint(evens)",
    "o": [
      "[2, 4]",
      "[1, 3, 5]",
      "[1, 2, 3, 4, 5]",
      "None"
    ]
  },
  {
    "q": "What is a key characteristic of an anonymous function in Python?",
    "c": null,
    "o": [
      "It has no name and is defined using lambda",
      "It must have a name like regular functions",
      "It can only be used inside loops",
      "It cannot take arguments"
    ]
  },
  {
    "q": "What is the output of this code with a local variable shadowing a global one?",
    "c": "x = 50\ndef modify():\n    x = 100\n    print(x)\nmodify()\nprint(x)",
    "o": [
      "100\n50",
      "50\n100",
      "100\n100",
      "50\n50"
    ]
  },
  {
    "q": "What happens if you try to modify a global variable inside a function without the 'global' keyword?",
    "c": null,
    "o": [
      "Python creates a new local variable instead",
      "The global variable is modified automatically",
      "The program crashes with an error",
      "Nothing happens"
    ]
  },
  {
    "q": "What is the output of this code using both global and local variables?",
    "c": "count = 0\ndef increment():\n    local_count = 5\n    global count\n    count += 1\n    return local_count + count\nprint(increment())\nprint(count)",
    "o": [
      "6\n1",
      "5\n0",
      "6\n0",
      "5\n1"
    ]
  },
  {
    "q": "Which keyword is used to access a global variable inside a function without modifying it?",
    "c": null,
    "o": [
      "nonlocal",
      "global",
      "local",
      "extern"
    ]
  },
  {
    "q": "What is the output of this code using a mix of positional and keyword arguments?",
    "c": "def build_profile(first, last, age=0):\n    return f'{first} {last}, Age: {age}'\n\nprint(build_profile('John', 'Doe', age=30))",
    "o": [
      "John Doe, Age: 30",
      "John Doe, Age: 0",
      "Error",
      "30 John Doe"
    ]
  },
  {
    "q": "Which of the following correctly passes a dictionary as keyword arguments to a function?",
    "c": "def display_info(name, job):\n    return f'{name} works as {job}'\ninfo = {'name': 'Alice', 'job': 'Engineer'}\n# Call here",
    "o": [
      "display_info(**info)",
      "display_info(*info)",
      "display_info(info)",
      "display_info(**info, name='Alice')"
    ]
  },
  {
    "q": "What is the output of this code with a function accepting arbitrary keyword arguments?",
    "c": "def print_details(**kwargs):\n    for key, value in kwargs.items():\n        print(f'{key}: {value}')\nprint_details(name='Eve', age=28)",
    "o": [
      "name: Eve\nage: 28",
      "Eve: name\n28: age",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is a limitation of using default arguments in Python?",
    "c": null,
    "o": [
      "Mutable default arguments like lists can retain changes across calls",
      "Default arguments must always be integers",
      "Default arguments cannot be used with *args",
      "Default arguments are not allowed in Python"
    ]
  },
  {
    "q": "What is the output of this recursive function summing numbers?",
    "c": "def sum_to_n(n):\n    if n <= 1:\n        return n\n    return n + sum_to_n(n-1)\n\nprint(sum_to_n(5))",
    "o": [
      "15",
      "5",
      "1",
      "10"
    ]
  },
  {
    "q": "What is the output of this recursive string reversal?",
    "c": "def reverse_string(s):\n    if len(s) <= 1:\n        return s\n    return reverse_string(s[1:]) + s[0]\n\nprint(reverse_string('hello'))",
    "o": [
      "olleh",
      "hello",
      "Error",
      "h"
    ]
  },
  {
    "q": "Which of the following recursive functions will terminate correctly?",
    "c": null,
    "o": [
      "def func(n): return n if n == 0 else func(n-1)",
      "def func(n): return func(n+1)",
      "def func(n): return n * func(n)",
      "def func(n): return func(n)"
    ]
  },
  {
    "q": "What is a potential downside of recursion in Python?",
    "c": null,
    "o": [
      "It can lead to a stack overflow for very deep recursions",
      "It is always slower than iteration",
      "It cannot handle large inputs",
      "It cannot use base cases"
    ]
  },
  {
    "q": "What is the output of this anonymous function sorting a list?",
    "c": "pairs = [(1, 'one'), (3, 'three'), (2, 'two')]\nsorted_pairs = sorted(pairs, key=lambda x: x[0])\nprint(sorted_pairs)",
    "o": [
      "[(1, 'one'), (2, 'two'), (3, 'three')]",
      "[(3, 'three'), (2, 'two'), (1, 'one')]",
      "[(1, 'one'), (3, 'three'), (2, 'two')]",
      "Error"
    ]
  },
  {
    "q": "What is the output of this nested anonymous function?",
    "c": "add = lambda x: lambda y: x + y\nresult = add(5)(3)\nprint(result)",
    "o": [
      "8",
      "5",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following uses an anonymous function to check if a number is positive?",
    "c": null,
    "o": [
      "lambda x: x > 0",
      "lambda x: x < 0",
      "lambda x: x == 0",
      "lambda x: x + 0"
    ]
  },
  {
    "q": "What is the primary use case for anonymous functions in Python?",
    "c": null,
    "o": [
      "Short, one-time use functions often passed as arguments",
      "Defining complex multi-line functions",
      "Replacing all named functions",
      "Storing large amounts of data"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable?",
    "c": "def outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x = 20\n    inner()\n    return x\nprint(outer())",
    "o": [
      "20",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the output of this code with a global variable accessed but not modified?",
    "c": "total = 100\ndef check_total():\n    return total\nprint(check_total())",
    "o": [
      "100",
      "0",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following correctly uses the nonlocal keyword?",
    "c": "def outer():\n    count = 1\n    def inner():\n        # Modify count here\n        return count\n    inner()\n    return count",
    "o": [
      "nonlocal count; count += 1",
      "global count; count += 1",
      "local count; count += 1",
      "count += 1"
    ]
  },
  {
    "q": "What happens when a local variable has the same name as a global variable?",
    "c": null,
    "o": [
      "The local variable shadows the global variable within the function",
      "The global variable is automatically modified",
      "Python throws an error",
      "The local variable is ignored"
    ]
  },
  {
    "q": "What is the output of this code with multiple nested scopes?",
    "c": "x = 1\ndef outer():\n    x = 2\n    def inner():\n        x = 3\n        return x\n    return inner()\nprint(outer())\nprint(x)",
    "o": [
      "3\n1",
      "2\n1",
      "3\n2",
      "1\n1"
    ]
  },
  {
    "q": "Which keyword allows a nested function to modify a variable from its enclosing scope?",
    "c": null,
    "o": [
      "nonlocal",
      "global",
      "local",
      "static"
    ]
  },
  {
    "q": "What is the output of this code using required and optional arguments?",
    "c": "def create_message(sender, recipient, greeting='Hello'):\n    return f'{greeting}, {recipient} from {sender}'\n\nprint(create_message('Alice', 'Bob'))",
    "o": [
      "Hello, Bob from Alice",
      "Alice, Bob from Hello",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following enforces a positional-only argument in Python?",
    "c": null,
    "o": [
      "def func(a, /): return a",
      "def func(a, *): return a",
      "def func(a, **): return a",
      "def func(/, a): return a"
    ]
  },
  {
    "q": "What is the output of this code unpacking a list into arguments?",
    "c": "def multiply(a, b, c):\n    return a * b * c\nnumbers = [2, 3, 4]\nprint(multiply(*numbers))",
    "o": [
      "24",
      "9",
      "2",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of the * operator in a function definition?",
    "c": null,
    "o": [
      "It allows the function to accept any number of positional arguments",
      "It multiplies all arguments together",
      "It marks an argument as optional",
      "It indicates a keyword-only argument"
    ]
  },
  {
    "q": "What is the output of this recursive function finding the power of a number?",
    "c": "def power(base, exp):\n    if exp == 0:\n        return 1\n    return base * power(base, exp-1)\n\nprint(power(2, 3))",
    "o": [
      "8",
      "6",
      "2",
      "1"
    ]
  },
  {
    "q": "What is the output of this recursive function counting digits?",
    "c": "def count_digits(n):\n    if n < 10:\n        return 1\n    return 1 + count_digits(n // 10)\n\nprint(count_digits(1234))",
    "o": [
      "4",
      "1",
      "1234",
      "Error"
    ]
  },
  {
    "q": "Which of the following recursive functions correctly computes the sum of a list?",
    "c": null,
    "o": [
      "def sum_list(lst): return 0 if not lst else lst[0] + sum_list(lst[1:])",
      "def sum_list(lst): return lst[0] + sum_list(lst)",
      "def sum_list(lst): return lst if not lst else sum_list(lst[1:])",
      "def sum_list(lst): return sum_list(lst[1:])"
    ]
  },
  {
    "q": "What is the base case in a recursive function?",
    "c": null,
    "o": [
      "The condition that stops the recursion",
      "The initial call to the function",
      "The recursive call itself",
      "The final return value"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a conditional?",
    "c": "check = lambda x: 'Positive' if x > 0 else 'Negative or Zero'\nprint(check(5))",
    "o": [
      "Positive",
      "Negative or Zero",
      "5",
      "Error"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with reduce?",
    "c": "from functools import reduce\nproduct = reduce(lambda x, y: x * y, [1, 2, 3, 4])\nprint(product)",
    "o": [
      "24",
      "10",
      "4",
      "Error"
    ]
  },
  {
    "q": "Which of the following anonymous functions correctly computes the square of a number?",
    "c": null,
    "o": [
      "lambda x: x * x",
      "lambda x: x + x",
      "lambda x: x / x",
      "lambda x: x - x"
    ]
  },
  {
    "q": "Why are anonymous functions often used with higher-order functions like map() and filter()?",
    "c": null,
    "o": [
      "They provide a concise way to define the operation inline",
      "They are required by these functions",
      "They are faster than named functions",
      "They can only be used in these contexts"
    ]
  },
  {
    "q": "What is the output of this code with a local variable in a nested function?",
    "c": "def outer():\n    x = 5\n    def inner():\n        y = 10\n        return x + y\n    return inner()\nprint(outer())",
    "o": [
      "15",
      "5",
      "10",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code attempting to access a global variable?",
    "c": "value = 25\ndef get_value():\n    print(value)\n    value = 50\nget_value()",
    "o": [
      "Error",
      "25",
      "50",
      "25\n50"
    ]
  },
  {
    "q": "Which of the following correctly modifies a nonlocal variable?",
    "c": "def outer():\n    num = 10\n    def inner():\n        # Modify num here\n        return num\n    inner()\n    return num",
    "o": [
      "nonlocal num; num = 20",
      "global num; num = 20",
      "num = 20",
      "local num; num = 20"
    ]
  },
  {
    "q": "What happens when a function tries to access an undefined local variable?",
    "c": null,
    "o": [
      "It raises an UnboundLocalError",
      "It uses the global variable instead",
      "It defaults to None",
      "It ignores the variable"
    ]
  },
  {
    "q": "What is the output of this code with global and nonlocal variables?",
    "c": "g = 1\ndef outer():\n    o = 2\n    def inner():\n        nonlocal o\n        global g\n        o = 3\n        g = 4\n        return o + g\n    return inner()\nprint(outer())\nprint(g)",
    "o": [
      "7\n4",
      "3\n1",
      "7\n1",
      "Error"
    ]
  },
  {
    "q": "What is the scope of a variable defined inside a function without global or nonlocal keywords?",
    "c": null,
    "o": [
      "Local to that function",
      "Global to the entire program",
      "Nonlocal to the enclosing function",
      "Accessible only in nested functions"
    ]
  },
  {
    "q": "What is the output of this code with a closure?",
    "c": "def make_multiplier(n):\n    return lambda x: x * n\nmult_by_3 = make_multiplier(3)\nprint(mult_by_3(4))",
    "o": [
      "12",
      "7",
      "3",
      "4"
    ]
  },
  {
    "q": "What is the output of this code with keyword-only arguments?",
    "c": "def order_food(main, *, drink='water'):\n    return f'Main: {main}, Drink: {drink}'\n\nprint(order_food('pizza', drink='soda'))",
    "o": [
      "Main: pizza, Drink: soda",
      "Main: pizza, Drink: water",
      "Error",
      "pizza soda"
    ]
  },
  {
    "q": "Which of the following defines a function with a mix of positional-only and keyword-only arguments?",
    "c": null,
    "o": [
      "def func(a, /, b, *, c): return a + b + c",
      "def func(a, *, b, /, c): return a + b + c",
      "def func(a, b, c, /, *): return a + b + c",
      "def func(/, a, b, *, c): return a + b + c"
    ]
  },
  {
    "q": "What is the output of this code passing a tuple as arguments?",
    "c": "def add_three(x, y, z):\n    return x + y + z\nt = (1, 2, 3)\nprint(add_three(*t))",
    "o": [
      "6",
      "3",
      "123",
      "Error"
    ]
  },
  {
    "q": "What does the / symbol in a function definition indicate?",
    "c": null,
    "o": [
      "Arguments before it are positional-only",
      "Arguments after it are positional-only",
      "It separates required and optional arguments",
      "It indicates a variable number of arguments"
    ]
  },
  {
    "q": "What is the output of this recursive function finding the greatest common divisor (GCD)?",
    "c": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nprint(gcd(48, 18))",
    "o": [
      "6",
      "48",
      "18",
      "0"
    ]
  },
  {
    "q": "What is the output of this recursive function generating a sequence?",
    "c": "def sequence(n):\n    if n <= 1:\n        return [1]\n    prev = sequence(n-1)\n    return prev + [prev[-1] * 2]\n\nprint(sequence(3))",
    "o": [
      "[1, 2, 4]",
      "[1, 1, 2]",
      "[1, 3, 6]",
      "Error"
    ]
  },
  {
    "q": "Which recursive function correctly calculates the length of a string?",
    "c": null,
    "o": [
      "def str_len(s): return 0 if not s else 1 + str_len(s[1:])",
      "def str_len(s): return 1 + str_len(s)",
      "def str_len(s): return s if not s else str_len(s[1:])",
      "def str_len(s): return str_len(s[1:]) + 1"
    ]
  },
  {
    "q": "What is tail recursion?",
    "c": null,
    "o": [
      "A recursive call that is the last operation in the function",
      "A recursive call that occurs at the start of the function",
      "A recursive function with multiple base cases",
      "A recursive function that uses a loop"
    ]
  },
  {
    "q": "What is the output of this anonymous function with multiple arguments?",
    "c": "combine = lambda x, y, z: x + y + z\nprint(combine('a', 'b', 'c'))",
    "o": [
      "abc",
      "a b c",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with a list comprehension?",
    "c": "nums = [1, 2, 3]\nresult = [lambda x: x * n for n in nums]\nprint(result[1](5))",
    "o": [
      "10",
      "5",
      "15",
      "Error"
    ]
  },
  {
    "q": "Which of the following anonymous functions correctly returns the maximum of two numbers?",
    "c": null,
    "o": [
      "lambda x, y: x if x > y else y",
      "lambda x, y: x + y",
      "lambda x, y: x < y",
      "lambda x, y: x * y"
    ]
  },
  {
    "q": "What is a limitation of anonymous functions in Python?",
    "c": null,
    "o": [
      "They can only contain a single expression",
      "They cannot take arguments",
      "They must be named",
      "They cannot be used with map()"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a loop?",
    "c": "def outer():\n    count = 0\n    def inner():\n        nonlocal count\n        count += 1\n        return count\n    inner()\n    inner()\n    return count\nprint(outer())",
    "o": [
      "2",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable shadowed by a parameter?",
    "c": "x = 100\ndef shadow(x):\n    return x + 1\nprint(shadow(5))\nprint(x)",
    "o": [
      "6\n100",
      "101\n100",
      "6\n101",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly accesses a global variable inside a function?",
    "c": "x = 10\ndef use_global():\n    # Access x here\n    return x",
    "o": [
      "return x",
      "nonlocal x; return x",
      "global x; x = 20; return x",
      "local x; return x"
    ]
  },
  {
    "q": "What happens if you use the nonlocal keyword with a variable that isnt in the enclosing scope?",
    "c": null,
    "o": [
      "It raises a SyntaxError",
      "It creates a new local variable",
      "It accesses the global variable instead",
      "It ignores the keyword"
    ]
  },
  {
    "q": "What is the output of this code with nested functions and scope?",
    "c": "def outer():\n    a = 1\n    def middle():\n        b = 2\n        def inner():\n            return a + b\n        return inner()\n    return middle()\nprint(outer())",
    "o": [
      "3",
      "1",
      "2",
      "Error"
    ]
  },
  {
    "q": "What is the scope resolution order in Python for variable lookup?",
    "c": null,
    "o": [
      "Local, Enclosing, Global, Built-in",
      "Global, Local, Enclosing, Built-in",
      "Built-in, Global, Enclosing, Local",
      "Local, Global, Enclosing, Built-in"
    ]
  },
  {
    "q": "What is the output of this code with a closure modifying an enclosed variable?",
    "c": "def create_counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\ncounter = create_counter()\nprint(counter())\nprint(counter())",
    "o": [
      "1 2",
      "0 1",
      "1 1",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a mix of argument types?",
    "c": "def mixed_args(a, /, b, *, c=10):\n    return a + b + c\nprint(mixed_args(1, 2, c=3))",
    "o": [
      "6",
      "13",
      "Error",
      "3"
    ]
  },
  {
    "q": "Which of the following correctly unpacks a dictionary with extra arguments?",
    "c": "def info(name, age, city):\n    return f'{name}, {age}, {city}'\nd = {'name': 'Tom', 'age': 30}\n# Call here",
    "o": [
      "info(**d, city='NY')",
      "info(d, city='NY')",
      "info(*d, 'NY')",
      "info(**d, 'NY')"
    ]
  },
  {
    "q": "What is the output of this code with default mutable arguments?",
    "c": "def append_item(item, lst=[]):\n    lst.append(item)\n    return lst\nprint(append_item(1))\nprint(append_item(2))",
    "o": [
      "[1]\n[1, 2]",
      "[1]\n[2]",
      "Error",
      "[1, 2]\n[1, 2]"
    ]
  },
  {
    "q": "What does the * symbol after the / symbol in a function definition enforce?",
    "c": null,
    "o": [
      "Arguments after it must be keyword-only",
      "Arguments before it must be keyword-only",
      "It allows unlimited positional arguments",
      "It prevents any arguments after it"
    ]
  },
  {
    "q": "What is the output of this recursive function finding the minimum in a list?",
    "c": "def find_min(lst):\n    if len(lst) == 1:\n        return lst[0]\n    return lst[0] if lst[0] < find_min(lst[1:]) else find_min(lst[1:])\n\nprint(find_min([3, 1, 4, 1]))",
    "o": [
      "1",
      "3",
      "4",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive binary search function?",
    "c": "def binary_search(lst, target, start=0, end=None):\n    if end is None:\n        end = len(lst) - 1\n    if start > end:\n        return -1\n    mid = (start + end) // 2\n    if lst[mid] == target:\n        return mid\n    elif lst[mid] > target:\n        return binary_search(lst, target, start, mid-1)\n    else:\n        return binary_search(lst, target, mid+1, end)\n\nprint(binary_search([1, 2, 3, 4, 5], 3))",
    "o": [
      "2",
      "-1",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which recursive function correctly checks if a string is a palindrome?",
    "c": null,
    "o": [
      "def is_palindrome(s): return True if len(s) <= 1 else s[0] == s[-1] and is_palindrome(s[1:-1])",
      "def is_palindrome(s): return s == s[::-1] and is_palindrome(s[1:])",
      "def is_palindrome(s): return s[0] == s[-1] or is_palindrome(s[1:])",
      "def is_palindrome(s): return is_palindrome(s[:-1])"
    ]
  },
  {
    "q": "What is the advantage of using recursion over iteration in some cases?",
    "c": null,
    "o": [
      "It can make the code more readable and concise for problems with a natural recursive structure",
      "It is always faster than iteration",
      "It uses less memory than iteration",
      "It avoids the need for base cases"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a default argument?",
    "c": "get_value = lambda x=5: x * 2\nprint(get_value())\nprint(get_value(3))",
    "o": [
      "10\n6",
      "5\n6",
      "10\n3",
      "Error"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with sorted() and a custom key?",
    "c": "words = ['cat', 'dog', 'elephant']\nsorted_words = sorted(words, key=lambda x: len(x))\nprint(sorted_words)",
    "o": [
      "['cat', 'dog', 'elephant']",
      "['elephant', 'dog', 'cat']",
      "['dog', 'cat', 'elephant']",
      "Error"
    ]
  },
  {
    "q": "Which anonymous function correctly filters out odd numbers from a list?",
    "c": "nums = [1, 2, 3, 4, 5]\nresult = list(filter(?, nums))",
    "o": [
      "lambda x: x % 2 == 0",
      "lambda x: x % 2 != 0",
      "lambda x: x > 0",
      "lambda x: x < 5"
    ]
  },
  {
    "q": "What is the difference between a lambda function and a regular function in Python?",
    "c": null,
    "o": [
      "A lambda function is anonymous and limited to a single expression, while a regular function has a name and can contain multiple statements",
      "A lambda function can have multiple statements, while a regular function cannot",
      "A lambda function is always slower than a regular function",
      "There is no difference"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable modified across calls?",
    "c": "def outer():\n    x = 0\n    def inner():\n        nonlocal x\n        x += 2\n        return x\n    return inner\nf = outer()\nprint(f())\nprint(f())",
    "o": [
      "2\n4",
      "0\n2",
      "2\n2",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable and a local reassignment?",
    "c": "y = 5\ndef test():\n    y = 10\n    print(y)\ntest()\nprint(y)",
    "o": [
      "10\n5",
      "5\n10",
      "10\n10",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly uses nonlocal to modify an enclosing variable?",
    "c": "def outer():\n    z = 1\n    def inner():\n        # Modify z here\n        return z\n    inner()\n    return z",
    "o": [
      "nonlocal z; z = 5",
      "global z; z = 5",
      "z = 5",
      "local z; z = 5"
    ]
  },
  {
    "q": "What happens if a function assigns to a variable before declaring it as global?",
    "c": null,
    "o": [
      "It raises an UnboundLocalError",
      "It modifies the global variable anyway",
      "It creates a new global variable",
      "It ignores the assignment"
    ]
  },
  {
    "q": "What is the output of this code with nested scopes and shadowing?",
    "c": "a = 10\ndef outer():\n    a = 20\n    def inner():\n        a = 30\n        return a\n    return inner()\nprint(outer())\nprint(a)",
    "o": [
      "30\n10",
      "20\n10",
      "30\n20",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of the nonlocal keyword in Python?",
    "c": null,
    "o": [
      "To modify a variable in an enclosing (non-global) scope",
      "To declare a variable as global",
      "To prevent variable shadowing",
      "To create a new local variable"
    ]
  },
  {
    "q": "What is the output of this code with a closure and multiple calls?",
    "c": "def make_adder(n):\n    def adder(x):\n        return x + n\n    return adder\nadd_5 = make_adder(5)\nprint(add_5(3))\nprint(add_5(10))",
    "o": [
      "8\n15",
      "5\n10",
      "3\n15",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with positional-only and keyword-only arguments?",
    "c": "def calc(a, /, b, *, c):\n    return a * b + c\nprint(calc(2, 3, c=4))",
    "o": [
      "10",
      "6",
      "Error",
      "9"
    ]
  },
  {
    "q": "Which of the following correctly combines *args and **kwargs in a function?",
    "c": null,
    "o": [
      "def func(*args, **kwargs): return sum(args) + sum(kwargs.values())",
      "def func(**kwargs, *args): return sum(args) + sum(kwargs.values())",
      "def func(*args, kwargs): return sum(args) + sum(kwargs.values())",
      "def func(args, kwargs): return sum(args) + sum(kwargs.values())"
    ]
  },
  {
    "q": "What is the output of this code with a function unpacking mixed arguments?",
    "c": "def describe(*items, **details):\n    return f'Items: {list(items)}, Details: {details}'\n\nprint(describe('pen', 'book', color='blue', size='small'))",
    "o": [
      "Items: ['pen', 'book'], Details: {'color': 'blue', 'size': 'small'}",
      "Items: ['pen', 'book', 'color', 'blue'], Details: {}",
      "Error",
      "Items: [], Details: {'pen': 'book', 'color': 'blue', 'size': 'small'}"
    ]
  },
  {
    "q": "What is the significance of placing *args before **kwargs in a function definition?",
    "c": null,
    "o": [
      "It allows positional arguments to be collected before keyword arguments",
      "It ensures keyword arguments are processed first",
      "It prevents the use of positional arguments",
      "It has no significance"
    ]
  },
  {
    "q": "What is the output of this recursive function computing a triangular number?",
    "c": "def triangular(n):\n    if n <= 1:\n        return n\n    return n + triangular(n-1)\n\nprint(triangular(4))",
    "o": [
      "10",
      "4",
      "1",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function flattening a nested list?",
    "c": "def flatten(lst):\n    result = []\n    for item in lst:\n        if isinstance(item, list):\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    return result\n\nprint(flatten([1, [2, 3], [4, [5]]]))",
    "o": [
      "[1, 2, 3, 4, 5]",
      "[1, [2, 3], 4, 5]",
      "Error",
      "[1, 2, 3, [4, 5]]"
    ]
  },
  {
    "q": "Which recursive function correctly computes the product of a list?",
    "c": null,
    "o": [
      "def prod(lst): return 1 if not lst else lst[0] * prod(lst[1:])",
      "def prod(lst): return 0 if not lst else lst[0] * prod(lst[1:])",
      "def prod(lst): return lst[0] * prod(lst)",
      "def prod(lst): return prod(lst[1:]) * lst[0] if lst else 0"
    ]
  },
  {
    "q": "What is a common optimization technique for recursive functions?",
    "c": null,
    "o": [
      "Memoization to cache results of expensive calls",
      "Increasing the recursion depth limit",
      "Avoiding base cases",
      "Using global variables"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a tuple argument?",
    "c": "pair_sum = lambda t: t[0] + t[1]\nprint(pair_sum((3, 4)))",
    "o": [
      "7",
      "34",
      "Error",
      "3"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with map() over two lists?",
    "c": "a = [1, 2, 3]\nb = [4, 5, 6]\nresult = list(map(lambda x, y: x + y, a, b))\nprint(result)",
    "o": [
      "[5, 7, 9]",
      "[1, 2, 3]",
      "[4, 5, 6]",
      "Error"
    ]
  },
  {
    "q": "Which anonymous function correctly computes the cube of a number?",
    "c": null,
    "o": [
      "lambda x: x ** 3",
      "lambda x: x * 3",
      "lambda x: x + 3",
      "lambda x: x / 3"
    ]
  },
  {
    "q": "What is the benefit of using an anonymous function in a one-time operation?",
    "c": null,
    "o": [
      "It avoids cluttering the namespace with a named function",
      "It improves performance over named functions",
      "It allows multiple statements",
      "It can be reused easily"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a nested call?",
    "c": "def outer():\n    x = 3\n    def middle():\n        nonlocal x\n        x = 4\n        def inner():\n            nonlocal x\n            x = 5\n            return x\n        return inner()\n    return middle()\nprint(outer())",
    "o": [
      "5",
      "4",
      "3",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable accessed in a loop?",
    "c": "g = 0\ndef increment():\n    global g\n    for _ in range(3):\n        g += 1\n    return g\nprint(increment())\nprint(g)",
    "o": [
      "3\n3",
      "0\n3",
      "3\n0",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly shadows a global variable without modifying it?",
    "c": "x = 50\ndef shadow():\n    # Define x here\n    return x\nprint(shadow())\nprint(x)",
    "o": [
      "x = 75; return x",
      "global x; x = 75; return x",
      "nonlocal x; x = 75; return x",
      "return x + 25"
    ]
  },
  {
    "q": "What happens if a function uses a variable before its defined locally or globally?",
    "c": null,
    "o": [
      "It raises a NameError",
      "It defaults to 0",
      "It uses the built-in scope",
      "It creates the variable automatically"
    ]
  },
  {
    "q": "What is the output of this code with multiple nonlocal variables?",
    "c": "def outer():\n    a = 1\n    b = 2\n    def inner():\n        nonlocal a, b\n        a += 1\n        b += 2\n        return a + b\n    return inner()\nprint(outer())",
    "o": [
      "5",
      "3",
      "4",
      "Error"
    ]
  },
  {
    "q": "What is the LEGB rule in Python?",
    "c": null,
    "o": [
      "Local, Enclosing, Global, Built-in scope lookup order",
      "Local, External, Global, Built-in scope lookup order",
      "Global, Local, Enclosing, Built-in scope lookup order",
      "Built-in, Enclosing, Global, Local scope lookup order"
    ]
  },
  {
    "q": "What is the output of this code with a closure capturing two variables?",
    "c": "def create_op(x):\n    y = 10\n    return lambda z: x + y + z\nop = create_op(5)\nprint(op(3))",
    "o": [
      "18",
      "15",
      "8",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function enforcing keyword-only arguments?",
    "c": "def details(*, name, age):\n    return f'{name} is {age}'\nprint(details(name='Sam', age=25))",
    "o": [
      "Sam is 25",
      "Error",
      "25 is Sam",
      "None"
    ]
  },
  {
    "q": "Which of the following correctly uses a positional-only argument with a default value?",
    "c": null,
    "o": [
      "def func(a=5, /): return a * 2",
      "def func(a, /=5): return a * 2",
      "def func(*, a=5): return a * 2",
      "def func(a=5): return a * 2"
    ]
  },
  {
    "q": "What is the output of this code unpacking a dictionary with missing arguments?",
    "c": "def profile(name, job, city):\n    return f'{name} - {job} - {city}'\nd = {'name': 'Lisa', 'city': 'Paris'}\nprint(profile(**d, job='Artist'))",
    "o": [
      "Lisa - Artist - Paris",
      "Error",
      "Lisa - Paris - Artist",
      "None"
    ]
  },
  {
    "q": "What is the purpose of keyword-only arguments in Python?",
    "c": null,
    "o": [
      "To improve readability by requiring explicit argument names",
      "To allow unlimited positional arguments",
      "To enforce positional-only arguments",
      "To prevent argument unpacking"
    ]
  },
  {
    "q": "What is the output of this recursive function calculating the sum of digits?",
    "c": "def sum_digits(n):\n    if n < 10:\n        return n\n    return (n % 10) + sum_digits(n // 10)\n\nprint(sum_digits(123))",
    "o": [
      "6",
      "123",
      "3",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function generating a countdown string?",
    "c": "def countdown(n):\n    if n <= 0:\n        return '0'\n    return str(n) + ' ' + countdown(n-1)\n\nprint(countdown(3))",
    "o": [
      "3 2 1 0",
      "0 1 2 3",
      "Error",
      "3"
    ]
  },
  {
    "q": "Which recursive function correctly computes the number of vowels in a string?",
    "c": null,
    "o": [
      "def count_vowels(s): return 0 if not s else (1 if s[0] in 'aeiou' else 0) + count_vowels(s[1:])",
      "def count_vowels(s): return 1 if s[0] in 'aeiou' else count_vowels(s[1:])",
      "def count_vowels(s): return count_vowels(s[1:]) + 1 if s else 0",
      "def count_vowels(s): return s.count('aeiou')"
    ]
  },
  {
    "q": "What is a key consideration when designing a recursive function?",
    "c": null,
    "o": [
      "Ensuring a base case exists to prevent infinite recursion",
      "Maximizing the number of recursive calls",
      "Avoiding return statements",
      "Using only global variables"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a string operation?",
    "c": "capitalize = lambda s: s.capitalize()\nprint(capitalize('hello'))",
    "o": [
      "Hello",
      "hello",
      "HELLO",
      "Error"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with filter() and a condition?",
    "c": "words = ['cat', 'dog', 'elephant']\nlong_words = list(filter(lambda w: len(w) > 3, words))\nprint(long_words)",
    "o": [
      "['elephant']",
      "['cat', 'dog']",
      "['cat', 'dog', 'elephant']",
      "Error"
    ]
  },
  {
    "q": "Which anonymous function correctly checks if a string is empty?",
    "c": null,
    "o": [
      "lambda s: len(s) == 0",
      "lambda s: len(s) > 0",
      "lambda s: s == ' '",
      "lambda s: s != ''"
    ]
  },
  {
    "q": "What is a scenario where an anonymous function might be less preferable than a named function?",
    "c": null,
    "o": [
      "When the function logic is complex and spans multiple lines",
      "When the function is used only once",
      "When the function takes no arguments",
      "When the function is passed to map()"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a conditional?",
    "c": "def outer():\n    flag = False\n    def inner():\n        nonlocal flag\n        if not flag:\n            flag = True\n        return flag\n    inner()\n    return flag\nprint(outer())",
    "o": [
      "True",
      "False",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the output of this code with a global variable modified conditionally?",
    "c": "x = 1\ndef modify():\n    global x\n    if x < 5:\n        x += 2\n    return x\nprint(modify())\nprint(x)",
    "o": [
      "3\n3",
      "1\n1",
      "3\n1",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly accesses an enclosing variable without modification?",
    "c": "def outer():\n    y = 10\n    def inner():\n        # Access y here\n        return y\n    return inner()",
    "o": [
      "return y",
      "nonlocal y; y = 20; return y",
      "global y; return y",
      "local y; return y"
    ]
  },
  {
    "q": "What happens when a variable is declared global but doesnt exist in the global scope yet?",
    "c": null,
    "o": [
      "It creates the variable in the global scope",
      "It raises a NameError",
      "It uses the local scope instead",
      "It defaults to None"
    ]
  },
  {
    "q": "What is the output of this code with nested scopes and a nonlocal modification?",
    "c": "def outer():\n    x = 2\n    def middle():\n        nonlocal x\n        x = 3\n        def inner():\n            return x\n        return inner()\n    return middle()\nprint(outer())",
    "o": [
      "3",
      "2",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the significance of the enclosing scope in Python?",
    "c": null,
    "o": [
      "It allows nested functions to access variables from their parent function",
      "It defines the global scope",
      "It prevents variable shadowing",
      "It limits access to local variables"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a changing enclosed value?",
    "c": "def make_counter():\n    count = 0\n    def counter():\n        nonlocal count\n        count += 1\n        return count\n    return counter\nc = make_counter()\nprint(c())\nprint(c())\nprint(c())",
    "o": [
      "1\n2\n3",
      "0\n1\n2",
      "1\n1\n1",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function using all argument types?",
    "c": "def complex_func(a, /, b, *args, c=0, **kwargs):\n    return a + b + sum(args) + c + sum(kwargs.values())\nprint(complex_func(1, 2, 3, 4, c=5, x=6))",
    "o": [
      "21",
      "11",
      "Error",
      "6"
    ]
  },
  {
    "q": "Which of the following correctly enforces a keyword-only argument after variable arguments?",
    "c": null,
    "o": [
      "def func(*args, key): return key",
      "def func(key, *args): return key",
      "def func(*args, key=0): return key",
      "def func(key, *, args): return key"
    ]
  },
  {
    "q": "What is the output of this code unpacking multiple sequences into a function?",
    "c": "def concat(a, b, c, d):\n    return f'{a}{b}{c}{d}'\nlst = ['x', 'y']\ntup = ('z', 'w')\nprint(concat(*lst, *tup))",
    "o": [
      "xyzw",
      "Error",
      "x y z w",
      "['x', 'y', 'z', 'w']"
    ]
  },
  {
    "q": "What is the benefit of using positional-only arguments in Python?",
    "c": null,
    "o": [
      "They allow the function signature to remain flexible for future changes",
      "They enforce keyword arguments",
      "They improve performance",
      "They prevent argument unpacking"
    ]
  },
  {
    "q": "What is the output of this recursive function computing the sum of squares?",
    "c": "def sum_squares(n):\n    if n <= 0:\n        return 0\n    return n * n + sum_squares(n-1)\n\nprint(sum_squares(3))",
    "o": [
      "14",
      "9",
      "3",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function reversing a list?",
    "c": "def reverse_list(lst):\n    if not lst:\n        return []\n    return reverse_list(lst[1:]) + [lst[0]]\n\nprint(reverse_list([1, 2, 3]))",
    "o": [
      "[3, 2, 1]",
      "[1, 2, 3]",
      "Error",
      "[2, 1, 3]"
    ]
  },
  {
    "q": "Which recursive function correctly finds the maximum value in a list?",
    "c": null,
    "o": [
      "def find_max(lst): return lst[0] if len(lst) == 1 else lst[0] if lst[0] > find_max(lst[1:]) else find_max(lst[1:])",
      "def find_max(lst): return lst[0] + find_max(lst[1:]) if lst else 0",
      "def find_max(lst): return max(lst[0], find_max(lst))",
      "def find_max(lst): return find_max(lst[1:]) if len(lst) > 1 else 0"
    ]
  },
  {
    "q": "What is a potential inefficiency of recursion compared to iteration?",
    "c": null,
    "o": [
      "It uses more stack space due to repeated function calls",
      "It requires more variables",
      "It cannot handle large datasets",
      "It is always less readable"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a list operation?",
    "c": "double_first = lambda lst: lst[0] * 2\nprint(double_first([3, 4, 5]))",
    "o": [
      "6",
      "3",
      "Error",
      "[6, 4, 5]"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with reduce() and a string?",
    "c": "from functools import reduce\njoin = reduce(lambda x, y: x + y, ['a', 'b', 'c'])\nprint(join)",
    "o": [
      "abc",
      "['a', 'b', 'c']",
      "Error",
      "a b c"
    ]
  },
  {
    "q": "Which anonymous function correctly checks if a number is even?",
    "c": null,
    "o": [
      "lambda x: x % 2 == 0",
      "lambda x: x % 2 != 0",
      "lambda x: x > 2",
      "lambda x: x == 2"
    ]
  },
  {
    "q": "What is the primary limitation of lambda functions compared to def-defined functions?",
    "c": null,
    "o": [
      "They cannot include statements, only expressions",
      "They cannot take multiple arguments",
      "They are slower to execute",
      "They cannot be reused"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a recursive function?",
    "c": "def outer():\n    total = 0\n    def add_recursive(n):\n        nonlocal total\n        if n <= 0:\n            return total\n        total += n\n        return add_recursive(n-1)\n    add_recursive(3)\n    return total\nprint(outer())",
    "o": [
      "6",
      "3",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable in a nested function?",
    "c": "g = 10\ndef outer():\n    def inner():\n        global g\n        g = 20\n        return g\n    inner()\n    return g\nprint(outer())\nprint(g)",
    "o": [
      "20\n20",
      "10\n20",
      "20\n10",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly modifies a variable from an enclosing scope?",
    "c": "def outer():\n    v = 5\n    def inner():\n        # Modify v here\n        return v\n    inner()\n    return v",
    "o": [
      "nonlocal v; v = 10",
      "global v; v = 10",
      "v = 10",
      "local v; v = 10"
    ]
  },
  {
    "q": "What happens if a nonlocal variable is referenced before the enclosing function defines it?",
    "c": null,
    "o": [
      "It raises a SyntaxError",
      "It defaults to the global scope",
      "It creates a new local variable",
      "It uses the built-in scope"
    ]
  },
  {
    "q": "What is the output of this code with multiple closures sharing a scope?",
    "c": "def outer():\n    x = 1\n    f1 = lambda: x\n    x = 2\n    f2 = lambda: x\n    return f1(), f2()\nprint(outer())",
    "o": [
      "(2, 2)",
      "(1, 2)",
      "(1, 1)",
      "Error"
    ]
  },
  {
    "q": "What is the role of the built-in scope in Pythons variable lookup?",
    "c": null,
    "o": [
      "It provides default functions and constants if not found in other scopes",
      "It overrides all other scopes",
      "It is checked before the local scope",
      "It is only accessible with the global keyword"
    ]
  },
  {
    "q": "What is the output of this code with a closure and an updated parameter?",
    "c": "def create_multiplier(n):\n    def mult(x):\n        return x * n\n    n = 10\n    return mult\nm = create_multiplier(2)\nprint(m(3))",
    "o": [
      "30",
      "6",
      "3",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function mixing positional and keyword arguments?",
    "c": "def mix(a, b, /, c, *, d):\n    return a + b + c + d\nprint(mix(1, 2, 3, d=4))",
    "o": [
      "10",
      "Error",
      "7",
      "6"
    ]
  },
  {
    "q": "Which of the following correctly handles an optional argument with *args?",
    "c": null,
    "o": [
      "def func(x, *args, y=0): return x + sum(args) + y",
      "def func(x, y=0, *args): return x + y + sum(args)",
      "def func(*args, x, y=0): return x + sum(args) + y",
      "def func(x, *args, *y=0): return x + sum(args) + y"
    ]
  },
  {
    "q": "What is the output of this code unpacking a nested structure into arguments?",
    "c": "def combine(a, b, c):\n    return f'{a}-{b}-{c}'\ndata = ([1, 2], 3)\nprint(combine(*data[0], data[1]))",
    "o": [
      "1-2-3",
      "Error",
      "[1, 2]-3",
      "1-2-[1, 2]"
    ]
  },
  {
    "q": "What is the advantage of using *args in a function definition?",
    "c": null,
    "o": [
      "It allows flexibility in the number of positional arguments passed",
      "It enforces keyword-only arguments",
      "It limits the function to a fixed number of arguments",
      "It automatically sorts the arguments"
    ]
  },
  {
    "q": "What is the output of this recursive function computing the factorial with a twist?",
    "c": "def twisted_factorial(n):\n    if n <= 1:\n        return 1\n    return n * twisted_factorial(n-2)\n\nprint(twisted_factorial(5))",
    "o": [
      "15",
      "120",
      "5",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function building a nested list?",
    "c": "def nest(n):\n    if n <= 0:\n        return []\n    return [n, nest(n-1)]\n\nprint(nest(3))",
    "o": [
      "[3, [2, [1, []]]]",
      "[3, 2, 1]",
      "Error",
      "[1, [2, [3, []]]]"
    ]
  },
  {
    "q": "Which recursive function correctly counts occurrences of a character in a string?",
    "c": null,
    "o": [
      "def count_char(s, ch): return 0 if not s else (1 if s[0] == ch else 0) + count_char(s[1:], ch)",
      "def count_char(s, ch): return 1 if s[0] == ch else count_char(s[1:], ch)",
      "def count_char(s, ch): return count_char(s[1:], ch) + s[0] == ch",
      "def count_char(s, ch): return s.count(ch)"
    ]
  },
  {
    "q": "What is the role of the recursion depth limit in Python?",
    "c": null,
    "o": [
      "It prevents stack overflow by limiting the number of recursive calls",
      "It speeds up recursive functions",
      "It enforces a minimum number of recursive calls",
      "It disables recursion entirely"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a dictionary operation?",
    "c": "get_value = lambda d: d['key']\nprint(get_value({'key': 42}))",
    "o": [
      "42",
      "Error",
      "{'key': 42}",
      "key"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with sorted() and reverse?",
    "c": "nums = [5, 2, 8, 1]\nsorted_nums = sorted(nums, key=lambda x: -x)\nprint(sorted_nums)",
    "o": [
      "[8, 5, 2, 1]",
      "[1, 2, 5, 8]",
      "Error",
      "[5, 2, 8, 1]"
    ]
  },
  {
    "q": "Which anonymous function correctly computes the length of a string?",
    "c": null,
    "o": [
      "lambda s: len(s)",
      "lambda s: s.length()",
      "lambda s: len(s) + 1",
      "lambda s: s.size()"
    ]
  },
  {
    "q": "What is a common use case for lambda functions in GUI programming?",
    "c": null,
    "o": [
      "Defining short callback functions for event handlers",
      "Creating complex multi-step processes",
      "Storing large datasets",
      "Replacing all function definitions"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a loop?",
    "c": "def outer():\n    x = 0\n    def inner():\n        nonlocal x\n        for i in range(2):\n            x += i\n        return x\n    inner()\n    return x\nprint(outer())",
    "o": [
      "1",
      "0",
      "2",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable shadowed locally?",
    "c": "z = 100\ndef func():\n    z = 200\n    def inner():\n        return z\n    return inner()\nprint(func())\nprint(z)",
    "o": [
      "200\n100",
      "100\n100",
      "200\n200",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly uses nonlocal with multiple nested levels?",
    "c": "def outer():\n    a = 1\n    def middle():\n        b = 2\n        def inner():\n            # Modify a here\n            return a\n        inner()\n        return a\n    return middle()",
    "o": [
      "nonlocal a; a = 3",
      "global a; a = 3",
      "a = 3",
      "local a; a = 3"
    ]
  },
  {
    "q": "What happens if you try to modify a variable without declaring it global or nonlocal?",
    "c": null,
    "o": [
      "It creates a new local variable",
      "It modifies the global variable",
      "It raises a SyntaxError",
      "It uses the enclosing scope"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a local override?",
    "c": "def outer():\n    x = 5\n    def inner():\n        x = 10\n        return x\n    return inner()\nprint(outer())",
    "o": [
      "10",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the effect of shadowing a variable in a nested function?",
    "c": null,
    "o": [
      "It hides the outer variable within the inner scope",
      "It modifies the outer variable",
      "It raises an error",
      "It merges the variables"
    ]
  },
  {
    "q": "What is the output of this code with a closure capturing a loop variable?",
    "c": "def create_funcs():\n    funcs = []\n    for i in range(3):\n        funcs.append(lambda x: x + i)\n    return funcs\nfs = create_funcs()\nprint(fs[0](1))\nprint(fs[1](1))",
    "o": [
      "3\n3",
      "1\n2",
      "0\n1",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function using positional-only and optional arguments?",
    "c": "def pos_only(a, b=2, /):\n    return a + b\nprint(pos_only(3))",
    "o": [
      "5",
      "3",
      "Error",
      "2"
    ]
  },
  {
    "q": "Which of the following correctly combines keyword-only and default arguments?",
    "c": null,
    "o": [
      "def func(*, x=1, y): return x + y",
      "def func(x=1, *, y): return x + y",
      "def func(x, y=1, *): return x + y",
      "def func(*, x, y=1=2): return x + y"
    ]
  },
  {
    "q": "What is the output of this code with mixed argument unpacking?",
    "c": "def build(a, b, c, d):\n    return f'{a}{b}{c}{d}'\nargs = {'a': 'p', 'c': 'r'}\nrest = ['q', 's']\nprint(build(**args, b=rest[0], d=rest[1]))",
    "o": [
      "pqrs",
      "Error",
      "prqs",
      "p q r s"
    ]
  },
  {
    "q": "What is the main reason for using keyword-only arguments after *args?",
    "c": null,
    "o": [
      "To clearly separate variable positional arguments from specific named ones",
      "To enforce positional-only arguments",
      "To limit the number of arguments",
      "To improve execution speed"
    ]
  },
  {
    "q": "What is the output of this recursive function calculating the sum of even numbers?",
    "c": "def sum_evens(n):\n    if n <= 0:\n        return 0\n    return (n if n % 2 == 0 else 0) + sum_evens(n-1)\n\nprint(sum_evens(5))",
    "o": [
      "6",
      "15",
      "4",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function generating a power set?",
    "c": "def power_set(lst):\n    if not lst:\n        return [[]]\n    rest = power_set(lst[1:])\n    return rest + [[lst[0]] + r for r in rest]\n\nprint(power_set([1, 2]))",
    "o": [
      "[[], [2], [1], [1, 2]]",
      "[[1, 2], [1], [2]]",
      "Error",
      "[[1], [2]]"
    ]
  },
  {
    "q": "Which recursive function correctly computes the depth of a nested list?",
    "c": null,
    "o": [
      "def depth(lst): return 1 if not isinstance(lst, list) or not lst else 1 + max(depth(x) for x in lst)",
      "def depth(lst): return len(lst) if isinstance(lst, list) else 0",
      "def depth(lst): return 1 + depth(lst[0]) if lst else 0",
      "def depth(lst): return depth(lst[1:]) + 1"
    ]
  },
  {
    "q": "What is a practical use of recursion in tree-like data structures?",
    "c": null,
    "o": [
      "Traversing or processing hierarchical nodes",
      "Sorting flat lists",
      "Performing linear searches",
      "Counting elements in a set"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a conditional expression?",
    "c": "sign = lambda x: 'positive' if x > 0 else 'negative' if x < 0 else 'zero'\nprint(sign(-5))",
    "o": [
      "negative",
      "positive",
      "zero",
      "Error"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with map() and a string?",
    "c": "text = 'abc'\nresult = ''.join(map(lambda x: x.upper(), text))\nprint(result)",
    "o": [
      "ABC",
      "abc",
      "Error",
      "A B C"
    ]
  },
  {
    "q": "Which anonymous function correctly doubles every element in a list?",
    "c": null,
    "o": [
      "lambda x: [i * 2 for i in x]",
      "lambda x: x * 2",
      "lambda x: [x * 2]",
      "lambda x: x + x"
    ]
  },
  {
    "q": "What is an advantage of lambda functions in functional programming?",
    "c": null,
    "o": [
      "They enable concise inline definitions for operations like mapping and filtering",
      "They allow complex logic with multiple statements",
      "They improve memory usage over regular functions",
      "They replace recursion entirely"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a nested loop?",
    "c": "def outer():\n    count = 0\n    def inner():\n        nonlocal count\n        for i in range(2):\n            for j in range(2):\n                count += 1\n        return count\n    inner()\n    return count\nprint(outer())",
    "o": [
      "4",
      "2",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable and a nested override?",
    "c": "g = 50\ndef outer():\n    g = 75\n    def inner():\n        global g\n        g = 100\n        return g\n    inner()\n    return g\nprint(outer())\nprint(g)",
    "o": [
      "75\n100",
      "100\n100",
      "75\n50",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly modifies a variable two levels up?",
    "c": "def outer():\n    x = 1\n    def middle():\n        def inner():\n            # Modify x here\n            return x\n        inner()\n        return x\n    return middle()",
    "o": [
      "nonlocal x; x = 2",
      "global x; x = 2",
      "x = 2",
      "local x; x = 2"
    ]
  },
  {
    "q": "What happens when a variable is accessed in a function with no local or enclosing definition?",
    "c": null,
    "o": [
      "It looks in the global scope, then built-in scope",
      "It raises a SyntaxError",
      "It creates a new local variable",
      "It defaults to zero"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a shadowed variable?",
    "c": "def outer():\n    x = 5\n    def inner():\n        x = 10\n        return lambda: x\n    return inner()()\nprint(outer())",
    "o": [
      "10",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the significance of scope in Pythons function execution?",
    "c": null,
    "o": [
      "It determines where variables are looked up and modified",
      "It controls the speed of function calls",
      "It limits the number of arguments",
      "It prevents recursion"
    ]
  },
  {
    "q": "What is the output of this code with a closure and an external update?",
    "c": "def create_tracker():\n    state = 0\n    def tracker():\n        nonlocal state\n        state += 1\n        return state\n    return tracker\nt = create_tracker()\nt()\nprint(t())",
    "o": [
      "2",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function enforcing all keyword-only arguments?",
    "c": "def all_keyword(*, a, b, c):\n    return a + b + c\nprint(all_keyword(a=1, b=2, c=3))",
    "o": [
      "6",
      "Error",
      "123",
      "None"
    ]
  },
  {
    "q": "Which of the following correctly uses *args with a default argument after it?",
    "c": null,
    "o": [
      "def func(*args, x=5): return sum(args) + x",
      "def func(x=5, *args): return x + sum(args)",
      "def func(*args, *x=5): return sum(args) + x",
      "def func(*, *args, x=5): return sum(args) + x"
    ]
  },
  {
    "q": "What is the output of this code with complex argument unpacking?",
    "c": "def assemble(w, x, y, z):\n    return f'{w}{x}{y}{z}'\nd = {'w': 'a', 'y': 'c'}\nl = ['b', 'd']\nprint(assemble(**d, x=l[0], z=l[1]))",
    "o": [
      "abcd",
      "Error",
      "acbd",
      "a b c d"
    ]
  },
  {
    "q": "What is the purpose of combining positional-only and keyword-only arguments?",
    "c": null,
    "o": [
      "To provide flexibility while enforcing specific argument passing styles",
      "To limit the total number of arguments",
      "To ensure all arguments are optional",
      "To prevent argument unpacking"
    ]
  },
  {
    "q": "What is the output of this recursive function computing the product of odds?",
    "c": "def prod_odds(n):\n    if n <= 0:\n        return 1\n    return (n if n % 2 != 0 else 1) * prod_odds(n-1)\n\nprint(prod_odds(5))",
    "o": [
      "15",
      "5",
      "1",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function creating a mirrored string?",
    "c": "def mirror(s):\n    if len(s) <= 1:\n        return s\n    return s[0] + mirror(s[1:]) + s[0]\n\nprint(mirror('abc'))",
    "o": [
      "abccba",
      "abc",
      "Error",
      "cbaabc"
    ]
  },
  {
    "q": "Which recursive function correctly sums nested list elements?",
    "c": null,
    "o": [
      "def sum_nested(lst): return sum(sum_nested(x) if isinstance(x, list) else x for x in lst)",
      "def sum_nested(lst): return lst[0] + sum_nested(lst[1:]) if lst else 0",
      "def sum_nested(lst): return sum(lst) + sum_nested(lst[1:])",
      "def sum_nested(lst): return sum_nested(lst[1:]) if isinstance(lst, list) else lst"
    ]
  },
  {
    "q": "What is a key benefit of recursion in divide-and-conquer algorithms?",
    "c": null,
    "o": [
      "It naturally splits problems into smaller subproblems",
      "It eliminates the need for base cases",
      "It reduces memory usage",
      "It avoids function calls"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a tuple unpacking?",
    "c": "unpack = lambda x, y: x - y\nprint(unpack(*[3, 2]))",
    "o": [
      "1",
      "Error",
      "5",
      "3"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with filter() on numbers?",
    "c": "nums = [1, -2, 3, -4]\npositives = list(filter(lambda x: x > 0, nums))\nprint(positives)",
    "o": [
      "[1, 3]",
      "[-2, -4]",
      "Error",
      "[1, -2, 3, -4]"
    ]
  },
  {
    "q": "Which anonymous function correctly returns the first character of a string?",
    "c": null,
    "o": [
      "lambda s: s[0]",
      "lambda s: s[-1]",
      "lambda s: s[1]",
      "lambda s: s[:]"
    ]
  },
  {
    "q": "What is a potential downside of overusing lambda functions?",
    "c": null,
    "o": [
      "They can reduce code readability if overly complex",
      "They increase execution time",
      "They cannot be debugged",
      "They limit argument flexibility"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a recursive call?",
    "c": "def outer():\n    x = 0\n    def inner(n):\n        nonlocal x\n        if n <= 0:\n            return x\n        x += n\n        return inner(n-1)\n    return inner(2)\nprint(outer())",
    "o": [
      "3",
      "2",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable and a local conflict?",
    "c": "v = 10\ndef outer():\n    v = 20\n    def inner():\n        v = 30\n        return v\n    return inner()\nprint(outer())\nprint(v)",
    "o": [
      "30\n10",
      "20\n10",
      "30\n20",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly modifies a variable from an enclosing scope conditionally?",
    "c": "def outer():\n    flag = False\n    def inner():\n        # Modify flag here\n        return flag\n    inner()\n    return flag",
    "o": [
      "nonlocal flag; flag = True",
      "global flag; flag = True",
      "flag = True",
      "local flag; flag = True"
    ]
  },
  {
    "q": "What happens if a function attempts to use nonlocal on a global variable?",
    "c": null,
    "o": [
      "It raises a SyntaxError",
      "It modifies the global variable",
      "It creates a new local variable",
      "It ignores the nonlocal keyword"
    ]
  },
  {
    "q": "What is the output of this code with nested closures?",
    "c": "def outer():\n    a = 1\n    def middle():\n        nonlocal a\n        a = 2\n        return lambda: a\n    return middle()()\nprint(outer())",
    "o": [
      "2",
      "1",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the purpose of variable scope in managing program state?",
    "c": null,
    "o": [
      "It isolates variables to prevent unintended interference",
      "It speeds up variable access",
      "It enforces global variables",
      "It limits recursion depth"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a dynamic update?",
    "c": "def make_adjuster():\n    value = 0\n    def adjust(n):\n        nonlocal value\n        value += n\n        return value\n    return adjust\na = make_adjuster()\na(3)\nprint(a(2))",
    "o": [
      "5",
      "2",
      "3",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function using positional-only and keyword-only arguments?",
    "c": "def hybrid(a, /, *, b, c=0):\n    return a + b + c\nprint(hybrid(1, b=2))",
    "o": [
      "3",
      "Error",
      "1",
      "2"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with *args and a required keyword argument?",
    "c": null,
    "o": [
      "def func(*args, key): return sum(args) + key",
      "def func(key, *args): return key + sum(args)",
      "def func(*args, *, key=0): return sum(args) + key",
      "def func(*args, key=0): return sum(args)"
    ]
  },
  {
    "q": "What is the output of this code with argument unpacking from multiple sources?",
    "c": "def format(a, b, c, d):\n    return f'{a}-{b}-{c}-{d}'\ndict_args = {'a': 'x', 'd': 'z'}\nlist_args = ['y']\nprint(format(**dict_args, b=list_args[0], c='w'))",
    "o": [
      "x-y-w-z",
      "Error",
      "x-w-y-z",
      "x y w z"
    ]
  },
  {
    "q": "What is the benefit of separating positional-only and keyword-only arguments with a / and *?",
    "c": null,
    "o": [
      "It enforces distinct calling conventions for clarity and flexibility",
      "It reduces the number of arguments allowed",
      "It speeds up function execution",
      "It prevents default arguments"
    ]
  },
  {
    "q": "What is the output of this recursive function computing alternating sums?",
    "c": "def alt_sum(n):\n    if n <= 0:\n        return 0\n    return n * (-1 if n % 2 == 0 else 1) + alt_sum(n-1)\n\nprint(alt_sum(4))",
    "o": [
      "2",
      "4",
      "-2",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function building a pattern?",
    "c": "def pattern(n):\n    if n <= 1:\n        return '1'\n    return pattern(n-1) + str(n) + pattern(n-1)\n\nprint(pattern(3))",
    "o": [
      "1213121",
      "123",
      "Error",
      "132"
    ]
  },
  {
    "q": "Which recursive function correctly computes the number of digits greater than 5?",
    "c": null,
    "o": [
      "def count_high(n): return 0 if n < 10 else (1 if n % 10 > 5 else 0) + count_high(n // 10)",
      "def count_high(n): return 1 if n > 5 else count_high(n-1)",
      "def count_high(n): return count_high(n // 10) + n % 10 > 5",
      "def count_high(n): return n.count('>5')"
    ]
  },
  {
    "q": "What is a practical application of recursion in parsing?",
    "c": null,
    "o": [
      "Breaking down nested expressions or grammars",
      "Counting flat sequences",
      "Sorting simple arrays",
      "Performing linear additions"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a nested operation?",
    "c": "nested = lambda x: (lambda y: x + y)(2)\nprint(nested(3))",
    "o": [
      "5",
      "3",
      "2",
      "Error"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with map() and a tuple?",
    "c": "pairs = [(1, 2), (3, 4)]\nsums = list(map(lambda t: t[0] + t[1], pairs))\nprint(sums)",
    "o": [
      "[3, 7]",
      "[1, 2, 3, 4]",
      "Error",
      "[2, 4]"
    ]
  },
  {
    "q": "Which anonymous function correctly reverses a string?",
    "c": null,
    "o": [
      "lambda s: s[::-1]",
      "lambda s: s.reverse()",
      "lambda s: s[1:] + s[0]",
      "lambda s: ''.join(s)"
    ]
  },
  {
    "q": "What is a key characteristic of lambda functions that makes them suitable for sorting?",
    "c": null,
    "o": [
      "They can define a custom key inline",
      "They are always faster than named functions",
      "They can include loops",
      "They store multiple values"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable across multiple calls?",
    "c": "def outer():\n    state = 0\n    def inner():\n        nonlocal state\n        state += 1\n        return state\n    return inner\nf = outer()\nf()\nprint(f())",
    "o": [
      "2",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable in a nested conditional?",
    "c": "x = 0\ndef outer():\n    global x\n    if x < 2:\n        x = 3\n        def inner():\n            global x\n            x += 1\n            return x\n        inner()\n    return x\nprint(outer())\nprint(x)",
    "o": [
      "4\n4",
      "3\n3",
      "0\n0",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly accesses an enclosing variable in a lambda?",
    "c": "def outer():\n    y = 5\n    return lambda x: x + y\nf = outer()",
    "o": [
      "f(3) returns 8",
      "f(3) returns 3",
      "f(3) raises an error",
      "f(3) returns 5"
    ]
  },
  {
    "q": "What happens if a function shadows a built-in function like len()?",
    "c": null,
    "o": [
      "The local definition takes precedence within the scope",
      "The built-in function is modified globally",
      "It raises a NameError",
      "The built-in function remains accessible"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a nonlocal update?",
    "c": "def outer():\n    count = 0\n    def inner():\n        nonlocal count\n        count += 2\n        return lambda: count\n    return inner()()\nprint(outer())",
    "o": [
      "2",
      "0",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the implication of using global variables extensively in a program?",
    "c": null,
    "o": [
      "It can lead to unintended side effects and harder debugging",
      "It improves performance",
      "It simplifies scope management",
      "It prevents variable shadowing"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a parameter override?",
    "c": "def make_op(base):\n    def op(x):\n        base = 10\n        return x + base\n    return op\nf = make_op(5)\nprint(f(3))",
    "o": [
      "13",
      "8",
      "3",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function using optional positional-only arguments?",
    "c": "def pos_opt(a=1, b=2, /):\n    return a * b\nprint(pos_opt(3))",
    "o": [
      "6",
      "3",
      "Error",
      "2"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with keyword-only arguments and defaults?",
    "c": null,
    "o": [
      "def func(*, x=0, y=1): return x + y",
      "def func(x=0, *, y=1): return x + y",
      "def func(*args, x=0, y=1): return x + y",
      "def func(x=0, y=1, *): return x + y"
    ]
  },
  {
    "q": "What is the output of this code with argument unpacking and overrides?",
    "c": "def construct(a, b, c):\n    return f'{a}{b}{c}'\nd = {'a': 'p', 'b': 'q'}\nprint(construct(**d, c='r', b='s'))",
    "o": [
      "psr",
      "pqr",
      "Error",
      "pqs"
    ]
  },
  {
    "q": "What is the primary motivation for using *args and **kwargs together?",
    "c": null,
    "o": [
      "To handle both variable positional and keyword arguments flexibly",
      "To enforce a fixed argument order",
      "To limit argument types",
      "To improve argument parsing speed"
    ]
  },
  {
    "q": "What is the output of this recursive function summing multiples of 3?",
    "c": "def sum_threes(n):\n    if n <= 0:\n        return 0\n    return (n if n % 3 == 0 else 0) + sum_threes(n-1)\n\nprint(sum_threes(6))",
    "o": [
      "9",
      "6",
      "3",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function generating a triangle pattern?",
    "c": "def triangle(n):\n    if n <= 1:\n        return '1'\n    return triangle(n-1) + ' ' + str(n)\n\nprint(triangle(4))",
    "o": [
      "1 2 3 4",
      "4 3 2 1",
      "Error",
      "1 2 3"
    ]
  },
  {
    "q": "Which recursive function correctly counts the number of even elements in a list?",
    "c": null,
    "o": [
      "def count_evens(lst): return 0 if not lst else (1 if lst[0] % 2 == 0 else 0) + count_evens(lst[1:])",
      "def count_evens(lst): return 1 if lst[0] % 2 == 0 else count_evens(lst)",
      "def count_evens(lst): return count_evens(lst[1:]) + lst[0] % 2",
      "def count_evens(lst): return len([x for x in lst if x % 2 == 0])"
    ]
  },
  {
    "q": "What is a common challenge when implementing recursive solutions?",
    "c": null,
    "o": [
      "Managing stack space for deep recursion",
      "Ensuring all arguments are keyword-only",
      "Avoiding default arguments",
      "Limiting variable scope"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a list slicing operation?",
    "c": "slice_last = lambda lst: lst[-1]\nprint(slice_last([1, 2, 3]))",
    "o": [
      "3",
      "1",
      "Error",
      "[1, 2, 3]"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with reduce() and a condition?",
    "c": "from functools import reduce\nmax_val = reduce(lambda x, y: x if x > y else y, [1, 4, 2, 5])\nprint(max_val)",
    "o": [
      "5",
      "1",
      "Error",
      "4"
    ]
  },
  {
    "q": "Which anonymous function correctly computes the average of two numbers?",
    "c": null,
    "o": [
      "lambda x, y: (x + y) / 2",
      "lambda x, y: x + y",
      "lambda x, y: x * y / 2",
      "lambda x, y: x / y"
    ]
  },
  {
    "q": "What is a typical use of lambda functions in data processing?",
    "c": null,
    "o": [
      "Applying transformations to collections via map or filter",
      "Defining recursive algorithms",
      "Managing global state",
      "Replacing all named functions"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable and a conditional update?",
    "c": "def outer():\n    value = 10\n    def inner():\n        nonlocal value\n        if value > 5:\n            value -= 2\n        return value\n    inner()\n    return value\nprint(outer())",
    "o": [
      "8",
      "10",
      "Error",
      "5"
    ]
  },
  {
    "q": "What is the output of this code with a global variable in a loop?",
    "c": "g = 1\ndef update():\n    global g\n    while g < 4:\n        g += 1\n    return g\nprint(update())\nprint(g)",
    "o": [
      "4\n4",
      "1\n1",
      "4\n1",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly accesses an enclosing variable across multiple calls?",
    "c": "def outer():\n    count = 0\n    def inner():\n        # Access count here\n        return count\n    inner()\n    count += 1\n    return inner()",
    "o": [
      "return count",
      "nonlocal count; count += 1; return count",
      "global count; return count",
      "local count; return count"
    ]
  },
  {
    "q": "What happens when a local variable shadows a global variable in a function?",
    "c": null,
    "o": [
      "The local variable is used within the function, leaving the global unchanged",
      "The global variable is modified",
      "It raises a NameError",
      "The local variable is ignored"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a nested lambda?",
    "c": "def outer():\n    x = 3\n    def inner():\n        return lambda y: x + y\n    return inner()(4)\nprint(outer())",
    "o": [
      "7",
      "3",
      "4",
      "Error"
    ]
  },
  {
    "q": "What is the benefit of isolating variables in local scopes?",
    "c": null,
    "o": [
      "It prevents accidental modification of unrelated variables",
      "It increases variable lookup speed",
      "It enforces global variable usage",
      "It limits recursion depth"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a dynamic counter?",
    "c": "def make_counter(start):\n    def counter():\n        nonlocal start\n        start += 1\n        return start\n    return counter\nc = make_counter(0)\nc()\nc()\nprint(c())",
    "o": [
      "3",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function mixing required and optional arguments?",
    "c": "def mixed(a, /, b, *, c=3):\n    return a + b + c\nprint(mixed(1, 2))",
    "o": [
      "6",
      "Error",
      "3",
      "5"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with *args followed by a keyword-only default?",
    "c": null,
    "o": [
      "def func(*args, x=10): return sum(args) + x",
      "def func(x=10, *args): return x + sum(args)",
      "def func(*args, *, x): return sum(args) + x",
      "def func(*args, x): return sum(args)"
    ]
  },
  {
    "q": "What is the output of this code with partial argument unpacking?",
    "c": "def compose(a, b, c, d):\n    return f'{a}{b}{c}{d}'\nd = {'b': 'y', 'd': 'w'}\nprint(compose('x', **d, c='z'))",
    "o": [
      "xyzw",
      "Error",
      "xzyw",
      "x y z w"
    ]
  },
  {
    "q": "What is the advantage of using keyword-only arguments for optional parameters?",
    "c": null,
    "o": [
      "It makes the function call more explicit and self-documenting",
      "It reduces the number of allowed arguments",
      "It enforces positional-only arguments",
      "It eliminates the need for defaults"
    ]
  },
  {
    "q": "What is the output of this recursive function computing the sum of powers of 2?",
    "c": "def sum_powers(n):\n    if n < 0:\n        return 0\n    return 2 ** n + sum_powers(n-1)\n\nprint(sum_powers(2))",
    "o": [
      "7",
      "4",
      "2",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function generating a nested tuple?",
    "c": "def nest_tuple(n):\n    if n <= 0:\n        return ()\n    return (n, nest_tuple(n-1))\n\nprint(nest_tuple(3))",
    "o": [
      "(3, (2, (1, ())))",
      "(1, (2, (3, ())))",
      "Error",
      "(3, 2, 1)"
    ]
  },
  {
    "q": "Which recursive function correctly counts occurrences of a value in a list?",
    "c": null,
    "o": [
      "def count_val(lst, val): return 0 if not lst else (1 if lst[0] == val else 0) + count_val(lst[1:], val)",
      "def count_val(lst, val): return 1 if lst[0] == val else count_val(lst)",
      "def count_val(lst, val): return count_val(lst[1:], val) + val",
      "def count_val(lst, val): return lst.count(val)"
    ]
  },
  {
    "q": "What is a key factor in deciding between recursion and iteration?",
    "c": null,
    "o": [
      "The problems natural structure and stack space constraints",
      "The number of arguments in the function",
      "The use of keyword-only arguments",
      "The availability of global variables"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a set operation?",
    "c": "union = lambda s: len(s)\nprint(union({1, 2, 3}))",
    "o": [
      "3",
      "Error",
      "{1, 2, 3}",
      "1"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with filter() and a string condition?",
    "c": "words = ['apple', 'bat', 'car']\nshort = list(filter(lambda w: len(w) < 4, words))\nprint(short)",
    "o": [
      "['bat', 'car']",
      "['apple']",
      "Error",
      "['apple', 'bat', 'car']"
    ]
  },
  {
    "q": "Which anonymous function correctly computes the product of two numbers?",
    "c": null,
    "o": [
      "lambda x, y: x * y",
      "lambda x, y: x + y",
      "lambda x, y: x - y",
      "lambda x, y: x / y"
    ]
  },
  {
    "q": "What is a scenario where lambda functions enhance code brevity?",
    "c": null,
    "o": [
      "Defining simple transformations in list comprehensions or map()",
      "Implementing multi-step algorithms",
      "Managing complex state",
      "Replacing recursive functions"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a nested function call?",
    "c": "def outer():\n    total = 0\n    def middle():\n        nonlocal total\n        total += 1\n        def inner():\n            nonlocal total\n            total += 2\n            return total\n        return inner()\n    middle()\n    return total\nprint(outer())",
    "o": [
      "3",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable modified in a loop?",
    "c": "x = 0\ndef modify():\n    global x\n    for i in range(2):\n        x += i + 1\n    return x\nprint(modify())\nprint(x)",
    "o": [
      "3\n3",
      "0\n0",
      "3\n0",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly uses nonlocal to update an enclosing counter?",
    "c": "def outer():\n    count = 0\n    def inner():\n        # Update count here\n        return count\n    inner()\n    return count",
    "o": [
      "nonlocal count; count += 1",
      "global count; count += 1",
      "count += 1",
      "local count; count += 1"
    ]
  },
  {
    "q": "What happens if a function accesses a variable declared nonlocal but not in an enclosing scope?",
    "c": null,
    "o": [
      "It raises a SyntaxError",
      "It uses the global scope instead",
      "It creates a new local variable",
      "It defaults to None"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a shadowed nonlocal?",
    "c": "def outer():\n    x = 5\n    def inner():\n        x = 10\n        def deeper():\n            nonlocal x\n            return x\n        return deeper()\n    return inner()\nprint(outer())",
    "o": [
      "10",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the purpose of scope isolation in large programs?",
    "c": null,
    "o": [
      "To reduce naming conflicts and improve maintainability",
      "To increase variable access speed",
      "To enforce recursion",
      "To limit argument flexibility"
    ]
  },
  {
    "q": "What is the output of this code with a closure and an incremented value?",
    "c": "def make_incrementer():\n    val = 0\n    def inc():\n        nonlocal val\n        val += 1\n        return val\n    return inc\ni = make_incrementer()\ni()\ni()\nprint(i())",
    "o": [
      "3",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function using positional-only and mixed arguments?",
    "c": "def pos_mix(a, /, b, c=5):\n    return a + b + c\nprint(pos_mix(2, 3))",
    "o": [
      "10",
      "Error",
      "5",
      "8"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with *args and multiple keyword-only arguments?",
    "c": null,
    "o": [
      "def func(*args, x, y=0): return sum(args) + x + y",
      "def func(x, y=0, *args): return x + y + sum(args)",
      "def func(*args, *, x, y): return sum(args) + x + y",
      "def func(*args, x=0, y): return sum(args)"
    ]
  },
  {
    "q": "What is the output of this code with argument unpacking from a nested dictionary?",
    "c": "def build(a, b, c):\n    return f'{a}{b}{c}'\nd = {'inner': {'a': 'p', 'b': 'q'}}\nprint(build(**d['inner'], c='r'))",
    "o": [
      "pqr",
      "Error",
      "prq",
      "p q r"
    ]
  },
  {
    "q": "What is the advantage of using / to define positional-only arguments?",
    "c": null,
    "o": [
      "It allows the function to reserve argument names for future use",
      "It enforces keyword-only arguments",
      "It reduces memory usage",
      "It limits the number of arguments"
    ]
  },
  {
    "q": "What is the output of this recursive function summing multiples of 4?",
    "c": "def sum_fours(n):\n    if n <= 0:\n        return 0\n    return (n if n % 4 == 0 else 0) + sum_fours(n-1)\n\nprint(sum_fours(8))",
    "o": [
      "12",
      "8",
      "4",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function generating a reversed sequence?",
    "c": "def rev_seq(n):\n    if n <= 0:\n        return ''\n    return str(n) + ' ' + rev_seq(n-1)\n\nprint(rev_seq(3))",
    "o": [
      "3 2 1 ",
      "1 2 3 ",
      "Error",
      "3 2"
    ]
  },
  {
    "q": "Which recursive function correctly computes the sum of squares in a list?",
    "c": null,
    "o": [
      "def sum_sq(lst): return 0 if not lst else lst[0] ** 2 + sum_sq(lst[1:])",
      "def sum_sq(lst): return lst[0] ** 2 + sum_sq(lst) if lst else 0",
      "def sum_sq(lst): return sum_sq(lst[1:]) + lst[0] if lst else 0",
      "def sum_sq(lst): return sum([x ** 2 for x in lst[1:]])"
    ]
  },
  {
    "q": "What is a benefit of recursion in problems like the Towers of Hanoi?",
    "c": null,
    "o": [
      "It mirrors the problems recursive nature for elegant solutions",
      "It avoids stack overflow",
      "It uses fewer variables",
      "It eliminates the need for iteration"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a dictionary key check?",
    "c": "has_key = lambda d, k: k in d\nprint(has_key({'a': 1}, 'a'))",
    "o": [
      "True",
      "False",
      "Error",
      "1"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with sorted() and a tuple?",
    "c": "data = [(1, 'z'), (2, 'y'), (3, 'x')]\nsorted_data = sorted(data, key=lambda t: t[1])\nprint(sorted_data)",
    "o": [
      "[(3, 'x'), (2, 'y'), (1, 'z')]",
      "[(1, 'z'), (2, 'y'), (3, 'x')]",
      "Error",
      "[(1, 'z'), (3, 'x'), (2, 'y')]"
    ]
  },
  {
    "q": "Which anonymous function correctly checks if a number is divisible by 3?",
    "c": null,
    "o": [
      "lambda x: x % 3 == 0",
      "lambda x: x % 3 != 0",
      "lambda x: x / 3",
      "lambda x: x == 3"
    ]
  },
  {
    "q": "What is a common pitfall of using lambda functions in loops?",
    "c": null,
    "o": [
      "They may capture the loop variables final value unexpectedly",
      "They cannot access loop variables",
      "They cause infinite recursion",
      "They increase memory usage significantly"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a conditional block?",
    "c": "def outer():\n    flag = 0\n    def inner():\n        nonlocal flag\n        if flag == 0:\n            flag = 1\n        return flag\n    inner()\n    inner()\n    return flag\nprint(outer())",
    "o": [
      "1",
      "0",
      "2",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable accessed and modified?",
    "c": "z = 5\ndef adjust():\n    global z\n    z -= 1\n    return z\nprint(adjust())\nprint(z)",
    "o": [
      "4\n4",
      "5\n5",
      "4\n5",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly modifies an enclosing variable in a nested lambda?",
    "c": "def outer():\n    count = 0\n    def inner():\n        nonlocal count\n        return lambda: count + 1\n    f = inner()\n    count = 2\n    return f()",
    "o": [
      "3",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "What happens if a variable is used before being defined in any scope?",
    "c": null,
    "o": [
      "It raises a NameError",
      "It defaults to 0",
      "It uses the built-in scope",
      "It creates a global variable"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a local reassignment?",
    "c": "def outer():\n    x = 10\n    def inner():\n        x = 20\n        return lambda: x\n    return inner()()\nprint(outer())",
    "o": [
      "20",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the benefit of using nonlocal over global in nested functions?",
    "c": null,
    "o": [
      "It targets the enclosing scope specifically, avoiding global pollution",
      "It improves performance",
      "It allows multiple variable modifications",
      "It prevents shadowing"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a cumulative sum?",
    "c": "def make_sum():\n    total = 0\n    def add(n):\n        nonlocal total\n        total += n\n        return total\n    return add\ns = make_sum()\ns(2)\nprint(s(3))",
    "o": [
      "5",
      "3",
      "2",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a function using mixed positional and keyword-only arguments?",
    "c": "def mixed_args(a, b, /, *, c):\n    return a + b + c\nprint(mixed_args(1, 2, c=3))",
    "o": [
      "6",
      "Error",
      "3",
      "5"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with *args and optional keyword-only arguments?",
    "c": null,
    "o": [
      "def func(*args, x=0, y=0): return sum(args) + x + y",
      "def func(x=0, y=0, *args): return x + y + sum(args)",
      "def func(*args, *, x, y=0): return sum(args) + x",
      "def func(*args, x, y=0): return sum(args)"
    ]
  },
  {
    "q": "What is the output of this code with argument unpacking from a list and dictionary?",
    "c": "def create(a, b, c):\n    return f'{a}{b}{c}'\nl = ['x']\nd = {'b': 'y', 'c': 'z'}\nprint(create(*l, **d))",
    "o": [
      "xyz",
      "Error",
      "x y z",
      "xy"
    ]
  },
  {
    "q": "What is the benefit of using * to enforce keyword-only arguments after positional ones?",
    "c": null,
    "o": [
      "It separates argument types for clarity and prevents positional misuse",
      "It limits the number of arguments",
      "It speeds up argument parsing",
      "It enforces default values"
    ]
  },
  {
    "q": "What is the output of this recursive function summing digits divisible by 2?",
    "c": "def sum_even_digits(n):\n    if n < 10:\n        return n if n % 2 == 0 else 0\n    return (n % 10 if (n % 10) % 2 == 0 else 0) + sum_even_digits(n // 10)\n\nprint(sum_even_digits(1234))",
    "o": [
      "6",
      "10",
      "4",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function generating a diamond pattern?",
    "c": "def diamond(n):\n    if n <= 1:\n        return '1'\n    return diamond(n-1) + str(n) + diamond(n-1)\n\nprint(diamond(2))",
    "o": [
      "121",
      "12",
      "Error",
      "212"
    ]
  },
  {
    "q": "Which recursive function correctly computes the number of odd elements in a list?",
    "c": null,
    "o": [
      "def count_odds(lst): return 0 if not lst else (1 if lst[0] % 2 != 0 else 0) + count_odds(lst[1:])",
      "def count_odds(lst): return 1 if lst[0] % 2 != 0 else count_odds(lst)",
      "def count_odds(lst): return count_odds(lst[1:]) + lst[0] % 2 != 0",
      "def count_odds(lst): return len([x for x in lst if x % 2 == 0])"
    ]
  },
  {
    "q": "What is a key consideration for recursion in real-world applications?",
    "c": null,
    "o": [
      "Balancing readability with performance and stack limitations",
      "Ensuring all arguments are positional-only",
      "Avoiding variable arguments",
      "Limiting scope to global variables"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a tuple length check?",
    "c": "is_pair = lambda t: len(t) == 2\nprint(is_pair((1, 2)))",
    "o": [
      "True",
      "False",
      "Error",
      "2"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with reduce() and a list?",
    "c": "from functools import reduce\nmin_val = reduce(lambda x, y: x if x < y else y, [3, 1, 4, 2])\nprint(min_val)",
    "o": [
      "1",
      "3",
      "Error",
      "4"
    ]
  },
  {
    "q": "Which anonymous function correctly computes the difference between two numbers?",
    "c": null,
    "o": [
      "lambda x, y: x - y",
      "lambda x, y: x + y",
      "lambda x, y: x * y",
      "lambda x, y: x / y"
    ]
  },
  {
    "q": "What is a practical use of lambda functions in event-driven programming?",
    "c": null,
    "o": [
      "Defining quick callbacks for event handlers",
      "Implementing recursive solutions",
      "Managing global state",
      "Replacing all function definitions"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a nested conditional?",
    "c": "def outer():\n    flag = False\n    def inner():\n        nonlocal flag\n        if not flag:\n            flag = True\n            if True:\n                flag = False\n        return flag\n    inner()\n    return flag\nprint(outer())",
    "o": [
      "False",
      "True",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the output of this code with a global variable modified conditionally?",
    "c": "g = 10\ndef tweak():\n    global g\n    if g > 5:\n        g -= 3\n    return g\nprint(tweak())\nprint(g)",
    "o": [
      "7\n7",
      "10\n10",
      "7\n10",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly accesses an enclosing variable in a nested function?",
    "c": "def outer():\n    x = 5\n    def middle():\n        def inner():\n            # Access x here\n            return x\n        return inner()\n    return middle()",
    "o": [
      "return x",
      "nonlocal x; x += 1; return x",
      "global x; return x",
      "local x; return x"
    ]
  },
  {
    "q": "What happens if a function tries to modify a variable without proper scope declaration?",
    "c": null,
    "o": [
      "It creates a new local variable",
      "It modifies the global variable",
      "It raises a SyntaxError",
      "It uses the enclosing scope"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a reassigned value?",
    "c": "def outer():\n    val = 1\n    def inner():\n        nonlocal val\n        val = 2\n        return lambda: val\n    return inner()()\nprint(outer())",
    "o": [
      "2",
      "1",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the advantage of using local variables over global ones in functions?",
    "c": null,
    "o": [
      "They reduce unintended side effects and improve encapsulation",
      "They increase execution speed",
      "They enforce recursion",
      "They limit argument flexibility"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a toggling flag?",
    "c": "def make_toggle():\n    state = False\n    def toggle():\n        nonlocal state\n        state = not state\n        return state\n    return toggle\nt = make_toggle()\nt()\nprint(t())",
    "o": [
      "False",
      "True",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the output of this code with a function using positional-only and optional keyword arguments?",
    "c": "def pos_key(a, /, b, *, c=0):\n    return a + b + c\nprint(pos_key(1, 2))",
    "o": [
      "3",
      "Error",
      "1",
      "2"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with *args and a required keyword-only argument?",
    "c": null,
    "o": [
      "def func(*args, *, key): return sum(args) + key",
      "def func(key, *args): return key + sum(args)",
      "def func(*args, key=0): return sum(args) + key",
      "def func(*args, key): return sum(args)"
    ]
  },
  {
    "q": "What is the output of this code with argument unpacking from a mixed structure?",
    "c": "def assemble(a, b, c):\n    return f'{a}{b}{c}'\nd = {'a': 'p'}\nt = ('q', 'r')\nprint(assemble(**d, *t))",
    "o": [
      "pqr",
      "Error",
      "prq",
      "p q r"
    ]
  },
  {
    "q": "What is the benefit of using a combination of / and * in a function signature?",
    "c": null,
    "o": [
      "It provides clear boundaries for argument types and enhances readability",
      "It reduces the number of arguments allowed",
      "It speeds up function calls",
      "It enforces all arguments to be optional"
    ]
  },
  {
    "q": "What is the output of this recursive function summing multiples of 5?",
    "c": "def sum_fives(n):\n    if n <= 0:\n        return 0\n    return (n if n % 5 == 0 else 0) + sum_fives(n-1)\n\nprint(sum_fives(10))",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "What is the output of this recursive function generating a staircase pattern?",
    "c": "def stairs(n):\n    if n <= 1:\n        return '1'\n    return stairs(n-1) + '\n' + str(n)\n\nprint(stairs(3))",
    "o": [
      "1\n2\n3",
      "3\n2\n1",
      "Error",
      "123"
    ]
  },
  {
    "q": "Which recursive function correctly computes the sum of positive numbers in a list?",
    "c": null,
    "o": [
      "def sum_pos(lst): return 0 if not lst else (lst[0] if lst[0] > 0 else 0) + sum_pos(lst[1:])",
      "def sum_pos(lst): return lst[0] + sum_pos(lst) if lst else 0",
      "def sum_pos(lst): return sum_pos(lst[1:]) + lst[0] if lst[0] > 0 else 0",
      "def sum_pos(lst): return sum([x for x in lst if x < 0])"
    ]
  },
  {
    "q": "What is a practical use of recursion in graph algorithms?",
    "c": null,
    "o": [
      "Exploring nodes in depth-first search",
      "Sorting edge weights",
      "Counting flat structures",
      "Performing linear traversals"
    ]
  },
  {
    "q": "What is the output of this anonymous function with a string length check?",
    "c": "is_short = lambda s: len(s) < 3\nprint(is_short('hi'))",
    "o": [
      "True",
      "False",
      "Error",
      "2"
    ]
  },
  {
    "q": "What is the output of this anonymous function used with filter() and a numeric condition?",
    "c": "nums = [0, 1, 2, 3, 4]\nevens = list(filter(lambda x: x % 2 == 0, nums))\nprint(evens)",
    "o": [
      "[0, 2, 4]",
      "[1, 3]",
      "Error",
      "[0, 1, 2, 3, 4]"
    ]
  },
  {
    "q": "Which anonymous function correctly computes the square root of a number?",
    "c": null,
    "o": [
      "lambda x: x ** 0.5",
      "lambda x: x * x",
      "lambda x: x / 2",
      "lambda x: x + 0.5"
    ]
  },
  {
    "q": "What is a key advantage of lambda functions in functional-style Python?",
    "c": null,
    "o": [
      "They enable concise, inline operations for higher-order functions",
      "They support multi-line logic",
      "They improve recursion efficiency",
      "They replace all named functions"
    ]
  },
  {
    "q": "What is the output of this code with a nonlocal variable in a recursive chain?",
    "c": "def outer():\n    total = 0\n    def inner(n):\n        nonlocal total\n        if n <= 0:\n            return total\n        total += n\n        return inner(n-1)\n    inner(3)\n    return total\nprint(outer())",
    "o": [
      "6",
      "3",
      "0",
      "Error"
    ]
  },
  {
    "q": "What is the output of this code with a global variable in a nested loop?",
    "c": "g = 0\ndef outer():\n    global g\n    for i in range(2):\n        for j in range(2):\n            g += 1\n    return g\nprint(outer())\nprint(g)",
    "o": [
      "4\n4",
      "0\n0",
      "4\n0",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly modifies an enclosing variable across nested calls?",
    "c": "def outer():\n    x = 1\n    def middle():\n        def inner():\n            nonlocal x\n            x += 1\n            return x\n        return inner()\n    middle()\n    return x",
    "o": [
      "2",
      "1",
      "Error",
      "None"
    ]
  },
  {
    "q": "What happens if a function uses a variable before declaring it nonlocal?",
    "c": null,
    "o": [
      "It raises an UnboundLocalError",
      "It uses the global variable",
      "It creates a new local variable",
      "It ignores the variable"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a lambda capturing an enclosing variable?",
    "c": "def outer():\n    val = 5\n    return lambda x: x + val\nf = outer()\nprint(f(3))",
    "o": [
      "8",
      "3",
      "5",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of the enclosing scope in closures?",
    "c": null,
    "o": [
      "It allows inner functions to retain access to outer variables",
      "It speeds up variable lookup",
      "It enforces global scope",
      "It prevents local variable use"
    ]
  },
  {
    "q": "What is the output of this code with a closure and a multiplier?",
    "c": "def make_multiplier(factor):\n    def multiply(n):\n        return n * factor\n    return multiply\nm = make_multiplier(3)\nprint(m(4))",
    "o": [
      "12",
      "4",
      "3",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def greet(name, message=\"Hello\"):\n    return f\"{message}, {name}!\"\n\nprint(greet(\"Alice\"))",
    "o": [
      "Hello, Alice!",
      "Alice, Hello!",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about function arguments in Python is TRUE?",
    "c": null,
    "o": [
      "Default arguments must come after required arguments in a function definition.",
      "A function can have only one argument.",
      "Python does not support keyword arguments.",
      "All function arguments must be passed positionally."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "4",
      "12",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about recursion is TRUE?",
    "c": null,
    "o": [
      "A recursive function must have a base case to prevent infinite recursion.",
      "Recursion is always more efficient than iteration.",
      "Python does not support recursion.",
      "Recursion is only used in mathematical calculations."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "add = lambda x, y: x + y\nprint(add(3, 7))",
    "o": [
      "10",
      "37",
      "lambda x, y: x + y",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct way to define an anonymous function in Python?",
    "c": null,
    "o": [
      "lambda x, y: x * y",
      "def lambda(x, y): return x * y",
      "function(x, y) => x * y",
      "lambda: (x, y) -> x * y"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\n\ndef modify_global():\n    global x\n    x += 5\n\nmodify_global()\nprint(x)",
    "o": [
      "15",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which statement about local and global variables in Python is correct?",
    "c": null,
    "o": [
      "A global variable can be accessed inside a function using the 'global' keyword.",
      "Local variables are accessible outside the function where they are defined.",
      "Global variables must always be passed as arguments to functions.",
      "Python does not allow global variables."
    ]
  },
  {
    "q": "What will be the output of the following function call?",
    "c": "def power(base, exp=2):\n    return base ** exp\n\nprint(power(3))",
    "o": [
      "9",
      "6",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about function parameters is TRUE?",
    "c": null,
    "o": [
      "A function can have both positional and keyword arguments.",
      "Only positional arguments are allowed in Python functions.",
      "Keyword arguments must always come before positional arguments in a function call.",
      "Functions cannot have default values for parameters."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def countdown(n):\n    if n == 0:\n        return \"Done!\"\n    else:\n        return str(n) + \" \" + countdown(n - 1)\n\nprint(countdown(3))",
    "o": [
      "3 2 1 Done!",
      "3 2 1 0",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the key characteristic of a recursive function?",
    "c": null,
    "o": [
      "It calls itself within its definition.",
      "It must return an integer value.",
      "It cannot have more than one parameter.",
      "It executes only once."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "double = lambda x: x * 2\nprint(double(4))",
    "o": [
      "8",
      "4",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is NOT a correct characteristic of a lambda function?",
    "c": null,
    "o": [
      "It can have multiple expressions.",
      "It is an anonymous function.",
      "It can take multiple arguments.",
      "It can be assigned to a variable."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 20\n\ndef show():\n    x = 10\n    print(x)\n\nshow()\nprint(x)",
    "o": [
      "10\n20",
      "20\n10",
      "10\n10",
      "Error"
    ]
  },
  {
    "q": "Which statement about local and global variables is FALSE?",
    "c": null,
    "o": [
      "A local variable declared inside a function cannot be accessed outside the function.",
      "A global variable can be modified inside a function using the 'global' keyword.",
      "Local variables have a higher precedence than global variables inside a function.",
      "Global variables can never be changed once they are declared."
    ]
  },
  {
    "q": "What will be the output of the following function call?",
    "c": "def multiply(a, b=5):\n    return a * b\n\nprint(multiply(4, 3))",
    "o": [
      "12",
      "20",
      "15",
      "Error"
    ]
  },
  {
    "q": "Which of the following function definitions is valid in Python?",
    "c": null,
    "o": [
      "def sum_values(a, b=10): return a + b",
      "def sum_values(a=10, b): return a + b",
      "def sum_values(a, b) => a + b",
      "def sum_values(a, b) { return a + b }"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "def outer():\n    x = \"local\"\n    def inner():\n        nonlocal x\n        x = \"nonlocal\"\n    inner()\n    return x\n\nprint(outer())",
    "o": [
      "nonlocal",
      "local",
      "Error",
      "None"
    ]
  },
  {
    "q": "What is the purpose of the 'nonlocal' keyword in Python?",
    "c": null,
    "o": [
      "It allows modifying a variable from the enclosing (non-global) scope inside a nested function.",
      "It makes a variable global.",
      "It declares a variable as constant.",
      "It prevents recursion in a function."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def sum_numbers(n):\n    if n == 0:\n        return 0\n    return n + sum_numbers(n - 1)\n\nprint(sum_numbers(5))",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes a lambda function in Python?",
    "c": null,
    "o": [
      "A function without a name that can have only a single expression.",
      "A function that must be called using the keyword 'lambda'.",
      "A function that can have multiple statements.",
      "A function that must be defined inside another function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def increment(n):\n    n += 1\n    return n\n\nnum = 5\nincrement(num)\nprint(num)",
    "o": [
      "5",
      "6",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is a correct way to define a function with variable-length arguments in Python?",
    "c": null,
    "o": [
      "def my_function(*args):",
      "def my_function(args*):",
      "def my_function(*args, **kwargs):",
      "def my_function(args):"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def greet(name=\"User\", age=25):\n    return f\"Hello, {name}! You are {age} years old.\"\n\nprint(greet(age=30))",
    "o": [
      "Hello, User! You are 30 years old.",
      "Hello, User! You are 25 years old.",
      "Hello, 30! You are User years old.",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct syntax to return a value from a Python function?",
    "c": null,
    "o": [
      "return value",
      "yield value",
      "exit value",
      "output value"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def sum_of_numbers(*numbers):\n    return sum(numbers)\n\nprint(sum_of_numbers(1, 2, 3, 4, 5))",
    "o": [
      "15",
      "12",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about Python functions is FALSE?",
    "c": null,
    "o": [
      "Functions in Python can return multiple values.",
      "A Python function can be passed as an argument to another function.",
      "Functions in Python cannot return objects.",
      "A Python function must always return a value."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def modify(x):\n    x = 10\n\nnum = 5\nmodify(num)\nprint(num)",
    "o": [
      "5",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about Python functions is correct?",
    "c": null,
    "o": [
      "A function can return a function in Python.",
      "Python functions must always take at least one argument.",
      "Functions in Python cannot accept arguments.",
      "Functions in Python cannot return values."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    def inner():\n        return \"Hello from inner\"\n    return inner()\n\nprint(outer())",
    "o": [
      "Hello from inner",
      "Hello from outer",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of the following is an example of a higher-order function?",
    "c": null,
    "o": [
      "A function that accepts another function as an argument or returns a function.",
      "A function that does not return anything.",
      "A function that only accepts one argument.",
      "A function that performs arithmetic operations."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def multiply_by_factor(num, factor=2):\n    return num * factor\n\nprint(multiply_by_factor(4, 5))",
    "o": [
      "20",
      "10",
      "8",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to define a recursive function?",
    "c": null,
    "o": [
      "def function_name():\n    function_name()",
      "function_name() -> function_name()",
      "function_name = function_name()",
      "def function_name():\n    function_name() if condition else stop"
    ]
  },
  {
    "q": "What is the primary use of the `*args` syntax in a Python function?",
    "c": null,
    "o": [
      "To pass a variable number of positional arguments.",
      "To pass keyword arguments.",
      "To pass a single positional argument.",
      "To pass arguments to a lambda function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def calculate(a, b=2, c=3):\n    return a * b * c\n\nprint(calculate(4))",
    "o": [
      "24",
      "12",
      "8",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to return a value from a Python function?",
    "c": null,
    "o": [
      "return value",
      "yield value",
      "output value",
      "return value, value"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def increment(x):\n    return x + 1\n\nresult = increment(5)\nprint(result)",
    "o": [
      "6",
      "5",
      "7",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes a closure in Python?",
    "c": null,
    "o": [
      "A function that remembers values from its enclosing scope.",
      "A function that returns a tuple.",
      "A function that modifies global variables.",
      "A function that is defined inside a class."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "16",
      "10",
      "4"
    ]
  },
  {
    "q": "Which of the following statements about recursion is TRUE?",
    "c": null,
    "o": [
      "A recursive function must have a base condition to prevent infinite recursion.",
      "Recursive functions always execute faster than iterative solutions.",
      "Recursion is only used for mathematical problems.",
      "A recursive function cannot return a value."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "add = lambda x, y: x + y\nprint(add(3, 5))",
    "o": [
      "8",
      "35",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of a lambda function in Python?",
    "c": null,
    "o": [
      "It can contain multiple expressions.",
      "It is an anonymous function.",
      "It can take multiple arguments.",
      "It can be assigned to a variable."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\n\ndef func():\n    global x\n    x = 20\n\nfunc()\nprint(x)",
    "o": [
      "20",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about global and local variables is TRUE?",
    "c": null,
    "o": [
      "A variable declared inside a function is local to that function unless explicitly declared global.",
      "Global variables are automatically available inside all functions without declaration.",
      "Local variables can be accessed outside the function where they are declared.",
      "A function can modify a global variable without declaring it as global."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 5\n\ndef change_x():\n    x = 10\n\nchange_x()\nprint(x)",
    "o": [
      "5",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following best describes a recursive function?",
    "c": null,
    "o": [
      "A function that calls itself.",
      "A function that contains a loop.",
      "A function that modifies global variables.",
      "A function that accepts only one argument."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = \"Hello\"\n    def inner():\n        return x + \" World\"\n    return inner\n\nfunc = outer()\nprint(func())",
    "o": [
      "Hello World",
      "Hello",
      "World",
      "Error"
    ]
  },
  {
    "q": "Which of the following is an example of using `nonlocal` in Python?",
    "c": null,
    "o": [
      "A variable declared inside a nested function that modifies a variable from the enclosing function.",
      "A variable declared inside a function that modifies a global variable.",
      "A variable declared outside all functions.",
      "A variable declared inside a loop."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def countdown(n):\n    if n == 0:\n        print(\"Done!\")\n        return\n    print(n)\n    countdown(n - 1)\n\ncountdown(3)",
    "o": [
      "3\n2\n1\nDone!",
      "3\n2\n1",
      "3\n2\n1\n0",
      "Done!"
    ]
  },
  {
    "q": "Which of the following is the correct way to modify a global variable inside a function?",
    "c": null,
    "o": [
      "Use the `global` keyword before modifying the variable.",
      "Use the `nonlocal` keyword before modifying the variable.",
      "Modify the variable without any keyword.",
      "Reassign the variable without defining it in the function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "square = lambda x: x ** 2\nprint(square(4))",
    "o": [
      "16",
      "8",
      "4",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a valid use of a lambda function?",
    "c": null,
    "o": [
      "Defining a multi-line function.",
      "Using it in a `map()` function.",
      "Passing it as an argument to another function.",
      "Using it in a `filter()` function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x = 20\n    inner()\n    return x\n\nprint(outer())",
    "o": [
      "20",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about local variables is TRUE?",
    "c": null,
    "o": [
      "A local variable is accessible only within the function where it is declared.",
      "A local variable can be accessed anywhere in the program.",
      "A local variable is automatically global if used inside a function.",
      "A local variable's value is retained across function calls."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def power(x, y):\n    return x ** y\n\nprint(power(2, 3))",
    "o": [
      "8",
      "6",
      "4",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def multiply(a, b=2):\n    return a * b\n\nprint(multiply(5))",
    "o": [
      "10",
      "5",
      "2",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about default arguments in Python is TRUE?",
    "c": null,
    "o": [
      "Default arguments are evaluated only once when the function is defined.",
      "Default arguments must always be placed before non-default arguments.",
      "Default arguments cannot be mutable data types.",
      "Default arguments must be explicitly passed when calling the function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def greet(name, msg=\"Hello\"):\n    return f\"{msg}, {name}!\"\n\nprint(greet(\"Alice\"))",
    "o": [
      "Hello, Alice!",
      "Alice, Hello!",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is a valid function definition using variable-length arguments?",
    "c": null,
    "o": [
      "def my_function(*args): pass",
      "def my_function(args*): pass",
      "def my_function(**args*): pass",
      "def my_function(args**): pass"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def my_function(a, *args):\n    return a + sum(args)\n\nprint(my_function(2, 3, 4))",
    "o": [
      "9",
      "5",
      "7",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes the `**kwargs` parameter in a Python function?",
    "c": null,
    "o": [
      "It allows passing a variable number of keyword arguments.",
      "It allows passing a variable number of positional arguments.",
      "It prevents a function from accepting any arguments.",
      "It automatically assigns values to global variables."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def my_function(**kwargs):\n    return kwargs[\"name\"]\n\nprint(my_function(name=\"Alice\"))",
    "o": [
      "Alice",
      "name",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about Python closures is TRUE?",
    "c": null,
    "o": [
      "A closure is a function that remembers the environment in which it was created.",
      "A closure cannot access variables from its enclosing scope.",
      "A closure must always be defined inside a loop.",
      "A closure is automatically a global function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 5\n    def inner():\n        return x\n    return inner\n\nfunc = outer()\nprint(func())",
    "o": [
      "5",
      "Error",
      "None",
      "outer"
    ]
  },
  {
    "q": "Which of the following best describes the difference between `global` and `nonlocal` in Python?",
    "c": null,
    "o": [
      "`global` modifies a variable in the global scope, while `nonlocal` modifies a variable in an enclosing function scope.",
      "`global` and `nonlocal` can be used interchangeably.",
      "`nonlocal` is used to declare a variable as global.",
      "`global` can only be used inside a loop."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\n\ndef outer():\n    x = 5\n    def inner():\n        nonlocal x\n        x += 1\n        return x\n    return inner\n\nfunc = outer()\nprint(func())",
    "o": [
      "6",
      "5",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about function decorators in Python?",
    "c": null,
    "o": [
      "A decorator is a function that modifies another function without modifying its code.",
      "A decorator is used to remove a function from memory.",
      "A decorator must always return `None`.",
      "A decorator can only be applied to lambda functions."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def decorator(func):\n    def wrapper():\n        return \"Hello, \" + func()\n    return wrapper\n\n@decorator\ndef say_name():\n    return \"Alice\"\n\nprint(say_name())",
    "o": [
      "Hello, Alice",
      "Alice, Hello",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about higher-order functions in Python is TRUE?",
    "c": null,
    "o": [
      "A higher-order function is a function that takes another function as an argument or returns one.",
      "A higher-order function cannot return a function.",
      "A higher-order function is always recursive.",
      "A higher-order function is the same as a lambda function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def apply_twice(func, value):\n    return func(func(value))\n\ndef square(x):\n    return x * x\n\nprint(apply_twice(square, 2))",
    "o": [
      "16",
      "4",
      "8",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "16",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about recursion in Python?",
    "c": null,
    "o": [
      "A recursive function must have a base case to avoid infinite recursion.",
      "Recursive functions are always faster than loops.",
      "Recursion is not allowed in Python.",
      "A recursive function must take exactly one argument."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "add = lambda x, y: x + y\nprint(add(3, 7))",
    "o": [
      "10",
      "37",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about lambda functions in Python?",
    "c": null,
    "o": [
      "Lambda functions are anonymous and can have only one expression.",
      "Lambda functions must have a name like normal functions.",
      "Lambda functions cannot take arguments.",
      "Lambda functions must return None."
    ]
  },
  {
    "q": "What will be the output of the following code snippet using a lambda function?",
    "c": "square = lambda x: x * x\nprint(square(5))",
    "o": [
      "25",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about global variables in Python is TRUE?",
    "c": null,
    "o": [
      "Global variables can be accessed inside functions using the `global` keyword.",
      "Global variables must always be modified inside a function.",
      "A global variable cannot be defined inside a function.",
      "Global variables cannot be accessed outside a function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\n\ndef change_global():\n    global x\n    x = 20\n\nchange_global()\nprint(x)",
    "o": [
      "20",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about local variables in Python is TRUE?",
    "c": null,
    "o": [
      "A local variable is only accessible within the function where it is defined.",
      "A local variable can be accessed anywhere in the program.",
      "Local variables are automatically global if used inside a function.",
      "A local variable must be declared using `local` keyword."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def my_function():\n    x = 5\n    return x\n\nprint(my_function())",
    "o": [
      "5",
      "Error",
      "None",
      "10"
    ]
  },
  {
    "q": "Which of the following best describes the use of `nonlocal` in Python?",
    "c": null,
    "o": [
      "`nonlocal` allows modifying a variable in an enclosing function's scope.",
      "`nonlocal` creates a global variable.",
      "`nonlocal` is used to define a local variable.",
      "`nonlocal` prevents a function from accepting arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x += 5\n        return x\n    return inner()\n\nprint(outer())",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about function scope in Python?",
    "c": null,
    "o": [
      "A variable defined inside a function is local by default.",
      "A function must declare all variables as global before using them.",
      "A function can access all global variables without restrictions.",
      "Functions cannot have nested scopes."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def sum_numbers(n):\n    if n == 1:\n        return 1\n    return n + sum_numbers(n - 1)\n\nprint(sum_numbers(5))",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about recursive functions is TRUE?",
    "c": null,
    "o": [
      "A recursive function must have a termination condition to prevent infinite recursion.",
      "Recursive functions must use the `recursion` keyword.",
      "Python does not support recursion.",
      "Recursive functions cannot return values."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(6))",
    "o": [
      "8",
      "6",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about function parameters in Python?",
    "c": null,
    "o": [
      "Functions in Python can accept both positional and keyword arguments.",
      "Functions can only accept positional arguments.",
      "Functions must always return a value.",
      "Functions cannot have default parameters."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b=5, c=10):\n    return a + b + c\n\nprint(func(2, c=7))",
    "o": [
      "14",
      "24",
      "19",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about default arguments in Python functions?",
    "c": null,
    "o": [
      "Default arguments must come after non-default arguments in function definitions.",
      "Default arguments can appear anywhere in the argument list.",
      "Default arguments must be specified in the function call.",
      "Default arguments cannot be changed once defined."
    ]
  },
  {
    "q": "What will be the output of the following code snippet using keyword arguments?",
    "c": "def greet(name, age):\n    return f\"Hello {name}, you are {age} years old.\"\n\nprint(greet(age=25, name='Alice'))",
    "o": [
      "Hello Alice, you are 25 years old.",
      "Hello 25, you are Alice years old.",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about keyword arguments in Python?",
    "c": null,
    "o": [
      "Keyword arguments allow you to specify argument values by name, not just position.",
      "Keyword arguments must always come before positional arguments.",
      "Keyword arguments cannot be used in Python.",
      "Functions that use keyword arguments cannot have default values."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def add(*args):\n    return sum(args)\n\nprint(add(1, 2, 3, 4))",
    "o": [
      "10",
      "(1, 2, 3, 4)",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about the `*args` parameter in Python functions?",
    "c": null,
    "o": [
      "`*args` allows a function to accept a variable number of positional arguments.",
      "`*args` must always be the first argument in a function.",
      "`*args` can only accept one argument.",
      "`*args` must always be used with `**kwargs`."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def display_info(**kwargs):\n    return kwargs\n\nprint(display_info(name='Alice', age=25))",
    "o": [
      "{'name': 'Alice', 'age': 25}",
      "['name', 'Alice', 'age', 25]",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about `**kwargs` in Python?",
    "c": null,
    "o": [
      "`**kwargs` allows passing a variable number of keyword arguments to a function.",
      "`**kwargs` must be used before `*args` in a function definition.",
      "`**kwargs` can only be used for default arguments.",
      "`**kwargs` cannot be used with `*args`."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 'Hello'\n    def inner():\n        return x + ' World'\n    return inner()\n\nprint(outer())",
    "o": [
      "Hello World",
      "Hello",
      "World",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about nested functions is TRUE?",
    "c": null,
    "o": [
      "A nested function can access variables from the outer function.",
      "A nested function cannot access variables from its outer function.",
      "Nested functions must be declared using `nested` keyword.",
      "Nested functions are not allowed in Python."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def multiply_by(n):\n    return lambda x: x * n\n\ndouble = multiply_by(2)\nprint(double(5))",
    "o": [
      "10",
      "25",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following best describes a function closure in Python?",
    "c": null,
    "o": [
      "A closure is a function returned by another function that remembers the variables from its enclosing scope.",
      "A closure is a function that does not take any arguments.",
      "A closure is a function that cannot be assigned to a variable.",
      "A closure is a function that must be defined inside a class."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def count():\n    num = 0\n    def increment():\n        nonlocal num\n        num += 1\n        return num\n    return increment\n\ncounter = count()\nprint(counter())\nprint(counter())",
    "o": [
      "1\n2",
      "2\n2",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about function decorators in Python?",
    "c": null,
    "o": [
      "Decorators are functions that modify the behavior of other functions.",
      "Decorators must be defined inside a class.",
      "Decorators cannot accept arguments.",
      "Decorators must always return `None`."
    ]
  },
  {
    "q": "What will be the output of the following code snippet using a function decorator?",
    "c": "def decorator(func):\n    def wrapper():\n        return 'Hello, ' + func()\n    return wrapper\n\n@decorator\ndef greet():\n    return 'Alice'\n\nprint(greet())",
    "o": [
      "Hello, Alice",
      "Alice",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about higher-order functions in Python?",
    "c": null,
    "o": [
      "A higher-order function is a function that takes another function as an argument or returns a function.",
      "A higher-order function is a function that does not take arguments.",
      "A higher-order function must always return `None`.",
      "A higher-order function must be defined inside a class."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def apply_function(func, value):\n    return func(value)\n\ndef square(x):\n    return x * x\n\nprint(apply_function(square, 3))",
    "o": [
      "9",
      "6",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about function arguments is TRUE?",
    "c": null,
    "o": [
      "A function can have a combination of positional, default, *args, and **kwargs parameters.",
      "A function must have exactly one argument.",
      "A function cannot have both *args and **kwargs.",
      "A function must always return a value."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b=[]):\n    b.append(a)\n    return b\n\nprint(func(1))\nprint(func(2))",
    "o": [
      "[1, 2]",
      "[1] [2]",
      "[2]",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about mutable default arguments is TRUE?",
    "c": null,
    "o": [
      "Using a mutable default argument can lead to unexpected behavior as it persists across function calls.",
      "A mutable default argument is reinitialized with every function call.",
      "Mutable default arguments are automatically copied when the function is called.",
      "Python prevents the use of mutable default arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(x, y=lambda z: z * 2):\n    return y(x)\n\nprint(func(5))",
    "o": [
      "10",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about lambda functions in Python is TRUE?",
    "c": null,
    "o": [
      "Lambda functions are anonymous functions that can take any number of arguments but only have one expression.",
      "Lambda functions must always be assigned to a variable.",
      "Lambda functions can have multiple statements.",
      "Lambda functions must be defined inside another function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "numbers = [1, 2, 3, 4]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)",
    "o": [
      "[1, 4, 9, 16]",
      "[1, 2, 3, 4]",
      "[2, 4, 6, 8]",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about the `map()` function in Python?",
    "c": null,
    "o": [
      "`map()` applies a given function to all items in an iterable and returns an iterator.",
      "`map()` only works with lambda functions.",
      "`map()` modifies the original iterable in place.",
      "`map()` returns a list by default."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "numbers = [1, 2, 3, 4, 5]\neven = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even)",
    "o": [
      "[2, 4]",
      "[1, 3, 5]",
      "[1, 2, 3, 4, 5]",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about `filter()` in Python is TRUE?",
    "c": null,
    "o": [
      "`filter()` returns an iterator containing elements that satisfy a condition.",
      "`filter()` modifies the original list.",
      "`filter()` always returns a list.",
      "`filter()` can only be used with lambda functions."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "from functools import reduce\n\nnumbers = [1, 2, 3, 4]\nresult = reduce(lambda x, y: x + y, numbers)\nprint(result)",
    "o": [
      "10",
      "[1, 2, 3, 4]",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about `reduce()` in Python is TRUE?",
    "c": null,
    "o": [
      "`reduce()` applies a function cumulatively to all elements in an iterable, reducing it to a single value.",
      "`reduce()` only works with numerical values.",
      "`reduce()` modifies the original iterable.",
      "`reduce()` is part of Python's built-in functions."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b, *args, **kwargs):\n    print(a, b, args, kwargs)\n\nfunc(1, 2, 3, 4, x=5, y=6)",
    "o": [
      "1 2 (3, 4) {'x': 5, 'y': 6}",
      "1 2 [3, 4] {'x': 5, 'y': 6}",
      "1 2 (3, 4) ['x': 5, 'y': 6]",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about `*args` and `**kwargs` in Python?",
    "c": null,
    "o": [
      "`*args` collects extra positional arguments, while `**kwargs` collects extra keyword arguments.",
      "`*args` and `**kwargs` must be used together in function definitions.",
      "`*args` collects extra keyword arguments.",
      "`**kwargs` collects extra positional arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "numbers = [1, 2, 3, 4]\ndoubled = [x * 2 for x in numbers]\nprint(doubled)",
    "o": [
      "[2, 4, 6, 8]",
      "[1, 2, 3, 4]",
      "[1, 4, 9, 16]",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about list comprehensions in Python?",
    "c": null,
    "o": [
      "List comprehensions provide a concise way to create lists using a for loop in a single expression.",
      "List comprehensions are slower than traditional loops.",
      "List comprehensions must always include an `if` condition.",
      "List comprehensions can only be used for numerical operations."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "numbers = [1, 2, 3, 4]\nsquares = {x: x**2 for x in numbers}\nprint(squares)",
    "o": [
      "{1: 1, 2: 4, 3: 9, 4: 16}",
      "[1, 4, 9, 16]",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about dictionary comprehensions in Python?",
    "c": null,
    "o": [
      "Dictionary comprehensions create dictionaries using a single-line for loop.",
      "Dictionary comprehensions are only used for numerical operations.",
      "Dictionary comprehensions must always use `if` conditions.",
      "Dictionary comprehensions are slower than traditional loops."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "gen = (x**2 for x in range(3))\nprint(next(gen))\nprint(next(gen))\nprint(next(gen))",
    "o": [
      "0\n1\n4",
      "[0, 1, 4]",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about generator expressions in Python?",
    "c": null,
    "o": [
      "Generator expressions produce values lazily, generating them as needed.",
      "Generator expressions store all values in memory like lists.",
      "Generator expressions cannot be used with `next()`.",
      "Generator expressions must always be wrapped inside a function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "class A:\n    def __init__(self):\n        self.var = 10\n\n    def method(self):\n        return self.var\n\na = A()\nprint(a.method())",
    "o": [
      "10",
      "None",
      "Error",
      "0"
    ]
  },
  {
    "q": "Which of the following statements about Python classes is TRUE?",
    "c": null,
    "o": [
      "Instance variables defined in the constructor using `self` are unique to each instance.",
      "Instance variables must be defined outside the constructor.",
      "Methods in Python classes cannot return values.",
      "Python classes do not support instance variables."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "class A:\n    class_var = 20\n\na1 = A()\na2 = A()\na1.class_var = 30\nprint(a2.class_var)",
    "o": [
      "20",
      "30",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about class variables in Python?",
    "c": null,
    "o": [
      "Class variables are shared across all instances unless overridden.",
      "Class variables must be modified inside a method.",
      "Class variables are automatically instance variables.",
      "Class variables cannot be defined in a Python class."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "class A:\n    def __init__(self):\n        self.var = 10\n\n    def __str__(self):\n        return str(self.var)\n\na = A()\nprint(a)",
    "o": [
      "10",
      "<A object at some_memory_address>",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about the `__str__` method in Python classes?",
    "c": null,
    "o": [
      "`__str__` defines the string representation of an object when `print()` is called on it.",
      "`__str__` is automatically called when an object is created.",
      "`__str__` must always return an integer.",
      "`__str__` cannot be overridden in subclasses."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "class A:\n    def method(self):\n        return 'A'\n\nclass B(A):\n    def method(self):\n        return 'B'\n\nb = B()\nprint(b.method())",
    "o": [
      "'B'",
      "'A'",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about method overriding in Python?",
    "c": null,
    "o": [
      "A subclass can override a method defined in its superclass.",
      "A method defined in a superclass cannot be overridden.",
      "Method overriding requires the `super()` function.",
      "Only static methods can be overridden."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "class A:\n    def method(self):\n        return 'A'\n\nclass B(A):\n    pass\n\nb = B()\nprint(b.method())",
    "o": [
      "'A'",
      "None",
      "Error",
      "''"
    ]
  },
  {
    "q": "Which of the following is TRUE about class inheritance in Python?",
    "c": null,
    "o": [
      "A subclass inherits methods from its superclass unless explicitly overridden.",
      "A subclass must redefine all methods from its superclass.",
      "A subclass cannot inherit methods from its superclass.",
      "A subclass must always define a constructor."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "class A:\n    def __init__(self):\n        print('A init')\n\nclass B(A):\n    def __init__(self):\n        print('B init')\n\nb = B()",
    "o": [
      "'B init'",
      "'A init'",
      "'A init' then 'B init'",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about constructor inheritance in Python?",
    "c": null,
    "o": [
      "A subclass does not automatically call the constructor of its superclass unless `super().__init__()` is used.",
      "A subclass always calls the constructor of its superclass first.",
      "A subclass cannot override the constructor of its superclass.",
      "A subclass cannot define its own constructor."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "class A:\n    def __init__(self):\n        print('A init')\n\nclass B(A):\n    def __init__(self):\n        super().__init__()\n        print('B init')\n\nb = B()",
    "o": [
      "'A init' then 'B init'",
      "'B init' then 'A init'",
      "'B init'",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about `super()` in Python?",
    "c": null,
    "o": [
      "`super()` is used to call methods from a superclass in a subclass.",
      "`super()` can only be used in the constructor.",
      "`super()` must always be the first statement in a method.",
      "`super()` is required for method overriding."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(5))",
    "o": [
      "120",
      "5",
      "25",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about recursion in Python?",
    "c": null,
    "o": [
      "Recursion is a function calling itself to solve smaller instances of the same problem.",
      "Recursion is only used in mathematical problems.",
      "Recursive functions must always return a string.",
      "Python does not support recursion."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "add = lambda x, y: x + y\nprint(add(3, 7))",
    "o": [
      "10",
      "3",
      "7",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about lambda functions in Python?",
    "c": null,
    "o": [
      "Lambda functions are anonymous functions that can take multiple arguments but contain only one expression.",
      "Lambda functions must always have a name.",
      "Lambda functions can have multiple return statements.",
      "Lambda functions are the same as normal functions in every way."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\ndef func():\n    global x\n    x = 20\n\nfunc()\nprint(x)",
    "o": [
      "20",
      "10",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about global variables in Python?",
    "c": null,
    "o": [
      "Global variables can be modified inside a function using the `global` keyword.",
      "Global variables are always read-only inside functions.",
      "Global variables cannot be accessed inside functions.",
      "Python does not support global variables."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 5\n    def inner():\n        nonlocal x\n        x += 1\n    inner()\n    print(x)\n\nouter()",
    "o": [
      "6",
      "5",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about the `nonlocal` keyword in Python?",
    "c": null,
    "o": [
      "`nonlocal` allows modification of a variable from an enclosing function's scope.",
      "`nonlocal` makes a variable global.",
      "`nonlocal` creates a new local variable.",
      "Python does not support `nonlocal`."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def f(x, y=2, z=3):\n    return x + y + z\n\nprint(f(5, z=4))",
    "o": [
      "11",
      "9",
      "12",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about default arguments in Python?",
    "c": null,
    "o": [
      "Default arguments allow parameters to have a pre-defined value if no argument is provided.",
      "Default arguments must always be at the beginning of the parameter list.",
      "Python does not support default arguments.",
      "Default arguments cannot be overridden."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, *args):\n    return a + sum(args)\n\nprint(func(2, 3, 4, 5))",
    "o": [
      "14",
      "9",
      "Error",
      "2"
    ]
  },
  {
    "q": "Which of the following is TRUE about `*args` in Python?",
    "c": null,
    "o": [
      "`*args` allows a function to accept a variable number of positional arguments.",
      "`*args` can only be used once in a function.",
      "`*args` is required in all Python functions.",
      "Python does not support variable-length arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(**kwargs):\n    return kwargs['x'] + kwargs['y']\n\nprint(func(x=5, y=10))",
    "o": [
      "15",
      "5",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about `**kwargs` in Python?",
    "c": null,
    "o": [
      "`**kwargs` allows a function to accept a variable number of keyword arguments.",
      "`**kwargs` can only store integers.",
      "`**kwargs` must always be used with `*args`.",
      "Python does not support keyword arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 10\n    def inner():\n        return x\n    return inner\n\nclosure = outer()\nprint(closure())",
    "o": [
      "10",
      "None",
      "Error",
      "0"
    ]
  },
  {
    "q": "Which of the following is TRUE about closures in Python?",
    "c": null,
    "o": [
      "A closure is a function that remembers variables from its enclosing scope even after the scope has finished executing.",
      "A closure must always return `None`.",
      "Closures require the `global` keyword.",
      "Python does not support closures."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def sum_n(n):\n    if n == 0:\n        return 0\n    return n + sum_n(n - 1)\n\nprint(sum_n(4))",
    "o": [
      "10",
      "4",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of recursion?",
    "c": null,
    "o": [
      "A recursive function must always have a base case.",
      "Recursive functions can be replaced with iteration.",
      "Recursion always consumes less memory than iteration.",
      "Recursion can lead to stack overflow if not handled properly."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "square = lambda x: x * x\nprint(square(6))",
    "o": [
      "36",
      "6",
      "12",
      "Error"
    ]
  },
  {
    "q": "Which of the following is an invalid lambda function?",
    "c": null,
    "o": [
      "lambda x, y: x + y",
      "lambda x: return x * 2",
      "lambda x: x * x",
      "lambda: 10"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "count = 5\n\ndef increment():\n    global count\n    count += 1\n\nincrement()\nprint(count)",
    "o": [
      "6",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is FALSE regarding local and global variables?",
    "c": null,
    "o": [
      "A local variable is only accessible within the function it is defined in.",
      "A global variable can be accessed inside a function without using the `global` keyword.",
      "Global variables can be modified inside a function using the `global` keyword.",
      "A local variable takes precedence over a global variable of the same name inside a function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b=5):\n    return a * b\n\nprint(func(2))",
    "o": [
      "10",
      "2",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about default arguments?",
    "c": null,
    "o": [
      "Default arguments must come after non-default arguments in a function definition.",
      "Default arguments can be placed anywhere in the parameter list.",
      "Default arguments cannot be overridden when calling the function.",
      "Default arguments must always be integers."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(*args):\n    return sum(args)\n\nprint(func(1, 2, 3, 4))",
    "o": [
      "10",
      "1",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about `*args`?",
    "c": null,
    "o": [
      "`*args` allows a function to accept any number of positional arguments.",
      "`*args` must always contain at least one argument.",
      "`*args` can only be used with integer arguments.",
      "`*args` must always be the last parameter in a function definition."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(**kwargs):\n    return kwargs.get('name', 'Unknown')\n\nprint(func(name='Alice'))",
    "o": [
      "Alice",
      "Unknown",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about `**kwargs`?",
    "c": null,
    "o": [
      "`**kwargs` allows a function to accept any number of keyword arguments.",
      "`**kwargs` can only store string values.",
      "`**kwargs` must always be used with `*args`.",
      "A function can have only `**kwargs` and no other arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def make_multiplier(n):\n    return lambda x: x * n\n\ndouble = make_multiplier(2)\nprint(double(5))",
    "o": [
      "10",
      "5",
      "2",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about closures in Python?",
    "c": null,
    "o": [
      "Closures can retain the state of variables from their enclosing function even after it has finished executing.",
      "Closures must always return `None`.",
      "Closures cannot contain lambda functions.",
      "Closures are only used in recursion."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(5))",
    "o": [
      "120",
      "24",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about recursion is FALSE?",
    "c": null,
    "o": [
      "Recursion always uses more memory than iteration.",
      "Every recursive function must have a base case.",
      "Recursion can be used to solve problems like tree traversal.",
      "Recursive functions must always return a value."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "multiply = lambda x, y: x * y\nprint(multiply(3, 4))",
    "o": [
      "12",
      "7",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about lambda functions?",
    "c": null,
    "o": [
      "Lambda functions can have only one expression.",
      "Lambda functions must always have a return statement.",
      "Lambda functions can contain multiple statements.",
      "Lambda functions cannot be assigned to variables."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\n\ndef func():\n    x = 5\n    print(x)\n\nfunc()\nprint(x)",
    "o": [
      "5\n10",
      "10\n5",
      "5\n5",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements is FALSE regarding local and global variables?",
    "c": null,
    "o": [
      "A local variable inside a function does not affect the global variable of the same name.",
      "A global variable can be accessed inside a function without using the `global` keyword.",
      "Using the `global` keyword allows modification of a global variable inside a function.",
      "Local variables are created when a function is called and destroyed when the function ends."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b=3, c=2):\n    return a + b * c\n\nprint(func(4, c=5))",
    "o": [
      "19",
      "14",
      "12",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about default arguments?",
    "c": null,
    "o": [
      "Default arguments are evaluated only once when the function is defined.",
      "Default arguments must be placed before non-default arguments.",
      "Default arguments cannot be overridden when calling a function.",
      "Default arguments can only be integers."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(*args):\n    return args[-1]\n\nprint(func(1, 2, 3, 4))",
    "o": [
      "4",
      "1",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is FALSE about `*args`?",
    "c": null,
    "o": [
      "`*args` collects additional positional arguments into a tuple.",
      "`*args` must always be used in function calls.",
      "`*args` allows a function to accept a variable number of arguments.",
      "`*args` must be placed before `**kwargs` in a function definition."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(**kwargs):\n    return kwargs['age']\n\nprint(func(name='Alice', age=25))",
    "o": [
      "25",
      "Alice",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is FALSE about `**kwargs`?",
    "c": null,
    "o": [
      "`**kwargs` collects keyword arguments into a dictionary.",
      "`**kwargs` can only be used with string keys.",
      "`**kwargs` allows a function to accept variable keyword arguments.",
      "`**kwargs` must be placed after `*args` in a function definition."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer_function(x):\n    def inner_function(y):\n        return x + y\n    return inner_function\n\nadd_five = outer_function(5)\nprint(add_five(10))",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes a closure in Python?",
    "c": null,
    "o": [
      "A function returned from another function that remembers variables from the outer function.",
      "A function that can only be used once.",
      "A function that does not accept arguments.",
      "A function that does not return anything."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b, /, c, d):\n    return a + b + c + d\n\nprint(func(1, 2, c=3, d=4))",
    "o": [
      "10",
      "Error",
      "7",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about positional-only arguments is TRUE?",
    "c": null,
    "o": [
      "Positional-only arguments must be passed without keyword arguments.",
      "Positional-only arguments must always have default values.",
      "Positional-only arguments must always be the last parameters in a function.",
      "Positional-only arguments cannot be combined with `*args`."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b, *, c, d):\n    return a + b + c + d\n\nprint(func(1, 2, c=3, d=4))",
    "o": [
      "10",
      "Error",
      "7",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about keyword-only arguments is TRUE?",
    "c": null,
    "o": [
      "Keyword-only arguments must be passed using their parameter names.",
      "Keyword-only arguments must always be the first parameters in a function.",
      "Keyword-only arguments cannot have default values.",
      "Keyword-only arguments must always be integers."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a=[]):\n    a.append(1)\n    return a\n\nprint(func())\nprint(func())",
    "o": [
      "[1]\n[1, 1]",
      "[1]\n[1]",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about mutable default arguments?",
    "c": null,
    "o": [
      "Mutable default arguments retain changes between function calls.",
      "Mutable default arguments reset to their original value every call.",
      "Mutable default arguments must be tuples.",
      "Mutable default arguments do not affect function behavior."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "a = [1, 2, 3]\nb = a\nb.append(4)\nprint(a)",
    "o": [
      "[1, 2, 3, 4]",
      "[1, 2, 3]",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about list assignment is TRUE?",
    "c": null,
    "o": [
      "Assigning one list to another does not create a copy, it creates a reference.",
      "Assigning one list to another creates an independent copy.",
      "Lists cannot be assigned to variables in Python.",
      "Lists are immutable in Python."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "a = [1, 2, 3]\nb = a[:]\nb.append(4)\nprint(a)",
    "o": [
      "[1, 2, 3]",
      "[1, 2, 3, 4]",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about list slicing is TRUE?",
    "c": null,
    "o": [
      "List slicing creates a shallow copy of the original list.",
      "List slicing creates a deep copy of the original list.",
      "List slicing is only available for lists, not other sequences.",
      "List slicing modifies the original list."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "a = (1, 2, [3, 4])\na[2].append(5)\nprint(a)",
    "o": [
      "(1, 2, [3, 4, 5])",
      "Error",
      "(1, 2, [3, 4])",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about tuple mutability is TRUE?",
    "c": null,
    "o": [
      "Tuples themselves are immutable, but they can contain mutable objects.",
      "Tuples are completely immutable, including any elements inside them.",
      "Tuples cannot store lists or dictionaries.",
      "Tuples are always passed by value, not by reference."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = {1, 2, 3}\ny = {3, 4, 5}\nprint(x & y)",
    "o": [
      "{3}",
      "{1, 2, 3, 4, 5}",
      "{1, 2}",
      "Error"
    ]
  },
  {
    "q": "Which of the following operations can be performed on sets in Python?",
    "c": null,
    "o": [
      "Union, intersection, difference, and symmetric difference",
      "Indexing and slicing",
      "Appending elements using `.append()`",
      "Storing duplicate values"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "d = {'a': 1, 'b': 2, 'c': 3}\nd.pop('b')\nprint(d)",
    "o": [
      "{'a': 1, 'c': 3}",
      "{'a': 1, 'b': 2, 'c': 3}",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about Python dictionaries?",
    "c": null,
    "o": [
      "Dictionaries store key-value pairs and keys must be unique.",
      "Dictionaries allow duplicate keys.",
      "Dictionaries are ordered before Python 3.7.",
      "Dictionaries do not support deletion of elements."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = {1, 2, 3, 4}\nx.remove(3)\nprint(x)",
    "o": [
      "{1, 2, 4}",
      "{1, 2, 3, 4}",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is FALSE about set operations?",
    "c": null,
    "o": [
      "Removing an element using `.remove()` raises an error if the element is missing.",
      "Sets support membership testing using the `in` keyword.",
      "Sets store elements in insertion order.",
      "Sets automatically remove duplicate elements."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(5))",
    "o": [
      "120",
      "25",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about recursion in Python?",
    "c": null,
    "o": [
      "Recursion must have a base case to prevent infinite recursion.",
      "Recursion always leads to better performance than iteration.",
      "Python does not support recursion.",
      "Recursion can only be used for mathematical calculations."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "sum_lambda = lambda a, b: a + b\nprint(sum_lambda(3, 4))",
    "o": [
      "7",
      "34",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about lambda functions in Python?",
    "c": null,
    "o": [
      "Lambda functions are anonymous functions that can take any number of arguments but have a single expression.",
      "Lambda functions must always have a return statement.",
      "Lambda functions are faster than regular functions in all cases.",
      "Lambda functions cannot be assigned to variables."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\ndef func():\n    global x\n    x = x + 5\nprint(func())",
    "o": [
      "None",
      "15",
      "Error",
      "10"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about global and local variables?",
    "c": null,
    "o": [
      "A variable declared inside a function is local unless explicitly declared global.",
      "A global variable can only be modified inside a function without using the `global` keyword.",
      "Local variables can be accessed outside their function scope.",
      "Python does not support global variables."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 'hello'\n    def inner():\n        print(x)\n    inner()\nouter()",
    "o": [
      "hello",
      "Error",
      "None",
      "x"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about nested functions?",
    "c": null,
    "o": [
      "A nested function can access variables from its enclosing function.",
      "A nested function must be declared global to work.",
      "Python does not allow nested functions.",
      "Nested functions cannot access variables from their enclosing function."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def add(x, y=5):\n    return x + y\nprint(add(10))",
    "o": [
      "15",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about function arguments in Python?",
    "c": null,
    "o": [
      "Default arguments are evaluated only once, at function definition time.",
      "Default arguments are evaluated every time the function is called.",
      "Python does not support default arguments.",
      "All function arguments must have a default value."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def countdown(n):\n    if n == 0:\n        return 'Done!'\n    print(n)\n    return countdown(n - 1)\n\ncountdown(3)",
    "o": [
      "3\n2\n1\nDone!",
      "3\n2\n1",
      "Done!",
      "Error"
    ]
  },
  {
    "q": "Which of the following is an advantage of using recursion?",
    "c": null,
    "o": [
      "It makes code more readable and simplifies complex problems.",
      "It always runs faster than loops.",
      "It uses less memory than iteration.",
      "It does not require a base case."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "multiply = lambda x, y: x * y\nprint(multiply(4, 5))",
    "o": [
      "20",
      "45",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is NOT true about lambda functions?",
    "c": null,
    "o": [
      "They can contain multiple expressions.",
      "They are used for short, simple functions.",
      "They are anonymous functions.",
      "They can take multiple arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 5\ndef my_func():\n    x = 10\n    print(x)\nmy_func()\nprint(x)",
    "o": [
      "10\n5",
      "5\n10",
      "10\n10",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about local and global variables is FALSE?",
    "c": null,
    "o": [
      "A local variable inside a function does not affect a global variable with the same name.",
      "The `global` keyword allows modification of a global variable inside a function.",
      "A function can modify a global variable without using the `global` keyword.",
      "Local variables are only accessible inside the function where they are defined."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 'Python'\n    def inner():\n        return x\n    return inner()\nprint(outer())",
    "o": [
      "Python",
      "Error",
      "None",
      "x"
    ]
  },
  {
    "q": "Which of the following best describes a nested function?",
    "c": null,
    "o": [
      "A function defined inside another function.",
      "A function that calls itself.",
      "A function that takes another function as an argument.",
      "A function with multiple return values."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def greet(name, msg='Hello'):\n    return f\"{msg}, {name}!\"\nprint(greet('Alice'))",
    "o": [
      "Hello, Alice!",
      "Alice, Hello!",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about function arguments in Python?",
    "c": null,
    "o": [
      "Keyword arguments allow calling a function with arguments in any order.",
      "A function cannot have both positional and keyword arguments.",
      "All function arguments must be passed in order.",
      "Function arguments cannot have default values."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "4",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct way to define a function with variable-length arguments?",
    "c": null,
    "o": [
      "def my_function(*args):",
      "def my_function(args*):",
      "def my_function(args...):",
      "def my_function(*args, **kwargs):"
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "square = lambda x: x * x\nprint(square(6))",
    "o": [
      "36",
      "6",
      "12",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about lambda functions is TRUE?",
    "c": null,
    "o": [
      "Lambda functions can only have a single expression.",
      "Lambda functions can have multiple return statements.",
      "Lambda functions can contain loops.",
      "Lambda functions must have a name."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\ndef modify_global():\n    global x\n    x = 20\n\nmodify_global()\nprint(x)",
    "o": [
      "20",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "What will happen if a function does not explicitly return a value?",
    "c": null,
    "o": [
      "It returns None.",
      "It causes an error.",
      "It returns an empty string.",
      "It returns 0."
    ]
  },
  {
    "q": "What will be the output of the following nested function?",
    "c": "def outer():\n    def inner():\n        return 'Hello from inner'\n    return inner\n\nfunc = outer()\nprint(func())",
    "o": [
      "Hello from inner",
      "None",
      "Error",
      "inner"
    ]
  },
  {
    "q": "Which of the following statements about global variables is FALSE?",
    "c": null,
    "o": [
      "Global variables can be accessed inside functions without using the `global` keyword.",
      "Global variables can be modified inside a function using the `global` keyword.",
      "Global variables exist throughout the entire runtime of a program.",
      "Using global variables is always recommended for better readability."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def test_scope():\n    x = 5\n    def inner():\n        nonlocal x\n        x += 1\n        return x\n    return inner()\n\nprint(test_scope())",
    "o": [
      "6",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is a correct way to define a recursive function?",
    "c": null,
    "o": [
      "A function that calls itself with a base case to prevent infinite recursion.",
      "A function that contains a loop.",
      "A function that calls another function.",
      "A function that never stops executing."
    ]
  },
  {
    "q": "What will be the output of the following function call?",
    "c": "def greet(name, greeting='Hi'):\n    return f\"{greeting}, {name}!\"\n\nprint(greet('Bob', 'Hello'))",
    "o": [
      "Hello, Bob!",
      "Hi, Bob!",
      "Bob, Hello!",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about the `nonlocal` keyword?",
    "c": null,
    "o": [
      "It allows modifying a variable in an enclosing (non-global) scope.",
      "It allows modifying a global variable.",
      "It declares a new local variable.",
      "It makes a variable immutable."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def recursive_sum(n):\n    if n == 1:\n        return 1\n    return n + recursive_sum(n - 1)\n\nprint(recursive_sum(5))",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes a recursive function?",
    "c": null,
    "o": [
      "A function that calls itself.",
      "A function that runs indefinitely.",
      "A function that returns multiple values.",
      "A function that never terminates."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "multiply = lambda x, y: x * y\nprint(multiply(3, 4))",
    "o": [
      "12",
      "7",
      "34",
      "Error"
    ]
  },
  {
    "q": "Which of the following is an advantage of using lambda functions in Python?",
    "c": null,
    "o": [
      "They provide a compact way to define small, anonymous functions.",
      "They allow defining multi-line functions without indentation.",
      "They execute faster than regular functions.",
      "They can contain loops and multiple expressions."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 5\n\ndef outer():\n    x = 10\n    def inner():\n        global x\n        x = 20\n    inner()\n    print(x)\n\nouter()\nprint(x)",
    "o": [
      "10\n20",
      "10\n10",
      "5\n10",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b=2, c=3):\n    return a + b + c\n\nprint(func(1, c=5))",
    "o": [
      "8",
      "6",
      "9",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly describes the difference between global and local variables?",
    "c": null,
    "o": [
      "Global variables exist throughout the program, while local variables are confined to a function.",
      "Local variables exist throughout the program, while global variables are confined to a function.",
      "Both global and local variables can be accessed anywhere in the program.",
      "Local variables are faster than global variables because they are stored in a different memory space."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def modify_list(lst):\n    lst.append(4)\n\nnums = [1, 2, 3]\nmodify_list(nums)\nprint(nums)",
    "o": [
      "[1, 2, 3, 4]",
      "[1, 2, 3]",
      "[4, 1, 2, 3]",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about default arguments in Python functions is TRUE?",
    "c": null,
    "o": [
      "Default arguments are evaluated only once when the function is defined.",
      "Default arguments must always be provided explicitly when calling the function.",
      "Default arguments cannot be modified inside the function.",
      "Default arguments are evaluated every time the function is called."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def f(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(f(1))\nprint(f(2))\nprint(f(3))",
    "o": [
      "[1, 2, 3]",
      "[1]\n[2]\n[3]",
      "[3]",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about function arguments in Python is FALSE?",
    "c": null,
    "o": [
      "Keyword arguments must always come after positional arguments.",
      "Positional arguments must always come after keyword arguments.",
      "Default arguments must always be placed after non-default arguments.",
      "Variable-length arguments are passed using *args and **kwargs."
    ]
  },
  {
    "q": "What will be the output of the following function call?",
    "c": "def power(base, exponent=2):\n    return base ** exponent\n\nprint(power(3))",
    "o": [
      "9",
      "6",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a valid function definition in Python?",
    "c": null,
    "o": [
      "def my_func(x, y=5, z):",
      "def my_func(x, y=5, z=10):",
      "def my_func(x, y=5):",
      "def my_func(*args, **kwargs):"
    ]
  },
  {
    "q": "What will be the output of the following function call?",
    "c": "def outer():\n    x = 'outer'\n    def inner():\n        nonlocal x\n        x = 'inner'\n    inner()\n    return x\n\nprint(outer())",
    "o": [
      "inner",
      "outer",
      "Error",
      "None"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "16",
      "4",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes an anonymous function in Python?",
    "c": null,
    "o": [
      "A function defined using the `lambda` keyword.",
      "A function that has no arguments.",
      "A function that is defined inside another function.",
      "A function that has no return value."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\n\ndef my_func():\n    x = 20\n    return x\n\nprint(my_func())\nprint(x)",
    "o": [
      "20\n10",
      "10\n20",
      "20\n20",
      "10\n10"
    ]
  },
  {
    "q": "Which of the following is NOT a correct way to define a function in Python?",
    "c": null,
    "o": [
      "def my_func(x, y) = x + y",
      "def my_func(x, y): return x + y",
      "def my_func(x, y=10): return x + y",
      "def my_func(*args): return sum(args)"
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "double = lambda x: x * 2\nprint(double(5))",
    "o": [
      "10",
      "5",
      "25",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about recursion is FALSE?",
    "c": null,
    "o": [
      "Every recursive function must have a base case.",
      "Recursive functions always run infinitely.",
      "Recursion can sometimes lead to a stack overflow error.",
      "Recursion can be replaced by iteration in some cases."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\n\nc = counter()\nprint(c())\nprint(c())",
    "o": [
      "1\n2",
      "2\n2",
      "1\n1",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT true about default arguments?",
    "c": null,
    "o": [
      "Default arguments are re-evaluated every time the function is called.",
      "Default arguments are evaluated only once when the function is defined.",
      "Mutable default arguments can lead to unexpected behavior.",
      "Default arguments must come after non-default arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def test(a, b=[]):\n    b.append(a)\n    return b\n\nprint(test(1))\nprint(test(2))",
    "o": [
      "[1, 2]",
      "[1]\n[2]",
      "[2]",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly represents the use of `*args` in Python functions?",
    "c": null,
    "o": [
      "It allows a function to accept any number of positional arguments.",
      "It allows a function to accept any number of keyword arguments.",
      "It specifies that a function must have at least one argument.",
      "It restricts a function to only positional arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def add(a, b=5, c=10):\n    return a + b + c\n\nprint(add(2, c=7))",
    "o": [
      "14",
      "19",
      "12",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about `**kwargs` is TRUE?",
    "c": null,
    "o": [
      "It allows a function to accept any number of keyword arguments.",
      "It allows a function to accept any number of positional arguments.",
      "It must always be used before `*args` in function parameters.",
      "It prevents the use of default arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b, *args):\n    return a + b + sum(args)\n\nprint(func(1, 2, 3, 4, 5))",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to call the function `def greet(name, message='Hello'):`?",
    "c": null,
    "o": [
      "greet(message='Hi', 'Alice')",
      "greet('Alice')",
      "greet('Alice', message='Hi')",
      "greet(name='Alice')"
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def countdown(n):\n    if n == 0:\n        return 'Done!'\n    else:\n        return countdown(n - 1)\n\nprint(countdown(5))",
    "o": [
      "'Done!'",
      "5 4 3 2 1 'Done!'",
      "None",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a characteristic of a recursive function?",
    "c": null,
    "o": [
      "It must always have a base case.",
      "It calls itself within its definition.",
      "It always runs indefinitely.",
      "It can be replaced by an iterative approach."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "multiply = lambda x, y: x * y\nprint(multiply(3, 4))",
    "o": [
      "12",
      "7",
      "34",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly describes the use of the `global` keyword in Python?",
    "c": null,
    "o": [
      "It allows a function to modify a global variable.",
      "It makes a local variable global.",
      "It prevents changes to a global variable inside a function.",
      "It restricts variable scope to the function only."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 5\n\ndef my_func():\n    global x\n    x = 10\n\nmy_func()\nprint(x)",
    "o": [
      "10",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is NOT a correct use of `lambda` functions?",
    "c": null,
    "o": [
      "lambda x, y: x + y if x > y else y",
      "lambda x: return x * 2",
      "lambda x: x ** 2",
      "lambda x, y, z: x + y + z"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 10\n    def inner():\n        return x\n    return inner()\n\nprint(outer())",
    "o": [
      "10",
      "None",
      "Error",
      "outer"
    ]
  },
  {
    "q": "Which of the following is TRUE about local variables?",
    "c": null,
    "o": [
      "They are accessible only within the function in which they are defined.",
      "They can be accessed anywhere in the program.",
      "They must be declared using the `global` keyword.",
      "They are automatically converted to global variables."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def test(a, b={}):\n    b[a] = a * 2\n    return b\n\nprint(test(1))\nprint(test(2))",
    "o": [
      "{1: 2, 2: 4}",
      "{1: 2}\n{2: 4}",
      "{2: 4}",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a valid function definition in Python?",
    "c": null,
    "o": [
      "def my_func(x, y=10, z): return x + y + z",
      "def my_func(x, y=10): return x + y",
      "def my_func(*args): return sum(args)",
      "def my_func(x, y=10, *args): return x + y + sum(args)"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b=5, c=10):\n    return a + b + c\n\nprint(func(2, b=7, c=3))",
    "o": [
      "12",
      "22",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about function arguments in Python is FALSE?",
    "c": null,
    "o": [
      "Keyword arguments must always be passed after positional arguments.",
      "Positional arguments can be followed by keyword arguments.",
      "Default arguments are evaluated once when the function is defined.",
      "Default arguments must always come before non-default arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b, *args, **kwargs):\n    return a + b + sum(args) + sum(kwargs.values())\n\nprint(func(1, 2, 3, 4, x=5, y=6))",
    "o": [
      "21",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following correctly represents the use of `**kwargs` in Python functions?",
    "c": null,
    "o": [
      "It allows a function to accept any number of keyword arguments.",
      "It allows a function to accept any number of positional arguments.",
      "It specifies that a function must have at least one argument.",
      "It restricts a function to only positional arguments."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "subtract = lambda x, y=2: x - y\nprint(subtract(10))",
    "o": [
      "8",
      "10",
      "12",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes the difference between a function and a lambda function in Python?",
    "c": null,
    "o": [
      "Lambda functions are anonymous and typically used for short, simple operations.",
      "Lambda functions are faster than normal functions.",
      "Lambda functions can contain multiple expressions.",
      "Lambda functions must be defined using the `def` keyword."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(func(1))\nprint(func(2))",
    "o": [
      "[1, 2]",
      "[1] [2]",
      "[2]",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about list comprehensions in Python is FALSE?",
    "c": null,
    "o": [
      "They can be used to create lists in a single line.",
      "They always execute faster than traditional loops.",
      "They can include conditions and expressions.",
      "They can be nested."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "a = [1, 2, 3]\nb = a\nb.append(4)\nprint(a)",
    "o": [
      "[1, 2, 3, 4]",
      "[1, 2, 3]",
      "Error",
      "[4]"
    ]
  },
  {
    "q": "Which of the following is the correct way to copy a list without modifying the original?",
    "c": null,
    "o": [
      "b = a[:]",
      "b = a",
      "b = copy(a)",
      "b = deepcopy(a)"
    ]
  },
  {
    "q": "What will be the output of the following dictionary operation?",
    "c": "d = {'a': 1, 'b': 2}\nd['c'] = 3\nprint(d)",
    "o": [
      "{'a': 1, 'b': 2, 'c': 3}",
      "{'a': 1, 'b': 2}",
      "Error",
      "{'c': 3}"
    ]
  },
  {
    "q": "Which of the following correctly removes a key from a dictionary?",
    "c": null,
    "o": [
      "del d['key']",
      "d.pop('key')",
      "d.remove('key')",
      "Both A and B"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "s = {1, 2, 3}\ns.add(2)\nprint(s)",
    "o": [
      "{1, 2, 3}",
      "{1, 2, 3, 2}",
      "Error",
      "{2, 3}"
    ]
  },
  {
    "q": "Which of the following is TRUE about Python sets?",
    "c": null,
    "o": [
      "They do not allow duplicate values.",
      "They maintain the insertion order.",
      "They are indexed collections.",
      "They support duplicate values."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "s = {1, 2, 3}\ns.remove(4)\nprint(s)",
    "o": [
      "Error",
      "{1, 2, 3}",
      "{1, 2}",
      "{1, 3}"
    ]
  },
  {
    "q": "Which of the following is the correct way to handle missing dictionary keys?",
    "c": null,
    "o": [
      "Using `get()`, which returns None or a default value.",
      "Accessing the key directly, which prevents errors.",
      "Using `del` to check for the key first.",
      "Python dictionaries do not allow missing keys."
    ]
  },
  {
    "q": "What will be the output of the following list comprehension?",
    "c": "lst = [x * 2 for x in range(3)]\nprint(lst)",
    "o": [
      "[0, 2, 4]",
      "[2, 4, 6]",
      "[1, 3, 5]",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a valid way to define a tuple in Python?",
    "c": null,
    "o": [
      "t = (1, 2, 3)",
      "t = tuple([1, 2, 3])",
      "t = 1, 2, 3",
      "t = {1, 2, 3}"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "t = (1, 2, 3)\nt[0] = 4\nprint(t)",
    "o": [
      "Error",
      "(4, 2, 3)",
      "(1, 2, 3)",
      "None"
    ]
  },
  {
    "q": "Which of the following methods can be used to convert a tuple to a list?",
    "c": null,
    "o": [
      "list(t)",
      "t.to_list()",
      "convert(t)",
      "tuple_to_list(t)"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "s1 = 'hello'\ns2 = s1\ns1 = 'world'\nprint(s2)",
    "o": [
      "'hello'",
      "'world'",
      "None",
      "Error"
    ]
  },
  {
    "q": "What is the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "10",
      "16",
      "4"
    ]
  },
  {
    "q": "Which of the following statements about recursion is TRUE?",
    "c": null,
    "o": [
      "A recursive function must have a base case.",
      "Recursion is always more efficient than iteration.",
      "Recursion cannot be used for mathematical computations.",
      "A recursive function must return an integer."
    ]
  },
  {
    "q": "What is the output of the following lambda function?",
    "c": "add = lambda x, y: x + y\nprint(add(3, 5))",
    "o": [
      "8",
      "15",
      "35",
      "Error"
    ]
  },
  {
    "q": "Which of the following is NOT a valid lambda function in Python?",
    "c": null,
    "o": [
      "lambda x, y: x + y",
      "lambda x: x * 2",
      "lambda x, y, z: return x + y + z",
      "lambda: 42"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 10\ndef func():\n    global x\n    x = 5\nfunc()\nprint(x)",
    "o": [
      "5",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about global and local variables is TRUE?",
    "c": null,
    "o": [
      "A global variable can be accessed inside a function using the `global` keyword.",
      "A local variable is accessible outside the function where it is defined.",
      "Global variables cannot be modified inside a function.",
      "Using global variables improves code readability."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def sum_numbers(n):\n    if n == 1:\n        return 1\n    return n + sum_numbers(n - 1)\n\nprint(sum_numbers(5))",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following functions is an example of a recursive function?",
    "c": null,
    "o": [
      "def factorial(n): return n * factorial(n-1) if n > 0 else 1",
      "def loop(n): for i in range(n): print(i)",
      "def square(n): return n * n",
      "def add(a, b): return a + b"
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "multiply = lambda x: x * x\nprint(multiply(4))",
    "o": [
      "16",
      "8",
      "4",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about lambda functions is FALSE?",
    "c": null,
    "o": [
      "Lambda functions can have multiple expressions.",
      "Lambda functions are anonymous functions.",
      "Lambda functions can take multiple arguments.",
      "Lambda functions are useful for short, simple operations."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 5\ndef test():\n    x = 10\n    print(x)\ntest()\nprint(x)",
    "o": [
      "10 5",
      "5 10",
      "10 10",
      "5 5"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about function arguments?",
    "c": null,
    "o": [
      "Default arguments must come after non-default arguments.",
      "A function can have an unlimited number of arguments, but only one return value.",
      "Keyword arguments must always come before positional arguments.",
      "A function cannot have both default and keyword arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def test(a, b=2, c=3):\n    return a + b + c\n\nprint(test(1, c=4))",
    "o": [
      "7",
      "6",
      "9",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with variable-length arguments?",
    "c": null,
    "o": [
      "def func(*args): pass",
      "def func(args*): pass",
      "def func(**args): pass",
      "def func(args): pass"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "def outer():\n    x = 'Hello'\n    def inner():\n        print(x)\n    inner()\nouter()",
    "o": [
      "Hello",
      "Error",
      "None",
      "outer"
    ]
  },
  {
    "q": "Which of the following statements about nested functions is TRUE?",
    "c": null,
    "o": [
      "A nested function can access variables from its enclosing function.",
      "A nested function can be called outside its enclosing function.",
      "A nested function cannot modify variables from its enclosing function.",
      "Nested functions are not allowed in Python."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(a, b=5, c=10):\n    return a + b + c\n\nprint(func(3, c=7))",
    "o": [
      "15",
      "10",
      "20",
      "Error"
    ]
  },
  {
    "q": "Which of the following function calls correctly uses both positional and keyword arguments?",
    "c": null,
    "o": [
      "func(5, c=7)",
      "func(a=5, 7)",
      "func(5, b=7, 10)",
      "func(5, c)"
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "subtract = lambda x, y: x - y\nprint(subtract(10, 3))",
    "o": [
      "7",
      "13",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about lambda functions?",
    "c": null,
    "o": [
      "Lambda functions can be used as arguments in higher-order functions.",
      "Lambda functions must have a return statement.",
      "Lambda functions can contain multiple statements.",
      "Lambda functions must be defined with the def keyword."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def count_down(n):\n    if n == 0:\n        return 'Done'\n    print(n)\n    return count_down(n - 1)\n\nprint(count_down(3))",
    "o": [
      "3\n2\n1\nDone",
      "3\n2\n1\n0\nDone",
      "Done",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes recursion?",
    "c": null,
    "o": [
      "A function calling itself until a base case is met.",
      "A function that loops through a list.",
      "A function that does not take any arguments.",
      "A function that is always faster than iteration."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 5\ndef func():\n    global x\n    x = 10\nfunc()\nprint(x)",
    "o": [
      "10",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about the global keyword is FALSE?",
    "c": null,
    "o": [
      "It allows modification of a global variable inside a function.",
      "It must be used before modifying a global variable inside a function.",
      "It creates a local variable with the same name as a global variable.",
      "It allows access to a global variable inside a function."
    ]
  },
  {
    "q": "What is the output of the following lambda function?",
    "c": "divide = lambda x, y: x / y\nprint(divide(9, 3))",
    "o": [
      "3.0",
      "9",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about variable-length arguments is TRUE?",
    "c": null,
    "o": [
      "The *args parameter allows passing multiple positional arguments.",
      "The **kwargs parameter allows passing multiple positional arguments.",
      "The *args parameter must be placed after all keyword arguments.",
      "Variable-length arguments must always be used in functions."
    ]
  },
  {
    "q": "What will be the output of the following nested function?",
    "c": "def outer():\n    x = 'Hello'\n    def inner():\n        return x + ' World'\n    return inner()\n\nprint(outer())",
    "o": [
      "Hello World",
      "Hello",
      "World",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with both variable-length positional and keyword arguments?",
    "c": null,
    "o": [
      "def func(*args, **kwargs): pass",
      "def func(**args, *kwargs): pass",
      "def func(args*, kwargs**): pass",
      "def func(args, kwargs): pass"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def add(a, b=2, c=3):\n    return a + b + c\n\nprint(add(1, c=4))",
    "o": [
      "7",
      "6",
      "9",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about default arguments is TRUE?",
    "c": null,
    "o": [
      "Default arguments must come after non-default arguments.",
      "A function cannot have both default and keyword arguments.",
      "Default arguments are mandatory when calling the function.",
      "Default arguments must be passed as the first parameters."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "power = lambda x: x ** 2\nprint(power(4))",
    "o": [
      "16",
      "8",
      "4",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about function scope is FALSE?",
    "c": null,
    "o": [
      "A variable defined inside a function is not accessible outside the function.",
      "A global variable can be accessed inside a function using the global keyword.",
      "A local variable can override a global variable with the same name inside a function.",
      "A function can access variables from another function without any special keyword."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def multiply(a, b=2):\n    return a * b\n\nprint(multiply(3))",
    "o": [
      "6",
      "3",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of the `return` statement in a function?",
    "c": null,
    "o": [
      "It specifies the value that a function should output.",
      "It prints a value to the console.",
      "It ends the execution of a program.",
      "It allows a function to call itself recursively."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def func(x, y=[]):\n    y.append(x)\n    return y\n\nprint(func(1))\nprint(func(2))",
    "o": [
      "[1]\n[1, 2]",
      "[1]\n[2]",
      "[1, 2]\n[2]",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements about mutable default arguments is TRUE?",
    "c": null,
    "o": [
      "Mutable default arguments can retain changes across function calls.",
      "Mutable default arguments are reinitialized every time the function is called.",
      "Mutable default arguments must always be a dictionary.",
      "Mutable default arguments cause an error if modified."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "concat = lambda x, y: x + y\nprint(concat('Hello', ' World'))",
    "o": [
      "Hello World",
      "HelloWorld",
      "Hello+World",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly defines a function that returns multiple values?",
    "c": null,
    "o": [
      "def func(): return 1, 2, 3",
      "def func(): return [1 2 3]",
      "def func(): return (1) (2) (3)",
      "def func(): return {1, 2, 3}"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x += 1\n        return x\n    return inner()\n\nprint(outer())",
    "o": [
      "11",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about the `nonlocal` keyword is TRUE?",
    "c": null,
    "o": [
      "It allows modification of a variable in an enclosing scope.",
      "It creates a new local variable in the function.",
      "It makes a variable globally accessible.",
      "It prevents a variable from being changed inside a function."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "modulus = lambda x, y: x % y\nprint(modulus(10, 3))",
    "o": [
      "1",
      "3",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly defines a function with only keyword arguments?",
    "c": null,
    "o": [
      "def func(*, a, b): pass",
      "def func(a, b, *args): pass",
      "def func(**args): pass",
      "def func(a=1, b=2): pass"
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "4",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about recursion in Python?",
    "c": null,
    "o": [
      "A recursive function must have a base case to prevent infinite recursion.",
      "Recursive functions cannot return values.",
      "Recursion is faster than iteration in all cases.",
      "A recursive function must take at least one parameter."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "x = 5\n\ndef outer():\n    x = 10\n    def inner():\n        global x\n        return x\n    return inner()\n\nprint(outer())",
    "o": [
      "5",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements about the `global` keyword is TRUE?",
    "c": null,
    "o": [
      "It allows modification of a global variable inside a function.",
      "It creates a new local variable in a function.",
      "It restricts access to global variables.",
      "It can only be used inside a class."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "power = lambda x: x ** 2\nprint(power(3))",
    "o": [
      "9",
      "6",
      "3",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly defines an anonymous function using `lambda`?",
    "c": null,
    "o": [
      "lambda x, y: x + y",
      "def lambda(x, y): return x + y",
      "lambda(x, y) -> x + y",
      "def func = lambda x, y: x + y"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(5))",
    "o": [
      "5",
      "3",
      "8",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes a Python function with default arguments?",
    "c": null,
    "o": [
      "A function where some parameters have predefined values.",
      "A function that must take at least one argument.",
      "A function without a return statement.",
      "A function with no arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def add(a, b=5):\n    return a + b\n\nprint(add(3))",
    "o": [
      "8",
      "3",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to pass an arbitrary number of arguments to a function?",
    "c": null,
    "o": [
      "def func(*args): pass",
      "def func(args*): pass",
      "def func(**args*): pass",
      "def func(*arg, **kwarg*): pass"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def greet(name, message=\"Hello\"):\n    return f\"{message}, {name}!\"\n\nprint(greet(\"Alice\"))",
    "o": [
      "Hello, Alice!",
      "Alice, Hello!",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which statement about local and global variables is correct?",
    "c": null,
    "o": [
      "A local variable is defined inside a function and is not accessible outside of it.",
      "A global variable must be declared inside a function.",
      "Local variables persist after a function call ends.",
      "Global variables cannot be modified inside a function."
    ]
  },
  {
    "q": "What will be the output of the following lambda function?",
    "c": "multiply = lambda x, y: x * y\nprint(multiply(3, 4))",
    "o": [
      "12",
      "7",
      "34",
      "Error"
    ]
  },
  {
    "q": "Which of the following is the correct way to use recursion in Python?",
    "c": null,
    "o": [
      "A function that calls itself with a terminating condition.",
      "A function that calls itself indefinitely.",
      "A function that uses `return self`.",
      "A function that requires two arguments."
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "def counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\n\nc = counter()\nprint(c())\nprint(c())",
    "o": [
      "1\n2",
      "0\n1",
      "1\n1",
      "Error"
    ]
  },
  {
    "q": "Which of the following is TRUE about the `nonlocal` keyword?",
    "c": null,
    "o": [
      "It allows modifying a variable from an enclosing function.",
      "It defines a global variable.",
      "It prevents modification of local variables.",
      "It creates a new local variable."
    ]
  },
  {
    "q": "What will be the output of the following recursive function?",
    "c": "def sum_n(n):\n    if n == 0:\n        return 0\n    return n + sum_n(n - 1)\n\nprint(sum_n(3))",
    "o": [
      "6",
      "3",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct way to pass keyword arguments to a function?",
    "c": null,
    "o": [
      "my_function(x=10, y=20)",
      "my_function(10=x, 20=y)",
      "my_function(x, y=20)",
      "my_function(10, 20=x, y)"
    ]
  },
  {
    "q": "What will be the output of the following function with a default mutable argument?",
    "c": "def append_value(value, my_list=[]):\n    my_list.append(value)\n    return my_list\n\nprint(append_value(1))\nprint(append_value(2))",
    "o": [
      "[1]\n[1, 2]",
      "[1]\n[2]",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is TRUE about function arguments in Python?",
    "c": null,
    "o": [
      "Default values are evaluated only once when the function is defined.",
      "Mutable default arguments create a new object every time the function is called.",
      "A function cannot have both positional and keyword arguments.",
      "Arguments cannot be passed by reference."
    ]
  },
  {
    "q": "What will be the output of the following function?",
    "c": "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(4))",
    "o": [
      "24",
      "16",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct example of an anonymous function in Python?",
    "c": null,
    "o": [
      "lambda x: x * 2",
      "def lambda x: x * 2",
      "lambda(x): x * 2",
      "def anonymous(x): return x * 2"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "x = 10\ndef change_global():\n    global x\n    x = 20\n\nchange_global()\nprint(x)",
    "o": [
      "20",
      "10",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which keyword is used to define a function in Python?",
    "c": null,
    "o": [
      "def",
      "func",
      "function",
      "define"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "def outer():\n    x = 5\n    def inner():\n        nonlocal x\n        x += 1\n        return x\n    return inner()\n\nprint(outer())",
    "o": [
      "6",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is correct about recursive functions?",
    "c": null,
    "o": [
      "They must have a base condition to prevent infinite recursion.",
      "They run indefinitely unless manually stopped.",
      "They do not require a return statement.",
      "They can only be used for mathematical operations."
    ]
  },
  {
    "q": "What will be the output of the following function?",
    "c": "def power(base, exp=2):\n    return base ** exp\n\nprint(power(3))",
    "o": [
      "9",
      "6",
      "3",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "add = lambda x, y=5: x + y\nprint(add(10))",
    "o": [
      "15",
      "10",
      "5",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes a lambda function?",
    "c": null,
    "o": [
      "A small anonymous function that can have any number of arguments but only one expression.",
      "A named function that can only take one argument.",
      "A function that must be declared inside another function.",
      "A recursive function that does not use a return statement."
    ]
  },
  {
    "q": "What will be the output of the following function call?",
    "c": "def greet(name, msg):\n    return f\"{msg}, {name}!\"\n\nprint(greet(msg=\"Good Morning\", name=\"Alice\"))",
    "o": [
      "Good Morning, Alice!",
      "Alice, Good Morning!",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following is a correct example of passing variable-length keyword arguments?",
    "c": null,
    "o": [
      "def func(**kwargs):",
      "def func(*args, kwargs):",
      "def func(**args):",
      "def func(kwarg**):"
    ]
  },
  {
    "q": "What will be the output of the following function?",
    "c": "def add(a, b, c=0):\n    return a + b + c\n\nprint(add(1, 2))",
    "o": [
      "3",
      "1",
      "2",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly explains the behavior of the `global` keyword?",
    "c": null,
    "o": [
      "It allows a function to modify a global variable inside its body.",
      "It makes a variable local inside a function.",
      "It creates a new global variable when used inside a function.",
      "It prevents a variable from being used inside a function."
    ]
  },
  {
    "q": "What will be the output of the following function?",
    "c": "def repeat_string(string, times):\n    return string * times\n\nprint(repeat_string(\"Hi\", 3))",
    "o": [
      "HiHiHi",
      "Hi 3",
      "3Hi",
      "Error"
    ]
  },
  {
    "q": "What will be the output of the following function?",
    "c": "def func(x, lst=[]):\n    lst.append(x)\n    return lst\n\nprint(func(1))\nprint(func(2))",
    "o": [
      "[1, 2]",
      "[1], [2]",
      "[2]",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about default arguments in Python functions?",
    "c": null,
    "o": [
      "They are evaluated only once when the function is defined.",
      "They are evaluated every time the function is called.",
      "They must always be immutable.",
      "They cannot be changed once assigned."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "def recursive_sum(n):\n    if n == 0:\n        return 0\n    return n + recursive_sum(n - 1)\n\nprint(recursive_sum(3))",
    "o": [
      "6",
      "3",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which statement is true about local variables in a function?",
    "c": null,
    "o": [
      "They are only accessible within the function in which they are defined.",
      "They are accessible globally.",
      "They must be explicitly declared as local.",
      "They retain their values even after the function exits."
    ]
  },
  {
    "q": "What will be the output of the following function?",
    "c": "x = 5\n\ndef modify_var():\n    x = 10\n    return x\n\nprint(modify_var())\nprint(x)",
    "o": [
      "10\n5",
      "10\n10",
      "5\n5",
      "Error"
    ]
  },
  {
    "q": "Which of the following is an advantage of using lambda functions in Python?",
    "c": null,
    "o": [
      "They are concise and useful for short, simple operations.",
      "They can have multiple expressions.",
      "They must be explicitly named.",
      "They are more efficient than regular functions in all cases."
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "def func(a, b=[]):\n    b.append(a)\n    return b\n\nprint(func(1))\nprint(func(2, []))\nprint(func(3))",
    "o": [
      "[1]\n[2]\n[1, 3]",
      "[1]\n[2]\n[3]",
      "[1]\n[2]\n[2, 3]",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of the `nonlocal` keyword in Python?",
    "c": null,
    "o": [
      "It allows a variable from an enclosing function to be modified.",
      "It creates a new local variable inside a function.",
      "It makes a variable global.",
      "It prevents a variable from being reassigned."
    ]
  },
  {
    "q": "What will be the output of the following function?",
    "c": "def multiply(x, y):\n    return x * y\n\ndef operate(func, a, b):\n    return func(a, b)\n\nprint(operate(multiply, 3, 4))",
    "o": [
      "12",
      "7",
      "34",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct way to define a function with a variable number of positional arguments?",
    "c": null,
    "o": [
      "def my_function(*args):",
      "def my_function(args*):",
      "def my_function(**args):",
      "def my_function(*args, **kwargs):"
    ]
  },
  {
    "q": "What is the output of the following lambda function?",
    "c": "add = lambda x, y: x + y\nprint(add(2, 3))",
    "o": [
      "5",
      "6",
      "23",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements is true about global variables?",
    "c": null,
    "o": [
      "They can be modified inside a function using the `global` keyword.",
      "They are always accessible inside a function without restrictions.",
      "They must be explicitly passed to functions.",
      "They cannot be modified once defined."
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "def counter():\n    count = 0\n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    return increment\n\nc = counter()\nprint(c())\nprint(c())",
    "o": [
      "1\n2",
      "0\n1",
      "2\n3",
      "Error"
    ]
  },
  {
    "q": "Which of the following correctly describes a recursive function?",
    "c": null,
    "o": [
      "A function that calls itself until a base condition is met.",
      "A function that must have exactly one argument.",
      "A function that cannot use loops.",
      "A function that does not return any value."
    ]
  },
  {
    "q": "What is the output of the following function?",
    "c": "def outer():\n    x = 2\n    def inner():\n        return x ** 2\n    return inner()\n\nprint(outer())",
    "o": [
      "4",
      "2",
      "Error",
      "None"
    ]
  },
  {
    "q": "What will be the output of the following Python code?",
    "c": "def test():\n    return lambda x: x * 2\n\ndouble = test()\nprint(double(5))",
    "o": [
      "10",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is true about Python closures?",
    "c": null,
    "o": [
      "A closure is a function that retains access to variables from its enclosing scope.",
      "A closure cannot access variables from an outer function.",
      "Closures are created using the `global` keyword.",
      "Closures can only be created using lambda functions."
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "def outer(x):\n    def inner(y):\n        return x + y\n    return inner\n\nadd_five = outer(5)\nprint(add_five(3))",
    "o": [
      "8",
      "5",
      "3",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of the `@staticmethod` decorator in Python?",
    "c": null,
    "o": [
      "It defines a method that does not require access to the instance or class.",
      "It allows the method to modify class-level attributes.",
      "It requires an instance to be called.",
      "It makes the method private."
    ]
  },
  {
    "q": "What will be the output of the following Python code?",
    "c": "class Test:\n    def __init__(self, x):\n        self.x = x\n    \n    def __repr__(self):\n        return str(self.x)\n\nt = Test(10)\nprint(t)",
    "o": [
      "10",
      "<Test object at some memory address>",
      "Error",
      "None"
    ]
  },
  {
    "q": "What will be the output of the following Python function?",
    "c": "def func(a, b, c=10):\n    return a + b + c\n\nprint(func(2, 3))",
    "o": [
      "15",
      "5",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following correctly defines a generator function?",
    "c": null,
    "o": [
      "A function that contains the `yield` keyword.",
      "A function that contains the `return` keyword.",
      "A function that always returns a list.",
      "A function that cannot be used in a loop."
    ]
  },
  {
    "q": "What will be the output of the following Python code?",
    "c": "def gen():\n    yield 1\n    yield 2\n    yield 3\n\ng = gen()\nprint(next(g))\nprint(next(g))",
    "o": [
      "1\n2",
      "1\n3",
      "Error",
      "None"
    ]
  },
  {
    "q": "Which of the following statements is true about the `global` keyword?",
    "c": null,
    "o": [
      "It allows a function to modify a global variable.",
      "It makes a variable local inside a function.",
      "It is required for reading global variables.",
      "It prevents a variable from being modified."
    ]
  },
  {
    "q": "What will be the output of the following Python code?",
    "c": "x = [1, 2, 3]\ndef modify():\n    x.append(4)\n\nmodify()\nprint(x)",
    "o": [
      "[1, 2, 3, 4]",
      "[1, 2, 3]",
      "Error",
      "None"
    ]
  }
]
